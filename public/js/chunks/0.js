webpackJsonp([0],Array(323).concat([
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reactRedux = __webpack_require__(11);

var _Article = __webpack_require__(337);

var _Article2 = _interopRequireDefault(_Article);

var _Page = __webpack_require__(501);

var _Page2 = _interopRequireDefault(_Page);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapStateToProps = function mapStateToProps(state, router) {
  var params = router.match.params;

  var article = state.articles.data.find(function (article) {
    return article.id === Number(params.id);
  });
  return {
    article: article ? new _Article2.default(article) : new _Article2.default({})
  };
};

// import components
exports.default = (0, _reactRedux.connect)(mapStateToProps)(_Page2.default);

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

/**
 *  Copyright (c) 2014-2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */

(function (global, factory) {
   true ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  global.Immutable = factory();
}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

  function createClass(ctor, superClass) {
    if (superClass) {
      ctor.prototype = Object.create(superClass.prototype);
    }
    ctor.prototype.constructor = ctor;
  }

  function Iterable(value) {
      return isIterable(value) ? value : Seq(value);
    }


  createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }


  createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }


  createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
    }



  function isIterable(maybeIterable) {
    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
  }

  function isKeyed(maybeKeyed) {
    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
  }

  function isIndexed(maybeIndexed) {
    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
  }

  function isAssociative(maybeAssociative) {
    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
  }

  function isOrdered(maybeOrdered) {
    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
  }

  Iterable.isIterable = isIterable;
  Iterable.isKeyed = isKeyed;
  Iterable.isIndexed = isIndexed;
  Iterable.isAssociative = isAssociative;
  Iterable.isOrdered = isOrdered;

  Iterable.Keyed = KeyedIterable;
  Iterable.Indexed = IndexedIterable;
  Iterable.Set = SetIterable;


  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  // Used for setting prototype methods that IE8 chokes on.
  var DELETE = 'delete';

  // Constants describing the size of trie nodes.
  var SHIFT = 5; // Resulted in best performance after ______?
  var SIZE = 1 << SHIFT;
  var MASK = SIZE - 1;

  // A consistent shared value representing "not set" which equals nothing other
  // than itself, and nothing that could be provided externally.
  var NOT_SET = {};

  // Boolean references, Rough equivalent of `bool &`.
  var CHANGE_LENGTH = { value: false };
  var DID_ALTER = { value: false };

  function MakeRef(ref) {
    ref.value = false;
    return ref;
  }

  function SetRef(ref) {
    ref && (ref.value = true);
  }

  // A function which returns a value representing an "owner" for transient writes
  // to tries. The return value will only ever equal itself, and will not equal
  // the return of any subsequent call of this function.
  function OwnerID() {}

  // http://jsperf.com/copy-array-inline
  function arrCopy(arr, offset) {
    offset = offset || 0;
    var len = Math.max(0, arr.length - offset);
    var newArr = new Array(len);
    for (var ii = 0; ii < len; ii++) {
      newArr[ii] = arr[ii + offset];
    }
    return newArr;
  }

  function ensureSize(iter) {
    if (iter.size === undefined) {
      iter.size = iter.__iterate(returnTrue);
    }
    return iter.size;
  }

  function wrapIndex(iter, index) {
    // This implements "is array index" which the ECMAString spec defines as:
    //
    //     A String property name P is an array index if and only if
    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    //     to 2^32−1.
    //
    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
    if (typeof index !== 'number') {
      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
      if ('' + uint32Index !== index || uint32Index === 4294967295) {
        return NaN;
      }
      index = uint32Index;
    }
    return index < 0 ? ensureSize(iter) + index : index;
  }

  function returnTrue() {
    return true;
  }

  function wholeSlice(begin, end, size) {
    return (begin === 0 || (size !== undefined && begin <= -size)) &&
      (end === undefined || (size !== undefined && end >= size));
  }

  function resolveBegin(begin, size) {
    return resolveIndex(begin, size, 0);
  }

  function resolveEnd(end, size) {
    return resolveIndex(end, size, size);
  }

  function resolveIndex(index, size, defaultIndex) {
    return index === undefined ?
      defaultIndex :
      index < 0 ?
        Math.max(0, size + index) :
        size === undefined ?
          index :
          Math.min(size, index);
  }

  /* global Symbol */

  var ITERATE_KEYS = 0;
  var ITERATE_VALUES = 1;
  var ITERATE_ENTRIES = 2;

  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';

  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


  function Iterator(next) {
      this.next = next;
    }

    Iterator.prototype.toString = function() {
      return '[Iterator]';
    };


  Iterator.KEYS = ITERATE_KEYS;
  Iterator.VALUES = ITERATE_VALUES;
  Iterator.ENTRIES = ITERATE_ENTRIES;

  Iterator.prototype.inspect =
  Iterator.prototype.toSource = function () { return this.toString(); }
  Iterator.prototype[ITERATOR_SYMBOL] = function () {
    return this;
  };


  function iteratorValue(type, k, v, iteratorResult) {
    var value = type === 0 ? k : type === 1 ? v : [k, v];
    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
      value: value, done: false
    });
    return iteratorResult;
  }

  function iteratorDone() {
    return { value: undefined, done: true };
  }

  function hasIterator(maybeIterable) {
    return !!getIteratorFn(maybeIterable);
  }

  function isIterator(maybeIterator) {
    return maybeIterator && typeof maybeIterator.next === 'function';
  }

  function getIterator(iterable) {
    var iteratorFn = getIteratorFn(iterable);
    return iteratorFn && iteratorFn.call(iterable);
  }

  function getIteratorFn(iterable) {
    var iteratorFn = iterable && (
      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
      iterable[FAUX_ITERATOR_SYMBOL]
    );
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  function isArrayLike(value) {
    return value && typeof value.length === 'number';
  }

  createClass(Seq, Iterable);
    function Seq(value) {
      return value === null || value === undefined ? emptySequence() :
        isIterable(value) ? value.toSeq() : seqFromValue(value);
    }

    Seq.of = function(/*...values*/) {
      return Seq(arguments);
    };

    Seq.prototype.toSeq = function() {
      return this;
    };

    Seq.prototype.toString = function() {
      return this.__toString('Seq {', '}');
    };

    Seq.prototype.cacheResult = function() {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };

    // abstract __iterateUncached(fn, reverse)

    Seq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, true);
    };

    // abstract __iteratorUncached(type, reverse)

    Seq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, true);
    };



  createClass(KeyedSeq, Seq);
    function KeyedSeq(value) {
      return value === null || value === undefined ?
        emptySequence().toKeyedSeq() :
        isIterable(value) ?
          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
          keyedSeqFromValue(value);
    }

    KeyedSeq.prototype.toKeyedSeq = function() {
      return this;
    };



  createClass(IndexedSeq, Seq);
    function IndexedSeq(value) {
      return value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
    }

    IndexedSeq.of = function(/*...values*/) {
      return IndexedSeq(arguments);
    };

    IndexedSeq.prototype.toIndexedSeq = function() {
      return this;
    };

    IndexedSeq.prototype.toString = function() {
      return this.__toString('Seq [', ']');
    };

    IndexedSeq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, false);
    };

    IndexedSeq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, false);
    };



  createClass(SetSeq, Seq);
    function SetSeq(value) {
      return (
        value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value
      ).toSetSeq();
    }

    SetSeq.of = function(/*...values*/) {
      return SetSeq(arguments);
    };

    SetSeq.prototype.toSetSeq = function() {
      return this;
    };



  Seq.isSeq = isSeq;
  Seq.Keyed = KeyedSeq;
  Seq.Set = SetSeq;
  Seq.Indexed = IndexedSeq;

  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

  Seq.prototype[IS_SEQ_SENTINEL] = true;



  createClass(ArraySeq, IndexedSeq);
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }

    ArraySeq.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };

    ArraySeq.prototype.__iterate = function(fn, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ArraySeq.prototype.__iterator = function(type, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new Iterator(function() 
        {return ii > maxIndex ?
          iteratorDone() :
          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
      );
    };



  createClass(ObjectSeq, KeyedSeq);
    function ObjectSeq(object) {
      var keys = Object.keys(object);
      this._object = object;
      this._keys = keys;
      this.size = keys.length;
    }

    ObjectSeq.prototype.get = function(key, notSetValue) {
      if (notSetValue !== undefined && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };

    ObjectSeq.prototype.has = function(key) {
      return this._object.hasOwnProperty(key);
    };

    ObjectSeq.prototype.__iterate = function(fn, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys[reverse ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ObjectSeq.prototype.__iterator = function(type, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var key = keys[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, key, object[key]);
      });
    };

  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(IterableSeq, IndexedSeq);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }

    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };

    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      if (!isIterator(iterator)) {
        return new Iterator(iteratorDone);
      }
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value);
      });
    };



  createClass(IteratorSeq, IndexedSeq);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }

    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };

    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new Iterator(function()  {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue(type, iterations, cache[iterations++]);
      });
    };




  // # pragma Helper functions

  function isSeq(maybeSeq) {
    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
  }

  var EMPTY_SEQ;

  function emptySequence() {
    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
  }

  function keyedSeqFromValue(value) {
    var seq =
      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
      typeof value === 'object' ? new ObjectSeq(value) :
      undefined;
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of [k, v] entries, '+
        'or keyed object: ' + value
      );
    }
    return seq;
  }

  function indexedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values: ' + value
      );
    }
    return seq;
  }

  function seqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value) ||
      (typeof value === 'object' && new ObjectSeq(value));
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values, or keyed object: ' + value
      );
    }
    return seq;
  }

  function maybeIndexedSeqFromValue(value) {
    return (
      isArrayLike(value) ? new ArraySeq(value) :
      isIterator(value) ? new IteratorSeq(value) :
      hasIterator(value) ? new IterableSeq(value) :
      undefined
    );
  }

  function seqIterate(seq, fn, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var entry = cache[reverse ? maxIndex - ii : ii];
        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
          return ii + 1;
        }
      }
      return ii;
    }
    return seq.__iterateUncached(fn, reverse);
  }

  function seqIterator(seq, type, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var entry = cache[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
      });
    }
    return seq.__iteratorUncached(type, reverse);
  }

  function fromJS(json, converter) {
    return converter ?
      fromJSWith(converter, json, '', {'': json}) :
      fromJSDefault(json);
  }

  function fromJSWith(converter, json, key, parentJSON) {
    if (Array.isArray(json)) {
      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    if (isPlainObj(json)) {
      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    return json;
  }

  function fromJSDefault(json) {
    if (Array.isArray(json)) {
      return IndexedSeq(json).map(fromJSDefault).toList();
    }
    if (isPlainObj(json)) {
      return KeyedSeq(json).map(fromJSDefault).toMap();
    }
    return json;
  }

  function isPlainObj(value) {
    return value && (value.constructor === Object || value.constructor === undefined);
  }

  /**
   * An extension of the "same-value" algorithm as [described for use by ES6 Map
   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
   *
   * NaN is considered the same as NaN, however -0 and 0 are considered the same
   * value, which is different from the algorithm described by
   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
   *
   * This is extended further to allow Objects to describe the values they
   * represent, by way of `valueOf` or `equals` (and `hashCode`).
   *
   * Note: because of this extension, the key equality of Immutable.Map and the
   * value equality of Immutable.Set will differ from ES6 Map and Set.
   *
   * ### Defining custom values
   *
   * The easiest way to describe the value an object represents is by implementing
   * `valueOf`. For example, `Date` represents a value by returning a unix
   * timestamp for `valueOf`:
   *
   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
   *     var date2 = new Date(1234567890000);
   *     date1.valueOf(); // 1234567890000
   *     assert( date1 !== date2 );
   *     assert( Immutable.is( date1, date2 ) );
   *
   * Note: overriding `valueOf` may have other implications if you use this object
   * where JavaScript expects a primitive, such as implicit string coercion.
   *
   * For more complex types, especially collections, implementing `valueOf` may
   * not be performant. An alternative is to implement `equals` and `hashCode`.
   *
   * `equals` takes another object, presumably of similar type, and returns true
   * if the it is equal. Equality is symmetrical, so the same result should be
   * returned if this and the argument are flipped.
   *
   *     assert( a.equals(b) === b.equals(a) );
   *
   * `hashCode` returns a 32bit integer number representing the object which will
   * be used to determine how to store the value object in a Map or Set. You must
   * provide both or neither methods, one must not exist without the other.
   *
   * Also, an important relationship between these methods must be upheld: if two
   * values are equal, they *must* return the same hashCode. If the values are not
   * equal, they might have the same hashCode; this is called a hash collision,
   * and while undesirable for performance reasons, it is acceptable.
   *
   *     if (a.equals(b)) {
   *       assert( a.hashCode() === b.hashCode() );
   *     }
   *
   * All Immutable collections implement `equals` and `hashCode`.
   *
   */
  function is(valueA, valueB) {
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
    if (typeof valueA.valueOf === 'function' &&
        typeof valueB.valueOf === 'function') {
      valueA = valueA.valueOf();
      valueB = valueB.valueOf();
      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
    }
    if (typeof valueA.equals === 'function' &&
        typeof valueB.equals === 'function' &&
        valueA.equals(valueB)) {
      return true;
    }
    return false;
  }

  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (
      !isIterable(b) ||
      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
      isKeyed(a) !== isKeyed(b) ||
      isIndexed(a) !== isIndexed(b) ||
      isOrdered(a) !== isOrdered(b)
    ) {
      return false;
    }

    if (a.size === 0 && b.size === 0) {
      return true;
    }

    var notAssociative = !isAssociative(a);

    if (isOrdered(a)) {
      var entries = a.entries();
      return b.every(function(v, k)  {
        var entry = entries.next().value;
        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
      }) && entries.next().done;
    }

    var flipped = false;

    if (a.size === undefined) {
      if (b.size === undefined) {
        if (typeof a.cacheResult === 'function') {
          a.cacheResult();
        }
      } else {
        flipped = true;
        var _ = a;
        a = b;
        b = _;
      }
    }

    var allEqual = true;
    var bSize = b.__iterate(function(v, k)  {
      if (notAssociative ? !a.has(v) :
          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
        allEqual = false;
        return false;
      }
    });

    return allEqual && a.size === bSize;
  }

  createClass(Repeat, IndexedSeq);

    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === undefined ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }

    Repeat.prototype.toString = function() {
      if (this.size === 0) {
        return 'Repeat []';
      }
      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };

    Repeat.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };

    Repeat.prototype.includes = function(searchValue) {
      return is(this._value, searchValue);
    };

    Repeat.prototype.slice = function(begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size) ? this :
        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
    };

    Repeat.prototype.reverse = function() {
      return this;
    };

    Repeat.prototype.indexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };

    Repeat.prototype.lastIndexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };

    Repeat.prototype.__iterate = function(fn, reverse) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
      var ii = 0;
      return new Iterator(function() 
        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
      );
    };

    Repeat.prototype.equals = function(other) {
      return other instanceof Repeat ?
        is(this._value, other._value) :
        deepEqual(other);
    };


  var EMPTY_REPEAT;

  function invariant(condition, error) {
    if (!condition) throw new Error(error);
  }

  createClass(Range, IndexedSeq);

    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start, end, step);
      }
      invariant(step !== 0, 'Cannot step a Range by 0');
      start = start || 0;
      if (end === undefined) {
        end = Infinity;
      }
      step = step === undefined ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }

    Range.prototype.toString = function() {
      if (this.size === 0) {
        return 'Range []';
      }
      return 'Range [ ' +
        this._start + '...' + this._end +
        (this._step > 1 ? ' by ' + this._step : '') +
      ' ]';
    };

    Range.prototype.get = function(index, notSetValue) {
      return this.has(index) ?
        this._start + wrapIndex(this, index) * this._step :
        notSetValue;
    };

    Range.prototype.includes = function(searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 &&
        possibleIndex < this.size &&
        possibleIndex === Math.floor(possibleIndex);
    };

    Range.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
    };

    Range.prototype.indexOf = function(searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index
        }
      }
      return -1;
    };

    Range.prototype.lastIndexOf = function(searchValue) {
      return this.indexOf(searchValue);
    };

    Range.prototype.__iterate = function(fn, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse ? -step : step;
      }
      return ii;
    };

    Range.prototype.__iterator = function(type, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new Iterator(function()  {
        var v = value;
        value += reverse ? -step : step;
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
      });
    };

    Range.prototype.equals = function(other) {
      return other instanceof Range ?
        this._start === other._start &&
        this._end === other._end &&
        this._step === other._step :
        deepEqual(this, other);
    };


  var EMPTY_RANGE;

  createClass(Collection, Iterable);
    function Collection() {
      throw TypeError('Abstract');
    }


  createClass(KeyedCollection, Collection);function KeyedCollection() {}

  createClass(IndexedCollection, Collection);function IndexedCollection() {}

  createClass(SetCollection, Collection);function SetCollection() {}


  Collection.Keyed = KeyedCollection;
  Collection.Indexed = IndexedCollection;
  Collection.Set = SetCollection;

  var imul =
    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
    Math.imul :
    function imul(a, b) {
      a = a | 0; // int
      b = b | 0; // int
      var c = a & 0xffff;
      var d = b & 0xffff;
      // Shift by 0 fixes the sign on the high part.
      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
    };

  // v8 has an optimization for storing 31-bit signed numbers.
  // Values which have either 00 or 11 as the high order bits qualify.
  // This function drops the highest order bit in a signed number, maintaining
  // the sign bit.
  function smi(i32) {
    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
  }

  function hash(o) {
    if (o === false || o === null || o === undefined) {
      return 0;
    }
    if (typeof o.valueOf === 'function') {
      o = o.valueOf();
      if (o === false || o === null || o === undefined) {
        return 0;
      }
    }
    if (o === true) {
      return 1;
    }
    var type = typeof o;
    if (type === 'number') {
      var h = o | 0;
      if (h !== o) {
        h ^= o * 0xFFFFFFFF;
      }
      while (o > 0xFFFFFFFF) {
        o /= 0xFFFFFFFF;
        h ^= o;
      }
      return smi(h);
    }
    if (type === 'string') {
      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
    }
    if (typeof o.hashCode === 'function') {
      return o.hashCode();
    }
    if (type === 'object') {
      return hashJSObj(o);
    }
    if (typeof o.toString === 'function') {
      return hashString(o.toString());
    }
    throw new Error('Value type ' + type + ' cannot be hashed.');
  }

  function cachedHashString(string) {
    var hash = stringHashCache[string];
    if (hash === undefined) {
      hash = hashString(string);
      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
        STRING_HASH_CACHE_SIZE = 0;
        stringHashCache = {};
      }
      STRING_HASH_CACHE_SIZE++;
      stringHashCache[string] = hash;
    }
    return hash;
  }

  // http://jsperf.com/hashing-strings
  function hashString(string) {
    // This is the hash from JVM
    // The hash code for a string is computed as
    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
    // where s[i] is the ith character of the string and n is the length of
    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
    // (exclusive) by dropping high bits.
    var hash = 0;
    for (var ii = 0; ii < string.length; ii++) {
      hash = 31 * hash + string.charCodeAt(ii) | 0;
    }
    return smi(hash);
  }

  function hashJSObj(obj) {
    var hash;
    if (usingWeakMap) {
      hash = weakMap.get(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = obj[UID_HASH_KEY];
    if (hash !== undefined) {
      return hash;
    }

    if (!canDefineProperty) {
      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
      if (hash !== undefined) {
        return hash;
      }

      hash = getIENodeHash(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = ++objHashUID;
    if (objHashUID & 0x40000000) {
      objHashUID = 0;
    }

    if (usingWeakMap) {
      weakMap.set(obj, hash);
    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
      throw new Error('Non-extensible objects are not allowed as keys.');
    } else if (canDefineProperty) {
      Object.defineProperty(obj, UID_HASH_KEY, {
        'enumerable': false,
        'configurable': false,
        'writable': false,
        'value': hash
      });
    } else if (obj.propertyIsEnumerable !== undefined &&
               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
      // Since we can't define a non-enumerable property on the object
      // we'll hijack one of the less-used non-enumerable properties to
      // save our hash on it. Since this is a function it will not show up in
      // `JSON.stringify` which is what we want.
      obj.propertyIsEnumerable = function() {
        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
      };
      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
    } else if (obj.nodeType !== undefined) {
      // At this point we couldn't get the IE `uniqueID` to use as a hash
      // and we couldn't use a non-enumerable property to exploit the
      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
      // itself.
      obj[UID_HASH_KEY] = hash;
    } else {
      throw new Error('Unable to set a non-enumerable property on object.');
    }

    return hash;
  }

  // Get references to ES5 object methods.
  var isExtensible = Object.isExtensible;

  // True if Object.defineProperty works as expected. IE8 fails this test.
  var canDefineProperty = (function() {
    try {
      Object.defineProperty({}, '@', {});
      return true;
    } catch (e) {
      return false;
    }
  }());

  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
  // and avoid memory leaks from the IE cloneNode bug.
  function getIENodeHash(node) {
    if (node && node.nodeType > 0) {
      switch (node.nodeType) {
        case 1: // Element
          return node.uniqueID;
        case 9: // Document
          return node.documentElement && node.documentElement.uniqueID;
      }
    }
  }

  // If possible, use a WeakMap.
  var usingWeakMap = typeof WeakMap === 'function';
  var weakMap;
  if (usingWeakMap) {
    weakMap = new WeakMap();
  }

  var objHashUID = 0;

  var UID_HASH_KEY = '__immutablehash__';
  if (typeof Symbol === 'function') {
    UID_HASH_KEY = Symbol(UID_HASH_KEY);
  }

  var STRING_HASH_CACHE_MIN_STRLEN = 16;
  var STRING_HASH_CACHE_MAX_SIZE = 255;
  var STRING_HASH_CACHE_SIZE = 0;
  var stringHashCache = {};

  function assertNotInfinite(size) {
    invariant(
      size !== Infinity,
      'Cannot perform this action with an infinite size.'
    );
  }

  createClass(Map, KeyedCollection);

    // @pragma Construction

    function Map(value) {
      return value === null || value === undefined ? emptyMap() :
        isMap(value) && !isOrdered(value) ? value :
        emptyMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    Map.prototype.toString = function() {
      return this.__toString('Map {', '}');
    };

    // @pragma Access

    Map.prototype.get = function(k, notSetValue) {
      return this._root ?
        this._root.get(0, undefined, k, notSetValue) :
        notSetValue;
    };

    // @pragma Modification

    Map.prototype.set = function(k, v) {
      return updateMap(this, k, v);
    };

    Map.prototype.setIn = function(keyPath, v) {
      return this.updateIn(keyPath, NOT_SET, function()  {return v});
    };

    Map.prototype.remove = function(k) {
      return updateMap(this, k, NOT_SET);
    };

    Map.prototype.deleteIn = function(keyPath) {
      return this.updateIn(keyPath, function()  {return NOT_SET});
    };

    Map.prototype.update = function(k, notSetValue, updater) {
      return arguments.length === 1 ?
        k(this) :
        this.updateIn([k], notSetValue, updater);
    };

    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = undefined;
      }
      var updatedValue = updateInDeepMap(
        this,
        forceIterator(keyPath),
        notSetValue,
        updater
      );
      return updatedValue === NOT_SET ? undefined : updatedValue;
    };

    Map.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };

    // @pragma Composition

    Map.prototype.merge = function(/*...iters*/) {
      return mergeIntoMapWith(this, undefined, arguments);
    };

    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };

    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.merge === 'function' ?
          m.merge.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoMapWith(this, deepMerger, arguments);
    };

    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
    };

    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.mergeDeep === 'function' ?
          m.mergeDeep.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.sort = function(comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator));
    };

    Map.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator, mapper));
    };

    // @pragma Mutability

    Map.prototype.withMutations = function(fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };

    Map.prototype.asMutable = function() {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    };

    Map.prototype.asImmutable = function() {
      return this.__ensureOwner();
    };

    Map.prototype.wasAltered = function() {
      return this.__altered;
    };

    Map.prototype.__iterator = function(type, reverse) {
      return new MapIterator(this, type, reverse);
    };

    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function(entry ) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse);
      return iterations;
    };

    Map.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };


  function isMap(maybeMap) {
    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
  }

  Map.isMap = isMap;

  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

  var MapPrototype = Map.prototype;
  MapPrototype[IS_MAP_SENTINEL] = true;
  MapPrototype[DELETE] = MapPrototype.remove;
  MapPrototype.removeIn = MapPrototype.deleteIn;


  // #pragma Trie Nodes



    function ArrayMapNode(ownerID, entries) {
      this.ownerID = ownerID;
      this.entries = entries;
    }

    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && entries.length === 1) {
        return; // undefined
      }

      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries, key, value);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new ArrayMapNode(ownerID, newEntries);
    };




    function BitmapIndexedNode(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }

    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue :
        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
    };

    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;

      if (!exists && value === NOT_SET) {
        return this;
      }

      var idx = popCount(bitmap & (bit - 1));
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : undefined;
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

      if (newNode === node) {
        return this;
      }

      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }

      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }

      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ?
        setIn(nodes, idx, newNode, isEditable) :
        spliceOut(nodes, idx, isEditable) :
        spliceIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }

      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };




    function HashArrayMapNode(ownerID, count, nodes) {
      this.ownerID = ownerID;
      this.count = count;
      this.nodes = nodes;
    }

    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };

    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];

      if (removed && !node) {
        return this;
      }

      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }

      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }

      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };




    function HashCollisionNode(ownerID, keyHash, entries) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries;
    }

    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }

      var removed = value === NOT_SET;

      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };




    function ValueNode(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }

    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };

    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }

      SetRef(didAlter);

      if (removed) {
        SetRef(didChangeSize);
        return; // undefined
      }

      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }

      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
    };



  // #pragma Iterators

  ArrayMapNode.prototype.iterate =
  HashCollisionNode.prototype.iterate = function (fn, reverse) {
    var entries = this.entries;
    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
        return false;
      }
    }
  }

  BitmapIndexedNode.prototype.iterate =
  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
    var nodes = this.nodes;
    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      var node = nodes[reverse ? maxIndex - ii : ii];
      if (node && node.iterate(fn, reverse) === false) {
        return false;
      }
    }
  }

  ValueNode.prototype.iterate = function (fn, reverse) {
    return fn(this.entry);
  }

  createClass(MapIterator, Iterator);

    function MapIterator(map, type, reverse) {
      this._type = type;
      this._reverse = reverse;
      this._stack = map._root && mapIteratorFrame(map._root);
    }

    MapIterator.prototype.next = function() {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone();
    };


  function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
  }

  function mapIteratorFrame(node, prev) {
    return {
      node: node,
      index: 0,
      __prev: prev
    };
  }

  function makeMap(size, root, ownerID, hash) {
    var map = Object.create(MapPrototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_MAP;
  function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }

  function updateMap(map, k, v) {
    var newRoot;
    var newSize;
    if (!map._root) {
      if (v === NOT_SET) {
        return map;
      }
      newSize = 1;
      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
    } else {
      var didChangeSize = MakeRef(CHANGE_LENGTH);
      var didAlter = MakeRef(DID_ALTER);
      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
      if (!didAlter.value) {
        return map;
      }
      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
    }
    if (map.__ownerID) {
      map.size = newSize;
      map._root = newRoot;
      map.__hash = undefined;
      map.__altered = true;
      return map;
    }
    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
  }

  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (!node) {
      if (value === NOT_SET) {
        return node;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return new ValueNode(ownerID, keyHash, [key, value]);
    }
    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
  }

  function isLeafNode(node) {
    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
  }

  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
    }

    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

    var newNode;
    var nodes = idx1 === idx2 ?
      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
  }

  function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
      ownerID = new OwnerID();
    }
    var node = new ValueNode(ownerID, hash(key), [key, value]);
    for (var ii = 0; ii < entries.length; ii++) {
      var entry = entries[ii];
      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
    }
    return node;
  }

  function packNodes(ownerID, nodes, count, excluding) {
    var bitmap = 0;
    var packedII = 0;
    var packedNodes = new Array(count);
    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
      var node = nodes[ii];
      if (node !== undefined && ii !== excluding) {
        bitmap |= bit;
        packedNodes[packedII++] = node;
      }
    }
    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
  }

  function expandNodes(ownerID, nodes, bitmap, including, node) {
    var count = 0;
    var expandedNodes = new Array(SIZE);
    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
    }
    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
  }

  function mergeIntoMapWith(map, merger, iterables) {
    var iters = [];
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = KeyedIterable(value);
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    return mergeIntoCollectionWith(map, merger, iters);
  }

  function deepMerger(existing, value, key) {
    return existing && existing.mergeDeep && isIterable(value) ?
      existing.mergeDeep(value) :
      is(existing, value) ? existing : value;
  }

  function deepMergerWith(merger) {
    return function(existing, value, key)  {
      if (existing && existing.mergeDeepWith && isIterable(value)) {
        return existing.mergeDeepWith(merger, value);
      }
      var nextValue = merger(existing, value, key);
      return is(existing, nextValue) ? existing : nextValue;
    };
  }

  function mergeIntoCollectionWith(collection, merger, iters) {
    iters = iters.filter(function(x ) {return x.size !== 0});
    if (iters.length === 0) {
      return collection;
    }
    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
      return collection.constructor(iters[0]);
    }
    return collection.withMutations(function(collection ) {
      var mergeIntoMap = merger ?
        function(value, key)  {
          collection.update(key, NOT_SET, function(existing )
            {return existing === NOT_SET ? value : merger(existing, value, key)}
          );
        } :
        function(value, key)  {
          collection.set(key, value);
        }
      for (var ii = 0; ii < iters.length; ii++) {
        iters[ii].forEach(mergeIntoMap);
      }
    });
  }

  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
    var isNotSet = existing === NOT_SET;
    var step = keyPathIter.next();
    if (step.done) {
      var existingValue = isNotSet ? notSetValue : existing;
      var newValue = updater(existingValue);
      return newValue === existingValue ? existing : newValue;
    }
    invariant(
      isNotSet || (existing && existing.set),
      'invalid keyPath'
    );
    var key = step.value;
    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
    var nextUpdated = updateInDeepMap(
      nextExisting,
      keyPathIter,
      notSetValue,
      updater
    );
    return nextUpdated === nextExisting ? existing :
      nextUpdated === NOT_SET ? existing.remove(key) :
      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
  }

  function popCount(x) {
    x = x - ((x >> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return x & 0x7f;
  }

  function setIn(array, idx, val, canEdit) {
    var newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
  }

  function spliceIn(array, idx, val, canEdit) {
    var newLen = array.length + 1;
    if (canEdit && idx + 1 === newLen) {
      array[idx] = val;
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        newArray[ii] = val;
        after = -1;
      } else {
        newArray[ii] = array[ii + after];
      }
    }
    return newArray;
  }

  function spliceOut(array, idx, canEdit) {
    var newLen = array.length - 1;
    if (canEdit && idx === newLen) {
      array.pop();
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        after = 1;
      }
      newArray[ii] = array[ii + after];
    }
    return newArray;
  }

  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

  createClass(List, IndexedCollection);

    // @pragma Construction

    function List(value) {
      var empty = emptyList();
      if (value === null || value === undefined) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function(list ) {
        list.setSize(size);
        iter.forEach(function(v, i)  {return list.set(i, v)});
      });
    }

    List.of = function(/*...values*/) {
      return this(arguments);
    };

    List.prototype.toString = function() {
      return this.__toString('List [', ']');
    };

    // @pragma Access

    List.prototype.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor(this, index);
        return node && node.array[index & MASK];
      }
      return notSetValue;
    };

    // @pragma Modification

    List.prototype.set = function(index, value) {
      return updateList(this, index, value);
    };

    List.prototype.remove = function(index) {
      return !this.has(index) ? this :
        index === 0 ? this.shift() :
        index === this.size - 1 ? this.pop() :
        this.splice(index, 1);
    };

    List.prototype.insert = function(index, value) {
      return this.splice(index, 0, value);
    };

    List.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };

    List.prototype.push = function(/*...values*/) {
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function(list ) {
        setListBounds(list, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(oldSize + ii, values[ii]);
        }
      });
    };

    List.prototype.pop = function() {
      return setListBounds(this, 0, -1);
    };

    List.prototype.unshift = function(/*...values*/) {
      var values = arguments;
      return this.withMutations(function(list ) {
        setListBounds(list, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(ii, values[ii]);
        }
      });
    };

    List.prototype.shift = function() {
      return setListBounds(this, 1);
    };

    // @pragma Composition

    List.prototype.merge = function(/*...iters*/) {
      return mergeIntoListWith(this, undefined, arguments);
    };

    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };

    List.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoListWith(this, deepMerger, arguments);
    };

    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMergerWith(merger), iters);
    };

    List.prototype.setSize = function(size) {
      return setListBounds(this, 0, size);
    };

    // @pragma Iteration

    List.prototype.slice = function(begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(
        this,
        resolveBegin(begin, size),
        resolveEnd(end, size)
      );
    };

    List.prototype.__iterator = function(type, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      return new Iterator(function()  {
        var value = values();
        return value === DONE ?
          iteratorDone() :
          iteratorValue(type, index++, value);
      });
    };

    List.prototype.__iterate = function(fn, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, index++, this) === false) {
          break;
        }
      }
      return index;
    };

    List.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };


  function isList(maybeList) {
    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
  }

  List.isList = isList;

  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

  var ListPrototype = List.prototype;
  ListPrototype[IS_LIST_SENTINEL] = true;
  ListPrototype[DELETE] = ListPrototype.remove;
  ListPrototype.setIn = MapPrototype.setIn;
  ListPrototype.deleteIn =
  ListPrototype.removeIn = MapPrototype.removeIn;
  ListPrototype.update = MapPrototype.update;
  ListPrototype.updateIn = MapPrototype.updateIn;
  ListPrototype.mergeIn = MapPrototype.mergeIn;
  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  ListPrototype.withMutations = MapPrototype.withMutations;
  ListPrototype.asMutable = MapPrototype.asMutable;
  ListPrototype.asImmutable = MapPrototype.asImmutable;
  ListPrototype.wasAltered = MapPrototype.wasAltered;



    function VNode(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }

    // TODO: seems like these methods are very similar

    VNode.prototype.removeBefore = function(ownerID, level, index) {
      if (index === level ? 1 << level : 0 || this.array.length === 0) {
        return this;
      }
      var originIndex = (index >>> level) & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = undefined;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };

    VNode.prototype.removeAfter = function(ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = ((index - 1) >>> level) & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }

      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }

      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };



  var DONE = {};

  function iterateList(list, reverse) {
    var left = list._origin;
    var right = list._capacity;
    var tailPos = getTailOffset(right);
    var tail = list._tail;

    return iterateNodeOrLeaf(list._root, list._level, 0);

    function iterateNodeOrLeaf(node, level, offset) {
      return level === 0 ?
        iterateLeaf(node, offset) :
        iterateNode(node, level, offset);
    }

    function iterateLeaf(node, offset) {
      var array = offset === tailPos ? tail && tail.array : node && node.array;
      var from = offset > left ? 0 : left - offset;
      var to = right - offset;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        if (from === to) {
          return DONE;
        }
        var idx = reverse ? --to : from++;
        return array && array[idx];
      };
    }

    function iterateNode(node, level, offset) {
      var values;
      var array = node && node.array;
      var from = offset > left ? 0 : (left - offset) >> level;
      var to = ((right - offset) >> level) + 1;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        do {
          if (values) {
            var value = values();
            if (value !== DONE) {
              return value;
            }
            values = null;
          }
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          values = iterateNodeOrLeaf(
            array && array[idx], level - SHIFT, offset + (idx << level)
          );
        } while (true);
      };
    }
  }

  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
    var list = Object.create(ListPrototype);
    list.size = capacity - origin;
    list._origin = origin;
    list._capacity = capacity;
    list._level = level;
    list._root = root;
    list._tail = tail;
    list.__ownerID = ownerID;
    list.__hash = hash;
    list.__altered = false;
    return list;
  }

  var EMPTY_LIST;
  function emptyList() {
    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
  }

  function updateList(list, index, value) {
    index = wrapIndex(list, index);

    if (index !== index) {
      return list;
    }

    if (index >= list.size || index < 0) {
      return list.withMutations(function(list ) {
        index < 0 ?
          setListBounds(list, index).set(0, value) :
          setListBounds(list, 0, index + 1).set(index, value)
      });
    }

    index += list._origin;

    var newTail = list._tail;
    var newRoot = list._root;
    var didAlter = MakeRef(DID_ALTER);
    if (index >= getTailOffset(list._capacity)) {
      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
    } else {
      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
    }

    if (!didAlter.value) {
      return list;
    }

    if (list.__ownerID) {
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
  }

  function updateVNode(node, ownerID, level, index, value, didAlter) {
    var idx = (index >>> level) & MASK;
    var nodeHas = node && idx < node.array.length;
    if (!nodeHas && value === undefined) {
      return node;
    }

    var newNode;

    if (level > 0) {
      var lowerNode = node && node.array[idx];
      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
      if (newLowerNode === lowerNode) {
        return node;
      }
      newNode = editableVNode(node, ownerID);
      newNode.array[idx] = newLowerNode;
      return newNode;
    }

    if (nodeHas && node.array[idx] === value) {
      return node;
    }

    SetRef(didAlter);

    newNode = editableVNode(node, ownerID);
    if (value === undefined && idx === newNode.array.length - 1) {
      newNode.array.pop();
    } else {
      newNode.array[idx] = value;
    }
    return newNode;
  }

  function editableVNode(node, ownerID) {
    if (ownerID && node && ownerID === node.ownerID) {
      return node;
    }
    return new VNode(node ? node.array.slice() : [], ownerID);
  }

  function listNodeFor(list, rawIndex) {
    if (rawIndex >= getTailOffset(list._capacity)) {
      return list._tail;
    }
    if (rawIndex < 1 << (list._level + SHIFT)) {
      var node = list._root;
      var level = list._level;
      while (node && level > 0) {
        node = node.array[(rawIndex >>> level) & MASK];
        level -= SHIFT;
      }
      return node;
    }
  }

  function setListBounds(list, begin, end) {
    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      end = end | 0;
    }
    var owner = list.__ownerID || new OwnerID();
    var oldOrigin = list._origin;
    var oldCapacity = list._capacity;
    var newOrigin = oldOrigin + begin;
    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
      return list;
    }

    // If it's going to end after it starts, it's empty.
    if (newOrigin >= newCapacity) {
      return list.clear();
    }

    var newLevel = list._level;
    var newRoot = list._root;

    // New origin might need creating a higher root.
    var offsetShift = 0;
    while (newOrigin + offsetShift < 0) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
      newLevel += SHIFT;
      offsetShift += 1 << newLevel;
    }
    if (offsetShift) {
      newOrigin += offsetShift;
      oldOrigin += offsetShift;
      newCapacity += offsetShift;
      oldCapacity += offsetShift;
    }

    var oldTailOffset = getTailOffset(oldCapacity);
    var newTailOffset = getTailOffset(newCapacity);

    // New size might need creating a higher root.
    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
      newLevel += SHIFT;
    }

    // Locate or create the new tail.
    var oldTail = list._tail;
    var newTail = newTailOffset < oldTailOffset ?
      listNodeFor(list, newCapacity - 1) :
      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

    // Merge Tail into tree.
    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
      newRoot = editableVNode(newRoot, owner);
      var node = newRoot;
      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
        var idx = (oldTailOffset >>> level) & MASK;
        node = node.array[idx] = editableVNode(node.array[idx], owner);
      }
      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
    }

    // If the size has been reduced, there's a chance the tail needs to be trimmed.
    if (newCapacity < oldCapacity) {
      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
    }

    // If the new origin is within the tail, then we do not need a root.
    if (newOrigin >= newTailOffset) {
      newOrigin -= newTailOffset;
      newCapacity -= newTailOffset;
      newLevel = SHIFT;
      newRoot = null;
      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

    // Otherwise, if the root has been trimmed, garbage collect.
    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
      offsetShift = 0;

      // Identify the new top root node of the subtree of the old root.
      while (newRoot) {
        var beginIndex = (newOrigin >>> newLevel) & MASK;
        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
          break;
        }
        if (beginIndex) {
          offsetShift += (1 << newLevel) * beginIndex;
        }
        newLevel -= SHIFT;
        newRoot = newRoot.array[beginIndex];
      }

      // Trim the new sides of the new root.
      if (newRoot && newOrigin > oldOrigin) {
        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
      }
      if (newRoot && newTailOffset < oldTailOffset) {
        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
      }
      if (offsetShift) {
        newOrigin -= offsetShift;
        newCapacity -= offsetShift;
      }
    }

    if (list.__ownerID) {
      list.size = newCapacity - newOrigin;
      list._origin = newOrigin;
      list._capacity = newCapacity;
      list._level = newLevel;
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
  }

  function mergeIntoListWith(list, merger, iterables) {
    var iters = [];
    var maxSize = 0;
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = IndexedIterable(value);
      if (iter.size > maxSize) {
        maxSize = iter.size;
      }
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    if (maxSize > list.size) {
      list = list.setSize(maxSize);
    }
    return mergeIntoCollectionWith(list, merger, iters);
  }

  function getTailOffset(size) {
    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
  }

  createClass(OrderedMap, Map);

    // @pragma Construction

    function OrderedMap(value) {
      return value === null || value === undefined ? emptyOrderedMap() :
        isOrderedMap(value) ? value :
        emptyOrderedMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    OrderedMap.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedMap.prototype.toString = function() {
      return this.__toString('OrderedMap {', '}');
    };

    // @pragma Access

    OrderedMap.prototype.get = function(k, notSetValue) {
      var index = this._map.get(k);
      return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };

    // @pragma Modification

    OrderedMap.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap();
    };

    OrderedMap.prototype.set = function(k, v) {
      return updateOrderedMap(this, k, v);
    };

    OrderedMap.prototype.remove = function(k) {
      return updateOrderedMap(this, k, NOT_SET);
    };

    OrderedMap.prototype.wasAltered = function() {
      return this._map.wasAltered() || this._list.wasAltered();
    };

    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._list.__iterate(
        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
        reverse
      );
    };

    OrderedMap.prototype.__iterator = function(type, reverse) {
      return this._list.fromEntrySeq().__iterator(type, reverse);
    };

    OrderedMap.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };


  function isOrderedMap(maybeOrderedMap) {
    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
  }

  OrderedMap.isOrderedMap = isOrderedMap;

  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



  function makeOrderedMap(map, list, ownerID, hash) {
    var omap = Object.create(OrderedMap.prototype);
    omap.size = map ? map.size : 0;
    omap._map = map;
    omap._list = list;
    omap.__ownerID = ownerID;
    omap.__hash = hash;
    return omap;
  }

  var EMPTY_ORDERED_MAP;
  function emptyOrderedMap() {
    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
  }

  function updateOrderedMap(omap, k, v) {
    var map = omap._map;
    var list = omap._list;
    var i = map.get(k);
    var has = i !== undefined;
    var newMap;
    var newList;
    if (v === NOT_SET) { // removed
      if (!has) {
        return omap;
      }
      if (list.size >= SIZE && list.size >= map.size * 2) {
        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
        if (omap.__ownerID) {
          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
        }
      } else {
        newMap = map.remove(k);
        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
      }
    } else {
      if (has) {
        if (v === list.get(i)[1]) {
          return omap;
        }
        newMap = map;
        newList = list.set(i, [k, v]);
      } else {
        newMap = map.set(k, list.size);
        newList = list.set(list.size, [k, v]);
      }
    }
    if (omap.__ownerID) {
      omap.size = newMap.size;
      omap._map = newMap;
      omap._list = newList;
      omap.__hash = undefined;
      return omap;
    }
    return makeOrderedMap(newMap, newList);
  }

  createClass(ToKeyedSequence, KeyedSeq);
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }

    ToKeyedSequence.prototype.get = function(key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };

    ToKeyedSequence.prototype.has = function(key) {
      return this._iter.has(key);
    };

    ToKeyedSequence.prototype.valueSeq = function() {
      return this._iter.valueSeq();
    };

    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
      }
      return reversedSequence;
    };

    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
      var mappedSequence = mapFactory(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
      }
      return mappedSequence;
    };

    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var ii;
      return this._iter.__iterate(
        this._useKeys ?
          function(v, k)  {return fn(v, k, this$0)} :
          ((ii = reverse ? resolveSize(this) : 0),
            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
        reverse
      );
    };

    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
      if (this._useKeys) {
        return this._iter.__iterator(type, reverse);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var ii = reverse ? resolveSize(this) : 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
      });
    };

  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(ToIndexedSequence, IndexedSeq);
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToIndexedSequence.prototype.includes = function(value) {
      return this._iter.includes(value);
    };

    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
    };

    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, iterations++, step.value, step)
      });
    };



  createClass(ToSetSequence, SetSeq);
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToSetSequence.prototype.has = function(key) {
      return this._iter.includes(key);
    };

    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
    };

    ToSetSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, step.value, step.value, step);
      });
    };



  createClass(FromEntriesSequence, KeyedSeq);
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }

    FromEntriesSequence.prototype.entrySeq = function() {
      return this._iter.toSeq();
    };

    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(entry ) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return fn(
            indexedIterable ? entry.get(1) : entry[1],
            indexedIterable ? entry.get(0) : entry[0],
            this$0
          );
        }
      }, reverse);
    };

    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          // Check if entry exists first so array access doesn't throw for holes
          // in the parent iteration.
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue(
              type,
              indexedIterable ? entry.get(0) : entry[0],
              indexedIterable ? entry.get(1) : entry[1],
              step
            );
          }
        }
      });
    };


  ToIndexedSequence.prototype.cacheResult =
  ToKeyedSequence.prototype.cacheResult =
  ToSetSequence.prototype.cacheResult =
  FromEntriesSequence.prototype.cacheResult =
    cacheResultThrough;


  function flipFactory(iterable) {
    var flipSequence = makeSequence(iterable);
    flipSequence._iter = iterable;
    flipSequence.size = iterable.size;
    flipSequence.flip = function()  {return iterable};
    flipSequence.reverse = function () {
      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
      reversedSequence.flip = function()  {return iterable.reverse()};
      return reversedSequence;
    };
    flipSequence.has = function(key ) {return iterable.includes(key)};
    flipSequence.includes = function(key ) {return iterable.has(key)};
    flipSequence.cacheResult = cacheResultThrough;
    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
    }
    flipSequence.__iteratorUncached = function(type, reverse) {
      if (type === ITERATE_ENTRIES) {
        var iterator = iterable.__iterator(type, reverse);
        return new Iterator(function()  {
          var step = iterator.next();
          if (!step.done) {
            var k = step.value[0];
            step.value[0] = step.value[1];
            step.value[1] = k;
          }
          return step;
        });
      }
      return iterable.__iterator(
        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
        reverse
      );
    }
    return flipSequence;
  }


  function mapFactory(iterable, mapper, context) {
    var mappedSequence = makeSequence(iterable);
    mappedSequence.size = iterable.size;
    mappedSequence.has = function(key ) {return iterable.has(key)};
    mappedSequence.get = function(key, notSetValue)  {
      var v = iterable.get(key, NOT_SET);
      return v === NOT_SET ?
        notSetValue :
        mapper.call(context, v, key, iterable);
    };
    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(
        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
        reverse
      );
    }
    mappedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        return iteratorValue(
          type,
          key,
          mapper.call(context, entry[1], key, iterable),
          step
        );
      });
    }
    return mappedSequence;
  }


  function reverseFactory(iterable, useKeys) {
    var reversedSequence = makeSequence(iterable);
    reversedSequence._iter = iterable;
    reversedSequence.size = iterable.size;
    reversedSequence.reverse = function()  {return iterable};
    if (iterable.flip) {
      reversedSequence.flip = function () {
        var flipSequence = flipFactory(iterable);
        flipSequence.reverse = function()  {return iterable.flip()};
        return flipSequence;
      };
    }
    reversedSequence.get = function(key, notSetValue) 
      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
    reversedSequence.has = function(key )
      {return iterable.has(useKeys ? key : -1 - key)};
    reversedSequence.includes = function(value ) {return iterable.includes(value)};
    reversedSequence.cacheResult = cacheResultThrough;
    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
    };
    reversedSequence.__iterator =
      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
    return reversedSequence;
  }


  function filterFactory(iterable, predicate, context, useKeys) {
    var filterSequence = makeSequence(iterable);
    if (useKeys) {
      filterSequence.has = function(key ) {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
      };
      filterSequence.get = function(key, notSetValue)  {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
          v : notSetValue;
      };
    }
    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      }, reverse);
      return iterations;
    };
    filterSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          var value = entry[1];
          if (predicate.call(context, value, key, iterable)) {
            return iteratorValue(type, useKeys ? key : iterations++, value, step);
          }
        }
      });
    }
    return filterSequence;
  }


  function countByFactory(iterable, grouper, context) {
    var groups = Map().asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        0,
        function(a ) {return a + 1}
      );
    });
    return groups.asImmutable();
  }


  function groupByFactory(iterable, grouper, context) {
    var isKeyedIter = isKeyed(iterable);
    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
      );
    });
    var coerce = iterableClass(iterable);
    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
  }


  function sliceFactory(iterable, begin, end, useKeys) {
    var originalSize = iterable.size;

    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      end = end | 0;
    }

    if (wholeSlice(begin, end, originalSize)) {
      return iterable;
    }

    var resolvedBegin = resolveBegin(begin, originalSize);
    var resolvedEnd = resolveEnd(end, originalSize);

    // begin or end will be NaN if they were provided as negative numbers and
    // this iterable's size is unknown. In that case, cache first so there is
    // a known size and these do not resolve to NaN.
    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
    }

    // Note: resolvedEnd is undefined when the original sequence's length is
    // unknown and this slice did not supply an end and should contain all
    // elements after resolvedBegin.
    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
    var resolvedSize = resolvedEnd - resolvedBegin;
    var sliceSize;
    if (resolvedSize === resolvedSize) {
      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
    }

    var sliceSeq = makeSequence(iterable);

    // If iterable.size is undefined, the size of the realized sliceSeq is
    // unknown at this point unless the number of items to slice is 0
    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
      sliceSeq.get = function (index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 && index < sliceSize ?
          iterable.get(index + resolvedBegin, notSetValue) :
          notSetValue;
      }
    }

    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (sliceSize === 0) {
        return 0;
      }
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var skipped = 0;
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k)  {
        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
                 iterations !== sliceSize;
        }
      });
      return iterations;
    };

    sliceSeq.__iteratorUncached = function(type, reverse) {
      if (sliceSize !== 0 && reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      // Don't bother instantiating parent iterator if taking 0.
      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
      var skipped = 0;
      var iterations = 0;
      return new Iterator(function()  {
        while (skipped++ < resolvedBegin) {
          iterator.next();
        }
        if (++iterations > sliceSize) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (useKeys || type === ITERATE_VALUES) {
          return step;
        } else if (type === ITERATE_KEYS) {
          return iteratorValue(type, iterations - 1, undefined, step);
        } else {
          return iteratorValue(type, iterations - 1, step.value[1], step);
        }
      });
    }

    return sliceSeq;
  }


  function takeWhileFactory(iterable, predicate, context) {
    var takeSequence = makeSequence(iterable);
    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterations = 0;
      iterable.__iterate(function(v, k, c) 
        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
      );
      return iterations;
    };
    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterating = true;
      return new Iterator(function()  {
        if (!iterating) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var k = entry[0];
        var v = entry[1];
        if (!predicate.call(context, v, k, this$0)) {
          iterating = false;
          return iteratorDone();
        }
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return takeSequence;
  }


  function skipWhileFactory(iterable, predicate, context, useKeys) {
    var skipSequence = makeSequence(iterable);
    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      });
      return iterations;
    };
    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var skipping = true;
      var iterations = 0;
      return new Iterator(function()  {
        var step, k, v;
        do {
          step = iterator.next();
          if (step.done) {
            if (useKeys || type === ITERATE_VALUES) {
              return step;
            } else if (type === ITERATE_KEYS) {
              return iteratorValue(type, iterations++, undefined, step);
            } else {
              return iteratorValue(type, iterations++, step.value[1], step);
            }
          }
          var entry = step.value;
          k = entry[0];
          v = entry[1];
          skipping && (skipping = predicate.call(context, v, k, this$0));
        } while (skipping);
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return skipSequence;
  }


  function concatFactory(iterable, values) {
    var isKeyedIterable = isKeyed(iterable);
    var iters = [iterable].concat(values).map(function(v ) {
      if (!isIterable(v)) {
        v = isKeyedIterable ?
          keyedSeqFromValue(v) :
          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
      } else if (isKeyedIterable) {
        v = KeyedIterable(v);
      }
      return v;
    }).filter(function(v ) {return v.size !== 0});

    if (iters.length === 0) {
      return iterable;
    }

    if (iters.length === 1) {
      var singleton = iters[0];
      if (singleton === iterable ||
          isKeyedIterable && isKeyed(singleton) ||
          isIndexed(iterable) && isIndexed(singleton)) {
        return singleton;
      }
    }

    var concatSeq = new ArraySeq(iters);
    if (isKeyedIterable) {
      concatSeq = concatSeq.toKeyedSeq();
    } else if (!isIndexed(iterable)) {
      concatSeq = concatSeq.toSetSeq();
    }
    concatSeq = concatSeq.flatten(true);
    concatSeq.size = iters.reduce(
      function(sum, seq)  {
        if (sum !== undefined) {
          var size = seq.size;
          if (size !== undefined) {
            return sum + size;
          }
        }
      },
      0
    );
    return concatSeq;
  }


  function flattenFactory(iterable, depth, useKeys) {
    var flatSequence = makeSequence(iterable);
    flatSequence.__iterateUncached = function(fn, reverse) {
      var iterations = 0;
      var stopped = false;
      function flatDeep(iter, currentDepth) {var this$0 = this;
        iter.__iterate(function(v, k)  {
          if ((!depth || currentDepth < depth) && isIterable(v)) {
            flatDeep(v, currentDepth + 1);
          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
            stopped = true;
          }
          return !stopped;
        }, reverse);
      }
      flatDeep(iterable, 0);
      return iterations;
    }
    flatSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(type, reverse);
      var stack = [];
      var iterations = 0;
      return new Iterator(function()  {
        while (iterator) {
          var step = iterator.next();
          if (step.done !== false) {
            iterator = stack.pop();
            continue;
          }
          var v = step.value;
          if (type === ITERATE_ENTRIES) {
            v = v[1];
          }
          if ((!depth || stack.length < depth) && isIterable(v)) {
            stack.push(iterator);
            iterator = v.__iterator(type, reverse);
          } else {
            return useKeys ? step : iteratorValue(type, iterations++, v, step);
          }
        }
        return iteratorDone();
      });
    }
    return flatSequence;
  }


  function flatMapFactory(iterable, mapper, context) {
    var coerce = iterableClass(iterable);
    return iterable.toSeq().map(
      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
    ).flatten(true);
  }


  function interposeFactory(iterable, separator) {
    var interposedSequence = makeSequence(iterable);
    interposedSequence.size = iterable.size && iterable.size * 2 -1;
    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k) 
        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
        fn(v, iterations++, this$0) !== false},
        reverse
      );
      return iterations;
    };
    interposedSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      var step;
      return new Iterator(function()  {
        if (!step || iterations % 2) {
          step = iterator.next();
          if (step.done) {
            return step;
          }
        }
        return iterations % 2 ?
          iteratorValue(type, iterations++, separator) :
          iteratorValue(type, iterations++, step.value, step);
      });
    };
    return interposedSequence;
  }


  function sortFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    var isKeyedIterable = isKeyed(iterable);
    var index = 0;
    var entries = iterable.toSeq().map(
      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
    ).toArray();
    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
      isKeyedIterable ?
      function(v, i)  { entries[i].length = 2; } :
      function(v, i)  { entries[i] = v[1]; }
    );
    return isKeyedIterable ? KeyedSeq(entries) :
      isIndexed(iterable) ? IndexedSeq(entries) :
      SetSeq(entries);
  }


  function maxFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    if (mapper) {
      var entry = iterable.toSeq()
        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
      return entry && entry[0];
    } else {
      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
    }
  }

  function maxCompare(comparator, a, b) {
    var comp = comparator(b, a);
    // b is considered the new max if the comparator declares them equal, but
    // they are not equal and b is in fact a nullish value.
    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
  }


  function zipWithFactory(keyIter, zipper, iters) {
    var zipSequence = makeSequence(keyIter);
    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
    // Note: this a generic base implementation of __iterate in terms of
    // __iterator which may be more generically useful in the future.
    zipSequence.__iterate = function(fn, reverse) {
      /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */
      // indexed:
      var iterator = this.__iterator(ITERATE_VALUES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    zipSequence.__iteratorUncached = function(type, reverse) {
      var iterators = iters.map(function(i )
        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
      );
      var iterations = 0;
      var isDone = false;
      return new Iterator(function()  {
        var steps;
        if (!isDone) {
          steps = iterators.map(function(i ) {return i.next()});
          isDone = steps.some(function(s ) {return s.done});
        }
        if (isDone) {
          return iteratorDone();
        }
        return iteratorValue(
          type,
          iterations++,
          zipper.apply(null, steps.map(function(s ) {return s.value}))
        );
      });
    };
    return zipSequence
  }


  // #pragma Helper Functions

  function reify(iter, seq) {
    return isSeq(iter) ? seq : iter.constructor(seq);
  }

  function validateEntry(entry) {
    if (entry !== Object(entry)) {
      throw new TypeError('Expected [K, V] tuple: ' + entry);
    }
  }

  function resolveSize(iter) {
    assertNotInfinite(iter.size);
    return ensureSize(iter);
  }

  function iterableClass(iterable) {
    return isKeyed(iterable) ? KeyedIterable :
      isIndexed(iterable) ? IndexedIterable :
      SetIterable;
  }

  function makeSequence(iterable) {
    return Object.create(
      (
        isKeyed(iterable) ? KeyedSeq :
        isIndexed(iterable) ? IndexedSeq :
        SetSeq
      ).prototype
    );
  }

  function cacheResultThrough() {
    if (this._iter.cacheResult) {
      this._iter.cacheResult();
      this.size = this._iter.size;
      return this;
    } else {
      return Seq.prototype.cacheResult.call(this);
    }
  }

  function defaultComparator(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }

  function forceIterator(keyPath) {
    var iter = getIterator(keyPath);
    if (!iter) {
      // Array might not be iterable in this environment, so we need a fallback
      // to our wrapped type.
      if (!isArrayLike(keyPath)) {
        throw new TypeError('Expected iterable or array-like: ' + keyPath);
      }
      iter = getIterator(Iterable(keyPath));
    }
    return iter;
  }

  createClass(Record, KeyedCollection);

    function Record(defaultValues, name) {
      var hasInitialized;

      var RecordType = function Record(values) {
        if (values instanceof RecordType) {
          return values;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys);
          RecordTypePrototype.size = keys.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = Map(values);
      };

      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;

      return RecordType;
    }

    Record.prototype.toString = function() {
      return this.__toString(recordName(this) + ' {', '}');
    };

    // @pragma Access

    Record.prototype.has = function(k) {
      return this._defaultValues.hasOwnProperty(k);
    };

    Record.prototype.get = function(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k];
      return this._map ? this._map.get(k, defaultVal) : defaultVal;
    };

    // @pragma Modification

    Record.prototype.clear = function() {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
    };

    Record.prototype.set = function(k, v) {
      if (!this.has(k)) {
        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
      }
      var newMap = this._map && this._map.set(k, v);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.remove = function(k) {
      if (!this.has(k)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
    };

    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
    };

    Record.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };


  var RecordPrototype = Record.prototype;
  RecordPrototype[DELETE] = RecordPrototype.remove;
  RecordPrototype.deleteIn =
  RecordPrototype.removeIn = MapPrototype.removeIn;
  RecordPrototype.merge = MapPrototype.merge;
  RecordPrototype.mergeWith = MapPrototype.mergeWith;
  RecordPrototype.mergeIn = MapPrototype.mergeIn;
  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  RecordPrototype.setIn = MapPrototype.setIn;
  RecordPrototype.update = MapPrototype.update;
  RecordPrototype.updateIn = MapPrototype.updateIn;
  RecordPrototype.withMutations = MapPrototype.withMutations;
  RecordPrototype.asMutable = MapPrototype.asMutable;
  RecordPrototype.asImmutable = MapPrototype.asImmutable;


  function makeRecord(likeRecord, map, ownerID) {
    var record = Object.create(Object.getPrototypeOf(likeRecord));
    record._map = map;
    record.__ownerID = ownerID;
    return record;
  }

  function recordName(record) {
    return record._name || record.constructor.name || 'Record';
  }

  function setProps(prototype, names) {
    try {
      names.forEach(setProp.bind(undefined, prototype));
    } catch (error) {
      // Object.defineProperty failed. Probably IE8.
    }
  }

  function setProp(prototype, name) {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      }
    });
  }

  createClass(Set, SetCollection);

    // @pragma Construction

    function Set(value) {
      return value === null || value === undefined ? emptySet() :
        isSet(value) && !isOrdered(value) ? value :
        emptySet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    Set.of = function(/*...values*/) {
      return this(arguments);
    };

    Set.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    Set.prototype.toString = function() {
      return this.__toString('Set {', '}');
    };

    // @pragma Access

    Set.prototype.has = function(value) {
      return this._map.has(value);
    };

    // @pragma Modification

    Set.prototype.add = function(value) {
      return updateSet(this, this._map.set(value, true));
    };

    Set.prototype.remove = function(value) {
      return updateSet(this, this._map.remove(value));
    };

    Set.prototype.clear = function() {
      return updateSet(this, this._map.clear());
    };

    // @pragma Composition

    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function(x ) {return x.size !== 0});
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function(set ) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
        }
      });
    };

    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (!iters.every(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (iters.some(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.merge = function() {
      return this.union.apply(this, arguments);
    };

    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };

    Set.prototype.sort = function(comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator));
    };

    Set.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator, mapper));
    };

    Set.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
    };

    Set.prototype.__iterator = function(type, reverse) {
      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
    };

    Set.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };


  function isSet(maybeSet) {
    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
  }

  Set.isSet = isSet;

  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

  var SetPrototype = Set.prototype;
  SetPrototype[IS_SET_SENTINEL] = true;
  SetPrototype[DELETE] = SetPrototype.remove;
  SetPrototype.mergeDeep = SetPrototype.merge;
  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
  SetPrototype.withMutations = MapPrototype.withMutations;
  SetPrototype.asMutable = MapPrototype.asMutable;
  SetPrototype.asImmutable = MapPrototype.asImmutable;

  SetPrototype.__empty = emptySet;
  SetPrototype.__make = makeSet;

  function updateSet(set, newMap) {
    if (set.__ownerID) {
      set.size = newMap.size;
      set._map = newMap;
      return set;
    }
    return newMap === set._map ? set :
      newMap.size === 0 ? set.__empty() :
      set.__make(newMap);
  }

  function makeSet(map, ownerID) {
    var set = Object.create(SetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_SET;
  function emptySet() {
    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
  }

  createClass(OrderedSet, Set);

    // @pragma Construction

    function OrderedSet(value) {
      return value === null || value === undefined ? emptyOrderedSet() :
        isOrderedSet(value) ? value :
        emptyOrderedSet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    OrderedSet.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedSet.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    OrderedSet.prototype.toString = function() {
      return this.__toString('OrderedSet {', '}');
    };


  function isOrderedSet(maybeOrderedSet) {
    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
  }

  OrderedSet.isOrderedSet = isOrderedSet;

  var OrderedSetPrototype = OrderedSet.prototype;
  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

  OrderedSetPrototype.__empty = emptyOrderedSet;
  OrderedSetPrototype.__make = makeOrderedSet;

  function makeOrderedSet(map, ownerID) {
    var set = Object.create(OrderedSetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_ORDERED_SET;
  function emptyOrderedSet() {
    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
  }

  createClass(Stack, IndexedCollection);

    // @pragma Construction

    function Stack(value) {
      return value === null || value === undefined ? emptyStack() :
        isStack(value) ? value :
        emptyStack().unshiftAll(value);
    }

    Stack.of = function(/*...values*/) {
      return this(arguments);
    };

    Stack.prototype.toString = function() {
      return this.__toString('Stack [', ']');
    };

    // @pragma Access

    Stack.prototype.get = function(index, notSetValue) {
      var head = this._head;
      index = wrapIndex(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };

    Stack.prototype.peek = function() {
      return this._head && this._head.value;
    };

    // @pragma Modification

    Stack.prototype.push = function(/*...values*/) {
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pushAll = function(iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function(value ) {
        newSize++;
        head = {
          value: value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pop = function() {
      return this.slice(1);
    };

    Stack.prototype.unshift = function(/*...values*/) {
      return this.push.apply(this, arguments);
    };

    Stack.prototype.unshiftAll = function(iter) {
      return this.pushAll(iter);
    };

    Stack.prototype.shift = function() {
      return this.pop.apply(this, arguments);
    };

    Stack.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = undefined;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };

    Stack.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        // super.slice(begin, end);
        return IndexedCollection.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    // @pragma Mutability

    Stack.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };

    // @pragma Iteration

    Stack.prototype.__iterate = function(fn, reverse) {
      if (reverse) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };

    Stack.prototype.__iterator = function(type, reverse) {
      if (reverse) {
        return this.reverse().__iterator(type);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator(function()  {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type, iterations++, value);
        }
        return iteratorDone();
      });
    };


  function isStack(maybeStack) {
    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
  }

  Stack.isStack = isStack;

  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

  var StackPrototype = Stack.prototype;
  StackPrototype[IS_STACK_SENTINEL] = true;
  StackPrototype.withMutations = MapPrototype.withMutations;
  StackPrototype.asMutable = MapPrototype.asMutable;
  StackPrototype.asImmutable = MapPrototype.asImmutable;
  StackPrototype.wasAltered = MapPrototype.wasAltered;


  function makeStack(size, head, ownerID, hash) {
    var map = Object.create(StackPrototype);
    map.size = size;
    map._head = head;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_STACK;
  function emptyStack() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  }

  /**
   * Contributes additional methods to a constructor
   */
  function mixin(ctor, methods) {
    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
    Object.keys(methods).forEach(keyCopier);
    Object.getOwnPropertySymbols &&
      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
    return ctor;
  }

  Iterable.Iterator = Iterator;

  mixin(Iterable, {

    // ### Conversion to other types

    toArray: function() {
      assertNotInfinite(this.size);
      var array = new Array(this.size || 0);
      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
      return array;
    },

    toIndexedSeq: function() {
      return new ToIndexedSequence(this);
    },

    toJS: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
      ).__toJS();
    },

    toJSON: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
      ).__toJS();
    },

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, true);
    },

    toMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return Map(this.toKeyedSeq());
    },

    toObject: function() {
      assertNotInfinite(this.size);
      var object = {};
      this.__iterate(function(v, k)  { object[k] = v; });
      return object;
    },

    toOrderedMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedMap(this.toKeyedSeq());
    },

    toOrderedSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
    },

    toSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return Set(isKeyed(this) ? this.valueSeq() : this);
    },

    toSetSeq: function() {
      return new ToSetSequence(this);
    },

    toSeq: function() {
      return isIndexed(this) ? this.toIndexedSeq() :
        isKeyed(this) ? this.toKeyedSeq() :
        this.toSetSeq();
    },

    toStack: function() {
      // Use Late Binding here to solve the circular dependency.
      return Stack(isKeyed(this) ? this.valueSeq() : this);
    },

    toList: function() {
      // Use Late Binding here to solve the circular dependency.
      return List(isKeyed(this) ? this.valueSeq() : this);
    },


    // ### Common JavaScript methods and properties

    toString: function() {
      return '[Iterable]';
    },

    __toString: function(head, tail) {
      if (this.size === 0) {
        return head + tail;
      }
      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    concat: function() {var values = SLICE$0.call(arguments, 0);
      return reify(this, concatFactory(this, values));
    },

    includes: function(searchValue) {
      return this.some(function(value ) {return is(value, searchValue)});
    },

    entries: function() {
      return this.__iterator(ITERATE_ENTRIES);
    },

    every: function(predicate, context) {
      assertNotInfinite(this.size);
      var returnValue = true;
      this.__iterate(function(v, k, c)  {
        if (!predicate.call(context, v, k, c)) {
          returnValue = false;
          return false;
        }
      });
      return returnValue;
    },

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, true));
    },

    find: function(predicate, context, notSetValue) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[1] : notSetValue;
    },

    findEntry: function(predicate, context) {
      var found;
      this.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          found = [k, v];
          return false;
        }
      });
      return found;
    },

    findLastEntry: function(predicate, context) {
      return this.toSeq().reverse().findEntry(predicate, context);
    },

    forEach: function(sideEffect, context) {
      assertNotInfinite(this.size);
      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
    },

    join: function(separator) {
      assertNotInfinite(this.size);
      separator = separator !== undefined ? '' + separator : ',';
      var joined = '';
      var isFirst = true;
      this.__iterate(function(v ) {
        isFirst ? (isFirst = false) : (joined += separator);
        joined += v !== null && v !== undefined ? v.toString() : '';
      });
      return joined;
    },

    keys: function() {
      return this.__iterator(ITERATE_KEYS);
    },

    map: function(mapper, context) {
      return reify(this, mapFactory(this, mapper, context));
    },

    reduce: function(reducer, initialReduction, context) {
      assertNotInfinite(this.size);
      var reduction;
      var useFirst;
      if (arguments.length < 2) {
        useFirst = true;
      } else {
        reduction = initialReduction;
      }
      this.__iterate(function(v, k, c)  {
        if (useFirst) {
          useFirst = false;
          reduction = v;
        } else {
          reduction = reducer.call(context, reduction, v, k, c);
        }
      });
      return reduction;
    },

    reduceRight: function(reducer, initialReduction, context) {
      var reversed = this.toKeyedSeq().reverse();
      return reversed.reduce.apply(reversed, arguments);
    },

    reverse: function() {
      return reify(this, reverseFactory(this, true));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, true));
    },

    some: function(predicate, context) {
      return !this.every(not(predicate), context);
    },

    sort: function(comparator) {
      return reify(this, sortFactory(this, comparator));
    },

    values: function() {
      return this.__iterator(ITERATE_VALUES);
    },


    // ### More sequential methods

    butLast: function() {
      return this.slice(0, -1);
    },

    isEmpty: function() {
      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
    },

    count: function(predicate, context) {
      return ensureSize(
        predicate ? this.toSeq().filter(predicate, context) : this
      );
    },

    countBy: function(grouper, context) {
      return countByFactory(this, grouper, context);
    },

    equals: function(other) {
      return deepEqual(this, other);
    },

    entrySeq: function() {
      var iterable = this;
      if (iterable._cache) {
        // We cache as an entries array, so we can just return the cache!
        return new ArraySeq(iterable._cache);
      }
      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
      return entriesSequence;
    },

    filterNot: function(predicate, context) {
      return this.filter(not(predicate), context);
    },

    findLast: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
    },

    first: function() {
      return this.find(returnTrue);
    },

    flatMap: function(mapper, context) {
      return reify(this, flatMapFactory(this, mapper, context));
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, true));
    },

    fromEntrySeq: function() {
      return new FromEntriesSequence(this);
    },

    get: function(searchKey, notSetValue) {
      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
    },

    getIn: function(searchKeyPath, notSetValue) {
      var nested = this;
      // Note: in an ES6 environment, we would prefer:
      // for (var key of searchKeyPath) {
      var iter = forceIterator(searchKeyPath);
      var step;
      while (!(step = iter.next()).done) {
        var key = step.value;
        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
        if (nested === NOT_SET) {
          return notSetValue;
        }
      }
      return nested;
    },

    groupBy: function(grouper, context) {
      return groupByFactory(this, grouper, context);
    },

    has: function(searchKey) {
      return this.get(searchKey, NOT_SET) !== NOT_SET;
    },

    hasIn: function(searchKeyPath) {
      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
    },

    isSubset: function(iter) {
      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
      return this.every(function(value ) {return iter.includes(value)});
    },

    isSuperset: function(iter) {
      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
      return iter.isSubset(this);
    },

    keySeq: function() {
      return this.toSeq().map(keyMapper).toIndexedSeq();
    },

    last: function() {
      return this.toSeq().reverse().first();
    },

    max: function(comparator) {
      return maxFactory(this, comparator);
    },

    maxBy: function(mapper, comparator) {
      return maxFactory(this, comparator, mapper);
    },

    min: function(comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
    },

    minBy: function(mapper, comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
    },

    rest: function() {
      return this.slice(1);
    },

    skip: function(amount) {
      return this.slice(Math.max(0, amount));
    },

    skipLast: function(amount) {
      return reify(this, this.toSeq().reverse().skip(amount).reverse());
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, true));
    },

    skipUntil: function(predicate, context) {
      return this.skipWhile(not(predicate), context);
    },

    sortBy: function(mapper, comparator) {
      return reify(this, sortFactory(this, comparator, mapper));
    },

    take: function(amount) {
      return this.slice(0, Math.max(0, amount));
    },

    takeLast: function(amount) {
      return reify(this, this.toSeq().reverse().take(amount).reverse());
    },

    takeWhile: function(predicate, context) {
      return reify(this, takeWhileFactory(this, predicate, context));
    },

    takeUntil: function(predicate, context) {
      return this.takeWhile(not(predicate), context);
    },

    valueSeq: function() {
      return this.toIndexedSeq();
    },


    // ### Hashable Object

    hashCode: function() {
      return this.__hash || (this.__hash = hashIterable(this));
    }


    // ### Internal

    // abstract __iterate(fn, reverse)

    // abstract __iterator(type, reverse)
  });

  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  var IterablePrototype = Iterable.prototype;
  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
  IterablePrototype.__toJS = IterablePrototype.toArray;
  IterablePrototype.__toStringMapper = quoteString;
  IterablePrototype.inspect =
  IterablePrototype.toSource = function() { return this.toString(); };
  IterablePrototype.chain = IterablePrototype.flatMap;
  IterablePrototype.contains = IterablePrototype.includes;

  // Temporary warning about using length
  (function () {
    try {
      Object.defineProperty(IterablePrototype, 'length', {
        get: function () {
          if (!Iterable.noLengthWarning) {
            var stack;
            try {
              throw new Error();
            } catch (error) {
              stack = error.stack;
            }
            if (stack.indexOf('_wrapObject') === -1) {
              console && console.warn && console.warn(
                'iterable.length has been deprecated, '+
                'use iterable.size or iterable.count(). '+
                'This warning will become a silent error in a future version. ' +
                stack
              );
              return this.size;
            }
          }
        }
      });
    } catch (e) {}
  })();



  mixin(KeyedIterable, {

    // ### More sequential methods

    flip: function() {
      return reify(this, flipFactory(this));
    },

    findKey: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry && entry[0];
    },

    findLastKey: function(predicate, context) {
      return this.toSeq().reverse().findKey(predicate, context);
    },

    keyOf: function(searchValue) {
      return this.findKey(function(value ) {return is(value, searchValue)});
    },

    lastKeyOf: function(searchValue) {
      return this.findLastKey(function(value ) {return is(value, searchValue)});
    },

    mapEntries: function(mapper, context) {var this$0 = this;
      var iterations = 0;
      return reify(this,
        this.toSeq().map(
          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
        ).fromEntrySeq()
      );
    },

    mapKeys: function(mapper, context) {var this$0 = this;
      return reify(this,
        this.toSeq().flip().map(
          function(k, v)  {return mapper.call(context, k, v, this$0)}
        ).flip()
      );
    }

  });

  var KeyedIterablePrototype = KeyedIterable.prototype;
  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



  mixin(IndexedIterable, {

    // ### Conversion to other types

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, false);
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, false));
    },

    findIndex: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    indexOf: function(searchValue) {
      var key = this.toKeyedSeq().keyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    lastIndexOf: function(searchValue) {
      var key = this.toKeyedSeq().reverse().keyOf(searchValue);
      return key === undefined ? -1 : key;

      // var index =
      // return this.toSeq().reverse().indexOf(searchValue);
    },

    reverse: function() {
      return reify(this, reverseFactory(this, false));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, false));
    },

    splice: function(index, removeNum /*, ...values*/) {
      var numArgs = arguments.length;
      removeNum = Math.max(removeNum | 0, 0);
      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
        return this;
      }
      // If index is negative, it should resolve relative to the size of the
      // collection. However size may be expensive to compute if not cached, so
      // only call count() if the number is in fact negative.
      index = resolveBegin(index, index < 0 ? this.count() : this.size);
      var spliced = this.slice(0, index);
      return reify(
        this,
        numArgs === 1 ?
          spliced :
          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
      );
    },


    // ### More collection methods

    findLastIndex: function(predicate, context) {
      var key = this.toKeyedSeq().findLastKey(predicate, context);
      return key === undefined ? -1 : key;
    },

    first: function() {
      return this.get(0);
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, false));
    },

    get: function(index, notSetValue) {
      index = wrapIndex(this, index);
      return (index < 0 || (this.size === Infinity ||
          (this.size !== undefined && index > this.size))) ?
        notSetValue :
        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
    },

    has: function(index) {
      index = wrapIndex(this, index);
      return index >= 0 && (this.size !== undefined ?
        this.size === Infinity || index < this.size :
        this.indexOf(index) !== -1
      );
    },

    interpose: function(separator) {
      return reify(this, interposeFactory(this, separator));
    },

    interleave: function(/*...iterables*/) {
      var iterables = [this].concat(arrCopy(arguments));
      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
      var interleaved = zipped.flatten(true);
      if (zipped.size) {
        interleaved.size = zipped.size * iterables.length;
      }
      return reify(this, interleaved);
    },

    last: function() {
      return this.get(-1);
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, false));
    },

    zip: function(/*, ...iterables */) {
      var iterables = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, iterables));
    },

    zipWith: function(zipper/*, ...iterables */) {
      var iterables = arrCopy(arguments);
      iterables[0] = this;
      return reify(this, zipWithFactory(this, zipper, iterables));
    }

  });

  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



  mixin(SetIterable, {

    // ### ES6 Collection methods (ES6 Array and Map)

    get: function(value, notSetValue) {
      return this.has(value) ? value : notSetValue;
    },

    includes: function(value) {
      return this.has(value);
    },


    // ### More sequential methods

    keySeq: function() {
      return this.valueSeq();
    }

  });

  SetIterable.prototype.has = IterablePrototype.includes;


  // Mixin subclasses

  mixin(KeyedSeq, KeyedIterable.prototype);
  mixin(IndexedSeq, IndexedIterable.prototype);
  mixin(SetSeq, SetIterable.prototype);

  mixin(KeyedCollection, KeyedIterable.prototype);
  mixin(IndexedCollection, IndexedIterable.prototype);
  mixin(SetCollection, SetIterable.prototype);


  // #pragma Helper functions

  function keyMapper(v, k) {
    return k;
  }

  function entryMapper(v, k) {
    return [k, v];
  }

  function not(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    }
  }

  function neg(predicate) {
    return function() {
      return -predicate.apply(this, arguments);
    }
  }

  function quoteString(value) {
    return typeof value === 'string' ? JSON.stringify(value) : value;
  }

  function defaultZipper() {
    return arrCopy(arguments);
  }

  function defaultNegComparator(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
  }

  function hashIterable(iterable) {
    if (iterable.size === Infinity) {
      return 0;
    }
    var ordered = isOrdered(iterable);
    var keyed = isKeyed(iterable);
    var h = ordered ? 1 : 0;
    var size = iterable.__iterate(
      keyed ?
        ordered ?
          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
        ordered ?
          function(v ) { h = 31 * h + hash(v) | 0; } :
          function(v ) { h = h + hash(v) | 0; }
    );
    return murmurHashOfSize(size, h);
  }

  function murmurHashOfSize(size, h) {
    h = imul(h, 0xCC9E2D51);
    h = imul(h << 15 | h >>> -15, 0x1B873593);
    h = imul(h << 13 | h >>> -13, 5);
    h = (h + 0xE6546B64 | 0) ^ size;
    h = imul(h ^ h >>> 16, 0x85EBCA6B);
    h = imul(h ^ h >>> 13, 0xC2B2AE35);
    h = smi(h ^ h >>> 16);
    return h;
  }

  function hashMerge(a, b) {
    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
  }

  var Immutable = {

    Iterable: Iterable,

    Seq: Seq,
    Collection: Collection,
    Map: Map,
    OrderedMap: OrderedMap,
    List: List,
    Stack: Stack,
    Set: Set,
    OrderedSet: OrderedSet,

    Record: Record,
    Range: Range,
    Repeat: Repeat,

    is: is,
    fromJS: fromJS

  };

  return Immutable;

}));

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EditorState
 * @format
 * 
 */



var _assign = __webpack_require__(18);

var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BlockTree = __webpack_require__(364);
var ContentState = __webpack_require__(348);
var EditorBidiService = __webpack_require__(402);
var Immutable = __webpack_require__(324);
var SelectionState = __webpack_require__(335);

var OrderedSet = Immutable.OrderedSet,
    Record = Immutable.Record,
    Stack = Immutable.Stack;


var defaultRecord = {
  allowUndo: true,
  currentContent: null,
  decorator: null,
  directionMap: null,
  forceSelection: false,
  inCompositionMode: false,
  inlineStyleOverride: null,
  lastChangeType: null,
  nativelyRenderedContent: null,
  redoStack: Stack(),
  selection: null,
  treeMap: null,
  undoStack: Stack()
};

var EditorStateRecord = Record(defaultRecord);

var EditorState = function () {
  EditorState.createEmpty = function createEmpty(decorator) {
    return EditorState.createWithContent(ContentState.createFromText(''), decorator);
  };

  EditorState.createWithContent = function createWithContent(contentState, decorator) {
    var firstKey = contentState.getBlockMap().first().getKey();
    return EditorState.create({
      currentContent: contentState,
      undoStack: Stack(),
      redoStack: Stack(),
      decorator: decorator || null,
      selection: SelectionState.createEmpty(firstKey)
    });
  };

  EditorState.create = function create(config) {
    var currentContent = config.currentContent,
        decorator = config.decorator;

    var recordConfig = _extends({}, config, {
      treeMap: generateNewTreeMap(currentContent, decorator),
      directionMap: EditorBidiService.getDirectionMap(currentContent)
    });
    return new EditorState(new EditorStateRecord(recordConfig));
  };

  EditorState.set = function set(editorState, put) {
    var map = editorState.getImmutable().withMutations(function (state) {
      var existingDecorator = state.get('decorator');
      var decorator = existingDecorator;
      if (put.decorator === null) {
        decorator = null;
      } else if (put.decorator) {
        decorator = put.decorator;
      }

      var newContent = put.currentContent || editorState.getCurrentContent();

      if (decorator !== existingDecorator) {
        var treeMap = state.get('treeMap');
        var newTreeMap;
        if (decorator && existingDecorator) {
          newTreeMap = regenerateTreeForNewDecorator(newContent, newContent.getBlockMap(), treeMap, decorator, existingDecorator);
        } else {
          newTreeMap = generateNewTreeMap(newContent, decorator);
        }

        state.merge({
          decorator: decorator,
          treeMap: newTreeMap,
          nativelyRenderedContent: null
        });
        return;
      }

      var existingContent = editorState.getCurrentContent();
      if (newContent !== existingContent) {
        state.set('treeMap', regenerateTreeForNewBlocks(editorState, newContent.getBlockMap(), newContent.getEntityMap(), decorator));
      }

      state.merge(put);
    });

    return new EditorState(map);
  };

  EditorState.prototype.toJS = function toJS() {
    return this.getImmutable().toJS();
  };

  EditorState.prototype.getAllowUndo = function getAllowUndo() {
    return this.getImmutable().get('allowUndo');
  };

  EditorState.prototype.getCurrentContent = function getCurrentContent() {
    return this.getImmutable().get('currentContent');
  };

  EditorState.prototype.getUndoStack = function getUndoStack() {
    return this.getImmutable().get('undoStack');
  };

  EditorState.prototype.getRedoStack = function getRedoStack() {
    return this.getImmutable().get('redoStack');
  };

  EditorState.prototype.getSelection = function getSelection() {
    return this.getImmutable().get('selection');
  };

  EditorState.prototype.getDecorator = function getDecorator() {
    return this.getImmutable().get('decorator');
  };

  EditorState.prototype.isInCompositionMode = function isInCompositionMode() {
    return this.getImmutable().get('inCompositionMode');
  };

  EditorState.prototype.mustForceSelection = function mustForceSelection() {
    return this.getImmutable().get('forceSelection');
  };

  EditorState.prototype.getNativelyRenderedContent = function getNativelyRenderedContent() {
    return this.getImmutable().get('nativelyRenderedContent');
  };

  EditorState.prototype.getLastChangeType = function getLastChangeType() {
    return this.getImmutable().get('lastChangeType');
  };

  /**
   * While editing, the user may apply inline style commands with a collapsed
   * cursor, intending to type text that adopts the specified style. In this
   * case, we track the specified style as an "override" that takes precedence
   * over the inline style of the text adjacent to the cursor.
   *
   * If null, there is no override in place.
   */


  EditorState.prototype.getInlineStyleOverride = function getInlineStyleOverride() {
    return this.getImmutable().get('inlineStyleOverride');
  };

  EditorState.setInlineStyleOverride = function setInlineStyleOverride(editorState, inlineStyleOverride) {
    return EditorState.set(editorState, { inlineStyleOverride: inlineStyleOverride });
  };

  /**
   * Get the appropriate inline style for the editor state. If an
   * override is in place, use it. Otherwise, the current style is
   * based on the location of the selection state.
   */


  EditorState.prototype.getCurrentInlineStyle = function getCurrentInlineStyle() {
    var override = this.getInlineStyleOverride();
    if (override != null) {
      return override;
    }

    var content = this.getCurrentContent();
    var selection = this.getSelection();

    if (selection.isCollapsed()) {
      return getInlineStyleForCollapsedSelection(content, selection);
    }

    return getInlineStyleForNonCollapsedSelection(content, selection);
  };

  EditorState.prototype.getBlockTree = function getBlockTree(blockKey) {
    return this.getImmutable().getIn(['treeMap', blockKey]);
  };

  EditorState.prototype.isSelectionAtStartOfContent = function isSelectionAtStartOfContent() {
    var firstKey = this.getCurrentContent().getBlockMap().first().getKey();
    return this.getSelection().hasEdgeWithin(firstKey, 0, 0);
  };

  EditorState.prototype.isSelectionAtEndOfContent = function isSelectionAtEndOfContent() {
    var content = this.getCurrentContent();
    var blockMap = content.getBlockMap();
    var last = blockMap.last();
    var end = last.getLength();
    return this.getSelection().hasEdgeWithin(last.getKey(), end, end);
  };

  EditorState.prototype.getDirectionMap = function getDirectionMap() {
    return this.getImmutable().get('directionMap');
  };

  /**
   * Incorporate native DOM selection changes into the EditorState. This
   * method can be used when we simply want to accept whatever the DOM
   * has given us to represent selection, and we do not need to re-render
   * the editor.
   *
   * To forcibly move the DOM selection, see `EditorState.forceSelection`.
   */


  EditorState.acceptSelection = function acceptSelection(editorState, selection) {
    return updateSelection(editorState, selection, false);
  };

  /**
   * At times, we need to force the DOM selection to be where we
   * need it to be. This can occur when the anchor or focus nodes
   * are non-text nodes, for instance. In this case, we want to trigger
   * a re-render of the editor, which in turn forces selection into
   * the correct place in the DOM. The `forceSelection` method
   * accomplishes this.
   *
   * This method should be used in cases where you need to explicitly
   * move the DOM selection from one place to another without a change
   * in ContentState.
   */


  EditorState.forceSelection = function forceSelection(editorState, selection) {
    if (!selection.getHasFocus()) {
      selection = selection.set('hasFocus', true);
    }
    return updateSelection(editorState, selection, true);
  };

  /**
   * Move selection to the end of the editor without forcing focus.
   */


  EditorState.moveSelectionToEnd = function moveSelectionToEnd(editorState) {
    var content = editorState.getCurrentContent();
    var lastBlock = content.getLastBlock();
    var lastKey = lastBlock.getKey();
    var length = lastBlock.getLength();

    return EditorState.acceptSelection(editorState, new SelectionState({
      anchorKey: lastKey,
      anchorOffset: length,
      focusKey: lastKey,
      focusOffset: length,
      isBackward: false
    }));
  };

  /**
   * Force focus to the end of the editor. This is useful in scenarios
   * where we want to programmatically focus the input and it makes sense
   * to allow the user to continue working seamlessly.
   */


  EditorState.moveFocusToEnd = function moveFocusToEnd(editorState) {
    var afterSelectionMove = EditorState.moveSelectionToEnd(editorState);
    return EditorState.forceSelection(afterSelectionMove, afterSelectionMove.getSelection());
  };

  /**
   * Push the current ContentState onto the undo stack if it should be
   * considered a boundary state, and set the provided ContentState as the
   * new current content.
   */


  EditorState.push = function push(editorState, contentState, changeType) {
    if (editorState.getCurrentContent() === contentState) {
      return editorState;
    }

    var forceSelection = changeType !== 'insert-characters';
    var directionMap = EditorBidiService.getDirectionMap(contentState, editorState.getDirectionMap());

    if (!editorState.getAllowUndo()) {
      return EditorState.set(editorState, {
        currentContent: contentState,
        directionMap: directionMap,
        lastChangeType: changeType,
        selection: contentState.getSelectionAfter(),
        forceSelection: forceSelection,
        inlineStyleOverride: null
      });
    }

    var selection = editorState.getSelection();
    var currentContent = editorState.getCurrentContent();
    var undoStack = editorState.getUndoStack();
    var newContent = contentState;

    if (selection !== currentContent.getSelectionAfter() || mustBecomeBoundary(editorState, changeType)) {
      undoStack = undoStack.push(currentContent);
      newContent = newContent.set('selectionBefore', selection);
    } else if (changeType === 'insert-characters' || changeType === 'backspace-character' || changeType === 'delete-character') {
      // Preserve the previous selection.
      newContent = newContent.set('selectionBefore', currentContent.getSelectionBefore());
    }

    var inlineStyleOverride = editorState.getInlineStyleOverride();

    // Don't discard inline style overrides for the following change types:
    var overrideChangeTypes = ['adjust-depth', 'change-block-type', 'split-block'];

    if (overrideChangeTypes.indexOf(changeType) === -1) {
      inlineStyleOverride = null;
    }

    var editorStateChanges = {
      currentContent: newContent,
      directionMap: directionMap,
      undoStack: undoStack,
      redoStack: Stack(),
      lastChangeType: changeType,
      selection: contentState.getSelectionAfter(),
      forceSelection: forceSelection,
      inlineStyleOverride: inlineStyleOverride
    };

    return EditorState.set(editorState, editorStateChanges);
  };

  /**
   * Make the top ContentState in the undo stack the new current content and
   * push the current content onto the redo stack.
   */


  EditorState.undo = function undo(editorState) {
    if (!editorState.getAllowUndo()) {
      return editorState;
    }

    var undoStack = editorState.getUndoStack();
    var newCurrentContent = undoStack.peek();
    if (!newCurrentContent) {
      return editorState;
    }

    var currentContent = editorState.getCurrentContent();
    var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());

    return EditorState.set(editorState, {
      currentContent: newCurrentContent,
      directionMap: directionMap,
      undoStack: undoStack.shift(),
      redoStack: editorState.getRedoStack().push(currentContent),
      forceSelection: true,
      inlineStyleOverride: null,
      lastChangeType: 'undo',
      nativelyRenderedContent: null,
      selection: currentContent.getSelectionBefore()
    });
  };

  /**
   * Make the top ContentState in the redo stack the new current content and
   * push the current content onto the undo stack.
   */


  EditorState.redo = function redo(editorState) {
    if (!editorState.getAllowUndo()) {
      return editorState;
    }

    var redoStack = editorState.getRedoStack();
    var newCurrentContent = redoStack.peek();
    if (!newCurrentContent) {
      return editorState;
    }

    var currentContent = editorState.getCurrentContent();
    var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());

    return EditorState.set(editorState, {
      currentContent: newCurrentContent,
      directionMap: directionMap,
      undoStack: editorState.getUndoStack().push(currentContent),
      redoStack: redoStack.shift(),
      forceSelection: true,
      inlineStyleOverride: null,
      lastChangeType: 'redo',
      nativelyRenderedContent: null,
      selection: newCurrentContent.getSelectionAfter()
    });
  };

  /**
   * Not for public consumption.
   */


  function EditorState(immutable) {
    _classCallCheck(this, EditorState);

    this._immutable = immutable;
  }

  /**
   * Not for public consumption.
   */


  EditorState.prototype.getImmutable = function getImmutable() {
    return this._immutable;
  };

  return EditorState;
}();

/**
 * Set the supplied SelectionState as the new current selection, and set
 * the `force` flag to trigger manual selection placement by the view.
 */


function updateSelection(editorState, selection, forceSelection) {
  return EditorState.set(editorState, {
    selection: selection,
    forceSelection: forceSelection,
    nativelyRenderedContent: null,
    inlineStyleOverride: null
  });
}

/**
 * Regenerate the entire tree map for a given ContentState and decorator.
 * Returns an OrderedMap that maps all available ContentBlock objects.
 */
function generateNewTreeMap(contentState, decorator) {
  return contentState.getBlockMap().map(function (block) {
    return BlockTree.generate(contentState, block, decorator);
  }).toOrderedMap();
}

/**
 * Regenerate tree map objects for all ContentBlocks that have changed
 * between the current editorState and newContent. Returns an OrderedMap
 * with only changed regenerated tree map objects.
 */
function regenerateTreeForNewBlocks(editorState, newBlockMap, newEntityMap, decorator) {
  var contentState = editorState.getCurrentContent().set('entityMap', newEntityMap);
  var prevBlockMap = contentState.getBlockMap();
  var prevTreeMap = editorState.getImmutable().get('treeMap');
  return prevTreeMap.merge(newBlockMap.toSeq().filter(function (block, key) {
    return block !== prevBlockMap.get(key);
  }).map(function (block) {
    return BlockTree.generate(contentState, block, decorator);
  }));
}

/**
 * Generate tree map objects for a new decorator object, preserving any
 * decorations that are unchanged from the previous decorator.
 *
 * Note that in order for this to perform optimally, decoration Lists for
 * decorators should be preserved when possible to allow for direct immutable
 * List comparison.
 */
function regenerateTreeForNewDecorator(content, blockMap, previousTreeMap, decorator, existingDecorator) {
  return previousTreeMap.merge(blockMap.toSeq().filter(function (block) {
    return decorator.getDecorations(block, content) !== existingDecorator.getDecorations(block, content);
  }).map(function (block) {
    return BlockTree.generate(content, block, decorator);
  }));
}

/**
 * Return whether a change should be considered a boundary state, given
 * the previous change type. Allows us to discard potential boundary states
 * during standard typing or deletion behavior.
 */
function mustBecomeBoundary(editorState, changeType) {
  var lastChangeType = editorState.getLastChangeType();
  return changeType !== lastChangeType || changeType !== 'insert-characters' && changeType !== 'backspace-character' && changeType !== 'delete-character';
}

function getInlineStyleForCollapsedSelection(content, selection) {
  var startKey = selection.getStartKey();
  var startOffset = selection.getStartOffset();
  var startBlock = content.getBlockForKey(startKey);

  // If the cursor is not at the start of the block, look backward to
  // preserve the style of the preceding character.
  if (startOffset > 0) {
    return startBlock.getInlineStyleAt(startOffset - 1);
  }

  // The caret is at position zero in this block. If the block has any
  // text at all, use the style of the first character.
  if (startBlock.getLength()) {
    return startBlock.getInlineStyleAt(0);
  }

  // Otherwise, look upward in the document to find the closest character.
  return lookUpwardForInlineStyle(content, startKey);
}

function getInlineStyleForNonCollapsedSelection(content, selection) {
  var startKey = selection.getStartKey();
  var startOffset = selection.getStartOffset();
  var startBlock = content.getBlockForKey(startKey);

  // If there is a character just inside the selection, use its style.
  if (startOffset < startBlock.getLength()) {
    return startBlock.getInlineStyleAt(startOffset);
  }

  // Check if the selection at the end of a non-empty block. Use the last
  // style in the block.
  if (startOffset > 0) {
    return startBlock.getInlineStyleAt(startOffset - 1);
  }

  // Otherwise, look upward in the document to find the closest character.
  return lookUpwardForInlineStyle(content, startKey);
}

function lookUpwardForInlineStyle(content, fromKey) {
  var lastNonEmpty = content.getBlockMap().reverse().skipUntil(function (_, k) {
    return k === fromKey;
  }).skip(1).skipUntil(function (block, _) {
    return block.getLength();
  }).first();

  if (lastNonEmpty) return lastNonEmpty.getInlineStyleAt(lastNonEmpty.getLength() - 1);
  return OrderedSet();
}

module.exports = EditorState;

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftModifier
 * @format
 * 
 */



var CharacterMetadata = __webpack_require__(327);
var ContentStateInlineStyle = __webpack_require__(391);
var DraftFeatureFlags = __webpack_require__(332);
var Immutable = __webpack_require__(324);

var applyEntityToContentState = __webpack_require__(392);
var getCharacterRemovalRange = __webpack_require__(394);
var getContentStateFragment = __webpack_require__(345);
var insertFragmentIntoContentState = __webpack_require__(397);
var insertTextIntoContentState = __webpack_require__(398);
var invariant = __webpack_require__(10);
var modifyBlockForContentState = __webpack_require__(399);
var removeEntitiesAtEdges = __webpack_require__(361);
var removeRangeFromContentState = __webpack_require__(400);
var splitBlockInContentState = __webpack_require__(401);

var OrderedSet = Immutable.OrderedSet;

/**
 * `DraftModifier` provides a set of convenience methods that apply
 * modifications to a `ContentState` object based on a target `SelectionState`.
 *
 * Any change to a `ContentState` should be decomposable into a series of
 * transaction functions that apply the required changes and return output
 * `ContentState` objects.
 *
 * These functions encapsulate some of the most common transaction sequences.
 */

var DraftModifier = {
  replaceText: function replaceText(contentState, rangeToReplace, text, inlineStyle, entityKey) {
    var withoutEntities = removeEntitiesAtEdges(contentState, rangeToReplace);
    var withoutText = removeRangeFromContentState(withoutEntities, rangeToReplace);

    var character = CharacterMetadata.create({
      style: inlineStyle || OrderedSet(),
      entity: entityKey || null
    });

    return insertTextIntoContentState(withoutText, withoutText.getSelectionAfter(), text, character);
  },

  insertText: function insertText(contentState, targetRange, text, inlineStyle, entityKey) {
    !targetRange.isCollapsed() ?  true ? invariant(false, 'Target range must be collapsed for `insertText`.') : invariant(false) : void 0;
    return DraftModifier.replaceText(contentState, targetRange, text, inlineStyle, entityKey);
  },

  moveText: function moveText(contentState, removalRange, targetRange) {
    var movedFragment = getContentStateFragment(contentState, removalRange);

    var afterRemoval = DraftModifier.removeRange(contentState, removalRange, 'backward');

    return DraftModifier.replaceWithFragment(afterRemoval, targetRange, movedFragment);
  },

  replaceWithFragment: function replaceWithFragment(contentState, targetRange, fragment) {
    var withoutEntities = removeEntitiesAtEdges(contentState, targetRange);
    var withoutText = removeRangeFromContentState(withoutEntities, targetRange);

    return insertFragmentIntoContentState(withoutText, withoutText.getSelectionAfter(), fragment);
  },

  removeRange: function removeRange(contentState, rangeToRemove, removalDirection) {
    var startKey = void 0,
        endKey = void 0,
        startBlock = void 0,
        endBlock = void 0;
    if (rangeToRemove.getIsBackward()) {
      rangeToRemove = rangeToRemove.merge({
        anchorKey: rangeToRemove.getFocusKey(),
        anchorOffset: rangeToRemove.getFocusOffset(),
        focusKey: rangeToRemove.getAnchorKey(),
        focusOffset: rangeToRemove.getAnchorOffset(),
        isBackward: false
      });
    }
    startKey = rangeToRemove.getAnchorKey();
    endKey = rangeToRemove.getFocusKey();
    startBlock = contentState.getBlockForKey(startKey);
    endBlock = contentState.getBlockForKey(endKey);
    var startOffset = rangeToRemove.getStartOffset();
    var endOffset = rangeToRemove.getEndOffset();

    var startEntityKey = startBlock.getEntityAt(startOffset);
    var endEntityKey = endBlock.getEntityAt(endOffset - 1);

    // Check whether the selection state overlaps with a single entity.
    // If so, try to remove the appropriate substring of the entity text.
    if (startKey === endKey) {
      if (startEntityKey && startEntityKey === endEntityKey) {
        var _adjustedRemovalRange = getCharacterRemovalRange(contentState.getEntityMap(), startBlock, endBlock, rangeToRemove, removalDirection);
        return removeRangeFromContentState(contentState, _adjustedRemovalRange);
      }
    }
    var adjustedRemovalRange = rangeToRemove;
    if (DraftFeatureFlags.draft_segmented_entities_behavior) {
      // Adjust the selection to properly delete segemented and immutable
      // entities
      adjustedRemovalRange = getCharacterRemovalRange(contentState.getEntityMap(), startBlock, endBlock, rangeToRemove, removalDirection);
    }

    var withoutEntities = removeEntitiesAtEdges(contentState, adjustedRemovalRange);
    return removeRangeFromContentState(withoutEntities, adjustedRemovalRange);
  },

  splitBlock: function splitBlock(contentState, selectionState) {
    var withoutEntities = removeEntitiesAtEdges(contentState, selectionState);
    var withoutText = removeRangeFromContentState(withoutEntities, selectionState);

    return splitBlockInContentState(withoutText, withoutText.getSelectionAfter());
  },

  applyInlineStyle: function applyInlineStyle(contentState, selectionState, inlineStyle) {
    return ContentStateInlineStyle.add(contentState, selectionState, inlineStyle);
  },

  removeInlineStyle: function removeInlineStyle(contentState, selectionState, inlineStyle) {
    return ContentStateInlineStyle.remove(contentState, selectionState, inlineStyle);
  },

  setBlockType: function setBlockType(contentState, selectionState, blockType) {
    return modifyBlockForContentState(contentState, selectionState, function (block) {
      return block.merge({ type: blockType, depth: 0 });
    });
  },

  setBlockData: function setBlockData(contentState, selectionState, blockData) {
    return modifyBlockForContentState(contentState, selectionState, function (block) {
      return block.merge({ data: blockData });
    });
  },

  mergeBlockData: function mergeBlockData(contentState, selectionState, blockData) {
    return modifyBlockForContentState(contentState, selectionState, function (block) {
      return block.merge({ data: block.getData().merge(blockData) });
    });
  },

  applyEntity: function applyEntity(contentState, selectionState, entityKey) {
    var withoutEntities = removeEntitiesAtEdges(contentState, selectionState);
    return applyEntityToContentState(withoutEntities, selectionState, entityKey);
  }
};

module.exports = DraftModifier;

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CharacterMetadata
 * @format
 * 
 */



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _require = __webpack_require__(324),
    Map = _require.Map,
    OrderedSet = _require.OrderedSet,
    Record = _require.Record;

// Immutable.map is typed such that the value for every key in the map
// must be the same type


var EMPTY_SET = OrderedSet();

var defaultRecord = {
  style: EMPTY_SET,
  entity: null
};

var CharacterMetadataRecord = Record(defaultRecord);

var CharacterMetadata = function (_CharacterMetadataRec) {
  _inherits(CharacterMetadata, _CharacterMetadataRec);

  function CharacterMetadata() {
    _classCallCheck(this, CharacterMetadata);

    return _possibleConstructorReturn(this, _CharacterMetadataRec.apply(this, arguments));
  }

  CharacterMetadata.prototype.getStyle = function getStyle() {
    return this.get('style');
  };

  CharacterMetadata.prototype.getEntity = function getEntity() {
    return this.get('entity');
  };

  CharacterMetadata.prototype.hasStyle = function hasStyle(style) {
    return this.getStyle().includes(style);
  };

  CharacterMetadata.applyStyle = function applyStyle(record, style) {
    var withStyle = record.set('style', record.getStyle().add(style));
    return CharacterMetadata.create(withStyle);
  };

  CharacterMetadata.removeStyle = function removeStyle(record, style) {
    var withoutStyle = record.set('style', record.getStyle().remove(style));
    return CharacterMetadata.create(withoutStyle);
  };

  CharacterMetadata.applyEntity = function applyEntity(record, entityKey) {
    var withEntity = record.getEntity() === entityKey ? record : record.set('entity', entityKey);
    return CharacterMetadata.create(withEntity);
  };

  /**
   * Use this function instead of the `CharacterMetadata` constructor.
   * Since most content generally uses only a very small number of
   * style/entity permutations, we can reuse these objects as often as
   * possible.
   */


  CharacterMetadata.create = function create(config) {
    if (!config) {
      return EMPTY;
    }

    var defaultConfig = {
      style: EMPTY_SET,
      entity: null
    };

    // Fill in unspecified properties, if necessary.
    var configMap = Map(defaultConfig).merge(config);

    var existing = pool.get(configMap);
    if (existing) {
      return existing;
    }

    var newCharacter = new CharacterMetadata(configMap);
    pool = pool.set(configMap, newCharacter);
    return newCharacter;
  };

  return CharacterMetadata;
}(CharacterMetadataRecord);

var EMPTY = new CharacterMetadata();
var pool = Map([[Map(defaultRecord), EMPTY]]);

CharacterMetadata.EMPTY = EMPTY;

module.exports = CharacterMetadata;

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ContentBlockNode
 * @format
 * 
 *
 * This file is a fork of ContentBlock adding support for nesting references by
 * providing links to children, parent, prevSibling, and nextSibling.
 *
 * This is unstable and not part of the public API and should not be used by
 * production systems. This file may be update/removed without notice.
 */



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CharacterMetadata = __webpack_require__(327);
var Immutable = __webpack_require__(324);

var findRangesImmutable = __webpack_require__(341);

var List = Immutable.List,
    Map = Immutable.Map,
    OrderedSet = Immutable.OrderedSet,
    Record = Immutable.Record,
    Repeat = Immutable.Repeat;


var EMPTY_SET = OrderedSet();

var defaultRecord = {
  parent: null,
  characterList: List(),
  data: Map(),
  depth: 0,
  key: '',
  text: '',
  type: 'unstyled',
  children: List(),
  prevSibling: null,
  nextSibling: null
};

var haveEqualStyle = function haveEqualStyle(charA, charB) {
  return charA.getStyle() === charB.getStyle();
};

var haveEqualEntity = function haveEqualEntity(charA, charB) {
  return charA.getEntity() === charB.getEntity();
};

var decorateCharacterList = function decorateCharacterList(config) {
  if (!config) {
    return config;
  }

  var characterList = config.characterList,
      text = config.text;


  if (text && !characterList) {
    config.characterList = List(Repeat(CharacterMetadata.EMPTY, text.length));
  }

  return config;
};

var ContentBlockNode = function (_Record) {
  _inherits(ContentBlockNode, _Record);

  function ContentBlockNode() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultRecord;

    _classCallCheck(this, ContentBlockNode);

    return _possibleConstructorReturn(this, _Record.call(this, decorateCharacterList(props)));
  }

  ContentBlockNode.prototype.getKey = function getKey() {
    return this.get('key');
  };

  ContentBlockNode.prototype.getType = function getType() {
    return this.get('type');
  };

  ContentBlockNode.prototype.getText = function getText() {
    return this.get('text');
  };

  ContentBlockNode.prototype.getCharacterList = function getCharacterList() {
    return this.get('characterList');
  };

  ContentBlockNode.prototype.getLength = function getLength() {
    return this.getText().length;
  };

  ContentBlockNode.prototype.getDepth = function getDepth() {
    return this.get('depth');
  };

  ContentBlockNode.prototype.getData = function getData() {
    return this.get('data');
  };

  ContentBlockNode.prototype.getInlineStyleAt = function getInlineStyleAt(offset) {
    var character = this.getCharacterList().get(offset);
    return character ? character.getStyle() : EMPTY_SET;
  };

  ContentBlockNode.prototype.getEntityAt = function getEntityAt(offset) {
    var character = this.getCharacterList().get(offset);
    return character ? character.getEntity() : null;
  };

  ContentBlockNode.prototype.getChildKeys = function getChildKeys() {
    return this.get('children');
  };

  ContentBlockNode.prototype.getParentKey = function getParentKey() {
    return this.get('parent');
  };

  ContentBlockNode.prototype.getPrevSiblingKey = function getPrevSiblingKey() {
    return this.get('prevSibling');
  };

  ContentBlockNode.prototype.getNextSiblingKey = function getNextSiblingKey() {
    return this.get('nextSibling');
  };

  ContentBlockNode.prototype.findStyleRanges = function findStyleRanges(filterFn, callback) {
    findRangesImmutable(this.getCharacterList(), haveEqualStyle, filterFn, callback);
  };

  ContentBlockNode.prototype.findEntityRanges = function findEntityRanges(filterFn, callback) {
    findRangesImmutable(this.getCharacterList(), haveEqualEntity, filterFn, callback);
  };

  return ContentBlockNode;
}(Record(defaultRecord));

module.exports = ContentBlockNode;

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var nullthrows = function nullthrows(x) {
  if (x != null) {
    return x;
  }
  throw new Error("Got unexpected null or undefined");
};

module.exports = nullthrows;

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var UserAgentData = __webpack_require__(412);
var VersionRange = __webpack_require__(415);

var mapObject = __webpack_require__(416);
var memoizeStringOnly = __webpack_require__(417);

/**
 * Checks to see whether `name` and `version` satisfy `query`.
 *
 * @param {string} name Name of the browser, device, engine or platform
 * @param {?string} version Version of the browser, engine or platform
 * @param {string} query Query of form "Name [range expression]"
 * @param {?function} normalizer Optional pre-processor for range expression
 * @return {boolean}
 */
function compare(name, version, query, normalizer) {
  // check for exact match with no version
  if (name === query) {
    return true;
  }

  // check for non-matching names
  if (!query.startsWith(name)) {
    return false;
  }

  // full comparison with version
  var range = query.slice(name.length);
  if (version) {
    range = normalizer ? normalizer(range) : range;
    return VersionRange.contains(range, version);
  }

  return false;
}

/**
 * Normalizes `version` by stripping any "NT" prefix, but only on the Windows
 * platform.
 *
 * Mimics the stripping performed by the `UserAgentWindowsPlatform` PHP class.
 *
 * @param {string} version
 * @return {string}
 */
function normalizePlatformVersion(version) {
  if (UserAgentData.platformName === 'Windows') {
    return version.replace(/^\s*NT/, '');
  }

  return version;
}

/**
 * Provides client-side access to the authoritative PHP-generated User Agent
 * information supplied by the server.
 */
var UserAgent = {
  /**
   * Check if the User Agent browser matches `query`.
   *
   * `query` should be a string like "Chrome" or "Chrome > 33".
   *
   * Valid browser names include:
   *
   * - ACCESS NetFront
   * - AOL
   * - Amazon Silk
   * - Android
   * - BlackBerry
   * - BlackBerry PlayBook
   * - Chrome
   * - Chrome for iOS
   * - Chrome frame
   * - Facebook PHP SDK
   * - Facebook for iOS
   * - Firefox
   * - IE
   * - IE Mobile
   * - Mobile Safari
   * - Motorola Internet Browser
   * - Nokia
   * - Openwave Mobile Browser
   * - Opera
   * - Opera Mini
   * - Opera Mobile
   * - Safari
   * - UIWebView
   * - Unknown
   * - webOS
   * - etc...
   *
   * An authoritative list can be found in the PHP `BrowserDetector` class and
   * related classes in the same file (see calls to `new UserAgentBrowser` here:
   * https://fburl.com/50728104).
   *
   * @note Function results are memoized
   *
   * @param {string} query Query of the form "Name [range expression]"
   * @return {boolean}
   */
  isBrowser: function isBrowser(query) {
    return compare(UserAgentData.browserName, UserAgentData.browserFullVersion, query);
  },


  /**
   * Check if the User Agent browser uses a 32 or 64 bit architecture.
   *
   * @note Function results are memoized
   *
   * @param {string} query Query of the form "32" or "64".
   * @return {boolean}
   */
  isBrowserArchitecture: function isBrowserArchitecture(query) {
    return compare(UserAgentData.browserArchitecture, null, query);
  },


  /**
   * Check if the User Agent device matches `query`.
   *
   * `query` should be a string like "iPhone" or "iPad".
   *
   * Valid device names include:
   *
   * - Kindle
   * - Kindle Fire
   * - Unknown
   * - iPad
   * - iPhone
   * - iPod
   * - etc...
   *
   * An authoritative list can be found in the PHP `DeviceDetector` class and
   * related classes in the same file (see calls to `new UserAgentDevice` here:
   * https://fburl.com/50728332).
   *
   * @note Function results are memoized
   *
   * @param {string} query Query of the form "Name"
   * @return {boolean}
   */
  isDevice: function isDevice(query) {
    return compare(UserAgentData.deviceName, null, query);
  },


  /**
   * Check if the User Agent rendering engine matches `query`.
   *
   * `query` should be a string like "WebKit" or "WebKit >= 537".
   *
   * Valid engine names include:
   *
   * - Gecko
   * - Presto
   * - Trident
   * - WebKit
   * - etc...
   *
   * An authoritative list can be found in the PHP `RenderingEngineDetector`
   * class related classes in the same file (see calls to `new
   * UserAgentRenderingEngine` here: https://fburl.com/50728617).
   *
   * @note Function results are memoized
   *
   * @param {string} query Query of the form "Name [range expression]"
   * @return {boolean}
   */
  isEngine: function isEngine(query) {
    return compare(UserAgentData.engineName, UserAgentData.engineVersion, query);
  },


  /**
   * Check if the User Agent platform matches `query`.
   *
   * `query` should be a string like "Windows" or "iOS 5 - 6".
   *
   * Valid platform names include:
   *
   * - Android
   * - BlackBerry OS
   * - Java ME
   * - Linux
   * - Mac OS X
   * - Mac OS X Calendar
   * - Mac OS X Internet Account
   * - Symbian
   * - SymbianOS
   * - Windows
   * - Windows Mobile
   * - Windows Phone
   * - iOS
   * - iOS Facebook Integration Account
   * - iOS Facebook Social Sharing UI
   * - webOS
   * - Chrome OS
   * - etc...
   *
   * An authoritative list can be found in the PHP `PlatformDetector` class and
   * related classes in the same file (see calls to `new UserAgentPlatform`
   * here: https://fburl.com/50729226).
   *
   * @note Function results are memoized
   *
   * @param {string} query Query of the form "Name [range expression]"
   * @return {boolean}
   */
  isPlatform: function isPlatform(query) {
    return compare(UserAgentData.platformName, UserAgentData.platformFullVersion, query, normalizePlatformVersion);
  },


  /**
   * Check if the User Agent platform is a 32 or 64 bit architecture.
   *
   * @note Function results are memoized
   *
   * @param {string} query Query of the form "32" or "64".
   * @return {boolean}
   */
  isPlatformArchitecture: function isPlatformArchitecture(query) {
    return compare(UserAgentData.platformArchitecture, null, query);
  }
};

module.exports = mapObject(UserAgent, memoizeStringOnly);

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule generateRandomKey
 * @format
 * 
 */



var seenKeys = {};
var MULTIPLIER = Math.pow(2, 24);

function generateRandomKey() {
  var key = void 0;
  while (key === undefined || seenKeys.hasOwnProperty(key) || !isNaN(+key)) {
    key = Math.floor(Math.random() * MULTIPLIER).toString(32);
  }
  seenKeys[key] = true;
  return key;
}

module.exports = generateRandomKey;

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftFeatureFlags
 * @format
 * 
 */



var DraftFeatureFlags = __webpack_require__(390);

module.exports = DraftFeatureFlags;

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ContentBlock
 * @format
 * 
 */



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CharacterMetadata = __webpack_require__(327);
var Immutable = __webpack_require__(324);

var findRangesImmutable = __webpack_require__(341);

var List = Immutable.List,
    Map = Immutable.Map,
    OrderedSet = Immutable.OrderedSet,
    Record = Immutable.Record,
    Repeat = Immutable.Repeat;


var EMPTY_SET = OrderedSet();

var defaultRecord = {
  key: '',
  type: 'unstyled',
  text: '',
  characterList: List(),
  depth: 0,
  data: Map()
};

var ContentBlockRecord = Record(defaultRecord);

var decorateCharacterList = function decorateCharacterList(config) {
  if (!config) {
    return config;
  }

  var characterList = config.characterList,
      text = config.text;


  if (text && !characterList) {
    config.characterList = List(Repeat(CharacterMetadata.EMPTY, text.length));
  }

  return config;
};

var ContentBlock = function (_ContentBlockRecord) {
  _inherits(ContentBlock, _ContentBlockRecord);

  function ContentBlock(config) {
    _classCallCheck(this, ContentBlock);

    return _possibleConstructorReturn(this, _ContentBlockRecord.call(this, decorateCharacterList(config)));
  }

  ContentBlock.prototype.getKey = function getKey() {
    return this.get('key');
  };

  ContentBlock.prototype.getType = function getType() {
    return this.get('type');
  };

  ContentBlock.prototype.getText = function getText() {
    return this.get('text');
  };

  ContentBlock.prototype.getCharacterList = function getCharacterList() {
    return this.get('characterList');
  };

  ContentBlock.prototype.getLength = function getLength() {
    return this.getText().length;
  };

  ContentBlock.prototype.getDepth = function getDepth() {
    return this.get('depth');
  };

  ContentBlock.prototype.getData = function getData() {
    return this.get('data');
  };

  ContentBlock.prototype.getInlineStyleAt = function getInlineStyleAt(offset) {
    var character = this.getCharacterList().get(offset);
    return character ? character.getStyle() : EMPTY_SET;
  };

  ContentBlock.prototype.getEntityAt = function getEntityAt(offset) {
    var character = this.getCharacterList().get(offset);
    return character ? character.getEntity() : null;
  };

  /**
   * Execute a callback for every contiguous range of styles within the block.
   */


  ContentBlock.prototype.findStyleRanges = function findStyleRanges(filterFn, callback) {
    findRangesImmutable(this.getCharacterList(), haveEqualStyle, filterFn, callback);
  };

  /**
   * Execute a callback for every contiguous range of entities within the block.
   */


  ContentBlock.prototype.findEntityRanges = function findEntityRanges(filterFn, callback) {
    findRangesImmutable(this.getCharacterList(), haveEqualEntity, filterFn, callback);
  };

  return ContentBlock;
}(ContentBlockRecord);

function haveEqualStyle(charA, charB) {
  return charA.getStyle() === charB.getStyle();
}

function haveEqualEntity(charA, charB) {
  return charA.getEntity() === charB.getEntity();
}

module.exports = ContentBlock;

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * Unicode-enabled replacesments for basic String functions.
 *
 * All the functions in this module assume that the input string is a valid
 * UTF-16 encoding of a Unicode sequence. If it's not the case, the behavior
 * will be undefined.
 *
 * WARNING: Since this module is typechecks-enforced, you may find new bugs
 * when replacing normal String functions with ones provided here.
 */



var invariant = __webpack_require__(10);

// These two ranges are consecutive so anything in [HIGH_START, LOW_END] is a
// surrogate code unit.
var SURROGATE_HIGH_START = 0xD800;
var SURROGATE_HIGH_END = 0xDBFF;
var SURROGATE_LOW_START = 0xDC00;
var SURROGATE_LOW_END = 0xDFFF;
var SURROGATE_UNITS_REGEX = /[\uD800-\uDFFF]/;

/**
 * @param {number} codeUnit   A Unicode code-unit, in range [0, 0x10FFFF]
 * @return {boolean}          Whether code-unit is in a surrogate (hi/low) range
 */
function isCodeUnitInSurrogateRange(codeUnit) {
  return SURROGATE_HIGH_START <= codeUnit && codeUnit <= SURROGATE_LOW_END;
}

/**
 * Returns whether the two characters starting at `index` form a surrogate pair.
 * For example, given the string s = "\uD83D\uDE0A", (s, 0) returns true and
 * (s, 1) returns false.
 *
 * @param {string} str
 * @param {number} index
 * @return {boolean}
 */
function isSurrogatePair(str, index) {
  !(0 <= index && index < str.length) ?  true ? invariant(false, 'isSurrogatePair: Invalid index %s for string length %s.', index, str.length) : invariant(false) : void 0;
  if (index + 1 === str.length) {
    return false;
  }
  var first = str.charCodeAt(index);
  var second = str.charCodeAt(index + 1);
  return SURROGATE_HIGH_START <= first && first <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= second && second <= SURROGATE_LOW_END;
}

/**
 * @param {string} str  Non-empty string
 * @return {boolean}    True if the input includes any surrogate code units
 */
function hasSurrogateUnit(str) {
  return SURROGATE_UNITS_REGEX.test(str);
}

/**
 * Return the length of the original Unicode character at given position in the
 * String by looking into the UTF-16 code unit; that is equal to 1 for any
 * non-surrogate characters in BMP ([U+0000..U+D7FF] and [U+E000, U+FFFF]); and
 * returns 2 for the hi/low surrogates ([U+D800..U+DFFF]), which are in fact
 * representing non-BMP characters ([U+10000..U+10FFFF]).
 *
 * Examples:
 * - '\u0020' => 1
 * - '\u3020' => 1
 * - '\uD835' => 2
 * - '\uD835\uDDEF' => 2
 * - '\uDDEF' => 2
 *
 * @param {string} str  Non-empty string
 * @param {number} pos  Position in the string to look for one code unit
 * @return {number}      Number 1 or 2
 */
function getUTF16Length(str, pos) {
  return 1 + isCodeUnitInSurrogateRange(str.charCodeAt(pos));
}

/**
 * Fully Unicode-enabled replacement for String#length
 *
 * @param {string} str  Valid Unicode string
 * @return {number}     The number of Unicode characters in the string
 */
function strlen(str) {
  // Call the native functions if there's no surrogate char
  if (!hasSurrogateUnit(str)) {
    return str.length;
  }

  var len = 0;
  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {
    len++;
  }
  return len;
}

/**
 * Fully Unicode-enabled replacement for String#substr()
 *
 * @param {string} str      Valid Unicode string
 * @param {number} start    Location in Unicode sequence to begin extracting
 * @param {?number} length  The number of Unicode characters to extract
 *                          (default: to the end of the string)
 * @return {string}         Extracted sub-string
 */
function substr(str, start, length) {
  start = start || 0;
  length = length === undefined ? Infinity : length || 0;

  // Call the native functions if there's no surrogate char
  if (!hasSurrogateUnit(str)) {
    return str.substr(start, length);
  }

  // Obvious cases
  var size = str.length;
  if (size <= 0 || start > size || length <= 0) {
    return '';
  }

  // Find the actual starting position
  var posA = 0;
  if (start > 0) {
    for (; start > 0 && posA < size; start--) {
      posA += getUTF16Length(str, posA);
    }
    if (posA >= size) {
      return '';
    }
  } else if (start < 0) {
    for (posA = size; start < 0 && 0 < posA; start++) {
      posA -= getUTF16Length(str, posA - 1);
    }
    if (posA < 0) {
      posA = 0;
    }
  }

  // Find the actual ending position
  var posB = size;
  if (length < size) {
    for (posB = posA; length > 0 && posB < size; length--) {
      posB += getUTF16Length(str, posB);
    }
  }

  return str.substring(posA, posB);
}

/**
 * Fully Unicode-enabled replacement for String#substring()
 *
 * @param {string} str    Valid Unicode string
 * @param {number} start  Location in Unicode sequence to begin extracting
 * @param {?number} end   Location in Unicode sequence to end extracting
 *                        (default: end of the string)
 * @return {string}       Extracted sub-string
 */
function substring(str, start, end) {
  start = start || 0;
  end = end === undefined ? Infinity : end || 0;

  if (start < 0) {
    start = 0;
  }
  if (end < 0) {
    end = 0;
  }

  var length = Math.abs(end - start);
  start = start < end ? start : end;
  return substr(str, start, length);
}

/**
 * Get a list of Unicode code-points from a String
 *
 * @param {string} str        Valid Unicode string
 * @return {array<number>}    A list of code-points in [0..0x10FFFF]
 */
function getCodePoints(str) {
  var codePoints = [];
  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {
    codePoints.push(str.codePointAt(pos));
  }
  return codePoints;
}

var UnicodeUtils = {
  getCodePoints: getCodePoints,
  getUTF16Length: getUTF16Length,
  hasSurrogateUnit: hasSurrogateUnit,
  isCodeUnitInSurrogateRange: isCodeUnitInSurrogateRange,
  isSurrogatePair: isSurrogatePair,
  strlen: strlen,
  substring: substring,
  substr: substr
};

module.exports = UnicodeUtils;

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SelectionState
 * @format
 * 
 */



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Immutable = __webpack_require__(324);

var Record = Immutable.Record;


var defaultRecord = {
  anchorKey: '',
  anchorOffset: 0,
  focusKey: '',
  focusOffset: 0,
  isBackward: false,
  hasFocus: false
};

var SelectionStateRecord = Record(defaultRecord);

var SelectionState = function (_SelectionStateRecord) {
  _inherits(SelectionState, _SelectionStateRecord);

  function SelectionState() {
    _classCallCheck(this, SelectionState);

    return _possibleConstructorReturn(this, _SelectionStateRecord.apply(this, arguments));
  }

  SelectionState.prototype.serialize = function serialize() {
    return 'Anchor: ' + this.getAnchorKey() + ':' + this.getAnchorOffset() + ', ' + 'Focus: ' + this.getFocusKey() + ':' + this.getFocusOffset() + ', ' + 'Is Backward: ' + String(this.getIsBackward()) + ', ' + 'Has Focus: ' + String(this.getHasFocus());
  };

  SelectionState.prototype.getAnchorKey = function getAnchorKey() {
    return this.get('anchorKey');
  };

  SelectionState.prototype.getAnchorOffset = function getAnchorOffset() {
    return this.get('anchorOffset');
  };

  SelectionState.prototype.getFocusKey = function getFocusKey() {
    return this.get('focusKey');
  };

  SelectionState.prototype.getFocusOffset = function getFocusOffset() {
    return this.get('focusOffset');
  };

  SelectionState.prototype.getIsBackward = function getIsBackward() {
    return this.get('isBackward');
  };

  SelectionState.prototype.getHasFocus = function getHasFocus() {
    return this.get('hasFocus');
  };

  /**
   * Return whether the specified range overlaps with an edge of the
   * SelectionState.
   */


  SelectionState.prototype.hasEdgeWithin = function hasEdgeWithin(blockKey, start, end) {
    var anchorKey = this.getAnchorKey();
    var focusKey = this.getFocusKey();

    if (anchorKey === focusKey && anchorKey === blockKey) {
      var selectionStart = this.getStartOffset();
      var selectionEnd = this.getEndOffset();
      return start <= selectionEnd && selectionStart <= end;
    }

    if (blockKey !== anchorKey && blockKey !== focusKey) {
      return false;
    }

    var offsetToCheck = blockKey === anchorKey ? this.getAnchorOffset() : this.getFocusOffset();

    return start <= offsetToCheck && end >= offsetToCheck;
  };

  SelectionState.prototype.isCollapsed = function isCollapsed() {
    return this.getAnchorKey() === this.getFocusKey() && this.getAnchorOffset() === this.getFocusOffset();
  };

  SelectionState.prototype.getStartKey = function getStartKey() {
    return this.getIsBackward() ? this.getFocusKey() : this.getAnchorKey();
  };

  SelectionState.prototype.getStartOffset = function getStartOffset() {
    return this.getIsBackward() ? this.getFocusOffset() : this.getAnchorOffset();
  };

  SelectionState.prototype.getEndKey = function getEndKey() {
    return this.getIsBackward() ? this.getAnchorKey() : this.getFocusKey();
  };

  SelectionState.prototype.getEndOffset = function getEndOffset() {
    return this.getIsBackward() ? this.getAnchorOffset() : this.getFocusOffset();
  };

  SelectionState.createEmpty = function createEmpty(key) {
    return new SelectionState({
      anchorKey: key,
      anchorOffset: 0,
      focusKey: key,
      focusOffset: 0,
      isBackward: false,
      hasFocus: false
    });
  };

  return SelectionState;
}(SelectionStateRecord);

module.exports = SelectionState;

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * This function is used to mark string literals representing CSS class names
 * so that they can be transformed statically. This allows for modularization
 * and minification of CSS class names.
 *
 * In static_upstream, this function is actually implemented, but it should
 * eventually be replaced with something more descriptive, and the transform
 * that is used in the main stack should be ported for use elsewhere.
 *
 * @param string|object className to modularize, or an object of key/values.
 *                      In the object case, the values are conditions that
 *                      determine if the className keys should be included.
 * @param [string ...]  Variable list of classNames in the string case.
 * @return string       Renderable space-separated CSS className.
 */
function cx(classNames) {
  if (typeof classNames == 'object') {
    return Object.keys(classNames).filter(function (className) {
      return classNames[className];
    }).map(replace).join(' ');
  }
  return Array.prototype.map.call(arguments, replace).join(' ');
}

function replace(str) {
  return str.replace(/\//g, '-');
}

module.exports = cx;

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _moment = __webpack_require__(0);

var _moment2 = _interopRequireDefault(_moment);

var _Model2 = __webpack_require__(194);

var _Model3 = _interopRequireDefault(_Model2);

var _User = __webpack_require__(191);

var _User2 = _interopRequireDefault(_User);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Article = function (_Model) {
  _inherits(Article, _Model);

  function Article(props) {
    _classCallCheck(this, Article);

    var _this = _possibleConstructorReturn(this, (Article.__proto__ || Object.getPrototypeOf(Article)).call(this, props));

    _this.initialize(props);
    return _this;
  }

  _createClass(Article, [{
    key: 'initialize',
    value: function initialize(props) {
      _get(Article.prototype.__proto__ || Object.getPrototypeOf(Article.prototype), 'initialize', this).call(this, props);

      this.slug = props.slug || '';
      this.title = props.title || '';
      this.description = props.description || '';
      this.content = props.content || '';
      this.published = props.published || false;
      this.publishedAt = props.publishedAt ? (0, _moment2.default)(props.publishedAt) : null;

      // relate user model
      this.user = props.user ? new _User2.default(props.user) : null;
    }
  }]);

  return Article;
}(_Model3.default);

exports.default = Article;

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.articleAddRequest = articleAddRequest;
exports.articleUpdateRequest = articleUpdateRequest;
exports.articleRemoveRequest = articleRemoveRequest;
exports.articleListRequest = articleListRequest;
exports.articleEditRequest = articleEditRequest;
exports.articleFetchRequest = articleFetchRequest;

var _Http = __webpack_require__(33);

var _Http2 = _interopRequireDefault(_Http);

var _Transformer = __webpack_require__(192);

var _Transformer2 = _interopRequireDefault(_Transformer);

var _actions = __webpack_require__(339);

var articleActions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function transformRequest(parms) {
  return _Transformer2.default.send(parms);
}

function transformResponse(params) {
  return _Transformer2.default.fetch(params);
}

function articleAddRequest(params) {
  return function (dispatch) {
    return new Promise(function (resolve, reject) {
      _Http2.default.post('/articles', transformRequest(params)).then(function (res) {
        dispatch(articleActions.add(transformResponse(res.data)));
        return resolve();
      }).catch(function (err) {
        var statusCode = err.response.status;
        var data = {
          error: null,
          statusCode: statusCode
        };

        if (statusCode === 422) {
          var resetErrors = {
            errors: err.response.data,
            replace: false,
            searchStr: '',
            replaceStr: ''
          };
          data.error = _Transformer2.default.resetValidationFields(resetErrors);
        } else if (statusCode === 401) {
          data.error = err.response.data.message;
        }
        return reject(data);
      });
    });
  };
}

function articleUpdateRequest(params) {
  return function (dispatch) {
    return new Promise(function (resolve, reject) {
      _Http2.default.patch('articles/' + params.id, transformRequest(params)).then(function (res) {
        dispatch(articleActions.add(transformResponse(res.data)));
        return resolve();
      }).catch(function (err) {
        var statusCode = err.response.status;
        var data = {
          error: null,
          statusCode: statusCode
        };

        if (statusCode === 422) {
          var resetErrors = {
            errors: err.response.data,
            replace: false,
            searchStr: '',
            replaceStr: ''
          };
          data.error = _Transformer2.default.resetValidationFields(resetErrors);
        } else if (statusCode === 401) {
          data.error = err.response.data.message;
        }
        return reject(data);
      });
    });
  };
}

function articleRemoveRequest(id) {
  return function (dispatch) {
    _Http2.default.delete('articles/' + id).then(function () {
      dispatch(articleActions.remove(id));
    }).catch(function (err) {
      // TODO: handle err
      console.error(err.response);
    });
  };
}

function articleListRequest(_ref) {
  var _ref$pageNumber = _ref.pageNumber,
      pageNumber = _ref$pageNumber === undefined ? 1 : _ref$pageNumber,
      _ref$url = _ref.url,
      url = _ref$url === undefined ? '/articles' : _ref$url;

  return function (dispatch) {
    if (pageNumber > 1) {
      url = url + ('?page=' + pageNumber);
    }

    _Http2.default.get(url).then(function (res) {
      dispatch(articleActions.list(transformResponse(res.data)));
    }).catch(function (err) {
      // TODO: handle err
      console.error(err.response);
    });
  };
}

function articleEditRequest(id) {
  return function (dispatch) {
    _Http2.default.get('articles/' + id).then(function (res) {
      dispatch(articleActions.add(transformResponse(res.data)));
    }).catch(function (err) {
      // TODO: handle err
      console.error(err.response);
    });
  };
}

function articleFetchRequest(slug) {
  return function (dispatch) {
    _Http2.default.get('articles/published/' + slug).then(function (res) {
      dispatch(articleActions.add(transformResponse(res.data)));
    }).catch(function (err) {
      // TODO: handle err
      console.error(err.response);
    });
  };
}

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.update = update;
exports.remove = remove;
exports.list = list;

var _actionTypes = __webpack_require__(195);

function add(payload) {
  return {
    type: _actionTypes.ARTICLE_ADD,
    payload: payload
  };
} /* ============
   * Actions for the article module
   * ============
   *
   * The actions that are available on the
   * article module.
   */

function update(payload) {
  return {
    type: _actionTypes.ARTICLE_UPDATE,
    payload: payload
  };
}

function remove(payload) {
  return {
    type: _actionTypes.ARTICLE_REMOVE,
    payload: payload
  };
}

function list(payload) {
  return {
    type: _actionTypes.ARTICLE_LIST,
    payload: payload
  };
}

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule BlockMapBuilder
 * @format
 * 
 */



var Immutable = __webpack_require__(324);

var OrderedMap = Immutable.OrderedMap;


var BlockMapBuilder = {
  createFromArray: function createFromArray(blocks) {
    return OrderedMap(blocks.map(function (block) {
      return [block.getKey(), block];
    }));
  }
};

module.exports = BlockMapBuilder;

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule findRangesImmutable
 * @format
 * 
 */



/**
 * Search through an array to find contiguous stretches of elements that
 * match a specified filter function.
 *
 * When ranges are found, execute a specified `found` function to supply
 * the values to the caller.
 */
function findRangesImmutable(haystack, areEqualFn, filterFn, foundFn) {
  if (!haystack.size) {
    return;
  }

  var cursor = 0;

  haystack.reduce(function (value, nextValue, nextIndex) {
    if (!areEqualFn(value, nextValue)) {
      if (filterFn(value)) {
        foundFn(cursor, nextIndex);
      }
      cursor = nextIndex;
    }
    return nextValue;
  });

  filterFn(haystack.last()) && foundFn(cursor, haystack.count());
}

module.exports = findRangesImmutable;

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventHandled
 * @format
 * 
 */



/**
 * Utility method for determining whether or not the value returned
 * from a handler indicates that it was handled.
 */
function isEventHandled(value) {
  return value === 'handled' || value === true;
}

module.exports = isEventHandled;

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule removeTextWithStrategy
 * @format
 * 
 */



var DraftModifier = __webpack_require__(326);

/**
 * For a collapsed selection state, remove text based on the specified strategy.
 * If the selection state is not collapsed, remove the entire selected range.
 */
function removeTextWithStrategy(editorState, strategy, direction) {
  var selection = editorState.getSelection();
  var content = editorState.getCurrentContent();
  var target = selection;
  if (selection.isCollapsed()) {
    if (direction === 'forward') {
      if (editorState.isSelectionAtEndOfContent()) {
        return content;
      }
    } else if (editorState.isSelectionAtStartOfContent()) {
      return content;
    }

    target = strategy(editorState);
    if (target === selection) {
      return content;
    }
  }
  return DraftModifier.removeRange(content, target, direction);
}

module.exports = removeTextWithStrategy;

/***/ }),
/* 344 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "use", function() { return use; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapFields", function() { return mapFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ErrorBag", function() { return ErrorBag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rules", function() { return Rules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/**
  * ree-validate v2.0.3
  * (c) 2018 Moeen Basra
  * @license MIT
  */
/**
 * Formates file size.
 *
 * @param {Number|String} size
 */
var formatFileSize = function (size) {
  var units = ['Byte', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  var threshold = 1024;
  size = Number(size) * threshold;
  var i = size === 0 ? 0 : Math.floor(Math.log(size) / Math.log(threshold));
  return (((size / Math.pow(threshold, i)).toFixed(2) * 1) + " " + (units[i]));
};

/**
 * Checks if vee-validate is defined globally.
 */
var isDefinedGlobally = function () {
  return typeof VeeValidate !== 'undefined';
};

var obj;
var messages = {
  _default: function (field) { return ("The " + field + " value is not valid."); },
  after: function (field, ref) {
    var target = ref[0];
    var inclusion = ref[1];

    return ("The " + field + " must be after " + (inclusion ? 'or equal to ' : '') + target + ".");
},
  alpha_dash: function (field) { return ("The " + field + " field may contain alpha-numeric characters as well as dashes and underscores."); },
  alpha_num: function (field) { return ("The " + field + " field may only contain alpha-numeric characters."); },
  alpha_spaces: function (field) { return ("The " + field + " field may only contain alphabetic characters as well as spaces."); },
  alpha: function (field) { return ("The " + field + " field may only contain alphabetic characters."); },
  before: function (field, ref) {
    var target = ref[0];
    var inclusion = ref[1];

    return ("The " + field + " must be before " + (inclusion ? 'or equal to ' : '') + target + ".");
},
  between: function (field, ref) {
    var min = ref[0];
    var max = ref[1];

    return ("The " + field + " field must be between " + min + " and " + max + ".");
},
  confirmed: function (field) { return ("The " + field + " confirmation does not match."); },
  credit_card: function (field) { return ("The " + field + " field is invalid."); },
  date_between: function (field, ref) {
    var min = ref[0];
    var max = ref[1];

    return ("The " + field + " must be between " + min + " and " + max + ".");
},
  date_format: function (field, ref) {
    var format = ref[0];

    return ("The " + field + " must be in the format " + format + ".");
},
  decimal: function (field, ref) {
    if ( ref === void 0 ) ref = [];
    var decimals = ref[0]; if ( decimals === void 0 ) decimals = '*';

    return ("The " + field + " field must be numeric and may contain " + (!decimals || decimals === '*' ? '' : decimals) + " decimal points.");
},
  digits: function (field, ref) {
    var length = ref[0];

    return ("The " + field + " field must be numeric and exactly contain " + length + " digits.");
},
  dimensions: function (field, ref) {
    var width = ref[0];
    var height = ref[1];

    return ("The " + field + " field must be " + width + " pixels by " + height + " pixels.");
},
  email: function (field) { return ("The " + field + " field must be a valid email."); },
  ext: function (field) { return ("The " + field + " field must be a valid file."); },
  image: function (field) { return ("The " + field + " field must be an image."); },
  in: function (field) { return ("The " + field + " field must be a valid value."); },
  integer: function (field) { return ("The " + field + " field must be an integer."); },
  ip: function (field) { return ("The " + field + " field must be a valid ip address."); },
  length: function (field, ref) {
    var length = ref[0];
    var max = ref[1];

    if (max) {
      return ("The " + field + " length be between " + length + " and " + max + ".");
    }

    return ("The " + field + " length must be " + length + ".");
  },
  max: function (field, ref) {
    var length = ref[0];

    return ("The " + field + " field may not be greater than " + length + " characters.");
},
  max_value: function (field, ref) {
    var max = ref[0];

    return ("The " + field + " field must be " + max + " or less.");
},
  mimes: function (field) { return ("The " + field + " field must have a valid file type."); },
  min: function (field, ref) {
    var length = ref[0];

    return ("The " + field + " field must be at least " + length + " characters.");
},
  min_value: function (field, ref) {
    var min = ref[0];

    return ("The " + field + " field must be " + min + " or more.");
},
  not_in: function (field) { return ("The " + field + " field must be a valid value."); },
  numeric: function (field) { return ("The " + field + " field may only contain numeric characters."); },
  regex: function (field) { return ("The " + field + " field format is invalid."); },
  required: function (field) { return ("The " + field + " field is required."); },
  size: function (field, ref) {
    var size = ref[0];

    return ("The " + field + " size must be less than " + (formatFileSize(size)) + ".");
},
  url: function (field) { return ("The " + field + " field is not a valid URL."); }
};

var locale = {
  name: 'en',
  messages: messages,
  attributes: {}
};

if (isDefinedGlobally()) {
  // eslint-disable-next-line
  VeeValidate.Validator.localize(( obj = {}, obj[locale.name] = locale, obj));
}

// 

/**
 * Gets the data attribute. the name must be kebab-case.
 */
var getDataAttribute = function (el, name) { return el.getAttribute(("data-vv-" + name)); };

/**
 * Checks if the value is either null or undefined.
 */
var isNullOrUndefined = function (value) {
  return value === null || value === undefined
};

/**
 * Sets the data attribute.
 */
var setDataAttribute = function (el, name, value) { return el.setAttribute(("data-vv-" + name), value); };

/**
 * Creates the default flags object.
 */
var createFlags = function () { return ({
  untouched: true,
  touched: false,
  dirty: false,
  pristine: true,
  valid: null,
  invalid: null,
  validated: false,
  pending: false,
  required: false,
}); };

/**
 * Shallow object comparison.
 */


/**
 * Determines the input field scope.
 */


/**
 * Gets the value in an object safely.
 */
var getPath = function (path, target, def) {
  if ( def === void 0 ) def = undefined;

  if (!path || !target) { return def }

  var value = target;
  path.split('.').every(function (prop) {
    if (! Object.prototype.hasOwnProperty.call(value, prop) && value[prop] === undefined) {
      value = def;

      return false
    }

    value = value[prop];

    return true
  });

  return value
};

/**
 * Checks if path exists within an object.
 */


/**
 * Parses a rule string expression.
 */
var parseRule = function (rule) {
  var params = [];
  var name = rule.split(':')[0];

  if (~rule.indexOf(':')) {
    params = rule.split(':').slice(1).join(':').split(',');
  }

  return { name: name, params: params }
};

/**
 * Debounces a function.
 */
var debounce = function (fn, wait, immediate) {
  if ( wait === void 0 ) wait = 0;
  if ( immediate === void 0 ) immediate = false;

  if (wait === 0) {
    return fn
  }

  var timeout;

  return function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var later = function () {
      timeout = null;
      if (!immediate) { fn.apply(void 0, args); }
    };
    /* istanbul ignore next */
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    /* istanbul ignore next */
    if (callNow) { fn.apply(void 0, args); }
  }
};

/**
 * Normalizes the given rules expression.
 */
var normalizeRules = function (rules) {
  // if falsy value return an empty object.
  if (!rules) {
    return {}
  }

  if (isObject(rules)) {
    // $FlowFixMe
    return Object.keys(rules).reduce(function (prev, curr) {
      var params = [];
      // $FlowFixMe
      if (rules[curr] === true) {
        params = [];
      } else if (Array.isArray(rules[curr])) {
        params = rules[curr];
      } else {
        params = [rules[curr]];
      }

      // $FlowFixMe
      if (rules[curr] !== false) {
        prev[curr] = params;
      }

      return prev
    }, {})
  }

  if (typeof rules !== 'string') {
    warn('rules must be either a string or an object.');
    return {}
  }

  return rules.split('|').reduce(function (prev, rule) {
    var parsedRule = parseRule(rule);
    if (!parsedRule.name) {
      return prev
    }

    prev[parsedRule.name] = parsedRule.params;
    return prev
  }, {})
};

/**
 * Emits a warning to the console.
 */
var warn = function (message) {
  console.warn(("[ree-validate] " + message)); // eslint-disable-line
};

/**
 * Creates a branded error object.
 */
var createError = function (message) { return new Error(("[ree-validate] " + message)); };

/**
 * Checks if the value is an object.
 */
var isObject = function (obj) { return obj !== null && obj && typeof obj === 'object' && ! Array.isArray(obj); };

/**
 * Checks if a function is callable.
 */
var isCallable = function (func) { return typeof func === 'function'; };

/**
 * Check if element has the css class on it.
 */
var hasClass = function (el, className) {
  if (el.classList) {
    return el.classList.contains(className)
  }

  return !!el.className.match(new RegExp(("(\\s|^)" + className + "(\\s|$)")))
};

/**
 * Adds the provided css className to the element.
 */
var addClass = function (el, className) {
  if (el.classList) {
    el.classList.add(className);
    return
  }

  if (!hasClass(el, className)) {
    el.className += " " + className;
  }
};

/**
 * Remove the provided css className from the element.
 */
var removeClass = function (el, className) {
  if (el.classList) {
    el.classList.remove(className);
    return
  }

  if (hasClass(el, className)) {
    var reg = new RegExp(("(\\s|^)" + className + "(\\s|$)"));
    el.className = el.className.replace(reg, ' ');
  }
};

/**
 * Adds or removes a class name on the input depending on the status flag.
 */
var toggleClass = function (el, className, status) {
  if (!el || !className) { return; }

  if (Array.isArray(className)) {
    className.forEach(function (item) { return toggleClass(el, item, status); });
    return;
  }

  if (status) {
    return addClass(el, className)
  }

  removeClass(el, className);
};

/**
 * Converts an array-like object to array, provides a simple polyfill for Array.from
 */
var toArray = function (arrayLike) {
  if (isCallable(Array.from)) {
    return Array.from(arrayLike)
  }

  var array = [];
  var length = arrayLike.length;
  for (var i = 0; i < length; i++) {
    array.push(arrayLike[i]);
  }

  return array
};

/**
 * Assign polyfill from the mdn.
 */
var assign = function (target) {
  var others = [], len = arguments.length - 1;
  while ( len-- > 0 ) others[ len ] = arguments[ len + 1 ];

  /* istanbul ignore else */
  if (isCallable(Object.assign)) {
    return Object.assign.apply(Object, [ target ].concat( others ))
  }

  /* istanbul ignore next */
  if (target == null) {
    throw new TypeError('Cannot convert undefined or null to object')
  }

  /* istanbul ignore next */
  var to = Object(target);
  /* istanbul ignore next */
  others.forEach(function (arg) {
    // Skip over if undefined or null
    if (arg != null) {
      Object.keys(arg).forEach(function (key) {
        to[key] = arg[key];
      });
    }
  });
  /* istanbul ignore next */
  return to
};

var id = 0;
var idTemplate = '{id}';

/**
 * Generates a unique id.
 */
var uniqId = function () {
  // handle too many uses of uniqId, although unlikely.
  if (id >= 9999) {
    id = 0;
    // shift the template.
    idTemplate = idTemplate.replace('{id}', '_{id}');
  }

  id++;
  var newId = idTemplate.replace('{id}', String(id));

  return newId
};

/**
 * finds the first element that satisfies the predicate callback, polyfills array.find
 */
var find = function (arrayLike, predicate) {
  var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);
  for (var i = 0; i < array.length; i++) {
    if (predicate(array[i])) {
      return array[i]
    }
  }

  return undefined
};

/**
 * Returns a suitable event name for the input element.
 */
var getInputEventName = function (el) {
  if (el && (el.tagName === 'SELECT' || ~['radio', 'checkbox', 'file'].indexOf(el.type))) {
    return 'change'
  }

  return 'input'
};



var makeEventsArray = function (events) {
  return (typeof events === 'string' && events.length) ? events.split('|') : []
};

var makeDelayObject = function (events, delay, delayConfig) {
  if (typeof delay === 'number') {
    return events.reduce(function (prev, e) {
      prev[e] = delay;
      return prev
    }, {})
  }

  return events.reduce(function (prev, e) {
    if (typeof delay === 'object' && e in delay) {
      prev[e] = delay[e];
      return prev
    }

    if (typeof delayConfig === 'number') {
      prev[e] = delayConfig;
      return prev
    }

    prev[e] = (delayConfig && delayConfig[e]) || 0;

    return prev
  }, {})
};



var merge = function (target, source) {
  if (! (isObject(target) && isObject(source))) {
    return target
  }

  Object.keys(source).forEach(function (key) {
    var obj, obj$1;

    if (isObject(source[key])) {
      if (! target[key]) {
        assign(target, ( obj = {}, obj[key] = {}, obj));
      }

      merge(target[key], source[key]);
      return
    }

    assign(target, ( obj$1 = {}, obj$1[key] = source[key], obj$1));
  });

  return target
};

// 

var ErrorBag = function ErrorBag () {
  this.items = [];
};

/**
 * Adds an error to the internal array.
 */
ErrorBag.prototype.add = function add (error) {
  // handle old signature.
  if (arguments.length > 1) {
    error = {
      field: arguments[0],
      msg: arguments[1],
      rule: arguments[2],
      scope: !isNullOrUndefined(arguments[3]) ? arguments[3] : null,
      regenerate: null,
    };
  }

  error.scope = !isNullOrUndefined(error.scope) ? error.scope : null;
  this.items.push(error);
};

/**
 * Regenrates error messages if they have a generator function.
 */
ErrorBag.prototype.regenerate = function regenerate () {
  this.items.forEach(function (i) {
    i.msg = isCallable(i.regenerate) ? i.regenerate() : i.msg;
  });
};

/**
 * Updates a field error with the new field scope.
 */
ErrorBag.prototype.update = function update (id, error) {
  var item = find(this.items, function (i) { return i.id === id; });
  if (!item) {
    return
  }

  var idx = this.items.indexOf(item);
  this.items.splice(idx, 1);
  item.scope = error.scope;
  this.items.push(item);
};

/**
 * Gets all error messages from the internal array.
 */
ErrorBag.prototype.all = function all (scope) {
  if (isNullOrUndefined(scope)) {
    return this.items.map(function (e) { return e.msg; })
  }

  return this.items.filter(function (e) { return e.scope === scope; }).map(function (e) { return e.msg; })
};

/**
 * Checks if there are any errors in the internal array.
 */
ErrorBag.prototype.any = function any (scope) {
  if (isNullOrUndefined(scope)) {
    return !!this.items.length
  }

  return !!this.items.filter(function (e) { return e.scope === scope; }).length
};

/**
 * Removes all items from the internal array.
 */
ErrorBag.prototype.clear = function clear (scope) {
    var this$1 = this;

  if (isNullOrUndefined(scope)) {
    scope = null;
  }

  for (var i = 0; i < this.items.length; ++i) {
    if (this$1.items[i].scope === scope) {
      this$1.items.splice(i, 1);
      --i;
    }
  }
};

/**
 * Collects errors into groups or for a specific field.
 */
ErrorBag.prototype.collect = function collect (field, scope, map) {
    if ( map === void 0 ) map = true;

  if (!field) {
    var collection = {};
    this.items.forEach(function (e) {
      if (!collection[e.field]) {
        collection[e.field] = [];
      }

      collection[e.field].push(map ? e.msg : e);
    });

    return collection
  }

  field = !isNullOrUndefined(field) ? String(field) : field;
  if (isNullOrUndefined(scope)) {
    return this.items.filter(function (e) { return e.field === field; }).map(function (e) { return (map ? e.msg : e); })
  }

  return this.items.filter(function (e) { return e.field === field && e.scope === scope; })
    .map(function (e) { return (map ? e.msg : e); })
};
/**
 * Gets the internal array length.
 */
ErrorBag.prototype.count = function count () {
  return this.items.length
};

/**
 * Finds and fetches the first error message for the specified field id.
 */
ErrorBag.prototype.firstById = function firstById (id) {
  var error = find(this.items, function (i) { return i.id === id; });

  return error ? error.msg : null
};

/**
 * Gets the first error message for a specific field.
 */
ErrorBag.prototype.first = function first (field, scope) {
    var this$1 = this;
    if ( scope === void 0 ) scope = null;

  if (isNullOrUndefined(field)) {
    return null
  }

  field = String(field);
  var selector = this._selector(field);
  var scoped = this._scope(field);

  if (scoped) {
    var result = this.first(scoped.name, scoped.scope);
    // if such result exist, return it. otherwise it could be a field.
    // with dot in its name.
    if (result) {
      return result
    }
  }

  if (selector) {
    return this.firstByRule(selector.name, selector.rule, scope)
  }

  for (var i = 0; i < this.items.length; ++i) {
    if (this$1.items[i].field === field && (this$1.items[i].scope === scope)) {
      return this$1.items[i].msg
    }
  }

  return null
};

/**
 * Returns the first error rule for the specified field
 */
ErrorBag.prototype.firstRule = function firstRule (field, scope) {
  var errors = this.collect(field, scope, false);

  return (errors.length && errors[0].rule) || null
};

/**
 * Checks if the internal array has at least one error for the specified field.
 */
ErrorBag.prototype.has = function has (field, scope) {
    if ( scope === void 0 ) scope = null;

  return !!this.first(field, scope)
};

/**
 * Gets the first error message for a specific field and a rule.
 */
ErrorBag.prototype.firstByRule = function firstByRule (name, rule, scope) {
    if ( scope === void 0 ) scope = null;

  var error = this.collect(name, scope, false).filter(function (e) { return e.rule === rule; })[0];

  return (error && error.msg) || null
};

/**
 * Gets the first error message for a specific field that not match the rule.
 */
ErrorBag.prototype.firstNot = function firstNot (name, rule, scope) {
    if ( rule === void 0 ) rule = 'required';
    if ( scope === void 0 ) scope = null;

  var error = this.collect(name, scope, false).filter(function (e) { return e.rule !== rule; })[0];

  return (error && error.msg) || null
};

/**
 * Removes errors by matching against the id.
 */
ErrorBag.prototype.removeById = function removeById (id) {
    var this$1 = this;

  for (var i = 0; i < this.items.length; ++i) {
    if (this$1.items[i].id === id) {
      this$1.items.splice(i, 1);
      --i;
    }
  }
};

/**
 * Removes all error messages associated with a specific field.
 */
ErrorBag.prototype.remove = function remove (field, scope, id) {
    var this$1 = this;

  field = !isNullOrUndefined(field) ? String(field) : field;
  var removeCondition = function (e) {
    if (e.id && id) {
      return e.id === id
    }

    if (!isNullOrUndefined(scope)) {
      return e.field === field && e.scope === scope
    }

    return e.field === field && e.scope === null
  };

  for (var i = 0; i < this.items.length; ++i) {
    if (removeCondition(this$1.items[i])) {
      this$1.items.splice(i, 1);
      --i;
    }
  }
};

/**
 * Get the field attributes if there's a rule selector.
 */
ErrorBag.prototype._selector = function _selector (field) {
  if (field.indexOf(':') > -1) {
    var ref = field.split(':');
      var name = ref[0];
      var rule = ref[1];

    return { name: name, rule: rule }
  }

  return null
};

/**
 * Get the field scope if specified using dot notation.
 */
ErrorBag.prototype._scope = function _scope (field) {
  if (field.indexOf('.') > -1) {
    var ref = field.split('.');
      var scope = ref[0];
      var name = ref.slice(1);

    return { name: name.join('.'), scope: scope }
  }

  return null
};

// 

var DEFAULT_OPTIONS = {
  targetOf: null,
  initial: false,
  scope: null,
  listen: true,
  name: null,
  rules: {},
  vm: null,
  classes: false,
  validity: true,
  aria: true,
  events: 'input|blur',
  delay: 0,
  classNames: {
    touched: 'touched', // the control has been blurred
    untouched: 'untouched', // the control hasn't been blurred
    valid: 'valid', // model is valid
    invalid: 'invalid', // model is invalid
    pristine: 'pristine', // control has not been interacted with
    dirty: 'dirty', // control has been interacted with
  },
};

var Field = function Field (el, options) {
  if ( options === void 0 ) options = {};

  this.id = uniqId();
  this.el = el;
  this.updated = false;
  this.dependencies = [];
  this.watchers = [];
  this.events = [];
  this.delay = 0;
  this.rules = {};
  this._cacheId(options);
  this.classNames = assign({}, DEFAULT_OPTIONS.classNames);
  options = assign({}, DEFAULT_OPTIONS, options);
  this._delay = !isNullOrUndefined(options.delay) ? options.delay : 0; // cache initial delay
  this.validity = options.validity;
  this.aria = options.aria;
  this.flags = createFlags();
  this.vm = options.vm;
  this.component = options.component;
  this.ctorConfig = this.component ? getPath('$options.$_reeValidate', this.component) : undefined;
  this.update(options);
  this.updated = false;
};

var prototypeAccessors = { validator: { configurable: true },isRequired: { configurable: true },isDisabled: { configurable: true },alias: { configurable: true },value: { configurable: true },rejectsFalse: { configurable: true } };

prototypeAccessors.validator.get = function () {
  if (!this.vm || !this.vm.$validator) {
    warn('No validator instance detected.');
    return { validate: function () {} }
  }

  return this.vm.$validator
};

prototypeAccessors.isRequired.get = function () {
  return !!this.rules.required
};

prototypeAccessors.isDisabled.get = function () {
  return !!(this.component && this.component.disabled) || !!(this.el && this.el.disabled)
};

/**
 * Gets the display name (user-friendly name).
 */
prototypeAccessors.alias.get = function () {
  if (this._alias) {
    return this._alias
  }

  var alias = null;
  if (this.el) {
    alias = getDataAttribute(this.el, 'as');
  }

  if (!alias && this.component) {
    return this.component.$attrs && this.component.$attrs['data-vv-as']
  }

  return alias
};

/**
 * Gets the input value.
 */

prototypeAccessors.value.get = function () {
  if (!isCallable(this.getter)) {
    return undefined
  }

  return this.getter()
};

/**
 * If the field rejects false as a valid value for the required rule.
 */

prototypeAccessors.rejectsFalse.get = function () {
  if (this.component && this.ctorConfig) {
    return !!this.ctorConfig.rejectsFalse
  }

  if (!this.el) {
    return false
  }

  return this.el.type === 'checkbox'
};

/**
 * Determines if the instance matches the options provided.
 */
Field.prototype.matches = function matches (options) {
  if (options.id) {
    return this.id === options.id
  }

  if (options.name === undefined && options.scope === undefined) {
    return true
  }

  if (options.scope === undefined) {
    return this.name === options.name
  }

  if (options.name === undefined) {
    return this.scope === options.scope
  }

  return options.name === this.name && options.scope === this.scope
};

/**
 * Caches the field id.
 */
Field.prototype._cacheId = function _cacheId (options) {
  if (this.el && !options.targetOf) {
    setDataAttribute(this.el, 'id', this.id); // cache field id if it is independent and has a root element.
  }
};

/**
 * Updates the field with changed data.
 */
Field.prototype.update = function update (options) {
  this.targetOf = options.targetOf || null;
  this.initial = options.initial || this.initial || false;

  // update errors scope if the field scope was changed.
  if (!isNullOrUndefined(options.scope) && options.scope !== this.scope && isCallable(this.validator.update)) {
    this.validator.update(this.id, { scope: options.scope });
  }
  this.scope = !isNullOrUndefined(options.scope) ? options.scope
    : !isNullOrUndefined(this.scope) ? this.scope : null;
  this.name = (!isNullOrUndefined(options.name) ? String(options.name) : options.name) || this.name || null;
  this.rules = options.rules !== undefined ? normalizeRules(options.rules) : this.rules;
  this.model = options.model || this.model;
  this.listen = options.listen !== undefined ? options.listen : this.listen;
  this.classes = (options.classes || this.classes || false) && !this.component;
  this.classNames = isObject(options.classNames) ? merge(this.classNames, options.classNames) : this.classNames;
  this.getter = isCallable(options.getter) ? options.getter : this.getter;
  this._alias = options.alias || this._alias;
  this.events = (options.events) ? makeEventsArray(options.events) : this.events;
  this.delay = (options.delay) ? makeDelayObject(this.events, options.delay, this._delay) : makeDelayObject(this.events, this.delay, this._delay);
  this.updateDependencies();
  this.addActionListeners();

  // update required flag flags
  if (options.rules !== undefined) {
    this.flags.required = this.isRequired;
  }

  // validate if it was validated before and field was updated and there was a rules mutation.
  if (this.flags.validated && options.rules !== undefined && this.updated) {
    this.validator.validate(("#" + (this.id)));
  }

  this.updated = true;
  this.addValueListeners();

  // no need to continue.
  if (!this.el) {
    return
  }

  this.updateClasses();
  this.updateAriaAttrs();
};

/**
 * Resets field flags and errors.
 */
Field.prototype.reset = function reset () {
    var this$1 = this;

  var defaults = createFlags();
  Object.keys(this.flags).filter(function (flag) { return flag !== 'required'; }).forEach(function (flag) {
    this$1.flags[flag] = defaults[flag];
  });

  this.addActionListeners();
  this.updateClasses();
  this.updateAriaAttrs();
  this.updateCustomValidity();
};

/**
 * Sets the flags and their negated counterparts, and updates the classes and re-adds action listeners.
 */
Field.prototype.setFlags = function setFlags (flags) {
    var this$1 = this;

  var negated = {
    pristine: 'dirty',
    dirty: 'pristine',
    valid: 'invalid',
    invalid: 'valid',
    touched: 'untouched',
    untouched: 'touched',
  };

  Object.keys(flags).forEach(function (flag) {
    this$1.flags[flag] = flags[flag];
    // if it has a negation and was not specified, set it as well.
    if (negated[flag] && flags[negated[flag]] === undefined) {
      this$1.flags[negated[flag]] = !flags[flag];
    }
  });

  if (
    flags.untouched !== undefined ||
    flags.touched !== undefined ||
    flags.dirty !== undefined ||
    flags.pristine !== undefined
  ) {
    this.addActionListeners();
  }
  this.updateClasses();
  this.updateAriaAttrs();
  this.updateCustomValidity();
};

/**
 * Determines if the field requires references to target fields.
 */
Field.prototype.updateDependencies = function updateDependencies () {
    var this$1 = this;

  // reset dependencies.
  this.dependencies.forEach(function (d) { return d.field.destroy(); });
  this.dependencies = [];

  // we get the selectors for each field.
  var fields = Object.keys(this.rules).reduce(function (prev, r) {
    if (Validator.isTargetRule(r)) {
      var selector = this$1.rules[r][0];
      if (r === 'confirmed' && !selector) {
        selector = (this$1.name) + "_confirmation";
      }

      prev.push({ selector: selector, name: r });
    }

    return prev
  }, []);

  if (!fields.length || !this.vm || !this.vm.$el) { return }

  // must be contained within the same component, so we use the vm root element constrain our dom search.
  fields.forEach(function (ref) {
      var selector = ref.selector;
      var name = ref.name;

    var el = null;
    // vue ref selector.
    if (selector[0] === '$') {
      var ref$1 = this$1.vm.$refs[selector.slice(1)];
      el = Array.isArray(ref$1) ? ref$1[0] : ref$1;
    } else {
      try {
        // try query selector
        el = this$1.vm.$el.querySelector(selector);
      } catch (err) {
        el = null;
      }
    }

    if (!el) {
      try {
        el = this$1.vm.$el.querySelector(("input[name=\"" + selector + "\"]"));
      } catch (err) {
        el = null;
      }
    }

    if (!el) {
      return
    }

    var options = {
      vm: this$1.vm,
      classes: this$1.classes,
      classNames: this$1.classNames,
      delay: this$1.delay,
      scope: this$1.scope,
      events: this$1.events.join('|'),
      initial: this$1.initial,
      targetOf: this$1.id,
    };

    this$1.dependencies.push({ name: name, field: new Field(options.el, options) });
  });
};

/**
 * Removes listeners.
 */
Field.prototype.unwatch = function unwatch (tag) {
    if ( tag === void 0 ) tag = null;

  if (!tag) {
    this.watchers.forEach(function (w) { return w.unwatch(); });
    this.watchers = [];
    return
  }

  this.watchers.filter(function (w) { return tag.test(w.tag); }).forEach(function (w) { return w.unwatch(); });
  this.watchers = this.watchers.filter(function (w) { return !tag.test(w.tag); });
};

/**
 * Updates the element classes depending on each field flag status.
 */
Field.prototype.updateClasses = function updateClasses () {
  if (!this.classes || this.isDisabled) { return }

  toggleClass(this.el, this.classNames.dirty, this.flags.dirty);
  toggleClass(this.el, this.classNames.pristine, this.flags.pristine);
  toggleClass(this.el, this.classNames.touched, this.flags.touched);
  toggleClass(this.el, this.classNames.untouched, this.flags.untouched);
  // make sure we don't set any classes if the state is undetermined.
  if (!isNullOrUndefined(this.flags.valid) && this.flags.validated) {
    toggleClass(this.el, this.classNames.valid, this.flags.valid);
  }

  if (!isNullOrUndefined(this.flags.invalid) && this.flags.validated) {
    toggleClass(this.el, this.classNames.invalid, this.flags.invalid);
  }
};

/**
 * Adds the listeners required for automatic classes and some flags.
 */
Field.prototype.addActionListeners = function addActionListeners () {
    var this$1 = this;

  // remove previous listeners.
  this.unwatch(/class/);

  var onBlur = function () {
    this$1.flags.touched = true;
    this$1.flags.untouched = false;
    if (this$1.classes) {
      toggleClass(this$1.el, this$1.classNames.touched, true);
      toggleClass(this$1.el, this$1.classNames.untouched, false);
    }

    // only needed once.
    this$1.unwatch(/^class_blur$/);
  };

  var inputEvent = getInputEventName(this.el);
  var onInput = function () {
    this$1.flags.dirty = true;
    this$1.flags.pristine = false;
    if (this$1.classes) {
      toggleClass(this$1.el, this$1.classNames.pristine, false);
      toggleClass(this$1.el, this$1.classNames.dirty, true);
    }

    // only needed once.
    this$1.unwatch(/^class_input$/);
  };

  if (this.component && isCallable(this.component.$once)) {
    this.component.$once('input', onInput);
    this.component.$once('blur', onBlur);
    this.watchers.push({
      tag: 'class_input',
      unwatch: function () {
        this$1.component.$off('input', onInput);
      },
    });
    this.watchers.push({
      tag: 'class_blur',
      unwatch: function () {
        this$1.component.$off('blur', onBlur);
      },
    });
    return
  }

  if (!this.el) { return }

  this.el.addEventListener(inputEvent, onInput);
  // Checkboxes and radio buttons on Mac don't emit blur naturally, so we listen on click instead.
  var blurEvent = ['radio', 'checkbox'].indexOf(this.el.type) === -1 ? 'blur' : 'click';
  this.el.addEventListener(blurEvent, onBlur);
  this.watchers.push({
    tag: 'class_input',
    unwatch: function () {
      this$1.el.removeEventListener(inputEvent, onInput);
    },
  });

  this.watchers.push({
    tag: 'class_blur',
    unwatch: function () {
      this$1.el.removeEventListener(blurEvent, onBlur);
    },
  });
};

/**
 * Adds the listeners required for validation.
 */
Field.prototype.addValueListeners = function addValueListeners () {
    var this$1 = this;

  this.unwatch(/^input_.+/);
  if (!this.listen) { return }

  var fn = this.targetOf ? function () {
    this$1.validator.validate(("#" + (this$1.targetOf)));
  } : function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

    // if its a DOM event, resolve the value, otherwise use the first parameter as the value.
    if (args.length === 0 || (isCallable(Event) && args[0] instanceof Event) || (args[0] && args[0].srcElement)) {
      args[0] = this$1.value;
    }

    this$1.validator.validate(("#" + (this$1.id)), args[0]);
  };

  var inputEvent = this.model && this.model.lazy ? 'change' : getInputEventName(this.el);
  // replace input event with suitable one.
  var events = this.events.map(function (e) {
    return e === 'input' ? inputEvent : e
  });

  // if there is a watchable model and an on input validation is requested.
  if (this.model && this.model.expression && events.indexOf(inputEvent) !== -1) {
    var debouncedFn = debounce(fn, this.delay[inputEvent]);
    var unwatch = this.vm.$watch(this.model.expression, function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

      this$1.flags.pending = true;
      debouncedFn.apply(void 0, args);
    });
    this.watchers.push({
      tag: 'input_model',
      unwatch: unwatch,
    });
    // filter out input event as it is already handled by the watcher API.
    events = events.filter(function (e) { return e !== inputEvent; });
  }

  // Add events.
  events.forEach(function (e) {
    var debouncedFn = debounce(fn, this$1.delay[e]);
    var validate = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

      this$1.flags.pending = true;
      debouncedFn.apply(void 0, args);
    };

    this$1._addComponentEventListener(e, validate);
    this$1._addHTMLEventListener(e, validate);
  });
};

Field.prototype._addComponentEventListener = function _addComponentEventListener (evt, validate) {
    var this$1 = this;

  if (!this.component) { return }

  this.component.$on(evt, validate);
  this.watchers.push({
    tag: 'input_vue',
    unwatch: function () {
      this$1.component.$off(evt, validate);
    },
  });
};

Field.prototype._addHTMLEventListener = function _addHTMLEventListener (evt, validate) {
    var this$1 = this;

  if (!this.el) { return }

  if (~['radio', 'checkbox'].indexOf(this.el.type)) {
    var els = document.querySelectorAll(("input[name=\"" + (this.el.name) + "\"]"));
    toArray(els).forEach(function (el) {
      el.addEventListener(evt, validate);
      this$1.watchers.push({
        tag: 'input_native',
        unwatch: function () {
          el.removeEventListener(evt, validate);
        },
      });
    });

    return
  }

  this.el.addEventListener(evt, validate);
  this.watchers.push({
    tag: 'input_native',
    unwatch: function () {
      this$1.el.removeEventListener(evt, validate);
    },
  });
};

/**
 * Updates aria attributes on the element.
 */
Field.prototype.updateAriaAttrs = function updateAriaAttrs () {
  if (!this.aria || !this.el || !isCallable(this.el.setAttribute)) { return }

  this.el.setAttribute('aria-required', this.isRequired ? 'true' : 'false');
  this.el.setAttribute('aria-invalid', this.flags.invalid ? 'true' : 'false');
};

/**
 * Updates the custom validity for the field.
 */
Field.prototype.updateCustomValidity = function updateCustomValidity () {
  if (!this.validity || !this.el || !isCallable(this.el.setCustomValidity)) { return }

  this.el.setCustomValidity(this.flags.valid ? '' : (this.validator.errors.firstById(this.id) || ''));
};

/**
 * Removes all listeners.
 */
Field.prototype.destroy = function destroy () {
  this.unwatch();
  this.dependencies.forEach(function (d) { return d.field.destroy(); });
  this.dependencies = [];
};

Object.defineProperties( Field.prototype, prototypeAccessors );

// 

var FieldBag = function FieldBag () {
  this.items = [];
};

var prototypeAccessors$1 = { length: { configurable: true } };

/**
 * Gets the current items length.
 */

prototypeAccessors$1.length.get = function () {
  return this.items.length
};

/**
 * Finds the first field that matches the provided matcher object.
 */
FieldBag.prototype.find = function find$1 (matcher) {
  return find(this.items, function (item) { return item.matches(matcher); })
};

/**
 * Filters the items down to the matched fields.
 */
FieldBag.prototype.filter = function filter (matcher) {
  // multiple matchers to be tried.
  if (Array.isArray(matcher)) {
    return this.items.filter(function (item) { return matcher.some(function (m) { return item.matches(m); }); })
  }

  return this.items.filter(function (item) { return item.matches(matcher); })
};

/**
 * Maps the field items using the mapping function.
 */
FieldBag.prototype.map = function map (mapper) {
  return this.items.map(mapper)
};

/**
 * Finds and removes the first field that matches the provided matcher object, returns the removed item.
 */
FieldBag.prototype.remove = function remove (matcher) {
  var item = null;
  if (matcher instanceof Field) {
    item = matcher;
  } else {
    item = this.find(matcher);
  }

  if (!item) { return null }

  var index = this.items.indexOf(item);
  this.items.splice(index, 1);

  return item
};

/**
 * Adds a field item to the list.
 */
FieldBag.prototype.push = function push (item) {
  if (! (item instanceof Field)) {
    throw createError('FieldBag only accepts instances of Field that has an id defined.')
  }

  if (!item.id) {
    throw createError('Field id must be defined.')
  }

  if (this.find({ id: item.id })) {
    throw createError(("Field with id " + (item.id) + " is already added."))
  }

  this.items.push(item);
};

Object.defineProperties( FieldBag.prototype, prototypeAccessors$1 );

// 

var LOCALE = 'en';

var Dictionary = function Dictionary (dictionary) {
  if ( dictionary === void 0 ) dictionary = {};

  this.container = {};
  this.merge(dictionary);
};

var prototypeAccessors$2 = { locale: { configurable: true } };

prototypeAccessors$2.locale.get = function () {
  return LOCALE
};

prototypeAccessors$2.locale.set = function (value) {
  LOCALE = value || 'en';
};

Dictionary.prototype.hasLocale = function hasLocale (locale) {
  return !!this.container[locale]
};

Dictionary.prototype.setDateFormat = function setDateFormat (locale, format) {
  if (!this.container[locale]) {
    this.container[locale] = {};
  }

  this.container[locale].dateFormat = format;
};

Dictionary.prototype.getDateFormat = function getDateFormat (locale) {
  if (!this.container[locale] || !this.container[locale].dateFormat) {
    return null
  }

  return this.container[locale].dateFormat
};

Dictionary.prototype.getMessage = function getMessage (locale, key, data) {
  var message = null;
  if (!this.hasMessage(locale, key)) {
    message = this._getDefaultMessage(locale);
  } else {
    message = this.container[locale].messages[key];
  }

  return isCallable(message) ? message.apply(void 0, data) : message
};

/**
 * Gets a specific message for field. falls back to the rule message.
 */
Dictionary.prototype.getFieldMessage = function getFieldMessage (locale, field, key, data) {
  if (!this.hasLocale(locale)) {
    return this.getMessage(locale, key, data)
  }

  var dict = this.container[locale].custom && this.container[locale].custom[field];
  if (!dict || !dict[key]) {
    return this.getMessage(locale, key, data)
  }

  var message = dict[key];
  return isCallable(message) ? message.apply(void 0, data) : message
};

Dictionary.prototype._getDefaultMessage = function _getDefaultMessage (locale) {
  if (this.hasMessage(locale, '_default')) {
    return this.container[locale].messages._default
  }

  return this.container.en.messages._default
};

Dictionary.prototype.getAttribute = function getAttribute (locale, key, fallback) {
    if ( fallback === void 0 ) fallback = '';

  if (!this.hasAttribute(locale, key)) {
    return fallback
  }

  return this.container[locale].attributes[key]
};

Dictionary.prototype.hasMessage = function hasMessage (locale, key) {
  return !! (
    this.hasLocale(locale) &&
          this.container[locale].messages &&
          this.container[locale].messages[key]
  )
};

Dictionary.prototype.hasAttribute = function hasAttribute (locale, key) {
  return !! (
    this.hasLocale(locale) &&
          this.container[locale].attributes &&
          this.container[locale].attributes[key]
  )
};

Dictionary.prototype.merge = function merge$1 (dictionary) {
  merge(this.container, dictionary);
};

Dictionary.prototype.setMessage = function setMessage (locale, key, message) {
  if (! this.hasLocale(locale)) {
    this.container[locale] = {
      messages: {},
      attributes: {},
    };
  }

  this.container[locale].messages[key] = message;
};

Dictionary.prototype.setAttribute = function setAttribute (locale, key, attribute) {
  if (! this.hasLocale(locale)) {
    this.container[locale] = {
      messages: {},
      attributes: {},
    };
  }

  this.container[locale].attributes[key] = attribute;
};

Object.defineProperties( Dictionary.prototype, prototypeAccessors$2 );

// 

var normalizeValue = function (value) {
  if (isObject(value)) {
    return Object.keys(value).reduce(function (prev, key) {
      prev[key] = normalizeValue(value[key]);

      return prev
    }, {})
  }

  if (isCallable(value)) {
    return value('{0}', ['{1}', '{2}', '{3}'])
  }

  return value
};

var normalizeFormat = function (locale) {
  // normalize messages
  var messages = normalizeValue(locale.messages);
  var custom = normalizeValue(locale.custom);

  return {
    messages: messages,
    custom: custom,
    attributes: locale.attributes,
    dateFormat: locale.dateFormat,
  }
};

var I18nDictionary = function I18nDictionary (i18n, rootKey) {
  this.i18n = i18n;
  this.rootKey = rootKey;
};

var prototypeAccessors$3 = { locale: { configurable: true } };

prototypeAccessors$3.locale.get = function () {
  return this.i18n.locale
};

prototypeAccessors$3.locale.set = function (value) {
  warn('Cannot set locale from the validator when using vue-i18n, use i18n.locale setter instead');
};

I18nDictionary.prototype.getDateFormat = function getDateFormat (locale) {
  return this.i18n.getDateTimeFormat(locale || this.locale)
};

I18nDictionary.prototype.setDateFormat = function setDateFormat (locale, value) {
  this.i18n.setDateTimeFormat(locale || this.locale, value);
};

I18nDictionary.prototype.getMessage = function getMessage (locale, key, data) {
  var path = (this.rootKey) + ".messages." + key;
  if (!this.i18n.te(path)) {
    return this.i18n.t(((this.rootKey) + ".messages._default"), locale, data)
  }

  return this.i18n.t(path, locale, data)
};

I18nDictionary.prototype.getAttribute = function getAttribute (locale, key, fallback) {
    if ( fallback === void 0 ) fallback = '';

  var path = (this.rootKey) + ".attributes." + key;
  if (!this.i18n.te(path)) {
    return fallback
  }

  return this.i18n.t(path, locale)
};

I18nDictionary.prototype.getFieldMessage = function getFieldMessage (locale, field, key, data) {
  var path = (this.rootKey) + ".custom." + field + "." + key;
  if (this.i18n.te(path)) {
    return this.i18n.t(path)
  }

  return this.getMessage(locale, key, data)
};

I18nDictionary.prototype.merge = function merge$1 (dictionary) {
    var this$1 = this;

  Object.keys(dictionary).forEach(function (localeKey) {
      var obj;

    // i18n doesn't deep merge
    // first clone the existing locale (avoid mutations to locale)
    var clone = merge({}, getPath((localeKey + "." + (this$1.rootKey)), this$1.i18n.messages, {}));
    // Merge cloned locale with new one
    var locale = merge(clone, normalizeFormat(dictionary[localeKey]));
    this$1.i18n.mergeLocaleMessage(localeKey, ( obj = {}, obj[this$1.rootKey] = locale, obj));
    if (locale.dateFormat) {
      this$1.i18n.setDateTimeFormat(localeKey, locale.dateFormat);
    }
  });
};

I18nDictionary.prototype.setMessage = function setMessage (locale, key, value) {
    var obj, obj$1;

  this.merge(( obj$1 = {}, obj$1[locale] = {
      messages: ( obj = {}, obj[key] = value, obj),
    }, obj$1));
};

I18nDictionary.prototype.setAttribute = function setAttribute (locale, key, value) {
    var obj, obj$1;

  this.merge(( obj$1 = {}, obj$1[locale] = {
      attributes: ( obj = {}, obj[key] = value, obj),
    }, obj$1));
};

Object.defineProperties( I18nDictionary.prototype, prototypeAccessors$3 );

// 

var defaultConfig = {
  locale: 'en',
  delay: 0,
  errorBagName: 'errors',
  dictionary: null,
  strict: true,
  fieldsBagName: 'fields',
  classes: false,
  classNames: null,
  events: 'input|blur',
  inject: true,
  fastExit: true,
  aria: true,
  validity: false,
  i18n: null,
  i18nRootKey: 'validation',
};

var currentConfig = assign({}, defaultConfig);
var dependencies = {
  dictionary: new Dictionary({
    en: {
      messages: {},
      attributes: {},
      custom: {},
    },
  }),
};

var Config = function Config () {};

var staticAccessors = { default: { configurable: true },current: { configurable: true } };

staticAccessors.default.get = function () {
  return defaultConfig
};

staticAccessors.current.get = function () {
  return currentConfig
};

Config.dependency = function dependency (key) {
  return dependencies[key]
};

/**
 * Merges the config with a new one.
 */
Config.merge = function merge$$1 (config) {
  currentConfig = assign({}, currentConfig, config);
  if (currentConfig.i18n) {
    Config.register('dictionary', new I18nDictionary(currentConfig.i18n, currentConfig.i18nRootKey));
  }
};

/**
 * Registers a dependency.
 */
Config.register = function register (key, value) {
  dependencies[key] = value;
};

/**
 * Resolves the working config from a Vue instance.
 */
Config.resolve = function resolve (context) {
  var selfConfig = getPath('$options.$_reeValidate', context, {});

  return assign({}, Config.current, selfConfig)
};

Object.defineProperties( Config, staticAccessors );

// 

var RULES = {};
var STRICT_MODE = true;
var TARGET_RULES = ['confirmed', 'after', 'before'];
var ERRORS = []; // HOLD errors references to trigger regeneration.

var Validator = function Validator (validations, options) {
  var this$1 = this;
  if ( options === void 0 ) options = { vm: null, fastExit: true };

  this.strict = STRICT_MODE;
  this.errors = new ErrorBag();

  // We are running in SSR Mode. Do not keep a reference. It prevent garbage collection.
  if (typeof window !== 'undefined') {
    ERRORS.push(this.errors);
  }
  this.fields = new FieldBag();
  this.flags = {};
  this._createFields(validations);
  this.paused = false;
  this.fastExit = options.fastExit || false;
  this.ownerId = options.vm && options.vm._uid;
  // create it statically since we don't need constant access to the vm.
  this.reset = options.vm && isCallable(options.vm.$nextTick) ? function (matcher) {
    return new Promise(function (resolve) {
      options.vm.$nextTick(function () {
        options.vm.$nextTick(function () {
          resolve(this$1._reset(matcher));
        });
      });
    })
  } : this._reset;
};

var prototypeAccessors$4 = { dictionary: { configurable: true },locale: { configurable: true },rules: { configurable: true } };
var staticAccessors$1 = { dictionary: { configurable: true },locale: { configurable: true },rules: { configurable: true } };

/**
 * Getter for the dictionary.
 */
prototypeAccessors$4.dictionary.get = function () {
  return Config.dependency('dictionary')
};

/**
 * Static Getter for the dictionary.
 */
staticAccessors$1.dictionary.get = function () {
  return Config.dependency('dictionary')
};

/**
 * Getter for the current locale.
 */
prototypeAccessors$4.locale.get = function () {
  return this.dictionary.locale
};

/**
 * Setter for the validator locale.
 */
prototypeAccessors$4.locale.set = function (value) {
  Validator.locale = value;
};

/**
 * Static getter for the validator locale.
 */
staticAccessors$1.locale.get = function () {
  return Validator.dictionary.locale
};

/**
 * Static setter for the validator locale.
 */
staticAccessors$1.locale.set = function (value) {
  var hasChanged = value !== Validator.dictionary.locale;
  Validator.dictionary.locale = value;
  if (hasChanged) {
    Validator.regenerate();
  }
};

/**
 * Getter for the rules object.
 */
prototypeAccessors$4.rules.get = function () {
  return RULES
};

/**
 * Static Getter for the rules object.
 */
staticAccessors$1.rules.get = function () {
  return RULES
};

/**
 * Static constructor.
 */
Validator.create = function create (validations, options) {
  return new Validator(validations, options)
};

/**
 * Adds a custom validator to the list of validation rules.
 */
Validator.extend = function extend (name, validator, options) {
    if ( options === void 0 ) options = {};

  Validator._guardExtend(name, validator);
  Validator._merge(name, validator);
  if (options && options.hasTarget) {
    TARGET_RULES.push(name);
  }
};

/**
 * Regenerates error messages across all validators.
 */
Validator.regenerate = function regenerate () {
  ERRORS.forEach(function (errorBag) { return errorBag.regenerate(); });
};

/**
 * Removes a rule from the list of validators.
 */
Validator.remove = function remove (name) {
  delete RULES[name];
  var idx = TARGET_RULES.indexOf(name);
  if (idx === -1) { return }

  TARGET_RULES.splice(idx, 1);
};

/**
 * Checks if the given rule name is a rule that targets other fields.
 */
Validator.isTargetRule = function isTargetRule (name) {
  return TARGET_RULES.indexOf(name) !== -1
};

/**
 * Sets the operating mode for all newly created validators.
 * strictMode = true: Values without a rule are invalid and cause failure.
 * strictMode = false: Values without a rule are valid and are skipped.
 */
Validator.setStrictMode = function setStrictMode (strictMode) {
    if ( strictMode === void 0 ) strictMode = true;

  STRICT_MODE = strictMode;
};

/**
 * Adds and sets the current locale for the validator.
 */
Validator.prototype.localize = function localize (lang, dictionary) {
  Validator.localize(lang, dictionary);
};

/**
 * Adds and sets the current locale for the validator.
 */
Validator.localize = function localize (lang, dictionary) {
    var obj;

  if (isObject(lang)) {
    Validator.dictionary.merge(lang);
    return
  }

  // merge the dictionary.
  if (dictionary) {
    var locale = lang || dictionary.name;
    dictionary = assign({}, dictionary);
    Validator.dictionary.merge(( obj = {}, obj[locale] = dictionary, obj));
  }

  if (lang) {
    // set the locale.
    Validator.locale = lang;
  }
};

/**
 * Registers a field to be validated.
 */
Validator.prototype.attach = function attach (field) {
  // deprecate: handle old signature.
  if (arguments.length > 1) {
    warn('This signature of the attach method has been deprecated, please consult the docs.');
    field = assign({}, {
      name: arguments[0],
      rules: arguments[1],
    }, arguments[2] || { vm: { $validator: this } });
  }

  // fixes initial value detection with v-model and select elements.
  var value = field.initialValue;
  if (!(field instanceof Field)) {
    field = new Field(field.el || null, field);
  }

  this.fields.push(field);

  // validate the field initially
  if (field.initial) {
    this.validate(("#" + (field.id)), value || field.value);
  } else {
    this._validate(field, value || field.value, true).then(function (result) {
      field.flags.valid = result.valid;
      field.flags.invalid = !result.valid;
    });
  }

  this._addFlag(field, field.scope);
  return field
};

/**
 * Sets the flags on a field.
 */
Validator.prototype.flag = function flag (name, flags) {
  var field = this._resolveField(name);
  if (!field || !flags) {
    return
  }

  field.setFlags(flags);
};

/**
 * Removes a field from the validator.
 */
Validator.prototype.detach = function detach (name, scope) {
  var field = name instanceof Field ? name : this._resolveField(name, scope);
  if (!field) { return }

  field.destroy();
  this.errors.remove(field.name, field.scope, field.id);
  this.fields.remove(field);
  var flags = this.flags;
  if (!isNullOrUndefined(field.scope) && flags[("$" + (field.scope))]) {
    delete flags[("$" + (field.scope))][field.name];
  } else if (isNullOrUndefined(field.scope)) {
    delete flags[field.name];
  }

  this.flags = assign({}, flags);
};

/**
 * Adds a custom validator to the list of validation rules.
 */
Validator.prototype.extend = function extend (name, validator, options) {
    if ( options === void 0 ) options = {};

  Validator.extend(name, validator, options);
};

/**
 * Updates a field, updating both errors and flags.
 */
Validator.prototype.update = function update (id, ref) {
    var scope = ref.scope;

  var field = this._resolveField(("#" + id));
  if (!field) { return }

  // remove old scope.
  this.errors.update(id, { scope: scope });
  if (!isNullOrUndefined(field.scope) && this.flags[("$" + (field.scope))]) {
    delete this.flags[("$" + (field.scope))][field.name];
  } else if (isNullOrUndefined(field.scope)) {
    delete this.flags[field.name];
  }

  this._addFlag(field, scope);
};

/**
 * Removes a rule from the list of validators.
 */
Validator.prototype.remove = function remove (name) {
  Validator.remove(name);
};

/**
 * Validates a value against a registered field validations.
 */
Validator.prototype.validate = function validate (name, value, scope) {
    var this$1 = this;
    if ( scope === void 0 ) scope = null;

  if (this.paused) { return Promise.resolve(true) }

  // overload to validate all.
  if (arguments.length === 0) {
    return this.validateScopes()
  }

  // overload to validate scope-less fields.
  if (arguments.length === 1 && arguments[0] === '*') {
    return this.validateAll()
  }

  // overload to validate a scope.
  if (arguments.length === 1 && typeof arguments[0] === 'string' && /^(.+)\.\*$/.test(arguments[0])) {
    var matched = arguments[0].match(/^(.+)\.\*$/)[1];
    return this.validateAll(matched)
  }

  var field = this._resolveField(name, scope);
  if (!field) {
    return this._handleFieldNotFound(name, scope)
  }

  field.flags.pending = true;
  if (arguments.length === 1) {
    value = field.value;
  }

  var silentRun = field.isDisabled;

  return this._validate(field, value, silentRun).then(function (result) {
    this$1.errors.remove(field.name, field.scope, field.id);
    if (silentRun) {
      return Promise.resolve(true)
    } else if (result.errors) {
      result.errors.forEach(function (e) { return this$1.errors.add(e); });
    }

    field.setFlags({
      pending: false,
      valid: result.valid,
      validated: true,
    });

    return result.valid
  })
};

/**
 * Pauses the validator.
 */
Validator.prototype.pause = function pause () {
  this.paused = true;

  return this
};

/**
 * Resumes the validator.
 */
Validator.prototype.resume = function resume () {
  this.paused = false;

  return this
};

/**
 * Validates each value against the corresponding field validations.
 */
Validator.prototype.validateAll = function validateAll (values) {
    var arguments$1 = arguments;
    var this$1 = this;

  if (this.paused) { return Promise.resolve(true) }

  var matcher = null;
  var providedValues = false;

  if (typeof values === 'string') {
    matcher = { scope: values };
  } else if (isObject(values)) {
    matcher = Object.keys(values).map(function (key) {
      return { name: key, scope: arguments$1[1] || null }
    });
    providedValues = true;
  } else if (arguments.length === 0) {
    matcher = { scope: null }; // global scope.
  } else if (Array.isArray(values)) {
    matcher = values.map(function (key) {
      return { name: key, scope: arguments$1[1] || null }
    });
  }

  var promises = this.fields.filter(matcher).map(function (field) { return this$1.validate(
    ("#" + (field.id)),
    providedValues ? values[field.name] : field.value
  ); });

  return Promise.all(promises).then(function (results) { return results.every(function (t) { return t; }); })
};

/**
 * Validates all scopes.
 */
Validator.prototype.validateScopes = function validateScopes () {
    var this$1 = this;

  if (this.paused) { return Promise.resolve(true) }

  var promises = this.fields.map(function (field) { return this$1.validate(
    ("#" + (field.id)),
    field.value
  ); });

  return Promise.all(promises).then(function (results) { return results.every(function (t) { return t; }); })
};

/**
 * Perform cleanup.
 */
Validator.prototype.destroy = function destroy () {
  // Remove ErrorBag instance.
  var idx = ERRORS.indexOf(this.errors);
  if (idx === -1) { return }

  ERRORS.splice(idx, 1);
};

/**
 * Creates the fields to be validated.
 */
Validator.prototype._createFields = function _createFields (validations) {
    var this$1 = this;

  if (!validations) { return }

  Object.keys(validations).forEach(function (field) {
    var options = assign({}, { name: field, rules: validations[field] });
    this$1.attach(options);
  });
};

/**
 * Date rules need the existence of a format, so date_format must be supplied.
 */
Validator.prototype._getDateFormat = function _getDateFormat (validations) {
  var format = null;
  if (validations.date_format && Array.isArray(validations.date_format)) {
    format = validations.date_format[0];
  }

  return format || this.dictionary.getDateFormat(this.locale)
};

/**
 * Checks if the passed rule is a date rule.
 */
Validator.prototype._isADateRule = function _isADateRule (rule) {
  return !!~['after', 'before', 'date_between', 'date_format'].indexOf(rule)
};

/**
 * Formats an error message for field and a rule.
 */
Validator.prototype._formatErrorMessage = function _formatErrorMessage (field, rule, data, targetName) {
    if ( data === void 0 ) data = {};
    if ( targetName === void 0 ) targetName = null;

  var name = this._getFieldDisplayName(field);
  var params = this._getLocalizedParams(rule, targetName);

  return this.dictionary.getFieldMessage(this.locale, field.name, rule.name, [name, params, data])
};

/**
 * Translates the parameters passed to the rule (mainly for target fields).
 */
Validator.prototype._getLocalizedParams = function _getLocalizedParams (rule, targetName) {
    if ( targetName === void 0 ) targetName = null;

  if (~TARGET_RULES.indexOf(rule.name) && rule.params && rule.params[0]) {
    var localizedName = targetName || this.dictionary.getAttribute(this.locale, rule.params[0], rule.params[0]);
    return [localizedName].concat(rule.params.slice(1))
  }

  return rule.params
};

/**
 * Resolves an appropriate display name, first checking 'data-as' or the registered 'prettyName'
 */
Validator.prototype._getFieldDisplayName = function _getFieldDisplayName (field) {
  return field.alias || this.dictionary.getAttribute(this.locale, field.name, field.name)
};

/**
 * Adds a field flags to the flags collection.
 */
Validator.prototype._addFlag = function _addFlag (field, scope) {
    var obj, obj$1, obj$2;

    if ( scope === void 0 ) scope = null;
  if (isNullOrUndefined(scope)) {
    this.flags = assign({}, this.flags, ( obj = {}, obj[("" + (field.name))] = field.flags, obj));
    return
  }

  var scopeObj = assign({}, this.flags[("$" + scope)] || {}, ( obj$1 = {}, obj$1[("" + (field.name))] = field.flags, obj$1));
  this.flags = assign({}, this.flags, ( obj$2 = {}, obj$2[("$" + scope)] = scopeObj, obj$2));
};

/**
 * Resets fields that matches the matcher options or all fields if not specified.
 */
Validator.prototype._reset = function _reset (matcher) {
    var this$1 = this;

  return new Promise(function (resolve) {
    if (matcher) {
      this$1.fields.filter(matcher).forEach(function (field) {
        field.reset(); // reset field flags.
        this$1.errors.remove(field.name, field.scope, field.id);
      });

      return resolve()
    }

    this$1.fields.items.forEach(function (i) { return i.reset(); });
    this$1.errors.clear();
    resolve();
  })
};

/**
 * Tests a single input value against a rule.
 */
Validator.prototype._test = function _test (field, value, rule) {
    var this$1 = this;

  var validator = RULES[rule.name];
  var params = Array.isArray(rule.params) ? toArray(rule.params) : [];
  var targetName = null;
  if (!validator || typeof validator !== 'function') {
    throw createError(("No such validator '" + (rule.name) + "' exists."))
  }

  // has field dependencies.
  if (TARGET_RULES.indexOf(rule.name) !== -1) {
    var target = find(field.dependencies, function (d) { return d.name === rule.name; });
    if (target) {
      targetName = target.field.alias;
      params = [target.field.value].concat(params.slice(1));
    }
  } else if (rule.name === 'required' && field.rejectsFalse) {
    // invalidate false if no args were specified and the field rejects false by default.
    params = params.length ? params : [true];
  }

  if (this._isADateRule(rule.name)) {
    var dateFormat = this._getDateFormat(field.rules);
    if (rule.name !== 'date_format') {
      params.push(dateFormat);
    }
  }

  var result = validator(value, params);

  // If it is a promise.
  if (isCallable(result.then)) {
    return result.then(function (values) {
      var allValid = true;
      var data = {};
      if (Array.isArray(values)) {
        allValid = values.every(function (t) { return (isObject(t) ? t.valid : t); });
      } else { // Is a single object/boolean.
        allValid = isObject(values) ? values.valid : values;
        data = values.data;
      }

      return {
        valid: allValid,
        error: allValid ? undefined : this$1._createFieldError(field, rule, data, targetName),
      }
    })
  }

  if (!isObject(result)) {
    result = { valid: result, data: {} };
  }

  return {
    valid: result.valid,
    error: result.valid ? undefined : this._createFieldError(field, rule, result.data, targetName),
  }
};

/**
 * Merges a validator object into the RULES and Messages.
 */
Validator._merge = function _merge (name, validator) {
  if (isCallable(validator)) {
    RULES[name] = validator;
    return
  }

  RULES[name] = validator.validate;
  if (validator.getMessage) {
    Validator.dictionary.setMessage(this.locale, name, validator.getMessage);
  }
};

/**
 * Guards from extension violations.
 */
Validator._guardExtend = function _guardExtend (name, validator) {
  if (isCallable(validator)) {
    return
  }

  if (!isCallable(validator.validate)) {
    throw createError(
      ("Extension Error: The validator '" + name + "' must be a function or have a 'validate' method.")
    )
  }

  if (!isCallable(validator.getMessage) && typeof validator.getMessage !== 'string') {
    throw createError(
      ("Extension Error: The validator '" + name + "' object must have a 'getMessage' method or string.")
    )
  }
};

/**
 * Creates a Field Error Object.
 */
Validator.prototype._createFieldError = function _createFieldError (field, rule, data, targetName) {
    var this$1 = this;

  return {
    id: field.id,
    field: field.name,
    msg: this._formatErrorMessage(field, rule, data, targetName),
    rule: rule.name,
    scope: field.scope,
    regenerate: function () {
      return this$1._formatErrorMessage(field, rule, data, targetName)
    },
  }
};

/**
 * Tries different strategies to find a field.
 */
Validator.prototype._resolveField = function _resolveField (name, scope) {
  if (!isNullOrUndefined(scope)) {
    return this.fields.find({ name: name, scope: scope })
  }

  if (name[0] === '#') {
    return this.fields.find({ id: name.slice(1) })
  }

  if (name.indexOf('.') > -1) {
    var ref = name.split('.');
      var fieldScope = ref[0];
      var fieldName = ref.slice(1);
    var field = this.fields.find({ name: fieldName.join('.'), scope: fieldScope });
    if (field) {
      return field
    }
  }

  return this.fields.find({ name: name, scope: null })
};

/**
 * Handles when a field is not found depending on the strict flag.
 */
Validator.prototype._handleFieldNotFound = function _handleFieldNotFound (name, scope) {
  if (!this.strict) { return Promise.resolve(true) }

  var fullName = isNullOrUndefined(scope) ? name : ("" + (!isNullOrUndefined(scope) ? scope + '.' : '') + name);
  throw createError(
    ("Validating a non-existent field: \"" + fullName + "\". Use \"attach()\" first.")
  )
};

/**
 * Starts the validation process.
 */
Validator.prototype._validate = function _validate (field, value, silent) {
    var this$1 = this;
    if ( silent === void 0 ) silent = false;

  if (!field.isRequired && (isNullOrUndefined(value) || value === '')) {
    return Promise.resolve({ valid: true })
  }

  var promises = [];
  var errors = [];
  var isExitEarly = false;
  // use of '.some()' is to break iteration in middle by returning true
  Object.keys(field.rules).some(function (rule) {
    var result = this$1._test(field, value, { name: rule, params: field.rules[rule] });
    if (isCallable(result.then)) {
      promises.push(result);
    } else if (this$1.fastExit && !result.valid) {
      errors.push(result.error);
      isExitEarly = true;
    } else {
      // promisify the result.
      promises.push(new Promise(function (resolve) {
        resolve(result);
      }));
    }

    return isExitEarly
  });

  if (isExitEarly) {
    return Promise.resolve({
      valid: false,
      errors: errors,
    })
  }

  return Promise.all(promises).then(function (values) { return values.map(function (v) {
    if (!v.valid) {
      errors.push(v.error);
    }

    return v.valid
  }).every(function (t) { return t; }); }
  ).then(function (result) {
    return {
      valid: result,
      errors: errors,
    }
  })
};

Object.defineProperties( Validator.prototype, prototypeAccessors$4 );
Object.defineProperties( Validator, staticAccessors$1 );

// 

function use (plugin, options) {
  if ( options === void 0 ) options = {};

  if (!isCallable(plugin)) {
    return warn('The plugin must be a callable function')
  }

  plugin({ Validator: Validator, ErrorBag: ErrorBag, Rules: Validator.rules }, options);
}

var MILLISECONDS_IN_HOUR = 3600000;
var MILLISECONDS_IN_MINUTE = 60000;
var DEFAULT_ADDITIONAL_DIGITS = 2;

var patterns = {
  dateTimeDelimeter: /[T ]/,
  plainTime: /:/,

  // year tokens
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/, // 0 additional digits
    /^([+-]\d{3})$/, // 1 additional digit
    /^([+-]\d{4})$/ // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/, // 0 additional digits
    /^([+-]\d{5})/, // 1 additional digit
    /^([+-]\d{6})/ // 2 additional digits
  ],

  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,

  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,

  // timezone tokens
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-])(\d{2})$/,
  timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
};

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If an argument is a string, the function tries to parse it.
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument is null, it is treated as an invalid date.
 *
 * If all above fails, the function passes the given argument to Date constructor.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.
 *
 * @param {*} argument - the value to convert
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * var result = toDate('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * var result = toDate('+02014101', {additionalDigits: 1})
 * //=> Fri Apr 11 2014 00:00:00
 */
function toDate (argument, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')
  }

  if (argument === null) {
    return new Date(NaN)
  }

  var options = dirtyOptions || {};

  var additionalDigits = options.additionalDigits === undefined ? DEFAULT_ADDITIONAL_DIGITS : Number(options.additionalDigits);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError('additionalDigits must be 0, 1 or 2')
  }

  // Clone the date
  if (argument instanceof Date) {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime())
  } else if (typeof argument !== 'string') {
    return new Date(argument)
  }

  var dateStrings = splitDateString(argument);

  var parseYearResult = parseYear(dateStrings.date, additionalDigits);
  var year = parseYearResult.year;
  var restDateString = parseYearResult.restDateString;

  var date = parseDate(restDateString, year);

  if (date) {
    var timestamp = date.getTime();
    var time = 0;
    var offset;

    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
    }

    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone);
    } else {
      // get offset accurate to hour in timezones that change offset
      offset = new Date(timestamp + time).getTimezoneOffset();
      offset = new Date(timestamp + time + offset * MILLISECONDS_IN_MINUTE).getTimezoneOffset();
    }

    return new Date(timestamp + time + offset * MILLISECONDS_IN_MINUTE)
  } else {
    return new Date(argument)
  }
}

function splitDateString (dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimeter);
  var timeString;

  if (patterns.plainTime.test(array[0])) {
    dateStrings.date = null;
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
  }

  if (timeString) {
    var token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], '');
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings
}

function parseYear (dateString, additionalDigits) {
  var patternYYY = patterns.YYY[additionalDigits];
  var patternYYYYY = patterns.YYYYY[additionalDigits];

  var token;

  // YYYY or ±YYYYY
  token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
  if (token) {
    var yearString = token[1];
    return {
      year: parseInt(yearString, 10),
      restDateString: dateString.slice(yearString.length)
    }
  }

  // YY or ±YYY
  token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);
  if (token) {
    var centuryString = token[1];
    return {
      year: parseInt(centuryString, 10) * 100,
      restDateString: dateString.slice(centuryString.length)
    }
  }

  // Invalid ISO-formatted year
  return {
    year: null
  }
}

function parseDate (dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) {
    return null
  }

  var token;
  var date;
  var month;
  var week;

  // YYYY
  if (dateString.length === 0) {
    date = new Date(0);
    date.setUTCFullYear(year);
    return date
  }

  // YYYY-MM
  token = patterns.MM.exec(dateString);
  if (token) {
    date = new Date(0);
    month = parseInt(token[1], 10) - 1;
    date.setUTCFullYear(year, month);
    return date
  }

  // YYYY-DDD or YYYYDDD
  token = patterns.DDD.exec(dateString);
  if (token) {
    date = new Date(0);
    var dayOfYear = parseInt(token[1], 10);
    date.setUTCFullYear(year, 0, dayOfYear);
    return date
  }

  // YYYY-MM-DD or YYYYMMDD
  token = patterns.MMDD.exec(dateString);
  if (token) {
    date = new Date(0);
    month = parseInt(token[1], 10) - 1;
    var day = parseInt(token[2], 10);
    date.setUTCFullYear(year, month, day);
    return date
  }

  // YYYY-Www or YYYYWww
  token = patterns.Www.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    return dayOfISOYear(year, week)
  }

  // YYYY-Www-D or YYYYWwwD
  token = patterns.WwwD.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    var dayOfWeek = parseInt(token[2], 10) - 1;
    return dayOfISOYear(year, week, dayOfWeek)
  }

  // Invalid ISO-formatted date
  return null
}

function parseTime (timeString) {
  var token;
  var hours;
  var minutes;

  // hh
  token = patterns.HH.exec(timeString);
  if (token) {
    hours = parseFloat(token[1].replace(',', '.'));
    return (hours % 24) * MILLISECONDS_IN_HOUR
  }

  // hh:mm or hhmm
  token = patterns.HHMM.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseFloat(token[2].replace(',', '.'));
    return (hours % 24) * MILLISECONDS_IN_HOUR +
      minutes * MILLISECONDS_IN_MINUTE
  }

  // hh:mm:ss or hhmmss
  token = patterns.HHMMSS.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseInt(token[2], 10);
    var seconds = parseFloat(token[3].replace(',', '.'));
    return (hours % 24) * MILLISECONDS_IN_HOUR +
      minutes * MILLISECONDS_IN_MINUTE +
      seconds * 1000
  }

  // Invalid ISO-formatted time
  return null
}

function parseTimezone (timezoneString) {
  var token;
  var absoluteOffset;

  // Z
  token = patterns.timezoneZ.exec(timezoneString);
  if (token) {
    return 0
  }

  // ±hh
  token = patterns.timezoneHH.exec(timezoneString);
  if (token) {
    absoluteOffset = parseInt(token[2], 10) * 60;
    return (token[1] === '+') ? -absoluteOffset : absoluteOffset
  }

  // ±hh:mm or ±hhmm
  token = patterns.timezoneHHMM.exec(timezoneString);
  if (token) {
    absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10);
    return (token[1] === '+') ? -absoluteOffset : absoluteOffset
  }

  return 0
}

function dayOfISOYear (isoYear, week, day) {
  week = week || 0;
  day = day || 0;
  var date = new Date(0);
  date.setUTCFullYear(isoYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date
}

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */
function addMilliseconds (dirtyDate, dirtyAmount, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
  }

  var timestamp = toDate(dirtyDate, dirtyOptions).getTime();
  var amount = Number(dirtyAmount);
  return new Date(timestamp + amount)
}

function cloneObject (dirtyObject) {
  dirtyObject = dirtyObject || {};
  var object = {};

  for (var property in dirtyObject) {
    if (dirtyObject.hasOwnProperty(property)) {
      object[property] = dirtyObject[property];
    }
  }

  return object
}

var MILLISECONDS_IN_MINUTE$2 = 60000;

/**
 * @name addMinutes
 * @category Minute Helpers
 * @summary Add the specified number of minutes to the given date.
 *
 * @description
 * Add the specified number of minutes to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of minutes to be added
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Date} the new date with the minutes added
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Add 30 minutes to 10 July 2014 12:00:00:
 * var result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 12:30:00
 */
function addMinutes (dirtyDate, dirtyAmount, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
  }

  var amount = Number(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE$2, dirtyOptions)
}

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {*} date - the date to check
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // For the valid date:
 * var result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * var result = isValid('2014-02-31')
 * //=> true
 *
 * @example
 * // For the invalid date:
 * var result = isValid(new Date(''))
 * //=> false
 */
function isValid (dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')
  }

  var date = toDate(dirtyDate, dirtyOptions);
  return !isNaN(date)
}

var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },

  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },

  halfAMinute: 'half a minute',

  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },

  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },

  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },

  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },

  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },

  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },

  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },

  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },

  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },

  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },

  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

function formatDistance (token, count, options) {
  options = options || {};

  var result;
  if (typeof formatDistanceLocale[token] === 'string') {
    result = formatDistanceLocale[token];
  } else if (count === 1) {
    result = formatDistanceLocale[token].one;
  } else {
    result = formatDistanceLocale[token].other.replace('{{count}}', count);
  }

  if (options.addSuffix) {
    if (options.comparison > 0) {
      return 'in ' + result
    } else {
      return result + ' ago'
    }
  }

  return result
}

var tokensToBeShortedPattern = /MMMM|MM|DD|dddd/g;

function buildShortLongFormat (format) {
  return format.replace(tokensToBeShortedPattern, function (token) {
    return token.slice(1)
  })
}

/**
 * @name buildFormatLongFn
 * @category Locale Helpers
 * @summary Build `formatLong` property for locale used by `format`, `formatRelative` and `parse` functions.
 *
 * @description
 * Build `formatLong` property for locale used by `format`, `formatRelative` and `parse` functions.
 * Returns a function which takes one of the following tokens as the argument:
 * `'LTS'`, `'LT'`, `'L'`, `'LL'`, `'LLL'`, `'l'`, `'ll'`, `'lll'`, `'llll'`
 * and returns a long format string written as `format` token strings.
 * See [format]{@link https://date-fns.org/docs/format}
 *
 * `'l'`, `'ll'`, `'lll'` and `'llll'` formats are built automatically
 * by shortening some of the tokens from corresponding unshortened formats
 * (e.g., if `LL` is `'MMMM DD YYYY'` then `ll` will be `MMM D YYYY`)
 *
 * @param {Object} obj - the object with long formats written as `format` token strings
 * @param {String} obj.LT - time format: hours and minutes
 * @param {String} obj.LTS - time format: hours, minutes and seconds
 * @param {String} obj.L - short date format: numeric day, month and year
 * @param {String} [obj.l] - short date format: numeric day, month and year (shortened)
 * @param {String} obj.LL - long date format: day, month in words, and year
 * @param {String} [obj.ll] - long date format: day, month in words, and year (shortened)
 * @param {String} obj.LLL - long date and time format
 * @param {String} [obj.lll] - long date and time format (shortened)
 * @param {String} obj.LLLL - long date, time and weekday format
 * @param {String} [obj.llll] - long date, time and weekday format (shortened)
 * @returns {Function} `formatLong` property of the locale
 *
 * @example
 * // For `en-US` locale:
 * locale.formatLong = buildFormatLongFn({
 *   LT: 'h:mm aa',
 *   LTS: 'h:mm:ss aa',
 *   L: 'MM/DD/YYYY',
 *   LL: 'MMMM D YYYY',
 *   LLL: 'MMMM D YYYY h:mm aa',
 *   LLLL: 'dddd, MMMM D YYYY h:mm aa'
 * })
 */
function buildFormatLongFn (obj) {
  var formatLongLocale = {
    LTS: obj.LTS,
    LT: obj.LT,
    L: obj.L,
    LL: obj.LL,
    LLL: obj.LLL,
    LLLL: obj.LLLL,
    l: obj.l || buildShortLongFormat(obj.L),
    ll: obj.ll || buildShortLongFormat(obj.LL),
    lll: obj.lll || buildShortLongFormat(obj.LLL),
    llll: obj.llll || buildShortLongFormat(obj.LLLL)
  };

  return function (token) {
    return formatLongLocale[token]
  }
}

var formatLong = buildFormatLongFn({
  LT: 'h:mm aa',
  LTS: 'h:mm:ss aa',
  L: 'MM/DD/YYYY',
  LL: 'MMMM D YYYY',
  LLL: 'MMMM D YYYY h:mm aa',
  LLLL: 'dddd, MMMM D YYYY h:mm aa'
});

var formatRelativeLocale = {
  lastWeek: '[last] dddd [at] LT',
  yesterday: '[yesterday at] LT',
  today: '[today at] LT',
  tomorrow: '[tomorrow at] LT',
  nextWeek: 'dddd [at] LT',
  other: 'L'
};

function formatRelative (token, date, baseDate, options) {
  return formatRelativeLocale[token]
}

/**
 * @name buildLocalizeFn
 * @category Locale Helpers
 * @summary Build `localize.weekday`, `localize.month` and `localize.timeOfDay` properties for the locale.
 *
 * @description
 * Build `localize.weekday`, `localize.month` and `localize.timeOfDay` properties for the locale
 * used by `format` function.
 * If no `type` is supplied to the options of the resulting function, `defaultType` will be used (see example).
 *
 * `localize.weekday` function takes the weekday index as argument (0 - Sunday).
 * `localize.month` takes the month index (0 - January).
 * `localize.timeOfDay` takes the hours. Use `indexCallback` to convert them to an array index (see example).
 *
 * @param {Object} values - the object with arrays of values
 * @param {String} defaultType - the default type for the localize function
 * @param {Function} [indexCallback] - the callback which takes the resulting function argument
 *   and converts it into value array index
 * @returns {Function} the resulting function
 *
 * @example
 * var timeOfDayValues = {
 *   uppercase: ['AM', 'PM'],
 *   lowercase: ['am', 'pm'],
 *   long: ['a.m.', 'p.m.']
 * }
 * locale.localize.timeOfDay = buildLocalizeFn(timeOfDayValues, 'long', function (hours) {
 *   // 0 is a.m. array index, 1 is p.m. array index
 *   return (hours / 12) >= 1 ? 1 : 0
 * })
 * locale.localize.timeOfDay(16, {type: 'uppercase'}) //=> 'PM'
 * locale.localize.timeOfDay(5) //=> 'a.m.'
 */
function buildLocalizeFn (values, defaultType, indexCallback) {
  return function (dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var type = options.type ? String(options.type) : defaultType;
    var valuesArray = values[type] || values[defaultType];
    var index = indexCallback ? indexCallback(Number(dirtyIndex)) : Number(dirtyIndex);
    return valuesArray[index]
  }
}

/**
 * @name buildLocalizeArrayFn
 * @category Locale Helpers
 * @summary Build `localize.weekdays`, `localize.months` and `localize.timesOfDay` properties for the locale.
 *
 * @description
 * Build `localize.weekdays`, `localize.months` and `localize.timesOfDay` properties for the locale.
 * If no `type` is supplied to the options of the resulting function, `defaultType` will be used (see example).
 *
 * @param {Object} values - the object with arrays of values
 * @param {String} defaultType - the default type for the localize function
 * @returns {Function} the resulting function
 *
 * @example
 * var weekdayValues = {
 *   narrow: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
 *   short: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
 *   long: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
 * }
 * locale.localize.weekdays = buildLocalizeArrayFn(weekdayValues, 'long')
 * locale.localize.weekdays({type: 'narrow'}) //=> ['Su', 'Mo', ...]
 * locale.localize.weekdays() //=> ['Sunday', 'Monday', ...]
 */
function buildLocalizeArrayFn (values, defaultType) {
  return function (dirtyOptions) {
    var options = dirtyOptions || {};
    var type = options.type ? String(options.type) : defaultType;
    return values[type] || values[defaultType]
  }
}

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
var weekdayValues = {
  narrow: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  short: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  long: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};

var monthValues = {
  short: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  long: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};

// `timeOfDay` is used to designate which part of the day it is, when used with 12-hour clock.
// Use the system which is used the most commonly in the locale.
// For example, if the country doesn't use a.m./p.m., you can use `night`/`morning`/`afternoon`/`evening`:
//
//   var timeOfDayValues = {
//     any: ['in the night', 'in the morning', 'in the afternoon', 'in the evening']
//   }
//
// And later:
//
//   var localize = {
//     // The callback takes the hours as the argument and returns the array index
//     timeOfDay: buildLocalizeFn(timeOfDayValues, 'any', function (hours) {
//       if (hours >= 17) {
//         return 3
//       } else if (hours >= 12) {
//         return 2
//       } else if (hours >= 4) {
//         return 1
//       } else {
//         return 0
//       }
//     }),
//     timesOfDay: buildLocalizeArrayFn(timeOfDayValues, 'any')
//   }
var timeOfDayValues = {
  uppercase: ['AM', 'PM'],
  lowercase: ['am', 'pm'],
  long: ['a.m.', 'p.m.']
};

function ordinalNumber (dirtyNumber, dirtyOptions) {
  var number = Number(dirtyNumber);

  // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`:
  //
  //   var options = dirtyOptions || {}
  //   var unit = String(options.unit)
  //
  // where `unit` can be 'month', 'quarter', 'week', 'isoWeek', 'dayOfYear',
  // 'dayOfMonth' or 'dayOfWeek'

  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st'
      case 2:
        return number + 'nd'
      case 3:
        return number + 'rd'
    }
  }
  return number + 'th'
}

var localize = {
  ordinalNumber: ordinalNumber,
  weekday: buildLocalizeFn(weekdayValues, 'long'),
  weekdays: buildLocalizeArrayFn(weekdayValues, 'long'),
  month: buildLocalizeFn(monthValues, 'long'),
  months: buildLocalizeArrayFn(monthValues, 'long'),
  timeOfDay: buildLocalizeFn(timeOfDayValues, 'long', function (hours) {
    return (hours / 12) >= 1 ? 1 : 0
  }),
  timesOfDay: buildLocalizeArrayFn(timeOfDayValues, 'long')
};

/**
 * @name buildMatchFn
 * @category Locale Helpers
 * @summary Build `match.weekdays`, `match.months` and `match.timesOfDay` properties for the locale.
 *
 * @description
 * Build `match.weekdays`, `match.months` and `match.timesOfDay` properties for the locale used by `parse` function.
 * If no `type` is supplied to the options of the resulting function, `defaultType` will be used (see example).
 * The result of the match function will be passed into corresponding parser function
 * (`match.weekday`, `match.month` or `match.timeOfDay` respectively. See `buildParseFn`).
 *
 * @param {Object} values - the object with RegExps
 * @param {String} defaultType - the default type for the match function
 * @returns {Function} the resulting function
 *
 * @example
 * var matchWeekdaysPatterns = {
 *   narrow: /^(su|mo|tu|we|th|fr|sa)/i,
 *   short: /^(sun|mon|tue|wed|thu|fri|sat)/i,
 *   long: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
 * }
 * locale.match.weekdays = buildMatchFn(matchWeekdaysPatterns, 'long')
 * locale.match.weekdays('Sunday', {type: 'narrow'}) //=> ['Su', 'Su', ...]
 * locale.match.weekdays('Sunday') //=> ['Sunday', 'Sunday', ...]
 */
function buildMatchFn (patterns, defaultType) {
  return function (dirtyString, dirtyOptions) {
    var options = dirtyOptions || {};
    var type = options.type ? String(options.type) : defaultType;
    var pattern = patterns[type] || patterns[defaultType];
    var string = String(dirtyString);
    return string.match(pattern)
  }
}

/**
 * @name buildParseFn
 * @category Locale Helpers
 * @summary Build `match.weekday`, `match.month` and `match.timeOfDay` properties for the locale.
 *
 * @description
 * Build `match.weekday`, `match.month` and `match.timeOfDay` properties for the locale used by `parse` function.
 * The argument of the resulting function is the result of the corresponding match function
 * (`match.weekdays`, `match.months` or `match.timesOfDay` respectively. See `buildMatchFn`).
 *
 * @param {Object} values - the object with arrays of RegExps
 * @param {String} defaultType - the default type for the parser function
 * @returns {Function} the resulting function
 *
 * @example
 * var parseWeekdayPatterns = {
 *   any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
 * }
 * locale.match.weekday = buildParseFn(matchWeekdaysPatterns, 'long')
 * var matchResult = locale.match.weekdays('Friday')
 * locale.match.weekday(matchResult) //=> 5
 */
function buildParseFn (patterns, defaultType) {
  return function (matchResult, dirtyOptions) {
    var options = dirtyOptions || {};
    var type = options.type ? String(options.type) : defaultType;
    var patternsArray = patterns[type] || patterns[defaultType];
    var string = matchResult[1];

    return patternsArray.findIndex(function (pattern) {
      return pattern.test(string)
    })
  }
}

/**
 * @name buildMatchPatternFn
 * @category Locale Helpers
 * @summary Build match function from a single RegExp.
 *
 * @description
 * Build match function from a single RegExp.
 * Usually used for building `match.ordinalNumbers` property of the locale.
 *
 * @param {Object} pattern - the RegExp
 * @returns {Function} the resulting function
 *
 * @example
 * locale.match.ordinalNumbers = buildMatchPatternFn(/^(\d+)(th|st|nd|rd)?/i)
 * locale.match.ordinalNumbers('3rd') //=> ['3rd', '3', 'rd', ...]
 */
function buildMatchPatternFn (pattern) {
  return function (dirtyString) {
    var string = String(dirtyString);
    return string.match(pattern)
  }
}

/**
 * @name parseDecimal
 * @category Locale Helpers
 * @summary Parses the match result into decimal number.
 *
 * @description
 * Parses the match result into decimal number.
 * Uses the string matched with the first set of parentheses of match RegExp.
 *
 * @param {Array} matchResult - the object returned by matching function
 * @returns {Number} the parsed value
 *
 * @example
 * locale.match = {
 *   ordinalNumbers: (dirtyString) {
 *     return String(dirtyString).match(/^(\d+)(th|st|nd|rd)?/i)
 *   },
 *   ordinalNumber: parseDecimal
 * }
 */
function parseDecimal (matchResult) {
  return parseInt(matchResult[1], 10)
}

var matchOrdinalNumbersPattern = /^(\d+)(th|st|nd|rd)?/i;

var matchWeekdaysPatterns = {
  narrow: /^(su|mo|tu|we|th|fr|sa)/i,
  short: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  long: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};

var parseWeekdayPatterns = {
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};

var matchMonthsPatterns = {
  short: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  long: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};

var parseMonthPatterns = {
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};

// `timeOfDay` is used to designate which part of the day it is, when used with 12-hour clock.
// Use the system which is used the most commonly in the locale.
// For example, if the country doesn't use a.m./p.m., you can use `night`/`morning`/`afternoon`/`evening`:
//
//   var matchTimesOfDayPatterns = {
//     long: /^((in the)? (night|morning|afternoon|evening?))/i
//   }
//
//   var parseTimeOfDayPatterns = {
//     any: [/(night|morning)/i, /(afternoon|evening)/i]
//   }
var matchTimesOfDayPatterns = {
  short: /^(am|pm)/i,
  long: /^([ap]\.?\s?m\.?)/i
};

var parseTimeOfDayPatterns = {
  any: [/^a/i, /^p/i]
};

var match = {
  ordinalNumbers: buildMatchPatternFn(matchOrdinalNumbersPattern),
  ordinalNumber: parseDecimal,
  weekdays: buildMatchFn(matchWeekdaysPatterns, 'long'),
  weekday: buildParseFn(parseWeekdayPatterns, 'any'),
  months: buildMatchFn(matchMonthsPatterns, 'long'),
  month: buildParseFn(parseMonthPatterns, 'any'),
  timesOfDay: buildMatchFn(matchTimesOfDayPatterns, 'long'),
  timeOfDay: buildParseFn(parseTimeOfDayPatterns, 'any')
};

/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 */
var locale$1 = {
  formatDistance: formatDistance,
  formatLong: formatLong,
  formatRelative: formatRelative,
  localize: localize,
  match: match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1
  }
};

var MILLISECONDS_IN_DAY$1 = 86400000;

// This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376
function getUTCDayOfYear (dirtyDate, dirtyOptions) {
  var date = toDate(dirtyDate, dirtyOptions);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY$1) + 1
}

// This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376
function startOfUTCISOWeek (dirtyDate, dirtyOptions) {
  var weekStartsOn = 1;

  var date = toDate(dirtyDate, dirtyOptions);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;

  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date
}

// This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376
function getUTCISOWeekYear (dirtyDate, dirtyOptions) {
  var date = toDate(dirtyDate, dirtyOptions);
  var year = date.getUTCFullYear();

  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear, dirtyOptions);

  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear, dirtyOptions);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year
  } else {
    return year - 1
  }
}

// This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376
function startOfUTCISOWeekYear (dirtyDate, dirtyOptions) {
  var year = getUTCISOWeekYear(dirtyDate, dirtyOptions);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary, dirtyOptions);
  return date
}

var MILLISECONDS_IN_WEEK$2 = 604800000;

// This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376
function getUTCISOWeek (dirtyDate, dirtyOptions) {
  var date = toDate(dirtyDate, dirtyOptions);
  var diff = startOfUTCISOWeek(date, dirtyOptions).getTime() - startOfUTCISOWeekYear(date, dirtyOptions).getTime();

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)
  return Math.round(diff / MILLISECONDS_IN_WEEK$2) + 1
}

var formatters = {
  // Month: 1, 2, ..., 12
  'M': function (date) {
    return date.getUTCMonth() + 1
  },

  // Month: 1st, 2nd, ..., 12th
  'Mo': function (date, options) {
    var month = date.getUTCMonth() + 1;
    return options.locale.localize.ordinalNumber(month, {unit: 'month'})
  },

  // Month: 01, 02, ..., 12
  'MM': function (date) {
    return addLeadingZeros(date.getUTCMonth() + 1, 2)
  },

  // Month: Jan, Feb, ..., Dec
  'MMM': function (date, options) {
    return options.locale.localize.month(date.getUTCMonth(), {type: 'short'})
  },

  // Month: January, February, ..., December
  'MMMM': function (date, options) {
    return options.locale.localize.month(date.getUTCMonth(), {type: 'long'})
  },

  // Quarter: 1, 2, 3, 4
  'Q': function (date) {
    return Math.ceil((date.getUTCMonth() + 1) / 3)
  },

  // Quarter: 1st, 2nd, 3rd, 4th
  'Qo': function (date, options) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    return options.locale.localize.ordinalNumber(quarter, {unit: 'quarter'})
  },

  // Day of month: 1, 2, ..., 31
  'D': function (date) {
    return date.getUTCDate()
  },

  // Day of month: 1st, 2nd, ..., 31st
  'Do': function (date, options) {
    return options.locale.localize.ordinalNumber(date.getUTCDate(), {unit: 'dayOfMonth'})
  },

  // Day of month: 01, 02, ..., 31
  'DD': function (date) {
    return addLeadingZeros(date.getUTCDate(), 2)
  },

  // Day of year: 1, 2, ..., 366
  'DDD': function (date) {
    return getUTCDayOfYear(date)
  },

  // Day of year: 1st, 2nd, ..., 366th
  'DDDo': function (date, options) {
    return options.locale.localize.ordinalNumber(getUTCDayOfYear(date), {unit: 'dayOfYear'})
  },

  // Day of year: 001, 002, ..., 366
  'DDDD': function (date) {
    return addLeadingZeros(getUTCDayOfYear(date), 3)
  },

  // Day of week: Su, Mo, ..., Sa
  'dd': function (date, options) {
    return options.locale.localize.weekday(date.getUTCDay(), {type: 'narrow'})
  },

  // Day of week: Sun, Mon, ..., Sat
  'ddd': function (date, options) {
    return options.locale.localize.weekday(date.getUTCDay(), {type: 'short'})
  },

  // Day of week: Sunday, Monday, ..., Saturday
  'dddd': function (date, options) {
    return options.locale.localize.weekday(date.getUTCDay(), {type: 'long'})
  },

  // Day of week: 0, 1, ..., 6
  'd': function (date) {
    return date.getUTCDay()
  },

  // Day of week: 0th, 1st, 2nd, ..., 6th
  'do': function (date, options) {
    return options.locale.localize.ordinalNumber(date.getUTCDay(), {unit: 'dayOfWeek'})
  },

  // Day of ISO week: 1, 2, ..., 7
  'E': function (date) {
    return date.getUTCDay() || 7
  },

  // ISO week: 1, 2, ..., 53
  'W': function (date) {
    return getUTCISOWeek(date)
  },

  // ISO week: 1st, 2nd, ..., 53th
  'Wo': function (date, options) {
    return options.locale.localize.ordinalNumber(getUTCISOWeek(date), {unit: 'isoWeek'})
  },

  // ISO week: 01, 02, ..., 53
  'WW': function (date) {
    return addLeadingZeros(getUTCISOWeek(date), 2)
  },

  // Year: 00, 01, ..., 99
  'YY': function (date) {
    return addLeadingZeros(date.getUTCFullYear(), 4).substr(2)
  },

  // Year: 1900, 1901, ..., 2099
  'YYYY': function (date) {
    return addLeadingZeros(date.getUTCFullYear(), 4)
  },

  // ISO week-numbering year: 00, 01, ..., 99
  'GG': function (date) {
    return String(getUTCISOWeekYear(date)).substr(2)
  },

  // ISO week-numbering year: 1900, 1901, ..., 2099
  'GGGG': function (date) {
    return getUTCISOWeekYear(date)
  },

  // Hour: 0, 1, ... 23
  'H': function (date) {
    return date.getUTCHours()
  },

  // Hour: 00, 01, ..., 23
  'HH': function (date) {
    return addLeadingZeros(date.getUTCHours(), 2)
  },

  // Hour: 1, 2, ..., 12
  'h': function (date) {
    var hours = date.getUTCHours();
    if (hours === 0) {
      return 12
    } else if (hours > 12) {
      return hours % 12
    } else {
      return hours
    }
  },

  // Hour: 01, 02, ..., 12
  'hh': function (date) {
    return addLeadingZeros(formatters['h'](date), 2)
  },

  // Minute: 0, 1, ..., 59
  'm': function (date) {
    return date.getUTCMinutes()
  },

  // Minute: 00, 01, ..., 59
  'mm': function (date) {
    return addLeadingZeros(date.getUTCMinutes(), 2)
  },

  // Second: 0, 1, ..., 59
  's': function (date) {
    return date.getUTCSeconds()
  },

  // Second: 00, 01, ..., 59
  'ss': function (date) {
    return addLeadingZeros(date.getUTCSeconds(), 2)
  },

  // 1/10 of second: 0, 1, ..., 9
  'S': function (date) {
    return Math.floor(date.getUTCMilliseconds() / 100)
  },

  // 1/100 of second: 00, 01, ..., 99
  'SS': function (date) {
    return addLeadingZeros(Math.floor(date.getUTCMilliseconds() / 10), 2)
  },

  // Millisecond: 000, 001, ..., 999
  'SSS': function (date) {
    return addLeadingZeros(date.getUTCMilliseconds(), 3)
  },

  // Timezone: -01:00, +00:00, ... +12:00
  'Z': function (date, options) {
    var originalDate = options._originalDate || date;
    return formatTimezone(originalDate.getTimezoneOffset(), ':')
  },

  // Timezone: -0100, +0000, ... +1200
  'ZZ': function (date, options) {
    var originalDate = options._originalDate || date;
    return formatTimezone(originalDate.getTimezoneOffset())
  },

  // Seconds timestamp: 512969520
  'X': function (date, options) {
    var originalDate = options._originalDate || date;
    return Math.floor(originalDate.getTime() / 1000)
  },

  // Milliseconds timestamp: 512969520900
  'x': function (date, options) {
    var originalDate = options._originalDate || date;
    return originalDate.getTime()
  },

  // AM, PM
  'A': function (date, options) {
    return options.locale.localize.timeOfDay(date.getUTCHours(), {type: 'uppercase'})
  },

  // am, pm
  'a': function (date, options) {
    return options.locale.localize.timeOfDay(date.getUTCHours(), {type: 'lowercase'})
  },

  // a.m., p.m.
  'aa': function (date, options) {
    return options.locale.localize.timeOfDay(date.getUTCHours(), {type: 'long'})
  }
};

function formatTimezone (offset, delimeter) {
  delimeter = delimeter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  return sign + addLeadingZeros(hours, 2) + delimeter + addLeadingZeros(minutes, 2)
}

function addLeadingZeros (number, targetLength) {
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = '0' + output;
  }
  return output
}

// This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376
function addUTCMinutes (dirtyDate, dirtyAmount, dirtyOptions) {
  var date = toDate(dirtyDate, dirtyOptions);
  var amount = Number(dirtyAmount);
  date.setUTCMinutes(date.getUTCMinutes() + amount);
  return date
}

var longFormattingTokensRegExp = /(\[[^[]*])|(\\)?(LTS|LT|LLLL|LLL|LL|L|llll|lll|ll|l)/g;
var defaultFormattingTokensRegExp = /(\[[^[]*])|(\\)?(x|ss|s|mm|m|hh|h|do|dddd|ddd|dd|d|aa|a|ZZ|Z|YYYY|YY|X|Wo|WW|W|SSS|SS|S|Qo|Q|Mo|MMMM|MMM|MM|M|HH|H|GGGG|GG|E|Do|DDDo|DDDD|DDD|DD|D|A|.)/g;

/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format.
 *
 * Accepted tokens:
 * | Unit                    | Token | Result examples                  |
 * |-------------------------|-------|----------------------------------|
 * | Month                   | M     | 1, 2, ..., 12                    |
 * |                         | Mo    | 1st, 2nd, ..., 12th              |
 * |                         | MM    | 01, 02, ..., 12                  |
 * |                         | MMM   | Jan, Feb, ..., Dec               |
 * |                         | MMMM  | January, February, ..., December |
 * | Quarter                 | Q     | 1, 2, 3, 4                       |
 * |                         | Qo    | 1st, 2nd, 3rd, 4th               |
 * | Day of month            | D     | 1, 2, ..., 31                    |
 * |                         | Do    | 1st, 2nd, ..., 31st              |
 * |                         | DD    | 01, 02, ..., 31                  |
 * | Day of year             | DDD   | 1, 2, ..., 366                   |
 * |                         | DDDo  | 1st, 2nd, ..., 366th             |
 * |                         | DDDD  | 001, 002, ..., 366               |
 * | Day of week             | d     | 0, 1, ..., 6                     |
 * |                         | do    | 0th, 1st, ..., 6th               |
 * |                         | dd    | Su, Mo, ..., Sa                  |
 * |                         | ddd   | Sun, Mon, ..., Sat               |
 * |                         | dddd  | Sunday, Monday, ..., Saturday    |
 * | Day of ISO week         | E     | 1, 2, ..., 7                     |
 * | ISO week                | W     | 1, 2, ..., 53                    |
 * |                         | Wo    | 1st, 2nd, ..., 53rd              |
 * |                         | WW    | 01, 02, ..., 53                  |
 * | Year                    | YY    | 00, 01, ..., 99                  |
 * |                         | YYYY  | 1900, 1901, ..., 2099            |
 * | ISO week-numbering year | GG    | 00, 01, ..., 99                  |
 * |                         | GGGG  | 1900, 1901, ..., 2099            |
 * | AM/PM                   | A     | AM, PM                           |
 * |                         | a     | am, pm                           |
 * |                         | aa    | a.m., p.m.                       |
 * | Hour                    | H     | 0, 1, ... 23                     |
 * |                         | HH    | 00, 01, ... 23                   |
 * |                         | h     | 1, 2, ..., 12                    |
 * |                         | hh    | 01, 02, ..., 12                  |
 * | Minute                  | m     | 0, 1, ..., 59                    |
 * |                         | mm    | 00, 01, ..., 59                  |
 * | Second                  | s     | 0, 1, ..., 59                    |
 * |                         | ss    | 00, 01, ..., 59                  |
 * | 1/10 of second          | S     | 0, 1, ..., 9                     |
 * | 1/100 of second         | SS    | 00, 01, ..., 99                  |
 * | Millisecond             | SSS   | 000, 001, ..., 999               |
 * | Timezone                | Z     | -01:00, +00:00, ... +12:00       |
 * |                         | ZZ    | -0100, +0000, ..., +1200         |
 * | Seconds timestamp       | X     | 512969520                        |
 * | Milliseconds timestamp  | x     | 512969520900                     |
 * | Long format             | LT    | 05:30 a.m.                       |
 * |                         | LTS   | 05:30:15 a.m.                    |
 * |                         | L     | 07/02/1995                       |
 * |                         | l     | 7/2/1995                         |
 * |                         | LL    | July 2 1995                      |
 * |                         | ll    | Jul 2 1995                       |
 * |                         | LLL   | July 2 1995 05:30 a.m.           |
 * |                         | lll   | Jul 2 1995 05:30 a.m.            |
 * |                         | LLLL  | Sunday, July 2 1995 05:30 a.m.   |
 * |                         | llll  | Sun, Jul 2 1995 05:30 a.m.       |
 *
 * The characters wrapped in square brackets are escaped.
 *
 * The result may vary by locale.
 *
 * @param {Date|String|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * var result = format(
 *   new Date(2014, 1, 11),
 *   'MM/DD/YYYY'
 * )
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * var result = format(
 *   new Date(2014, 6, 2),
 *   'Do [de] MMMM YYYY',
 *   {locale: eoLocale}
 * )
 * //=> '2-a de julio 2014'
 */
function format (dirtyDate, dirtyFormatStr, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
  }

  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};

  var locale = options.locale || locale$1;

  if (!locale.localize) {
    throw new RangeError('locale must contain localize property')
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property')
  }

  var localeFormatters = locale.formatters || {};
  var formattingTokensRegExp = locale.formattingTokensRegExp || defaultFormattingTokensRegExp;
  var formatLong = locale.formatLong;

  var originalDate = toDate(dirtyDate, options);

  if (!isValid(originalDate, options)) {
    return 'Invalid Date'
  }

  // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376
  var timezoneOffset = originalDate.getTimezoneOffset();
  var utcDate = addUTCMinutes(originalDate, -timezoneOffset, options);

  var formatterOptions = cloneObject(options);
  formatterOptions.locale = locale;
  formatterOptions.formatters = formatters;

  // When UTC functions will be implemented, options._originalDate will likely be a part of public API.
  // Right now, please don't use it in locales. If you have to use an original date,
  // please restore it from `date`, adding a timezone offset to it.
  formatterOptions._originalDate = originalDate;

  var result = formatStr
    .replace(longFormattingTokensRegExp, function (substring) {
      if (substring[0] === '[') {
        return substring
      }

      if (substring[0] === '\\') {
        return cleanEscapedString(substring)
      }

      return formatLong(substring)
    })
    .replace(formattingTokensRegExp, function (substring) {
      var formatter = localeFormatters[substring] || formatters[substring];

      if (formatter) {
        return formatter(utcDate, formatterOptions)
      } else {
        return cleanEscapedString(substring)
      }
    });

  return result
}

function cleanEscapedString (input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|]$/g, '')
  }
  return input.replace(/\\/g, '')
}

/**
 * @name subMinutes
 * @category Minute Helpers
 * @summary Subtract the specified number of minutes from the given date.
 *
 * @description
 * Subtract the specified number of minutes from the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of minutes to be subtracted
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Date} the new date with the mintues subtracted
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Subtract 30 minutes from 10 July 2014 12:00:00:
 * var result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 11:30:00
 */
function subMinutes (dirtyDate, dirtyAmount, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
  }

  var amount = Number(dirtyAmount);
  return addMinutes(dirtyDate, -amount, dirtyOptions)
}

/**
 * @name isAfter
 * @category Common Helpers
 * @summary Is the first date after the second one?
 *
 * @description
 * Is the first date after the second one?
 *
 * @param {Date|String|Number} date - the date that should be after the other one to return true
 * @param {Date|String|Number} dateToCompare - the date to compare with
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Boolean} the first date is after the second date
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Is 10 July 1989 after 11 February 1987?
 * var result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> true
 */
function isAfter (dirtyDate, dirtyDateToCompare, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
  }

  var date = toDate(dirtyDate, dirtyOptions);
  var dateToCompare = toDate(dirtyDateToCompare, dirtyOptions);
  return date.getTime() > dateToCompare.getTime()
}

/**
 * @name isBefore
 * @category Common Helpers
 * @summary Is the first date before the second one?
 *
 * @description
 * Is the first date before the second one?
 *
 * @param {Date|String|Number} date - the date that should be before the other one to return true
 * @param {Date|String|Number} dateToCompare - the date to compare with
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Boolean} the first date is before the second date
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Is 10 July 1989 before 11 February 1987?
 * var result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> false
 */
function isBefore (dirtyDate, dirtyDateToCompare, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
  }

  var date = toDate(dirtyDate, dirtyOptions);
  var dateToCompare = toDate(dirtyDateToCompare, dirtyOptions);
  return date.getTime() < dateToCompare.getTime()
}

/**
 * @name isEqual
 * @category Common Helpers
 * @summary Are the given dates equal?
 *
 * @description
 * Are the given dates equal?
 *
 * @param {Date|String|Number} dateLeft - the first date to compare
 * @param {Date|String|Number} dateRight - the second date to compare
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Boolean} the dates are equal
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
 * var result = isEqual(
 *   new Date(2014, 6, 2, 6, 30, 45, 0)
 *   new Date(2014, 6, 2, 6, 30, 45, 500)
 * )
 * //=> false
 */
function isEqual$1 (dirtyLeftDate, dirtyRightDate, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
  }

  var dateLeft = toDate(dirtyLeftDate, dirtyOptions);
  var dateRight = toDate(dirtyRightDate, dirtyOptions);
  return dateLeft.getTime() === dateRight.getTime()
}

var patterns$1 = {
  'M': /^(1[0-2]|0?\d)/, // 0 to 12
  'D': /^(3[0-1]|[0-2]?\d)/, // 0 to 31
  'DDD': /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/, // 0 to 366
  'W': /^(5[0-3]|[0-4]?\d)/, // 0 to 53
  'YYYY': /^(\d{1,4})/, // 0 to 9999
  'H': /^(2[0-3]|[0-1]?\d)/, // 0 to 23
  'm': /^([0-5]?\d)/, // 0 to 59
  'Z': /^([+-])(\d{2}):(\d{2})/,
  'ZZ': /^([+-])(\d{2})(\d{2})/,
  singleDigit: /^(\d)/,
  twoDigits: /^(\d{2})/,
  threeDigits: /^(\d{3})/,
  fourDigits: /^(\d{4})/,
  anyDigits: /^(\d+)/
};

function parseDecimal$1 (matchResult) {
  return parseInt(matchResult[1], 10)
}

var parsers = {
  // Year: 00, 01, ..., 99
  'YY': {
    unit: 'twoDigitYear',
    match: patterns$1.twoDigits,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult)
    }
  },

  // Year: 1900, 1901, ..., 2099
  'YYYY': {
    unit: 'year',
    match: patterns$1.YYYY,
    parse: parseDecimal$1
  },

  // ISO week-numbering year: 00, 01, ..., 99
  'GG': {
    unit: 'isoYear',
    match: patterns$1.twoDigits,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult) + 1900
    }
  },

  // ISO week-numbering year: 1900, 1901, ..., 2099
  'GGGG': {
    unit: 'isoYear',
    match: patterns$1.YYYY,
    parse: parseDecimal$1
  },

  // Quarter: 1, 2, 3, 4
  'Q': {
    unit: 'quarter',
    match: patterns$1.singleDigit,
    parse: parseDecimal$1
  },

  // Ordinal quarter
  'Qo': {
    unit: 'quarter',
    match: function (string, options) {
      return options.locale.match.ordinalNumbers(string, {unit: 'quarter'})
    },
    parse: function (matchResult, options) {
      return options.locale.match.ordinalNumber(matchResult, {unit: 'quarter'})
    }
  },

  // Month: 1, 2, ..., 12
  'M': {
    unit: 'month',
    match: patterns$1.M,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult) - 1
    }
  },

  // Ordinal month
  'Mo': {
    unit: 'month',
    match: function (string, options) {
      return options.locale.match.ordinalNumbers(string, {unit: 'month'})
    },
    parse: function (matchResult, options) {
      return options.locale.match.ordinalNumber(matchResult, {unit: 'month'}) - 1
    }
  },

  // Month: 01, 02, ..., 12
  'MM': {
    unit: 'month',
    match: patterns$1.twoDigits,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult) - 1
    }
  },

  // Month: Jan, Feb, ..., Dec
  'MMM': {
    unit: 'month',
    match: function (string, options) {
      return options.locale.match.months(string, {type: 'short'})
    },
    parse: function (matchResult, options) {
      return options.locale.match.month(matchResult, {type: 'short'})
    }
  },

  // Month: January, February, ..., December
  'MMMM': {
    unit: 'month',
    match: function (string, options) {
      return options.locale.match.months(string, {type: 'long'}) ||
        options.locale.match.months(string, {type: 'short'})
    },
    parse: function (matchResult, options) {
      var parseResult = options.locale.match.month(matchResult, {type: 'long'});

      if (parseResult == null) {
        parseResult = options.locale.match.month(matchResult, {type: 'short'});
      }

      return parseResult
    }
  },

  // ISO week: 1, 2, ..., 53
  'W': {
    unit: 'isoWeek',
    match: patterns$1.W,
    parse: parseDecimal$1
  },

  // Ordinal ISO week
  'Wo': {
    unit: 'isoWeek',
    match: function (string, options) {
      return options.locale.match.ordinalNumbers(string, {unit: 'isoWeek'})
    },
    parse: function (matchResult, options) {
      return options.locale.match.ordinalNumber(matchResult, {unit: 'isoWeek'})
    }
  },

  // ISO week: 01, 02, ..., 53
  'WW': {
    unit: 'isoWeek',
    match: patterns$1.twoDigits,
    parse: parseDecimal$1
  },

  // Day of week: 0, 1, ..., 6
  'd': {
    unit: 'dayOfWeek',
    match: patterns$1.singleDigit,
    parse: parseDecimal$1
  },

  // Ordinal day of week
  'do': {
    unit: 'dayOfWeek',
    match: function (string, options) {
      return options.locale.match.ordinalNumbers(string, {unit: 'dayOfWeek'})
    },
    parse: function (matchResult, options) {
      return options.locale.match.ordinalNumber(matchResult, {unit: 'dayOfWeek'})
    }
  },

  // Day of week: Su, Mo, ..., Sa
  'dd': {
    unit: 'dayOfWeek',
    match: function (string, options) {
      return options.locale.match.weekdays(string, {type: 'narrow'})
    },
    parse: function (matchResult, options) {
      return options.locale.match.weekday(matchResult, {type: 'narrow'})
    }
  },

  // Day of week: Sun, Mon, ..., Sat
  'ddd': {
    unit: 'dayOfWeek',
    match: function (string, options) {
      return options.locale.match.weekdays(string, {type: 'short'}) ||
        options.locale.match.weekdays(string, {type: 'narrow'})
    },
    parse: function (matchResult, options) {
      var parseResult = options.locale.match.weekday(matchResult, {type: 'short'});

      if (parseResult == null) {
        parseResult = options.locale.match.weekday(matchResult, {type: 'narrow'});
      }

      return parseResult
    }
  },

  // Day of week: Sunday, Monday, ..., Saturday
  'dddd': {
    unit: 'dayOfWeek',
    match: function (string, options) {
      return options.locale.match.weekdays(string, {type: 'long'}) ||
        options.locale.match.weekdays(string, {type: 'short'}) ||
        options.locale.match.weekdays(string, {type: 'narrow'})
    },
    parse: function (matchResult, options) {
      var parseResult = options.locale.match.weekday(matchResult, {type: 'long'});

      if (parseResult == null) {
        parseResult = options.locale.match.weekday(matchResult, {type: 'short'});

        if (parseResult == null) {
          parseResult = options.locale.match.weekday(matchResult, {type: 'narrow'});
        }
      }

      return parseResult
    }
  },

  // Day of ISO week: 1, 2, ..., 7
  'E': {
    unit: 'dayOfISOWeek',
    match: patterns$1.singleDigit,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult)
    }
  },

  // Day of month: 1, 2, ..., 31
  'D': {
    unit: 'dayOfMonth',
    match: patterns$1.D,
    parse: parseDecimal$1
  },

  // Ordinal day of month
  'Do': {
    unit: 'dayOfMonth',
    match: function (string, options) {
      return options.locale.match.ordinalNumbers(string, {unit: 'dayOfMonth'})
    },
    parse: function (matchResult, options) {
      return options.locale.match.ordinalNumber(matchResult, {unit: 'dayOfMonth'})
    }
  },

  // Day of month: 01, 02, ..., 31
  'DD': {
    unit: 'dayOfMonth',
    match: patterns$1.twoDigits,
    parse: parseDecimal$1
  },

  // Day of year: 1, 2, ..., 366
  'DDD': {
    unit: 'dayOfYear',
    match: patterns$1.DDD,
    parse: parseDecimal$1
  },

  // Ordinal day of year
  'DDDo': {
    unit: 'dayOfYear',
    match: function (string, options) {
      return options.locale.match.ordinalNumbers(string, {unit: 'dayOfYear'})
    },
    parse: function (matchResult, options) {
      return options.locale.match.ordinalNumber(matchResult, {unit: 'dayOfYear'})
    }
  },

  // Day of year: 001, 002, ..., 366
  'DDDD': {
    unit: 'dayOfYear',
    match: patterns$1.threeDigits,
    parse: parseDecimal$1
  },

  // AM, PM
  'A': {
    unit: 'timeOfDay',
    match: function (string, options) {
      return options.locale.match.timesOfDay(string, {type: 'short'})
    },
    parse: function (matchResult, options) {
      return options.locale.match.timeOfDay(matchResult, {type: 'short'})
    }
  },

  // a.m., p.m.
  'aa': {
    unit: 'timeOfDay',
    match: function (string, options) {
      return options.locale.match.timesOfDay(string, {type: 'long'}) ||
        options.locale.match.timesOfDay(string, {type: 'short'})
    },
    parse: function (matchResult, options) {
      var parseResult = options.locale.match.timeOfDay(matchResult, {type: 'long'});

      if (parseResult == null) {
        parseResult = options.locale.match.timeOfDay(matchResult, {type: 'short'});
      }

      return parseResult
    }
  },

  // Hour: 0, 1, ... 23
  'H': {
    unit: 'hours',
    match: patterns$1.H,
    parse: parseDecimal$1
  },

  // Hour: 00, 01, ..., 23
  'HH': {
    unit: 'hours',
    match: patterns$1.twoDigits,
    parse: parseDecimal$1
  },

  // Hour: 1, 2, ..., 12
  'h': {
    unit: 'timeOfDayHours',
    match: patterns$1.M,
    parse: parseDecimal$1
  },

  // Hour: 01, 02, ..., 12
  'hh': {
    unit: 'timeOfDayHours',
    match: patterns$1.twoDigits,
    parse: parseDecimal$1
  },

  // Minute: 0, 1, ..., 59
  'm': {
    unit: 'minutes',
    match: patterns$1.m,
    parse: parseDecimal$1
  },

  // Minute: 00, 01, ..., 59
  'mm': {
    unit: 'minutes',
    match: patterns$1.twoDigits,
    parse: parseDecimal$1
  },

  // Second: 0, 1, ..., 59
  's': {
    unit: 'seconds',
    match: patterns$1.m,
    parse: parseDecimal$1
  },

  // Second: 00, 01, ..., 59
  'ss': {
    unit: 'seconds',
    match: patterns$1.twoDigits,
    parse: parseDecimal$1
  },

  // 1/10 of second: 0, 1, ..., 9
  'S': {
    unit: 'milliseconds',
    match: patterns$1.singleDigit,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult) * 100
    }
  },

  // 1/100 of second: 00, 01, ..., 99
  'SS': {
    unit: 'milliseconds',
    match: patterns$1.twoDigits,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult) * 10
    }
  },

  // Millisecond: 000, 001, ..., 999
  'SSS': {
    unit: 'milliseconds',
    match: patterns$1.threeDigits,
    parse: parseDecimal$1
  },

  // Timezone: -01:00, +00:00, ... +12:00
  'Z': {
    unit: 'timezone',
    match: patterns$1.Z,
    parse: function (matchResult) {
      var sign = matchResult[1];
      var hours = parseInt(matchResult[2], 10);
      var minutes = parseInt(matchResult[3], 10);
      var absoluteOffset = hours * 60 + minutes;
      return (sign === '+') ? absoluteOffset : -absoluteOffset
    }
  },

  // Timezone: -0100, +0000, ... +1200
  'ZZ': {
    unit: 'timezone',
    match: patterns$1.ZZ,
    parse: function (matchResult) {
      var sign = matchResult[1];
      var hours = parseInt(matchResult[2], 10);
      var minutes = parseInt(matchResult[3], 10);
      var absoluteOffset = hours * 60 + minutes;
      return (sign === '+') ? absoluteOffset : -absoluteOffset
    }
  },

  // Seconds timestamp: 512969520
  'X': {
    unit: 'timestamp',
    match: patterns$1.anyDigits,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult) * 1000
    }
  },

  // Milliseconds timestamp: 512969520900
  'x': {
    unit: 'timestamp',
    match: patterns$1.anyDigits,
    parse: parseDecimal$1
  }
};

parsers['a'] = parsers['A'];

// This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376
function setUTCDay (dirtyDate, dirtyDay, dirtyOptions) {
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn === undefined ? 0 : Number(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn === undefined ? defaultWeekStartsOn : Number(options.weekStartsOn);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively')
  }

  var date = toDate(dirtyDate, dirtyOptions);
  var day = Number(dirtyDay);

  var currentDay = date.getUTCDay();

  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;

  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;

  date.setUTCDate(date.getUTCDate() + diff);
  return date
}

// This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376
function setUTCISODay (dirtyDate, dirtyDay, dirtyOptions) {
  var day = Number(dirtyDay);

  if (day % 7 === 0) {
    day = day - 7;
  }

  var weekStartsOn = 1;
  var date = toDate(dirtyDate, dirtyOptions);
  var currentDay = date.getUTCDay();

  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;

  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;

  date.setUTCDate(date.getUTCDate() + diff);
  return date
}

// This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376
function setUTCISOWeek (dirtyDate, dirtyISOWeek, dirtyOptions) {
  var date = toDate(dirtyDate, dirtyOptions);
  var isoWeek = Number(dirtyISOWeek);
  var diff = getUTCISOWeek(date, dirtyOptions) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date
}

var MILLISECONDS_IN_DAY$3 = 86400000;

// This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376
function setUTCISOWeekYear (dirtyDate, dirtyISOYear, dirtyOptions) {
  var date = toDate(dirtyDate, dirtyOptions);
  var isoYear = Number(dirtyISOYear);
  var dateStartOfYear = startOfUTCISOWeekYear(date, dirtyOptions);
  var diff = Math.floor((date.getTime() - dateStartOfYear.getTime()) / MILLISECONDS_IN_DAY$3);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(isoYear, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  date = startOfUTCISOWeekYear(fourthOfJanuary, dirtyOptions);
  date.setUTCDate(date.getUTCDate() + diff);
  return date
}

var MILLISECONDS_IN_MINUTE$6 = 60000;

function setTimeOfDay (hours, timeOfDay) {
  var isAM = timeOfDay === 0;

  if (isAM) {
    if (hours === 12) {
      return 0
    }
  } else {
    if (hours !== 12) {
      return 12 + hours
    }
  }

  return hours
}

var units = {
  twoDigitYear: {
    priority: 10,
    set: function (dateValues, value) {
      var century = Math.floor(dateValues.date.getUTCFullYear() / 100);
      var year = century * 100 + value;
      dateValues.date.setUTCFullYear(year, 0, 1);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues
    }
  },

  year: {
    priority: 10,
    set: function (dateValues, value) {
      dateValues.date.setUTCFullYear(value, 0, 1);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues
    }
  },

  isoYear: {
    priority: 10,
    set: function (dateValues, value, options) {
      dateValues.date = startOfUTCISOWeekYear(setUTCISOWeekYear(dateValues.date, value, options), options);
      return dateValues
    }
  },

  quarter: {
    priority: 20,
    set: function (dateValues, value) {
      dateValues.date.setUTCMonth((value - 1) * 3, 1);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues
    }
  },

  month: {
    priority: 30,
    set: function (dateValues, value) {
      dateValues.date.setUTCMonth(value, 1);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues
    }
  },

  isoWeek: {
    priority: 40,
    set: function (dateValues, value, options) {
      dateValues.date = startOfUTCISOWeek(setUTCISOWeek(dateValues.date, value, options), options);
      return dateValues
    }
  },

  dayOfWeek: {
    priority: 50,
    set: function (dateValues, value, options) {
      dateValues.date = setUTCDay(dateValues.date, value, options);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues
    }
  },

  dayOfISOWeek: {
    priority: 50,
    set: function (dateValues, value, options) {
      dateValues.date = setUTCISODay(dateValues.date, value, options);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues
    }
  },

  dayOfMonth: {
    priority: 50,
    set: function (dateValues, value) {
      dateValues.date.setUTCDate(value);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues
    }
  },

  dayOfYear: {
    priority: 50,
    set: function (dateValues, value) {
      dateValues.date.setUTCMonth(0, value);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues
    }
  },

  timeOfDay: {
    priority: 60,
    set: function (dateValues, value, options) {
      dateValues.timeOfDay = value;
      return dateValues
    }
  },

  hours: {
    priority: 70,
    set: function (dateValues, value, options) {
      dateValues.date.setUTCHours(value, 0, 0, 0);
      return dateValues
    }
  },

  timeOfDayHours: {
    priority: 70,
    set: function (dateValues, value, options) {
      var timeOfDay = dateValues.timeOfDay;
      if (timeOfDay != null) {
        value = setTimeOfDay(value, timeOfDay);
      }
      dateValues.date.setUTCHours(value, 0, 0, 0);
      return dateValues
    }
  },

  minutes: {
    priority: 80,
    set: function (dateValues, value) {
      dateValues.date.setUTCMinutes(value, 0, 0);
      return dateValues
    }
  },

  seconds: {
    priority: 90,
    set: function (dateValues, value) {
      dateValues.date.setUTCSeconds(value, 0);
      return dateValues
    }
  },

  milliseconds: {
    priority: 100,
    set: function (dateValues, value) {
      dateValues.date.setUTCMilliseconds(value);
      return dateValues
    }
  },

  timezone: {
    priority: 110,
    set: function (dateValues, value) {
      dateValues.date = new Date(dateValues.date.getTime() - value * MILLISECONDS_IN_MINUTE$6);
      return dateValues
    }
  },

  timestamp: {
    priority: 120,
    set: function (dateValues, value) {
      dateValues.date = new Date(value);
      return dateValues
    }
  }
};

var TIMEZONE_UNIT_PRIORITY = 110;
var MILLISECONDS_IN_MINUTE$7 = 60000;

var longFormattingTokensRegExp$1 = /(\[[^[]*])|(\\)?(LTS|LT|LLLL|LLL|LL|L|llll|lll|ll|l)/g;
var defaultParsingTokensRegExp = /(\[[^[]*])|(\\)?(x|ss|s|mm|m|hh|h|do|dddd|ddd|dd|d|aa|a|ZZ|Z|YYYY|YY|X|Wo|WW|W|SSS|SS|S|Qo|Q|Mo|MMMM|MMM|MM|M|HH|H|GGGG|GG|E|Do|DDDo|DDDD|DDD|DD|D|A|.)/g;

/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format.
 *
 * Accepted format tokens:
 * | Unit                    | Priority | Token | Input examples                   |
 * |-------------------------|----------|-------|----------------------------------|
 * | Year                    | 10       | YY    | 00, 01, ..., 99                  |
 * |                         |          | YYYY  | 1900, 1901, ..., 2099            |
 * | ISO week-numbering year | 10       | GG    | 00, 01, ..., 99                  |
 * |                         |          | GGGG  | 1900, 1901, ..., 2099            |
 * | Quarter                 | 20       | Q     | 1, 2, 3, 4                       |
 * |                         |          | Qo    | 1st, 2nd, 3rd, 4th               |
 * | Month                   | 30       | M     | 1, 2, ..., 12                    |
 * |                         |          | Mo    | 1st, 2nd, ..., 12th              |
 * |                         |          | MM    | 01, 02, ..., 12                  |
 * |                         |          | MMM   | Jan, Feb, ..., Dec               |
 * |                         |          | MMMM  | January, February, ..., December |
 * | ISO week                | 40       | W     | 1, 2, ..., 53                    |
 * |                         |          | Wo    | 1st, 2nd, ..., 53rd              |
 * |                         |          | WW    | 01, 02, ..., 53                  |
 * | Day of week             | 50       | d     | 0, 1, ..., 6                     |
 * |                         |          | do    | 0th, 1st, ..., 6th               |
 * |                         |          | dd    | Su, Mo, ..., Sa                  |
 * |                         |          | ddd   | Sun, Mon, ..., Sat               |
 * |                         |          | dddd  | Sunday, Monday, ..., Saturday    |
 * | Day of ISO week         | 50       | E     | 1, 2, ..., 7                     |
 * | Day of month            | 50       | D     | 1, 2, ..., 31                    |
 * |                         |          | Do    | 1st, 2nd, ..., 31st              |
 * |                         |          | DD    | 01, 02, ..., 31                  |
 * | Day of year             | 50       | DDD   | 1, 2, ..., 366                   |
 * |                         |          | DDDo  | 1st, 2nd, ..., 366th             |
 * |                         |          | DDDD  | 001, 002, ..., 366               |
 * | Time of day             | 60       | A     | AM, PM                           |
 * |                         |          | a     | am, pm                           |
 * |                         |          | aa    | a.m., p.m.                       |
 * | Hour                    | 70       | H     | 0, 1, ... 23                     |
 * |                         |          | HH    | 00, 01, ... 23                   |
 * | Time of day hour        | 70       | h     | 1, 2, ..., 12                    |
 * |                         |          | hh    | 01, 02, ..., 12                  |
 * | Minute                  | 80       | m     | 0, 1, ..., 59                    |
 * |                         |          | mm    | 00, 01, ..., 59                  |
 * | Second                  | 90       | s     | 0, 1, ..., 59                    |
 * |                         |          | ss    | 00, 01, ..., 59                  |
 * | 1/10 of second          | 100      | S     | 0, 1, ..., 9                     |
 * | 1/100 of second         | 100      | SS    | 00, 01, ..., 99                  |
 * | Millisecond             | 100      | SSS   | 000, 001, ..., 999               |
 * | Timezone                | 110      | Z     | -01:00, +00:00, ... +12:00       |
 * |                         |          | ZZ    | -0100, +0000, ..., +1200         |
 * | Seconds timestamp       | 120      | X     | 512969520                        |
 * | Milliseconds timestamp  | 120      | x     | 512969520900                     |
 *
 * Values will be assigned to the date in the ascending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `baseDate` which works as a context of parsing.
 *
 * `baseDate` must be passed for correct work of the function.
 * If you're not sure which `baseDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/DD/YYYY', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `baseDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * Also, `parse` unfolds long formats like those in [format]{@link https://date-fns.org/docs/format}:
 * | Token | Input examples                 |
 * |-------|--------------------------------|
 * | LT    | 05:30 a.m.                     |
 * | LTS   | 05:30:15 a.m.                  |
 * | L     | 07/02/1995                     |
 * | l     | 7/2/1995                       |
 * | LL    | July 2 1995                    |
 * | ll    | Jul 2 1995                     |
 * | LLL   | July 2 1995 05:30 a.m.         |
 * | lll   | Jul 2 1995 05:30 a.m.          |
 * | LLLL  | Sunday, July 2 1995 05:30 a.m. |
 * | llll  | Sun, Jul 2 1995 05:30 a.m.     |
 *
 * The characters wrapped in square brackets in the format string are escaped.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `baseDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|String|Number} baseDate - the date to took the missing higher priority values from
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse(
 *   '02/11/2014',
 *   'MM/DD/YYYY',
 *   new Date()
 * )
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in English locale in the context of 2010 year:
 * import eoLocale from 'date-fns/locale/eo'
 * var result = parse(
 *   '28-a de februaro',
 *   'Do [de] MMMM',
 *   new Date(2010, 0, 1)
 *   {locale: eoLocale}
 * )
 * //=> Sun Feb 28 2010 00:00:00
 */
function parse (dirtyDateString, dirtyFormatString, dirtyBaseDate, dirtyOptions) {
  if (arguments.length < 3) {
    throw new TypeError('3 arguments required, but only ' + arguments.length + ' present')
  }

  var dateString = String(dirtyDateString);
  var options = dirtyOptions || {};

  var weekStartsOn = options.weekStartsOn === undefined ? 0 : Number(options.weekStartsOn);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively')
  }

  var locale = options.locale || locale$1;
  var localeParsers = locale.parsers || {};
  var localeUnits = locale.units || {};

  if (!locale.match) {
    throw new RangeError('locale must contain match property')
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property')
  }

  var formatString = String(dirtyFormatString)
    .replace(longFormattingTokensRegExp$1, function (substring) {
      if (substring[0] === '[') {
        return substring
      }

      if (substring[0] === '\\') {
        return cleanEscapedString$1(substring)
      }

      return locale.formatLong(substring)
    });

  if (formatString === '') {
    if (dateString === '') {
      return toDate(dirtyBaseDate, options)
    } else {
      return new Date(NaN)
    }
  }

  var subFnOptions = cloneObject(options);
  subFnOptions.locale = locale;

  var tokens = formatString.match(locale.parsingTokensRegExp || defaultParsingTokensRegExp);
  var tokensLength = tokens.length;

  // If timezone isn't specified, it will be set to the system timezone
  var setters = [{
    priority: TIMEZONE_UNIT_PRIORITY,
    set: dateToSystemTimezone,
    index: 0
  }];

  var i;
  for (i = 0; i < tokensLength; i++) {
    var token = tokens[i];
    var parser = localeParsers[token] || parsers[token];
    if (parser) {
      var matchResult;

      if (parser.match instanceof RegExp) {
        matchResult = parser.match.exec(dateString);
      } else {
        matchResult = parser.match(dateString, subFnOptions);
      }

      if (!matchResult) {
        return new Date(NaN)
      }

      var unitName = parser.unit;
      var unit = localeUnits[unitName] || units[unitName];

      setters.push({
        priority: unit.priority,
        set: unit.set,
        value: parser.parse(matchResult, subFnOptions),
        index: setters.length
      });

      var substring = matchResult[0];
      dateString = dateString.slice(substring.length);
    } else {
      var head = tokens[i].match(/^\[.*]$/) ? tokens[i].replace(/^\[|]$/g, '') : tokens[i];
      if (dateString.indexOf(head) === 0) {
        dateString = dateString.slice(head.length);
      } else {
        return new Date(NaN)
      }
    }
  }

  var uniquePrioritySetters = setters
    .map(function (setter) {
      return setter.priority
    })
    .sort(function (a, b) {
      return a - b
    })
    .filter(function (priority, index, array) {
      return array.indexOf(priority) === index
    })
    .map(function (priority) {
      return setters
        .filter(function (setter) {
          return setter.priority === priority
        })
        .reverse()
    })
    .map(function (setterArray) {
      return setterArray[0]
    });

  var date = toDate(dirtyBaseDate, options);

  if (isNaN(date)) {
    return new Date(NaN)
  }

  // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/37
  var utcDate = subMinutes(date, date.getTimezoneOffset());

  var dateValues = {date: utcDate};

  var settersLength = uniquePrioritySetters.length;
  for (i = 0; i < settersLength; i++) {
    var setter = uniquePrioritySetters[i];
    dateValues = setter.set(dateValues, setter.value, subFnOptions);
  }

  return dateValues.date
}

function dateToSystemTimezone (dateValues) {
  var date = dateValues.date;
  var time = date.getTime();

  // Get the system timezone offset at (moment of time - offset)
  var offset = date.getTimezoneOffset();

  // Get the system timezone offset at the exact moment of time
  offset = new Date(time + offset * MILLISECONDS_IN_MINUTE$7).getTimezoneOffset();

  // Convert date in timezone "UTC+00:00" to the system timezone
  dateValues.date = new Date(time + offset * MILLISECONDS_IN_MINUTE$7);

  return dateValues
}

function cleanEscapedString$1 (input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|]$/g, '')
  }
  return input.replace(/\\/g, '')
}

// This file is generated automatically by `scripts/build/indices.js`. Please, don't change it.

// 

/**
 * Custom parse behavior on top of date-fns parse function.
 */
function parseDate$1 (date, format$$1) {
  if (typeof date !== 'string') {
    return isValid(date) ? date : null
  }

  var parsed = parse(date, format$$1, new Date());

  // if date is not valid or the formatted output after parsing does not match
  // the string value passed in (avoids overflows)
  if (!isValid(parsed) || format(parsed, format$$1) !== date) {
    return null
  }

  return parsed
}

function after (value, ref) {
  var otherValue = ref[0];
  var inclusion = ref[1];
  var format = ref[2];

  if (typeof format === 'undefined') {
    format = inclusion;
    inclusion = false;
  }
  value = parseDate$1(value, format);
  otherValue = parseDate$1(otherValue, format);

  // if either is not valid.
  if (!value || !otherValue) {
    return false
  }

  return isAfter(value, otherValue) || (inclusion && isEqual$1(value, otherValue))
}

/**
 * Some Alpha Regex helpers.
 * https://github.com/chriso/validator.js/blob/master/src/lib/alpha.js
 */

var alpha = {
  en: /^[A-Z]*$/i,
  cs: /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]*$/i,
  da: /^[A-ZÆØÅ]*$/i,
  de: /^[A-ZÄÖÜß]*$/i,
  es: /^[A-ZÁÉÍÑÓÚÜ]*$/i,
  fr: /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]*$/i,
  lt: /^[A-ZĄČĘĖĮŠŲŪŽ]*$/i,
  nl: /^[A-ZÉËÏÓÖÜ]*$/i,
  hu: /^[A-ZÁÉÍÓÖŐÚÜŰ]*$/i,
  pl: /^[A-ZĄĆĘŚŁŃÓŻŹ]*$/i,
  pt: /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]*$/i,
  ru: /^[А-ЯЁ]*$/i,
  sk: /^[A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ]*$/i,
  sr: /^[A-ZČĆŽŠĐ]*$/i,
  tr: /^[A-ZÇĞİıÖŞÜ]*$/i,
  uk: /^[А-ЩЬЮЯЄІЇҐ]*$/i,
  ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]*$/,
};

var alphaSpaces = {
  en: /^[A-Z\s]*$/i,
  cs: /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ\s]*$/i,
  da: /^[A-ZÆØÅ\s]*$/i,
  de: /^[A-ZÄÖÜß\s]*$/i,
  es: /^[A-ZÁÉÍÑÓÚÜ\s]*$/i,
  fr: /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ\s]*$/i,
  lt: /^[A-ZĄČĘĖĮŠŲŪŽ\s]*$/i,
  nl: /^[A-ZÉËÏÓÖÜ\s]*$/i,
  hu: /^[A-ZÁÉÍÓÖŐÚÜŰ\s]*$/i,
  pl: /^[A-ZĄĆĘŚŁŃÓŻŹ\s]*$/i,
  pt: /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ\s]*$/i,
  ru: /^[А-ЯЁ\s]*$/i,
  sk: /^[A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ\s]*$/i,
  sr: /^[A-ZČĆŽŠĐ\s]*$/i,
  tr: /^[A-ZÇĞİıÖŞÜ\s]*$/i,
  uk: /^[А-ЩЬЮЯЄІЇҐ\s]*$/i,
  ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ\s]*$/,
};

var alphanumeric = {
  en: /^[0-9A-Z]*$/i,
  cs: /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]*$/i,
  da: /^[0-9A-ZÆØÅ]$/i,
  de: /^[0-9A-ZÄÖÜß]*$/i,
  es: /^[0-9A-ZÁÉÍÑÓÚÜ]*$/i,
  fr: /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]*$/i,
  lt: /^[0-9A-ZĄČĘĖĮŠŲŪŽ]*$/i,
  hu: /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]*$/i,
  nl: /^[0-9A-ZÉËÏÓÖÜ]*$/i,
  pl: /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]*$/i,
  pt: /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]*$/i,
  ru: /^[0-9А-ЯЁ]*$/i,
  sk: /^[0-9A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ]*$/i,
  sr: /^[0-9A-ZČĆŽŠĐ]*$/i,
  tr: /^[0-9A-ZÇĞİıÖŞÜ]*$/i,
  uk: /^[0-9А-ЩЬЮЯЄІЇҐ]*$/i,
  ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]*$/,
};

var alphaDash = {
  en: /^[0-9A-Z_-]*$/i,
  cs: /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ_-]*$/i,
  da: /^[0-9A-ZÆØÅ_-]*$/i,
  de: /^[0-9A-ZÄÖÜß_-]*$/i,
  es: /^[0-9A-ZÁÉÍÑÓÚÜ_-]*$/i,
  fr: /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ_-]*$/i,
  lt: /^[0-9A-ZĄČĘĖĮŠŲŪŽ_-]*$/i,
  nl: /^[0-9A-ZÉËÏÓÖÜ_-]*$/i,
  hu: /^[0-9A-ZÁÉÍÓÖŐÚÜŰ_-]*$/i,
  pl: /^[0-9A-ZĄĆĘŚŁŃÓŻŹ_-]*$/i,
  pt: /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ_-]*$/i,
  ru: /^[0-9А-ЯЁ_-]*$/i,
  sk: /^[0-9A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ_-]*$/i,
  sr: /^[0-9A-ZČĆŽŠĐ_-]*$/i,
  tr: /^[0-9A-ZÇĞİıÖŞÜ_-]*$/i,
  uk: /^[0-9А-ЩЬЮЯЄІЇҐ_-]*$/i,
  ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ_-]*$/,
};

var validate = function (value, ref) {
  if ( ref === void 0 ) ref = [null];
  var locale = ref[0];

  if (Array.isArray(value)) {
    return value.every(function (val) { return validate(val, [locale]); })
  }

  // Match at least one locale.
  if (! locale) {
    return Object.keys(alpha).some(function (loc) { return alpha[loc].test(value); })
  }

  return (alpha[locale] || alpha.en).test(value)
};

var validate$1 = function (value, ref) {
  if ( ref === void 0 ) ref = [null];
  var locale = ref[0];

  if (Array.isArray(value)) {
    return value.every(function (val) { return validate$1(val, [locale]); })
  }

  // Match at least one locale.
  if (! locale) {
    return Object.keys(alphaDash).some(function (loc) { return alphaDash[loc].test(value); })
  }

  return (alphaDash[locale] || alphaDash.en).test(value)
};

var validate$2 = function (value, ref) {
  if ( ref === void 0 ) ref = [null];
  var locale = ref[0];

  if (Array.isArray(value)) {
    return value.every(function (val) { return validate$2(val, [locale]); })
  }

  // Match at least one locale.
  if (! locale) {
    return Object.keys(alphanumeric).some(function (loc) { return alphanumeric[loc].test(value); })
  }

  return (alphanumeric[locale] || alphanumeric.en).test(value)
};

var validate$3 = function (value, ref) {
  if ( ref === void 0 ) ref = [null];
  var locale = ref[0];

  if (Array.isArray(value)) {
    return value.every(function (val) { return validate$3(val, [locale]); })
  }

  // Match at least one locale.
  if (! locale) {
    return Object.keys(alphaSpaces).some(function (loc) { return alphaSpaces[loc].test(value); })
  }

  return (alphaSpaces[locale] || alphaSpaces.en).test(value)
};

function before (value, ref) {
  var otherValue = ref[0];
  var inclusion = ref[1];
  var format = ref[2];

  if (typeof format === 'undefined') {
    format = inclusion;
    inclusion = false;
  }
  value = parseDate$1(value, format);
  otherValue = parseDate$1(otherValue, format);

  // if either is not valid.
  if (!value || !otherValue) {
    return false
  }

  return isBefore(value, otherValue) || (inclusion && isEqual$1(value, otherValue))
}

var validate$4 = function (value, ref) {
  var min = ref[0];
  var max = ref[1];

  if (Array.isArray(value)) {
    return value.every(function (val) { return validate$4(val, [min, max]); })
  }

  return Number(min) <= value && Number(max) >= value
};

function confirmed (value, other) { return String(value) === String(other); }

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var assertString_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assertString;
function assertString(input) {
  var isString = typeof input === 'string' || input instanceof String;

  if (!isString) {
    throw new TypeError('This library (validator.js) validates strings only');
  }
}
module.exports = exports['default'];
});

unwrapExports(assertString_1);

var isCreditCard_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isCreditCard;



var _assertString2 = _interopRequireDefault(assertString_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable max-len */
var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|62[0-9]{14})$/;
/* eslint-enable max-len */

function isCreditCard(str) {
  (0, _assertString2.default)(str);
  var sanitized = str.replace(/[- ]+/g, '');
  if (!creditCard.test(sanitized)) {
    return false;
  }
  var sum = 0;
  var digit = void 0;
  var tmpNum = void 0;
  var shouldDouble = void 0;
  for (var i = sanitized.length - 1; i >= 0; i--) {
    digit = sanitized.substring(i, i + 1);
    tmpNum = parseInt(digit, 10);
    if (shouldDouble) {
      tmpNum *= 2;
      if (tmpNum >= 10) {
        sum += tmpNum % 10 + 1;
      } else {
        sum += tmpNum;
      }
    } else {
      sum += tmpNum;
    }
    shouldDouble = !shouldDouble;
  }
  return !!(sum % 10 === 0 ? sanitized : false);
}
module.exports = exports['default'];
});

var isCreditCard = unwrapExports(isCreditCard_1);

function credit_card (value) { return isCreditCard(String(value)); }

var validate$5 = function (value, params) {
  var decimals = Array.isArray(params) ? (params[0] || '*') : '*';
  var separator = Array.isArray(params) ? (params[1] || '.') : '.';
  if (Array.isArray(value)) {
    return value.every(function (val) { return validate$5(val, params); })
  }

  if (value === null || value === undefined || value === '') {
    return true
  }

  // if is 0.
  if (Number(decimals) === 0) {
    return /^-?\d*$/.test(value)
  }

  var regexPart = decimals === '*' ? '+' : ("{1," + decimals + "}");
  var regex = new RegExp(("^-?\\d*(\\" + separator + "\\d" + regexPart + ")?$"));

  if (! regex.test(value)) {
    return false
  }

  var parsedValue = parseFloat(value);

  // eslint-disable-next-line
    return parsedValue === parsedValue;
};

function date_between (value, params) {
  var assign, assign$1;

  var min;
  var max;
  var format;
  var inclusivity = '()';

  if (params.length > 3) {
    (assign = params, min = assign[0], max = assign[1], inclusivity = assign[2], format = assign[3]);
  } else {
    (assign$1 = params, min = assign$1[0], max = assign$1[1], format = assign$1[2]);
  }

  var minDate = parseDate$1(min, format);
  var maxDate = parseDate$1(max, format);
  var dateVal = parseDate$1(value, format);

  if (!minDate || !maxDate || !dateVal) {
    return false
  }

  if (inclusivity === '()') {
    return isAfter(dateVal, minDate) && isBefore(dateVal, maxDate)
  }

  if (inclusivity === '(]') {
    return isAfter(dateVal, minDate) && (isEqual$1(dateVal, maxDate) || isBefore(dateVal, maxDate))
  }

  if (inclusivity === '[)') {
    return isBefore(dateVal, maxDate) && (isEqual$1(dateVal, minDate) || isAfter(dateVal, minDate))
  }

  return isEqual$1(dateVal, maxDate) || isEqual$1(dateVal, minDate) ||
        (isBefore(dateVal, maxDate) && isAfter(dateVal, minDate))
}

function date_format (value, ref) {
  var format = ref[0];

  return !!parseDate$1(value, format)
}

var validate$6 = function (value, ref) {
  var length = ref[0];

  if (Array.isArray(value)) {
    return value.every(function (val) { return validate$6(val, [length]); })
  }
  var strVal = String(value);

  return /^[0-9]*$/.test(strVal) && strVal.length === Number(length)
};

var validateImage = function (file, width, height) {
  var URL = window.URL || window.webkitURL;
  return new Promise(function (resolve) {
    var image = new Image();
    image.onerror = function () { return resolve({ valid: false }); };
    image.onload = function () { return resolve({
      valid: image.width === Number(width) && image.height === Number(height),
    }); };

    image.src = URL.createObjectURL(file);
  })
};

function dimensions (files, ref) {
  var width = ref[0];
  var height = ref[1];

  var list = [];
  for (var i = 0; i < files.length; i++) {
    // if file is not an image, reject.
    if (! /\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(files[i].name)) {
      return false
    }

    list.push(files[i]);
  }

  return Promise.all(list.map(function (file) { return validateImage(file, width, height); }))
}

var merge_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = merge;
function merge() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaults = arguments[1];

  for (var key in defaults) {
    if (typeof obj[key] === 'undefined') {
      obj[key] = defaults[key];
    }
  }
  return obj;
}
module.exports = exports['default'];
});

unwrapExports(merge_1);

var isByteLength_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = isByteLength;



var _assertString2 = _interopRequireDefault(assertString_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable prefer-rest-params */
function isByteLength(str, options) {
  (0, _assertString2.default)(str);
  var min = void 0;
  var max = void 0;
  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
    min = options.min || 0;
    max = options.max;
  } else {
    // backwards compatibility: isByteLength(str, min [, max])
    min = arguments[1];
    max = arguments[2];
  }
  var len = encodeURI(str).split(/%..|./).length - 1;
  return len >= min && (typeof max === 'undefined' || len <= max);
}
module.exports = exports['default'];
});

unwrapExports(isByteLength_1);

var isFQDN_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isFQDN;



var _assertString2 = _interopRequireDefault(assertString_1);



var _merge2 = _interopRequireDefault(merge_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_fqdn_options = {
  require_tld: true,
  allow_underscores: false,
  allow_trailing_dot: false
};

function isFQDN(str, options) {
  (0, _assertString2.default)(str);
  options = (0, _merge2.default)(options, default_fqdn_options);

  /* Remove the optional trailing dot before checking validity */
  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
    str = str.substring(0, str.length - 1);
  }
  var parts = str.split('.');
  if (options.require_tld) {
    var tld = parts.pop();
    if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
      return false;
    }
    // disallow spaces
    if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
      return false;
    }
  }
  for (var part, i = 0; i < parts.length; i++) {
    part = parts[i];
    if (options.allow_underscores) {
      part = part.replace(/_/g, '');
    }
    if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
      return false;
    }
    // disallow full-width chars
    if (/[\uff01-\uff5e]/.test(part)) {
      return false;
    }
    if (part[0] === '-' || part[part.length - 1] === '-') {
      return false;
    }
  }
  return true;
}
module.exports = exports['default'];
});

unwrapExports(isFQDN_1);

var isEmail_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isEmail;



var _assertString2 = _interopRequireDefault(assertString_1);



var _merge2 = _interopRequireDefault(merge_1);



var _isByteLength2 = _interopRequireDefault(isByteLength_1);



var _isFQDN2 = _interopRequireDefault(isFQDN_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_email_options = {
  allow_display_name: false,
  require_display_name: false,
  allow_utf8_local_part: true,
  require_tld: true
};

/* eslint-disable max-len */
/* eslint-disable no-control-regex */
var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
/* eslint-enable max-len */
/* eslint-enable no-control-regex */

function isEmail(str, options) {
  (0, _assertString2.default)(str);
  options = (0, _merge2.default)(options, default_email_options);

  if (options.require_display_name || options.allow_display_name) {
    var display_email = str.match(displayName);
    if (display_email) {
      str = display_email[1];
    } else if (options.require_display_name) {
      return false;
    }
  }

  var parts = str.split('@');
  var domain = parts.pop();
  var user = parts.join('@');

  var lower_domain = domain.toLowerCase();
  if (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com') {
    user = user.replace(/\./g, '').toLowerCase();
  }

  if (!(0, _isByteLength2.default)(user, { max: 64 }) || !(0, _isByteLength2.default)(domain, { max: 254 })) {
    return false;
  }

  if (!(0, _isFQDN2.default)(domain, { require_tld: options.require_tld })) {
    return false;
  }

  if (user[0] === '"') {
    user = user.slice(1, user.length - 1);
    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
  }

  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;

  var user_parts = user.split('.');
  for (var i = 0; i < user_parts.length; i++) {
    if (!pattern.test(user_parts[i])) {
      return false;
    }
  }

  return true;
}
module.exports = exports['default'];
});

var isEmail = unwrapExports(isEmail_1);

var validate$7 = function (value) {
  if (Array.isArray(value)) {
    return value.every(function (val) { return isEmail(String(val)); })
  }

  return isEmail(String(value))
};

function ext (files, extensions) {
  var regex = new RegExp((".(" + (extensions.join('|')) + ")$"), 'i');

  return files.every(function (file) { return regex.test(file.name); })
}

function image (files) { return files.every(function (file) { return /\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(file.name); }
); }

var validate$8 = function (value, options) {
  if (Array.isArray(value)) {
    return value.every(function (val) { return validate$8(val, options); })
  }

  // eslint-disable-next-line
  return !! options.filter(function (option) { return option == value; }).length;
};

var isIP_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isIP;



var _assertString2 = _interopRequireDefault(assertString_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
var ipv6Block = /^[0-9A-F]{1,4}$/i;

function isIP(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  (0, _assertString2.default)(str);
  version = String(version);
  if (!version) {
    return isIP(str, 4) || isIP(str, 6);
  } else if (version === '4') {
    if (!ipv4Maybe.test(str)) {
      return false;
    }
    var parts = str.split('.').sort(function (a, b) {
      return a - b;
    });
    return parts[3] <= 255;
  } else if (version === '6') {
    var blocks = str.split(':');
    var foundOmissionBlock = false; // marker to indicate ::

    // At least some OS accept the last 32 bits of an IPv6 address
    // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
    // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
    // and '::a.b.c.d' is deprecated, but also valid.
    var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
    var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

    if (blocks.length > expectedNumberOfBlocks) {
      return false;
    }
    // initial or final ::
    if (str === '::') {
      return true;
    } else if (str.substr(0, 2) === '::') {
      blocks.shift();
      blocks.shift();
      foundOmissionBlock = true;
    } else if (str.substr(str.length - 2) === '::') {
      blocks.pop();
      blocks.pop();
      foundOmissionBlock = true;
    }

    for (var i = 0; i < blocks.length; ++i) {
      // test for a :: which can not be at the string start/end
      // since those cases have been handled above
      if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
        if (foundOmissionBlock) {
          return false; // multiple :: in address
        }
        foundOmissionBlock = true;
      } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {
        // it has been checked before that the last
        // block is a valid IPv4 address
      } else if (!ipv6Block.test(blocks[i])) {
        return false;
      }
    }
    if (foundOmissionBlock) {
      return blocks.length >= 1;
    }
    return blocks.length === expectedNumberOfBlocks;
  }
  return false;
}
module.exports = exports['default'];
});

var isIP = unwrapExports(isIP_1);

function ip (value, ref) {
  if ( ref === void 0 ) ref = [4];
  var version = ref[0];

  if (Array.isArray(value)) {
    return value.every(function (val) { return isIP(val, [version]); })
  }

  return isIP(value, version)
}

/**
 * @param {Array|String} value
 * @param {Number} length
 * @param {Number} max
 */
var compare = function (value, length, max) {
  if (max === undefined) {
    return value.length === length
  }

  // cast to number.
  max = Number(max);

  return value.length >= length && value.length <= max
};

function length (value, ref) {
  var length = ref[0];
  var max = ref[1]; if ( max === void 0 ) max = undefined;

  length = Number(length);
  if (value === undefined || value === null) {
    return false
  }

  if (typeof value === 'number') {
    value = String(value);
  }

  if (!value.length) {
    value = toArray(value);
  }

  return compare(value, length, max)
}

function integer (value) {
  if (Array.isArray(value)) {
    return value.every(function (val) { return /^-?[0-9]+$/.test(String(val)); })
  }

  return /^-?[0-9]+$/.test(String(value))
}

function max$1 (value, ref) {
  var length = ref[0];

  if (value === undefined || value === null) {
    return length >= 0
  }

  return String(value).length <= length
}

function max_value (value, ref) {
  var max = ref[0];

  if (Array.isArray(value) || value === null || value === undefined || value === '') {
    return false
  }

  return Number(value) <= max
}

function mimes (files, mimes) {
  var regex = new RegExp(((mimes.join('|').replace('*', '.+')) + "$"), 'i');

  return files.every(function (file) { return regex.test(file.type); })
}

function min$1 (value, ref) {
  var length = ref[0];

  if (value === undefined || value === null) {
    return false
  }
  return String(value).length >= length
}

function min_value (value, ref) {
  var min = ref[0];

  if (Array.isArray(value) || value === null || value === undefined || value === '') {
    return false
  }

  return Number(value) >= min
}

var validate$9 = function (value, options) {
  if (Array.isArray(value)) {
    return value.every(function (val) { return validate$9(val, options); })
  }

  // eslint-disable-next-line
  return ! options.filter(function (option) { return option == value; }).length;
};

function numeric (value) {
  if (Array.isArray(value)) {
    return value.every(function (val) { return /^[0-9]+$/.test(String(val)); })
  }

  return /^[0-9]+$/.test(String(value))
}

function regex (value, ref) {
  var regex = ref[0];
  var flags = ref.slice(1);

  if (regex instanceof RegExp) {
    return regex.test(value)
  }

  return new RegExp(regex, flags).test(String(value))
}

function required (value, params) {
  if ( params === void 0 ) params = [false];

  if (Array.isArray(value)) {
    return !! value.length
  }

  // incase a field considers `false` as an empty value like checkboxes.
  var invalidateFalse = params[0];
  if (value === false && invalidateFalse) {
    return false
  }

  if (value === undefined || value === null) {
    return false
  }

  return !! String(value).trim().length
}

function size (files, ref) {
  var size = ref[0];

  if (isNaN(size)) {
    return false
  }

  var nSize = Number(size) * 1024;
  for (var i = 0; i < files.length; i++) {
    if (files[i].size > nSize) {
      return false
    }
  }

  return true
}

var isURL_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isURL;



var _assertString2 = _interopRequireDefault(assertString_1);



var _isFQDN2 = _interopRequireDefault(isFQDN_1);



var _isIP2 = _interopRequireDefault(isIP_1);



var _merge2 = _interopRequireDefault(merge_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_url_options = {
  protocols: ['http', 'https', 'ftp'],
  require_tld: true,
  require_protocol: false,
  require_host: true,
  require_valid_protocol: true,
  allow_underscores: false,
  allow_trailing_dot: false,
  allow_protocol_relative_urls: false
};

var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]';
}

function checkHost(host, matches) {
  for (var i = 0; i < matches.length; i++) {
    var match = matches[i];
    if (host === match || isRegExp(match) && match.test(host)) {
      return true;
    }
  }
  return false;
}

function isURL(url, options) {
  (0, _assertString2.default)(url);
  if (!url || url.length >= 2083 || /[\s<>]/.test(url)) {
    return false;
  }
  if (url.indexOf('mailto:') === 0) {
    return false;
  }
  options = (0, _merge2.default)(options, default_url_options);
  var protocol = void 0,
      auth = void 0,
      host = void 0,
      hostname = void 0,
      port = void 0,
      port_str = void 0,
      split = void 0,
      ipv6 = void 0;

  split = url.split('#');
  url = split.shift();

  split = url.split('?');
  url = split.shift();

  split = url.split('://');
  if (split.length > 1) {
    protocol = split.shift();
    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
      return false;
    }
  } else if (options.require_protocol) {
    return false;
  } else if (options.allow_protocol_relative_urls && url.substr(0, 2) === '//') {
    split[0] = url.substr(2);
  }
  url = split.join('://');

  if (url === '') {
    return false;
  }

  split = url.split('/');
  url = split.shift();

  if (url === '' && !options.require_host) {
    return true;
  }

  split = url.split('@');
  if (split.length > 1) {
    auth = split.shift();
    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
      return false;
    }
  }
  hostname = split.join('@');

  port_str = null;
  ipv6 = null;
  var ipv6_match = hostname.match(wrapped_ipv6);
  if (ipv6_match) {
    host = '';
    ipv6 = ipv6_match[1];
    port_str = ipv6_match[2] || null;
  } else {
    split = hostname.split(':');
    host = split.shift();
    if (split.length) {
      port_str = split.join(':');
    }
  }

  if (port_str !== null) {
    port = parseInt(port_str, 10);
    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
      return false;
    }
  }

  if (!(0, _isIP2.default)(host) && !(0, _isFQDN2.default)(host, options) && (!ipv6 || !(0, _isIP2.default)(ipv6, 6))) {
    return false;
  }

  host = host || ipv6;

  if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
    return false;
  }
  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
    return false;
  }

  return true;
}
module.exports = exports['default'];
});

var isURL = unwrapExports(isURL_1);

function url (value, ref) {
  if ( ref === void 0 ) ref = [true];
  var requireProtocol = ref[0];

  var options = { require_protocol: !!requireProtocol, allow_underscores: true };
  if (Array.isArray(value)) {
    return value.every(function (val) { return isURL(val, options); })
  }

  return isURL(value, options)
}

/* eslint-disable camelcase */
var Rules = {
  after: after,
  alpha_dash: validate$1,
  alpha_num: validate$2,
  alpha_spaces: validate$3,
  alpha: validate,
  before: before,
  between: validate$4,
  confirmed: confirmed,
  credit_card: credit_card,
  date_between: date_between,
  date_format: date_format,
  decimal: validate$5,
  digits: validate$6,
  dimensions: dimensions,
  email: validate$7,
  ext: ext,
  image: image,
  in: validate$8,
  integer: integer,
  length: length,
  ip: ip,
  max: max$1,
  max_value: max_value,
  mimes: mimes,
  min: min$1,
  min_value: min_value,
  not_in: validate$9,
  numeric: numeric,
  regex: regex,
  required: required,
  size: size,
  url: url,
}

// 

var normalize = function (fields) {
  if (Array.isArray(fields)) {
    return fields.reduce(function (prev, curr) {
      if (~curr.indexOf('.')) {
        prev[curr.split('.')[1]] = curr;
      } else {
        prev[curr] = curr;
      }

      return prev
    }, {})
  }

  return fields
};

// Combines two flags using either AND or OR depending on the flag type.
var combine = function (lhs, rhs) {
  var mapper = {
    pristine: function (lhs, rhs) { return lhs && rhs; },
    dirty: function (lhs, rhs) { return lhs || rhs; },
    touched: function (lhs, rhs) { return lhs || rhs; },
    untouched: function (lhs, rhs) { return lhs && rhs; },
    valid: function (lhs, rhs) { return lhs && rhs; },
    invalid: function (lhs, rhs) { return lhs || rhs; },
    pending: function (lhs, rhs) { return lhs || rhs; },
    required: function (lhs, rhs) { return lhs || rhs; },
    validated: function (lhs, rhs) { return lhs && rhs; },
  };

  return Object.keys(mapper).reduce(function (flags, flag) {
    flags[flag] = mapper[flag](lhs[flag], rhs[flag]);

    return flags
  }, {})
};

var mapScope = function (scope, deep) {
  if ( deep === void 0 ) deep = true;

  return Object.keys(scope).reduce(function (flags, field) {
    if (!flags) {
      flags = assign({}, scope[field]);
      return flags
    }

    // scope.
    var isScope = field.indexOf('$') === 0;
    if (deep && isScope) {
      return combine(mapScope(scope[field]), flags)
    } else if (!deep && isScope) {
      return flags
    }

    flags = combine(flags, scope[field]);

    return flags
  }, null)
};

/**
 * Maps fields to computed functions.
 */
var mapFields = function (fields) {
  if (!fields) {
    return function () {
      return mapScope(this.$validator.flags)
    }
  }

  var normalized = normalize(fields);
  return Object.keys(normalized).reduce(function (prev, curr) {
    var field = normalized[curr];
    prev[curr] = function mappedField () {
      // if field exists
      if (this.$validator.flags[field]) {
        return this.$validator.flags[field]
      }

      // scopeless fields were selected.
      if (normalized[curr] === '*') {
        return mapScope(this.$validator.flags, false)
      }

      // if it has a scope defined
      var index = field.indexOf('.');
      if (index <= 0) {
        return {}
      }

      var ref = field.split('.');
      var scope = ref[0];
      var name = ref.slice(1);

      scope = this.$validator.flags[("$" + scope)];
      name = name.join('.');

      // an entire scope was selected: scope.*
      if (name === '*' && scope) {
        return mapScope(scope)
      }

      if (scope && scope[name]) {
        return scope[name]
      }

      return {}
    };

    return prev
  }, {})
};

var version = '2.0.3';

var rulesPlugin = function (ref) {
  var Validator$$1 = ref.Validator;

  Object.keys(Rules).forEach(function (rule) {
    Validator$$1.extend(rule, Rules[rule]);
  });

  // Merge the english messages.
  Validator$$1.localize('en', locale);
};

use(rulesPlugin);

/* harmony default export */ __webpack_exports__["default"] = (Validator);



/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getContentStateFragment
 * @format
 * 
 */



var randomizeBlockMapKeys = __webpack_require__(360);
var removeEntitiesAtEdges = __webpack_require__(361);

var getContentStateFragment = function getContentStateFragment(contentState, selectionState) {
  var startKey = selectionState.getStartKey();
  var startOffset = selectionState.getStartOffset();
  var endKey = selectionState.getEndKey();
  var endOffset = selectionState.getEndOffset();

  // Edge entities should be stripped to ensure that we don't preserve
  // invalid partial entities when the fragment is reused. We do, however,
  // preserve entities that are entirely within the selection range.
  var contentWithoutEdgeEntities = removeEntitiesAtEdges(contentState, selectionState);

  var blockMap = contentWithoutEdgeEntities.getBlockMap();
  var blockKeys = blockMap.keySeq();
  var startIndex = blockKeys.indexOf(startKey);
  var endIndex = blockKeys.indexOf(endKey) + 1;

  return randomizeBlockMapKeys(blockMap.slice(startIndex, endIndex).map(function (block, blockKey) {
    var text = block.getText();
    var chars = block.getCharacterList();

    if (startKey === endKey) {
      return block.merge({
        text: text.slice(startOffset, endOffset),
        characterList: chars.slice(startOffset, endOffset)
      });
    }

    if (blockKey === startKey) {
      return block.merge({
        text: text.slice(startOffset),
        characterList: chars.slice(startOffset)
      });
    }

    if (blockKey === endKey) {
      return block.merge({
        text: text.slice(0, endOffset),
        characterList: chars.slice(0, endOffset)
      });
    }

    return block;
  }));
};

module.exports = getContentStateFragment;

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _assign = __webpack_require__(18);

var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftEntity
 * @format
 * 
 */

var DraftEntityInstance = __webpack_require__(365);
var Immutable = __webpack_require__(324);

var invariant = __webpack_require__(10);

var Map = Immutable.Map;


var instances = Map();
var instanceKey = 0;

/**
 * Temporary utility for generating the warnings
 */
function logWarning(oldMethodCall, newMethodCall) {
  console.warn('WARNING: ' + oldMethodCall + ' will be deprecated soon!\nPlease use "' + newMethodCall + '" instead.');
}

/**
 * A "document entity" is an object containing metadata associated with a
 * piece of text in a ContentBlock.
 *
 * For example, a `link` entity might include a `uri` property. When a
 * ContentBlock is rendered in the browser, text that refers to that link
 * entity may be rendered as an anchor, with the `uri` as the href value.
 *
 * In a ContentBlock, every position in the text may correspond to zero
 * or one entities. This correspondence is tracked using a key string,
 * generated via DraftEntity.create() and used to obtain entity metadata
 * via DraftEntity.get().
 */
var DraftEntity = {
  /**
   * WARNING: This method will be deprecated soon!
   * Please use 'contentState.getLastCreatedEntityKey' instead.
   * ---
   * Get the random key string from whatever entity was last created.
   * We need this to support the new API, as part of transitioning to put Entity
   * storage in contentState.
   */
  getLastCreatedEntityKey: function getLastCreatedEntityKey() {
    logWarning('DraftEntity.getLastCreatedEntityKey', 'contentState.getLastCreatedEntityKey');
    return DraftEntity.__getLastCreatedEntityKey();
  },

  /**
   * WARNING: This method will be deprecated soon!
   * Please use 'contentState.createEntity' instead.
   * ---
   * Create a DraftEntityInstance and store it for later retrieval.
   *
   * A random key string will be generated and returned. This key may
   * be used to track the entity's usage in a ContentBlock, and for
   * retrieving data about the entity at render time.
   */
  create: function create(type, mutability, data) {
    logWarning('DraftEntity.create', 'contentState.createEntity');
    return DraftEntity.__create(type, mutability, data);
  },

  /**
   * WARNING: This method will be deprecated soon!
   * Please use 'contentState.addEntity' instead.
   * ---
   * Add an existing DraftEntityInstance to the DraftEntity map. This is
   * useful when restoring instances from the server.
   */
  add: function add(instance) {
    logWarning('DraftEntity.add', 'contentState.addEntity');
    return DraftEntity.__add(instance);
  },

  /**
   * WARNING: This method will be deprecated soon!
   * Please use 'contentState.getEntity' instead.
   * ---
   * Retrieve the entity corresponding to the supplied key string.
   */
  get: function get(key) {
    logWarning('DraftEntity.get', 'contentState.getEntity');
    return DraftEntity.__get(key);
  },

  /**
   * WARNING: This method will be deprecated soon!
   * Please use 'contentState.mergeEntityData' instead.
   * ---
   * Entity instances are immutable. If you need to update the data for an
   * instance, this method will merge your data updates and return a new
   * instance.
   */
  mergeData: function mergeData(key, toMerge) {
    logWarning('DraftEntity.mergeData', 'contentState.mergeEntityData');
    return DraftEntity.__mergeData(key, toMerge);
  },

  /**
   * WARNING: This method will be deprecated soon!
   * Please use 'contentState.replaceEntityData' instead.
   * ---
   * Completely replace the data for a given instance.
   */
  replaceData: function replaceData(key, newData) {
    logWarning('DraftEntity.replaceData', 'contentState.replaceEntityData');
    return DraftEntity.__replaceData(key, newData);
  },

  // ***********************************WARNING******************************
  // --- the above public API will be deprecated in the next version of Draft!
  // The methods below this line are private - don't call them directly.

  /**
   * Get the random key string from whatever entity was last created.
   * We need this to support the new API, as part of transitioning to put Entity
   * storage in contentState.
   */
  __getLastCreatedEntityKey: function __getLastCreatedEntityKey() {
    return '' + instanceKey;
  },

  /**
   * Create a DraftEntityInstance and store it for later retrieval.
   *
   * A random key string will be generated and returned. This key may
   * be used to track the entity's usage in a ContentBlock, and for
   * retrieving data about the entity at render time.
   */
  __create: function __create(type, mutability, data) {
    return DraftEntity.__add(new DraftEntityInstance({ type: type, mutability: mutability, data: data || {} }));
  },

  /**
   * Add an existing DraftEntityInstance to the DraftEntity map. This is
   * useful when restoring instances from the server.
   */
  __add: function __add(instance) {
    var key = '' + ++instanceKey;
    instances = instances.set(key, instance);
    return key;
  },

  /**
   * Retrieve the entity corresponding to the supplied key string.
   */
  __get: function __get(key) {
    var instance = instances.get(key);
    !!!instance ?  true ? invariant(false, 'Unknown DraftEntity key: %s.', key) : invariant(false) : void 0;
    return instance;
  },

  /**
   * Entity instances are immutable. If you need to update the data for an
   * instance, this method will merge your data updates and return a new
   * instance.
   */
  __mergeData: function __mergeData(key, toMerge) {
    var instance = DraftEntity.__get(key);
    var newData = _extends({}, instance.getData(), toMerge);
    var newInstance = instance.set('data', newData);
    instances = instances.set(key, newInstance);
    return newInstance;
  },

  /**
   * Completely replace the data for a given instance.
   */
  __replaceData: function __replaceData(key, newData) {
    var instance = DraftEntity.__get(key);
    var newInstance = instance.set('data', newData);
    instances = instances.set(key, newInstance);
    return newInstance;
  }
};

module.exports = DraftEntity;

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftOffsetKey
 * @format
 * 
 */



var KEY_DELIMITER = '-';

var DraftOffsetKey = {
  encode: function encode(blockKey, decoratorKey, leafKey) {
    return blockKey + KEY_DELIMITER + decoratorKey + KEY_DELIMITER + leafKey;
  },

  decode: function decode(offsetKey) {
    var _offsetKey$split = offsetKey.split(KEY_DELIMITER),
        blockKey = _offsetKey$split[0],
        decoratorKey = _offsetKey$split[1],
        leafKey = _offsetKey$split[2];

    return {
      blockKey: blockKey,
      decoratorKey: parseInt(decoratorKey, 10),
      leafKey: parseInt(leafKey, 10)
    };
  }
};

module.exports = DraftOffsetKey;

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ContentState
 * @format
 * 
 */



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BlockMapBuilder = __webpack_require__(340);
var CharacterMetadata = __webpack_require__(327);
var ContentBlock = __webpack_require__(333);
var ContentBlockNode = __webpack_require__(328);
var DraftEntity = __webpack_require__(346);
var DraftFeatureFlags = __webpack_require__(332);
var Immutable = __webpack_require__(324);
var SelectionState = __webpack_require__(335);

var generateRandomKey = __webpack_require__(331);
var sanitizeDraftText = __webpack_require__(349);

var List = Immutable.List,
    Record = Immutable.Record,
    Repeat = Immutable.Repeat;


var experimentalTreeDataSupport = DraftFeatureFlags.draft_tree_data_support;

var defaultRecord = {
  entityMap: null,
  blockMap: null,
  selectionBefore: null,
  selectionAfter: null
};

var ContentBlockNodeRecord = experimentalTreeDataSupport ? ContentBlockNode : ContentBlock;

var ContentStateRecord = Record(defaultRecord);

var ContentState = function (_ContentStateRecord) {
  _inherits(ContentState, _ContentStateRecord);

  function ContentState() {
    _classCallCheck(this, ContentState);

    return _possibleConstructorReturn(this, _ContentStateRecord.apply(this, arguments));
  }

  ContentState.prototype.getEntityMap = function getEntityMap() {
    // TODO: update this when we fully remove DraftEntity
    return DraftEntity;
  };

  ContentState.prototype.getBlockMap = function getBlockMap() {
    return this.get('blockMap');
  };

  ContentState.prototype.getSelectionBefore = function getSelectionBefore() {
    return this.get('selectionBefore');
  };

  ContentState.prototype.getSelectionAfter = function getSelectionAfter() {
    return this.get('selectionAfter');
  };

  ContentState.prototype.getBlockForKey = function getBlockForKey(key) {
    var block = this.getBlockMap().get(key);
    return block;
  };

  ContentState.prototype.getKeyBefore = function getKeyBefore(key) {
    return this.getBlockMap().reverse().keySeq().skipUntil(function (v) {
      return v === key;
    }).skip(1).first();
  };

  ContentState.prototype.getKeyAfter = function getKeyAfter(key) {
    return this.getBlockMap().keySeq().skipUntil(function (v) {
      return v === key;
    }).skip(1).first();
  };

  ContentState.prototype.getBlockAfter = function getBlockAfter(key) {
    return this.getBlockMap().skipUntil(function (_, k) {
      return k === key;
    }).skip(1).first();
  };

  ContentState.prototype.getBlockBefore = function getBlockBefore(key) {
    return this.getBlockMap().reverse().skipUntil(function (_, k) {
      return k === key;
    }).skip(1).first();
  };

  ContentState.prototype.getBlocksAsArray = function getBlocksAsArray() {
    return this.getBlockMap().toArray();
  };

  ContentState.prototype.getFirstBlock = function getFirstBlock() {
    return this.getBlockMap().first();
  };

  ContentState.prototype.getLastBlock = function getLastBlock() {
    return this.getBlockMap().last();
  };

  ContentState.prototype.getPlainText = function getPlainText(delimiter) {
    return this.getBlockMap().map(function (block) {
      return block ? block.getText() : '';
    }).join(delimiter || '\n');
  };

  ContentState.prototype.getLastCreatedEntityKey = function getLastCreatedEntityKey() {
    // TODO: update this when we fully remove DraftEntity
    return DraftEntity.__getLastCreatedEntityKey();
  };

  ContentState.prototype.hasText = function hasText() {
    var blockMap = this.getBlockMap();
    return blockMap.size > 1 || blockMap.first().getLength() > 0;
  };

  ContentState.prototype.createEntity = function createEntity(type, mutability, data) {
    // TODO: update this when we fully remove DraftEntity
    DraftEntity.__create(type, mutability, data);
    return this;
  };

  ContentState.prototype.mergeEntityData = function mergeEntityData(key, toMerge) {
    // TODO: update this when we fully remove DraftEntity
    DraftEntity.__mergeData(key, toMerge);
    return this;
  };

  ContentState.prototype.replaceEntityData = function replaceEntityData(key, newData) {
    // TODO: update this when we fully remove DraftEntity
    DraftEntity.__replaceData(key, newData);
    return this;
  };

  ContentState.prototype.addEntity = function addEntity(instance) {
    // TODO: update this when we fully remove DraftEntity
    DraftEntity.__add(instance);
    return this;
  };

  ContentState.prototype.getEntity = function getEntity(key) {
    // TODO: update this when we fully remove DraftEntity
    return DraftEntity.__get(key);
  };

  ContentState.createFromBlockArray = function createFromBlockArray(
  // TODO: update flow type when we completely deprecate the old entity API
  blocks, entityMap) {
    // TODO: remove this when we completely deprecate the old entity API
    var theBlocks = Array.isArray(blocks) ? blocks : blocks.contentBlocks;
    var blockMap = BlockMapBuilder.createFromArray(theBlocks);
    var selectionState = blockMap.isEmpty() ? new SelectionState() : SelectionState.createEmpty(blockMap.first().getKey());
    return new ContentState({
      blockMap: blockMap,
      entityMap: entityMap || DraftEntity,
      selectionBefore: selectionState,
      selectionAfter: selectionState
    });
  };

  ContentState.createFromText = function createFromText(text) {
    var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /\r\n?|\n/g;

    var strings = text.split(delimiter);
    var blocks = strings.map(function (block) {
      block = sanitizeDraftText(block);
      return new ContentBlockNodeRecord({
        key: generateRandomKey(),
        text: block,
        type: 'unstyled',
        characterList: List(Repeat(CharacterMetadata.EMPTY, block.length))
      });
    });
    return ContentState.createFromBlockArray(blocks);
  };

  return ContentState;
}(ContentStateRecord);

module.exports = ContentState;

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule sanitizeDraftText
 * @format
 * 
 */



var REGEX_BLOCK_DELIMITER = new RegExp('\r', 'g');

function sanitizeDraftText(input) {
  return input.replace(REGEX_BLOCK_DELIMITER, '');
}

module.exports = sanitizeDraftText;

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/**
 * Constants to represent text directionality
 *
 * Also defines a *global* direciton, to be used in bidi algorithms as a
 * default fallback direciton, when no better direction is found or provided.
 *
 * NOTE: Use `setGlobalDir()`, or update `initGlobalDir()`, to set the initial
 *       global direction value based on the application.
 *
 * Part of the implementation of Unicode Bidirectional Algorithm (UBA)
 * Unicode Standard Annex #9 (UAX9)
 * http://www.unicode.org/reports/tr9/
 */



var invariant = __webpack_require__(10);

var NEUTRAL = 'NEUTRAL'; // No strong direction
var LTR = 'LTR'; // Left-to-Right direction
var RTL = 'RTL'; // Right-to-Left direction

var globalDir = null;

// == Helpers ==

/**
 * Check if a directionality value is a Strong one
 */
function isStrong(dir) {
  return dir === LTR || dir === RTL;
}

/**
 * Get string value to be used for `dir` HTML attribute or `direction` CSS
 * property.
 */
function getHTMLDir(dir) {
  !isStrong(dir) ?  true ? invariant(false, '`dir` must be a strong direction to be converted to HTML Direction') : invariant(false) : void 0;
  return dir === LTR ? 'ltr' : 'rtl';
}

/**
 * Get string value to be used for `dir` HTML attribute or `direction` CSS
 * property, but returns null if `dir` has same value as `otherDir`.
 * `null`.
 */
function getHTMLDirIfDifferent(dir, otherDir) {
  !isStrong(dir) ?  true ? invariant(false, '`dir` must be a strong direction to be converted to HTML Direction') : invariant(false) : void 0;
  !isStrong(otherDir) ?  true ? invariant(false, '`otherDir` must be a strong direction to be converted to HTML Direction') : invariant(false) : void 0;
  return dir === otherDir ? null : getHTMLDir(dir);
}

// == Global Direction ==

/**
 * Set the global direction.
 */
function setGlobalDir(dir) {
  globalDir = dir;
}

/**
 * Initialize the global direction
 */
function initGlobalDir() {
  setGlobalDir(LTR);
}

/**
 * Get the global direction
 */
function getGlobalDir() {
  if (!globalDir) {
    this.initGlobalDir();
  }
  !globalDir ?  true ? invariant(false, 'Global direction not set.') : invariant(false) : void 0;
  return globalDir;
}

var UnicodeBidiDirection = {
  // Values
  NEUTRAL: NEUTRAL,
  LTR: LTR,
  RTL: RTL,
  // Helpers
  isStrong: isStrong,
  getHTMLDir: getHTMLDir,
  getHTMLDirIfDifferent: getHTMLDirIfDifferent,
  // Global Direction
  setGlobalDir: setGlobalDir,
  initGlobalDir: initGlobalDir,
  getGlobalDir: getGlobalDir
};

module.exports = UnicodeBidiDirection;

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DefaultDraftBlockRenderMap
 * @format
 * 
 */



var _require = __webpack_require__(324),
    Map = _require.Map;

var React = __webpack_require__(1);

var cx = __webpack_require__(336);

var UL_WRAP = React.createElement('ul', { className: cx('public/DraftStyleDefault/ul') });
var OL_WRAP = React.createElement('ol', { className: cx('public/DraftStyleDefault/ol') });
var PRE_WRAP = React.createElement('pre', { className: cx('public/DraftStyleDefault/pre') });

var DefaultDraftBlockRenderMap = Map({
  'header-one': {
    element: 'h1'
  },
  'header-two': {
    element: 'h2'
  },
  'header-three': {
    element: 'h3'
  },
  'header-four': {
    element: 'h4'
  },
  'header-five': {
    element: 'h5'
  },
  'header-six': {
    element: 'h6'
  },
  'unordered-list-item': {
    element: 'li',
    wrapper: UL_WRAP
  },
  'ordered-list-item': {
    element: 'li',
    wrapper: OL_WRAP
  },
  blockquote: {
    element: 'blockquote'
  },
  atomic: {
    element: 'figure'
  },
  'code-block': {
    element: 'pre',
    wrapper: PRE_WRAP
  },
  unstyled: {
    element: 'div',
    aliasedElements: ['p']
  }
});

module.exports = DefaultDraftBlockRenderMap;

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

module.exports = {
  BACKSPACE: 8,
  TAB: 9,
  RETURN: 13,
  ALT: 18,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  DELETE: 46,
  COMMA: 188,
  PERIOD: 190,
  A: 65,
  Z: 90,
  ZERO: 48,
  NUMPAD_0: 96,
  NUMPAD_9: 105
};

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEntityKeyForSelection
 * @format
 * 
 */



/**
 * Return the entity key that should be used when inserting text for the
 * specified target selection, only if the entity is `MUTABLE`. `IMMUTABLE`
 * and `SEGMENTED` entities should not be used for insertion behavior.
 */
function getEntityKeyForSelection(contentState, targetSelection) {
  var entityKey;

  if (targetSelection.isCollapsed()) {
    var key = targetSelection.getAnchorKey();
    var offset = targetSelection.getAnchorOffset();
    if (offset > 0) {
      entityKey = contentState.getBlockForKey(key).getEntityAt(offset - 1);
      if (entityKey !== contentState.getBlockForKey(key).getEntityAt(offset)) {
        return null;
      }
      return filterKey(contentState.getEntityMap(), entityKey);
    }
    return null;
  }

  var startKey = targetSelection.getStartKey();
  var startOffset = targetSelection.getStartOffset();
  var startBlock = contentState.getBlockForKey(startKey);

  entityKey = startOffset === startBlock.getLength() ? null : startBlock.getEntityAt(startOffset);

  return filterKey(contentState.getEntityMap(), entityKey);
}

/**
 * Determine whether an entity key corresponds to a `MUTABLE` entity. If so,
 * return it. If not, return null.
 */
function filterKey(entityMap, entityKey) {
  if (entityKey) {
    var entity = entityMap.__get(entityKey);
    return entity.getMutability() === 'MUTABLE' ? entityKey : null;
  }
  return null;
}

module.exports = getEntityKeyForSelection;

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var getStyleProperty = __webpack_require__(420);

/**
 * @param {DOMNode} element [description]
 * @param {string} name Overflow style property name.
 * @return {boolean} True if the supplied ndoe is scrollable.
 */
function _isNodeScrollable(element, name) {
  var overflow = Style.get(element, name);
  return overflow === 'auto' || overflow === 'scroll';
}

/**
 * Utilities for querying and mutating style properties.
 */
var Style = {
  /**
   * Gets the style property for the supplied node. This will return either the
   * computed style, if available, or the declared style.
   *
   * @param {DOMNode} node
   * @param {string} name Style property name.
   * @return {?string} Style property value.
   */
  get: getStyleProperty,

  /**
   * Determines the nearest ancestor of a node that is scrollable.
   *
   * NOTE: This can be expensive if used repeatedly or on a node nested deeply.
   *
   * @param {?DOMNode} node Node from which to start searching.
   * @return {?DOMWindow|DOMElement} Scroll parent of the supplied node.
   */
  getScrollParent: function getScrollParent(node) {
    if (!node) {
      return null;
    }
    var ownerDocument = node.ownerDocument;
    while (node && node !== ownerDocument.body) {
      if (_isNodeScrollable(node, 'overflow') || _isNodeScrollable(node, 'overflowY') || _isNodeScrollable(node, 'overflowX')) {
        return node;
      }
      node = node.parentNode;
    }
    return ownerDocument.defaultView || ownerDocument.parentWindow;
  }

};

module.exports = Style;

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var getDocumentScrollElement = __webpack_require__(423);
var getUnboundedScrollPosition = __webpack_require__(424);

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are bounded. This means that if the scroll position is
 * negative or exceeds the element boundaries (which is possible using inertial
 * scrolling), you will get zero or the maximum scroll position, respectively.
 *
 * If you need the unbound scroll position, use `getUnboundedScrollPosition`.
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */
function getScrollPosition(scrollable) {
  var documentScrollElement = getDocumentScrollElement(scrollable.ownerDocument || scrollable.document);
  if (scrollable.Window && scrollable instanceof scrollable.Window) {
    scrollable = documentScrollElement;
  }
  var scrollPosition = getUnboundedScrollPosition(scrollable);

  var viewport = scrollable === documentScrollElement ? scrollable.ownerDocument.documentElement : scrollable;

  var xMax = scrollable.scrollWidth - viewport.clientWidth;
  var yMax = scrollable.scrollHeight - viewport.clientHeight;

  scrollPosition.x = Math.max(0, Math.min(scrollPosition.x, xMax));
  scrollPosition.y = Math.max(0, Math.min(scrollPosition.y, yMax));

  return scrollPosition;
}

module.exports = getScrollPosition;

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule findAncestorOffsetKey
 * @format
 * 
 */



var getSelectionOffsetKeyForNode = __webpack_require__(372);

/**
 * Get the key from the node's nearest offset-aware ancestor.
 */
function findAncestorOffsetKey(node) {
  var searchNode = node;
  while (searchNode && searchNode !== document.documentElement) {
    var key = getSelectionOffsetKeyForNode(searchNode);
    if (key != null) {
      return key;
    }
    searchNode = searchNode.parentNode;
  }
  return null;
}

module.exports = findAncestorOffsetKey;

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule KeyBindingUtil
 * @format
 * 
 */



var UserAgent = __webpack_require__(330);

var isOSX = UserAgent.isPlatform('Mac OS X');

var KeyBindingUtil = {
  /**
   * Check whether the ctrlKey modifier is *not* being used in conjunction with
   * the altKey modifier. If they are combined, the result is an `altGraph`
   * key modifier, which should not be handled by this set of key bindings.
   */
  isCtrlKeyCommand: function isCtrlKeyCommand(e) {
    return !!e.ctrlKey && !e.altKey;
  },

  isOptionKeyCommand: function isOptionKeyCommand(e) {
    return isOSX && e.altKey;
  },

  hasCommandModifier: function hasCommandModifier(e) {
    return isOSX ? !!e.metaKey && !e.altKey : KeyBindingUtil.isCtrlKeyCommand(e);
  }
};

module.exports = KeyBindingUtil;

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule moveSelectionBackward
 * @format
 * 
 */



/**
 * Given a collapsed selection, move the focus `maxDistance` backward within
 * the selected block. If the selection will go beyond the start of the block,
 * move focus to the end of the previous block, but no further.
 *
 * This function is not Unicode-aware, so surrogate pairs will be treated
 * as having length 2.
 */
function moveSelectionBackward(editorState, maxDistance) {
  var selection = editorState.getSelection();
  var content = editorState.getCurrentContent();
  var key = selection.getStartKey();
  var offset = selection.getStartOffset();

  var focusKey = key;
  var focusOffset = 0;

  if (maxDistance > offset) {
    var keyBefore = content.getKeyBefore(key);
    if (keyBefore == null) {
      focusKey = key;
    } else {
      focusKey = keyBefore;
      var blockBefore = content.getBlockForKey(keyBefore);
      focusOffset = blockBefore.getText().length;
    }
  } else {
    focusOffset = offset - maxDistance;
  }

  return selection.merge({
    focusKey: focusKey,
    focusOffset: focusOffset,
    isBackward: true
  });
}

module.exports = moveSelectionBackward;

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Draft
 * @format
 * 
 */



var AtomicBlockUtils = __webpack_require__(389);
var BlockMapBuilder = __webpack_require__(340);
var CharacterMetadata = __webpack_require__(327);
var CompositeDraftDecorator = __webpack_require__(405);
var ContentBlock = __webpack_require__(333);
var ContentState = __webpack_require__(348);
var DefaultDraftBlockRenderMap = __webpack_require__(351);
var DefaultDraftInlineStyle = __webpack_require__(367);
var DraftEditor = __webpack_require__(406);
var DraftEditorBlock = __webpack_require__(369);
var DraftEntity = __webpack_require__(346);
var DraftModifier = __webpack_require__(326);
var DraftEntityInstance = __webpack_require__(365);
var EditorState = __webpack_require__(325);
var KeyBindingUtil = __webpack_require__(357);
var RichTextEditorUtil = __webpack_require__(382);
var SelectionState = __webpack_require__(335);

var convertFromDraftStateToRaw = __webpack_require__(464);
var convertFromHTMLToContentBlocks = __webpack_require__(380);
var convertFromRawToDraftState = __webpack_require__(467);
var generateRandomKey = __webpack_require__(331);
var getDefaultKeyBinding = __webpack_require__(383);
var getVisibleSelectionRect = __webpack_require__(472);

var DraftPublic = {
  Editor: DraftEditor,
  EditorBlock: DraftEditorBlock,
  EditorState: EditorState,

  CompositeDecorator: CompositeDraftDecorator,
  Entity: DraftEntity,
  EntityInstance: DraftEntityInstance,

  BlockMapBuilder: BlockMapBuilder,
  CharacterMetadata: CharacterMetadata,
  ContentBlock: ContentBlock,
  ContentState: ContentState,
  SelectionState: SelectionState,

  AtomicBlockUtils: AtomicBlockUtils,
  KeyBindingUtil: KeyBindingUtil,
  Modifier: DraftModifier,
  RichUtils: RichTextEditorUtil,

  DefaultDraftBlockRenderMap: DefaultDraftBlockRenderMap,
  DefaultDraftInlineStyle: DefaultDraftInlineStyle,

  convertFromHTML: convertFromHTMLToContentBlocks,
  convertFromRaw: convertFromRawToDraftState,
  convertToRaw: convertFromDraftStateToRaw,
  genKey: generateRandomKey,
  getDefaultKeyBinding: getDefaultKeyBinding,
  getVisibleSelectionRect: getVisibleSelectionRect
};

module.exports = DraftPublic;

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule randomizeBlockMapKeys
 * @format
 * 
 */



var ContentBlockNode = __webpack_require__(328);
var Immutable = __webpack_require__(324);

var generateRandomKey = __webpack_require__(331);

var OrderedMap = Immutable.OrderedMap;


var randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys(blockMap) {
  var newKeysRef = {};

  // we keep track of root blocks in order to update subsequent sibling links
  var lastRootBlock = void 0;

  return OrderedMap(blockMap.withMutations(function (blockMapState) {
    blockMapState.forEach(function (block, index) {
      var oldKey = block.getKey();
      var nextKey = block.getNextSiblingKey();
      var prevKey = block.getPrevSiblingKey();
      var childrenKeys = block.getChildKeys();
      var parentKey = block.getParentKey();

      // new key that we will use to build linking
      var key = generateRandomKey();

      // we will add it here to re-use it later
      newKeysRef[oldKey] = key;

      if (nextKey) {
        var nextBlock = blockMapState.get(nextKey);
        if (nextBlock) {
          blockMapState.setIn([nextKey, 'prevSibling'], key);
        } else {
          // this can happen when generating random keys for fragments
          blockMapState.setIn([oldKey, 'nextSibling'], null);
        }
      }

      if (prevKey) {
        var prevBlock = blockMapState.get(prevKey);
        if (prevBlock) {
          blockMapState.setIn([prevKey, 'nextSibling'], key);
        } else {
          // this can happen when generating random keys for fragments
          blockMapState.setIn([oldKey, 'prevSibling'], null);
        }
      }

      if (parentKey && blockMapState.get(parentKey)) {
        var parentBlock = blockMapState.get(parentKey);
        var parentChildrenList = parentBlock.getChildKeys();
        blockMapState.setIn([parentKey, 'children'], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));
      } else {
        // blocks will then be treated as root block nodes
        blockMapState.setIn([oldKey, 'parent'], null);

        if (lastRootBlock) {
          blockMapState.setIn([lastRootBlock.getKey(), 'nextSibling'], key);
          blockMapState.setIn([oldKey, 'prevSibling'], newKeysRef[lastRootBlock.getKey()]);
        }

        lastRootBlock = blockMapState.get(oldKey);
      }

      childrenKeys.forEach(function (childKey) {
        var childBlock = blockMapState.get(childKey);
        if (childBlock) {
          blockMapState.setIn([childKey, 'parent'], key);
        } else {
          blockMapState.setIn([oldKey, 'children'], block.getChildKeys().filter(function (child) {
            return child !== childKey;
          }));
        }
      });
    });
  }).toArray().map(function (block) {
    return [newKeysRef[block.getKey()], block.set('key', newKeysRef[block.getKey()])];
  }));
};

var randomizeContentBlockKeys = function randomizeContentBlockKeys(blockMap) {
  return OrderedMap(blockMap.toArray().map(function (block) {
    var key = generateRandomKey();
    return [key, block.set('key', key)];
  }));
};

var randomizeBlockMapKeys = function randomizeBlockMapKeys(blockMap) {
  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;

  if (!isTreeBasedBlockMap) {
    return randomizeContentBlockKeys(blockMap);
  }

  return randomizeContentBlockNodeKeys(blockMap);
};

module.exports = randomizeBlockMapKeys;

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule removeEntitiesAtEdges
 * @format
 * 
 */



var CharacterMetadata = __webpack_require__(327);

var findRangesImmutable = __webpack_require__(341);
var invariant = __webpack_require__(10);

function removeEntitiesAtEdges(contentState, selectionState) {
  var blockMap = contentState.getBlockMap();
  var entityMap = contentState.getEntityMap();

  var updatedBlocks = {};

  var startKey = selectionState.getStartKey();
  var startOffset = selectionState.getStartOffset();
  var startBlock = blockMap.get(startKey);
  var updatedStart = removeForBlock(entityMap, startBlock, startOffset);

  if (updatedStart !== startBlock) {
    updatedBlocks[startKey] = updatedStart;
  }

  var endKey = selectionState.getEndKey();
  var endOffset = selectionState.getEndOffset();
  var endBlock = blockMap.get(endKey);
  if (startKey === endKey) {
    endBlock = updatedStart;
  }

  var updatedEnd = removeForBlock(entityMap, endBlock, endOffset);

  if (updatedEnd !== endBlock) {
    updatedBlocks[endKey] = updatedEnd;
  }

  if (!Object.keys(updatedBlocks).length) {
    return contentState.set('selectionAfter', selectionState);
  }

  return contentState.merge({
    blockMap: blockMap.merge(updatedBlocks),
    selectionAfter: selectionState
  });
}

function getRemovalRange(characters, key, offset) {
  var removalRange;
  findRangesImmutable(characters, function (a, b) {
    return a.getEntity() === b.getEntity();
  }, function (element) {
    return element.getEntity() === key;
  }, function (start, end) {
    if (start <= offset && end >= offset) {
      removalRange = { start: start, end: end };
    }
  });
  !(typeof removalRange === 'object') ?  true ? invariant(false, 'Removal range must exist within character list.') : invariant(false) : void 0;
  return removalRange;
}

function removeForBlock(entityMap, block, offset) {
  var chars = block.getCharacterList();
  var charBefore = offset > 0 ? chars.get(offset - 1) : undefined;
  var charAfter = offset < chars.count() ? chars.get(offset) : undefined;
  var entityBeforeCursor = charBefore ? charBefore.getEntity() : undefined;
  var entityAfterCursor = charAfter ? charAfter.getEntity() : undefined;

  if (entityAfterCursor && entityAfterCursor === entityBeforeCursor) {
    var entity = entityMap.__get(entityAfterCursor);
    if (entity.getMutability() !== 'MUTABLE') {
      var _getRemovalRange = getRemovalRange(chars, entityAfterCursor, offset),
          start = _getRemovalRange.start,
          end = _getRemovalRange.end;

      var current;
      while (start < end) {
        current = chars.get(start);
        chars = chars.set(start, CharacterMetadata.applyEntity(current, null));
        start++;
      }
      return block.set('characterList', chars);
    }
  }

  return block;
}

module.exports = removeEntitiesAtEdges;

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule insertIntoList
 * @format
 * 
 */



/**
 * Maintain persistence for target list when appending and prepending.
 */
function insertIntoList(targetList, toInsert, offset) {
  if (offset === targetList.count()) {
    toInsert.forEach(function (c) {
      targetList = targetList.push(c);
    });
  } else if (offset === 0) {
    toInsert.reverse().forEach(function (c) {
      targetList = targetList.unshift(c);
    });
  } else {
    var head = targetList.slice(0, offset);
    var tail = targetList.slice(offset);
    targetList = head.concat(toInsert, tail).toList();
  }
  return targetList;
}

module.exports = insertIntoList;

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getNextDelimiterBlockKey
 * @format
 * 
 *
 * This is unstable and not part of the public API and should not be used by
 * production systems. This file may be update/removed without notice.
 */

var ContentBlockNode = __webpack_require__(328);

var getNextDelimiterBlockKey = function getNextDelimiterBlockKey(block, blockMap) {
  var isExperimentalTreeBlock = block instanceof ContentBlockNode;

  if (!isExperimentalTreeBlock) {
    return null;
  }

  var nextSiblingKey = block.getNextSiblingKey();

  if (nextSiblingKey) {
    return nextSiblingKey;
  }

  var parent = block.getParentKey();

  if (!parent) {
    return null;
  }

  var nextNonDescendantBlock = blockMap.get(parent);
  while (nextNonDescendantBlock && !nextNonDescendantBlock.getNextSiblingKey()) {
    var parentKey = nextNonDescendantBlock.getParentKey();
    nextNonDescendantBlock = parentKey ? blockMap.get(parentKey) : null;
  }

  if (!nextNonDescendantBlock) {
    return null;
  }

  return nextNonDescendantBlock.getNextSiblingKey();
};

module.exports = getNextDelimiterBlockKey;

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule BlockTree
 * @format
 * 
 */



var Immutable = __webpack_require__(324);

var emptyFunction = __webpack_require__(12);
var findRangesImmutable = __webpack_require__(341);

var List = Immutable.List,
    Repeat = Immutable.Repeat,
    Record = Immutable.Record;


var returnTrue = emptyFunction.thatReturnsTrue;

var FINGERPRINT_DELIMITER = '-';

var defaultLeafRange = {
  start: null,
  end: null
};

var LeafRange = Record(defaultLeafRange);

var defaultDecoratorRange = {
  start: null,
  end: null,
  decoratorKey: null,
  leaves: null
};

var DecoratorRange = Record(defaultDecoratorRange);

var BlockTree = {
  /**
   * Generate a block tree for a given ContentBlock/decorator pair.
   */
  generate: function generate(contentState, block, decorator) {
    var textLength = block.getLength();
    if (!textLength) {
      return List.of(new DecoratorRange({
        start: 0,
        end: 0,
        decoratorKey: null,
        leaves: List.of(new LeafRange({ start: 0, end: 0 }))
      }));
    }

    var leafSets = [];
    var decorations = decorator ? decorator.getDecorations(block, contentState) : List(Repeat(null, textLength));

    var chars = block.getCharacterList();

    findRangesImmutable(decorations, areEqual, returnTrue, function (start, end) {
      leafSets.push(new DecoratorRange({
        start: start,
        end: end,
        decoratorKey: decorations.get(start),
        leaves: generateLeaves(chars.slice(start, end).toList(), start)
      }));
    });

    return List(leafSets);
  },

  /**
   * Create a string representation of the given tree map. This allows us
   * to rapidly determine whether a tree has undergone a significant
   * structural change.
   */
  getFingerprint: function getFingerprint(tree) {
    return tree.map(function (leafSet) {
      var decoratorKey = leafSet.get('decoratorKey');
      var fingerprintString = decoratorKey !== null ? decoratorKey + '.' + (leafSet.get('end') - leafSet.get('start')) : '';
      return '' + fingerprintString + '.' + leafSet.get('leaves').size;
    }).join(FINGERPRINT_DELIMITER);
  }
};

/**
 * Generate LeafRange records for a given character list.
 */
function generateLeaves(characters, offset) {
  var leaves = [];
  var inlineStyles = characters.map(function (c) {
    return c.getStyle();
  }).toList();
  findRangesImmutable(inlineStyles, areEqual, returnTrue, function (start, end) {
    leaves.push(new LeafRange({
      start: start + offset,
      end: end + offset
    }));
  });
  return List(leaves);
}

function areEqual(a, b) {
  return a === b;
}

module.exports = BlockTree;

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftEntityInstance
 * @legacyServerCallableInstance
 * @format
 * 
 */



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Immutable = __webpack_require__(324);

var Record = Immutable.Record;


var DraftEntityInstanceRecord = Record({
  type: 'TOKEN',
  mutability: 'IMMUTABLE',
  data: Object
});

/**
 * An instance of a document entity, consisting of a `type` and relevant
 * `data`, metadata about the entity.
 *
 * For instance, a "link" entity might provide a URI, and a "mention"
 * entity might provide the mentioned user's ID. These pieces of data
 * may be used when rendering the entity as part of a ContentBlock DOM
 * representation. For a link, the data would be used as an href for
 * the rendered anchor. For a mention, the ID could be used to retrieve
 * a hovercard.
 */

var DraftEntityInstance = function (_DraftEntityInstanceR) {
  _inherits(DraftEntityInstance, _DraftEntityInstanceR);

  function DraftEntityInstance() {
    _classCallCheck(this, DraftEntityInstance);

    return _possibleConstructorReturn(this, _DraftEntityInstanceR.apply(this, arguments));
  }

  DraftEntityInstance.prototype.getType = function getType() {
    return this.get('type');
  };

  DraftEntityInstance.prototype.getMutability = function getMutability() {
    return this.get('mutability');
  };

  DraftEntityInstance.prototype.getData = function getData() {
    return this.get('data');
  };

  return DraftEntityInstance;
}(DraftEntityInstanceRecord);

module.exports = DraftEntityInstance;

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/**
 * Basic (stateless) API for text direction detection
 *
 * Part of our implementation of Unicode Bidirectional Algorithm (UBA)
 * Unicode Standard Annex #9 (UAX9)
 * http://www.unicode.org/reports/tr9/
 */



var UnicodeBidiDirection = __webpack_require__(350);

var invariant = __webpack_require__(10);

/**
 * RegExp ranges of characters with a *Strong* Bidi_Class value.
 *
 * Data is based on DerivedBidiClass.txt in UCD version 7.0.0.
 *
 * NOTE: For performance reasons, we only support Unicode's
 *       Basic Multilingual Plane (BMP) for now.
 */
var RANGE_BY_BIDI_TYPE = {

  L: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u01BA\u01BB' + '\u01BC-\u01BF\u01C0-\u01C3\u01C4-\u0293\u0294\u0295-\u02AF\u02B0-\u02B8' + '\u02BB-\u02C1\u02D0-\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376-\u0377' + '\u037A\u037B-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1' + '\u03A3-\u03F5\u03F7-\u0481\u0482\u048A-\u052F\u0531-\u0556\u0559' + '\u055A-\u055F\u0561-\u0587\u0589\u0903\u0904-\u0939\u093B\u093D' + '\u093E-\u0940\u0949-\u094C\u094E-\u094F\u0950\u0958-\u0961\u0964-\u0965' + '\u0966-\u096F\u0970\u0971\u0972-\u0980\u0982-\u0983\u0985-\u098C' + '\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD' + '\u09BE-\u09C0\u09C7-\u09C8\u09CB-\u09CC\u09CE\u09D7\u09DC-\u09DD' + '\u09DF-\u09E1\u09E6-\u09EF\u09F0-\u09F1\u09F4-\u09F9\u09FA\u0A03' + '\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33' + '\u0A35-\u0A36\u0A38-\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F' + '\u0A72-\u0A74\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0' + '\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0ABE-\u0AC0\u0AC9\u0ACB-\u0ACC\u0AD0' + '\u0AE0-\u0AE1\u0AE6-\u0AEF\u0AF0\u0B02-\u0B03\u0B05-\u0B0C\u0B0F-\u0B10' + '\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40' + '\u0B47-\u0B48\u0B4B-\u0B4C\u0B57\u0B5C-\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F' + '\u0B70\u0B71\u0B72-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95' + '\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9' + '\u0BBE-\u0BBF\u0BC1-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7' + '\u0BE6-\u0BEF\u0BF0-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10' + '\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C59\u0C60-\u0C61' + '\u0C66-\u0C6F\u0C7F\u0C82-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8' + '\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CBE\u0CBF\u0CC0-\u0CC4\u0CC6' + '\u0CC7-\u0CC8\u0CCA-\u0CCB\u0CD5-\u0CD6\u0CDE\u0CE0-\u0CE1\u0CE6-\u0CEF' + '\u0CF1-\u0CF2\u0D02-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D' + '\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D57\u0D60-\u0D61' + '\u0D66-\u0D6F\u0D70-\u0D75\u0D79\u0D7A-\u0D7F\u0D82-\u0D83\u0D85-\u0D96' + '\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF' + '\u0DE6-\u0DEF\u0DF2-\u0DF3\u0DF4\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E45' + '\u0E46\u0E4F\u0E50-\u0E59\u0E5A-\u0E5B\u0E81-\u0E82\u0E84\u0E87-\u0E88' + '\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7' + '\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6' + '\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F01-\u0F03\u0F04-\u0F12\u0F13\u0F14' + '\u0F15-\u0F17\u0F1A-\u0F1F\u0F20-\u0F29\u0F2A-\u0F33\u0F34\u0F36\u0F38' + '\u0F3E-\u0F3F\u0F40-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C' + '\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FCF\u0FD0-\u0FD4\u0FD5-\u0FD8' + '\u0FD9-\u0FDA\u1000-\u102A\u102B-\u102C\u1031\u1038\u103B-\u103C\u103F' + '\u1040-\u1049\u104A-\u104F\u1050-\u1055\u1056-\u1057\u105A-\u105D\u1061' + '\u1062-\u1064\u1065-\u1066\u1067-\u106D\u106E-\u1070\u1075-\u1081' + '\u1083-\u1084\u1087-\u108C\u108E\u108F\u1090-\u1099\u109A-\u109C' + '\u109E-\u109F\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FB\u10FC' + '\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288' + '\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5' + '\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u1368' + '\u1369-\u137C\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166D-\u166E' + '\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EB-\u16ED\u16EE-\u16F0' + '\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1735-\u1736' + '\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5' + '\u17C7-\u17C8\u17D4-\u17D6\u17D7\u17D8-\u17DA\u17DC\u17E0-\u17E9' + '\u1810-\u1819\u1820-\u1842\u1843\u1844-\u1877\u1880-\u18A8\u18AA' + '\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930-\u1931' + '\u1933-\u1938\u1946-\u194F\u1950-\u196D\u1970-\u1974\u1980-\u19AB' + '\u19B0-\u19C0\u19C1-\u19C7\u19C8-\u19C9\u19D0-\u19D9\u19DA\u1A00-\u1A16' + '\u1A19-\u1A1A\u1A1E-\u1A1F\u1A20-\u1A54\u1A55\u1A57\u1A61\u1A63-\u1A64' + '\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AA6\u1AA7\u1AA8-\u1AAD' + '\u1B04\u1B05-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B44\u1B45-\u1B4B' + '\u1B50-\u1B59\u1B5A-\u1B60\u1B61-\u1B6A\u1B74-\u1B7C\u1B82\u1B83-\u1BA0' + '\u1BA1\u1BA6-\u1BA7\u1BAA\u1BAE-\u1BAF\u1BB0-\u1BB9\u1BBA-\u1BE5\u1BE7' + '\u1BEA-\u1BEC\u1BEE\u1BF2-\u1BF3\u1BFC-\u1BFF\u1C00-\u1C23\u1C24-\u1C2B' + '\u1C34-\u1C35\u1C3B-\u1C3F\u1C40-\u1C49\u1C4D-\u1C4F\u1C50-\u1C59' + '\u1C5A-\u1C77\u1C78-\u1C7D\u1C7E-\u1C7F\u1CC0-\u1CC7\u1CD3\u1CE1' + '\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF2-\u1CF3\u1CF5-\u1CF6\u1D00-\u1D2B' + '\u1D2C-\u1D6A\u1D6B-\u1D77\u1D78\u1D79-\u1D9A\u1D9B-\u1DBF\u1E00-\u1F15' + '\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D' + '\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC' + '\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E' + '\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D' + '\u2124\u2126\u2128\u212A-\u212D\u212F-\u2134\u2135-\u2138\u2139' + '\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2182\u2183-\u2184' + '\u2185-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF' + '\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2C7B\u2C7C-\u2C7D\u2C7E-\u2CE4' + '\u2CEB-\u2CEE\u2CF2-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F' + '\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE' + '\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005\u3006\u3007' + '\u3021-\u3029\u302E-\u302F\u3031-\u3035\u3038-\u303A\u303B\u303C' + '\u3041-\u3096\u309D-\u309E\u309F\u30A1-\u30FA\u30FC-\u30FE\u30FF' + '\u3105-\u312D\u3131-\u318E\u3190-\u3191\u3192-\u3195\u3196-\u319F' + '\u31A0-\u31BA\u31F0-\u31FF\u3200-\u321C\u3220-\u3229\u322A-\u3247' + '\u3248-\u324F\u3260-\u327B\u327F\u3280-\u3289\u328A-\u32B0\u32C0-\u32CB' + '\u32D0-\u32FE\u3300-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DB5' + '\u4E00-\u9FCC\uA000-\uA014\uA015\uA016-\uA48C\uA4D0-\uA4F7\uA4F8-\uA4FD' + '\uA4FE-\uA4FF\uA500-\uA60B\uA60C\uA610-\uA61F\uA620-\uA629\uA62A-\uA62B' + '\uA640-\uA66D\uA66E\uA680-\uA69B\uA69C-\uA69D\uA6A0-\uA6E5\uA6E6-\uA6EF' + '\uA6F2-\uA6F7\uA722-\uA76F\uA770\uA771-\uA787\uA789-\uA78A\uA78B-\uA78E' + '\uA790-\uA7AD\uA7B0-\uA7B1\uA7F7\uA7F8-\uA7F9\uA7FA\uA7FB-\uA801' + '\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA823-\uA824\uA827\uA830-\uA835' + '\uA836-\uA837\uA840-\uA873\uA880-\uA881\uA882-\uA8B3\uA8B4-\uA8C3' + '\uA8CE-\uA8CF\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8F8-\uA8FA\uA8FB\uA900-\uA909' + '\uA90A-\uA925\uA92E-\uA92F\uA930-\uA946\uA952-\uA953\uA95F\uA960-\uA97C' + '\uA983\uA984-\uA9B2\uA9B4-\uA9B5\uA9BA-\uA9BB\uA9BD-\uA9C0\uA9C1-\uA9CD' + '\uA9CF\uA9D0-\uA9D9\uA9DE-\uA9DF\uA9E0-\uA9E4\uA9E6\uA9E7-\uA9EF' + '\uA9F0-\uA9F9\uA9FA-\uA9FE\uAA00-\uAA28\uAA2F-\uAA30\uAA33-\uAA34' + '\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA5F\uAA60-\uAA6F' + '\uAA70\uAA71-\uAA76\uAA77-\uAA79\uAA7A\uAA7B\uAA7D\uAA7E-\uAAAF\uAAB1' + '\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADC\uAADD\uAADE-\uAADF' + '\uAAE0-\uAAEA\uAAEB\uAAEE-\uAAEF\uAAF0-\uAAF1\uAAF2\uAAF3-\uAAF4\uAAF5' + '\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E' + '\uAB30-\uAB5A\uAB5B\uAB5C-\uAB5F\uAB64-\uAB65\uABC0-\uABE2\uABE3-\uABE4' + '\uABE6-\uABE7\uABE9-\uABEA\uABEB\uABEC\uABF0-\uABF9\uAC00-\uD7A3' + '\uD7B0-\uD7C6\uD7CB-\uD7FB\uE000-\uF8FF\uF900-\uFA6D\uFA70-\uFAD9' + '\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFF6F\uFF70' + '\uFF71-\uFF9D\uFF9E-\uFF9F\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF' + '\uFFD2-\uFFD7\uFFDA-\uFFDC',

  R: '\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05D0-\u05EA\u05EB-\u05EF' + '\u05F0-\u05F2\u05F3-\u05F4\u05F5-\u05FF\u07C0-\u07C9\u07CA-\u07EA' + '\u07F4-\u07F5\u07FA\u07FB-\u07FF\u0800-\u0815\u081A\u0824\u0828' + '\u082E-\u082F\u0830-\u083E\u083F\u0840-\u0858\u085C-\u085D\u085E' + '\u085F-\u089F\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB37\uFB38-\uFB3C' + '\uFB3D\uFB3E\uFB3F\uFB40-\uFB41\uFB42\uFB43-\uFB44\uFB45\uFB46-\uFB4F',

  AL: '\u0608\u060B\u060D\u061B\u061C\u061D\u061E-\u061F\u0620-\u063F\u0640' + '\u0641-\u064A\u066D\u066E-\u066F\u0671-\u06D3\u06D4\u06D5\u06E5-\u06E6' + '\u06EE-\u06EF\u06FA-\u06FC\u06FD-\u06FE\u06FF\u0700-\u070D\u070E\u070F' + '\u0710\u0712-\u072F\u074B-\u074C\u074D-\u07A5\u07B1\u07B2-\u07BF' + '\u08A0-\u08B2\u08B3-\u08E3\uFB50-\uFBB1\uFBB2-\uFBC1\uFBC2-\uFBD2' + '\uFBD3-\uFD3D\uFD40-\uFD4F\uFD50-\uFD8F\uFD90-\uFD91\uFD92-\uFDC7' + '\uFDC8-\uFDCF\uFDF0-\uFDFB\uFDFC\uFDFE-\uFDFF\uFE70-\uFE74\uFE75' + '\uFE76-\uFEFC\uFEFD-\uFEFE'

};

var REGEX_STRONG = new RegExp('[' + RANGE_BY_BIDI_TYPE.L + RANGE_BY_BIDI_TYPE.R + RANGE_BY_BIDI_TYPE.AL + ']');

var REGEX_RTL = new RegExp('[' + RANGE_BY_BIDI_TYPE.R + RANGE_BY_BIDI_TYPE.AL + ']');

/**
 * Returns the first strong character (has Bidi_Class value of L, R, or AL).
 *
 * @param str  A text block; e.g. paragraph, table cell, tag
 * @return     A character with strong bidi direction, or null if not found
 */
function firstStrongChar(str) {
  var match = REGEX_STRONG.exec(str);
  return match == null ? null : match[0];
}

/**
 * Returns the direction of a block of text, based on the direction of its
 * first strong character (has Bidi_Class value of L, R, or AL).
 *
 * @param str  A text block; e.g. paragraph, table cell, tag
 * @return     The resolved direction
 */
function firstStrongCharDir(str) {
  var strongChar = firstStrongChar(str);
  if (strongChar == null) {
    return UnicodeBidiDirection.NEUTRAL;
  }
  return REGEX_RTL.exec(strongChar) ? UnicodeBidiDirection.RTL : UnicodeBidiDirection.LTR;
}

/**
 * Returns the direction of a block of text, based on the direction of its
 * first strong character (has Bidi_Class value of L, R, or AL), or a fallback
 * direction, if no strong character is found.
 *
 * This function is supposed to be used in respect to Higher-Level Protocol
 * rule HL1. (http://www.unicode.org/reports/tr9/#HL1)
 *
 * @param str       A text block; e.g. paragraph, table cell, tag
 * @param fallback  Fallback direction, used if no strong direction detected
 *                  for the block (default = NEUTRAL)
 * @return          The resolved direction
 */
function resolveBlockDir(str, fallback) {
  fallback = fallback || UnicodeBidiDirection.NEUTRAL;
  if (!str.length) {
    return fallback;
  }
  var blockDir = firstStrongCharDir(str);
  return blockDir === UnicodeBidiDirection.NEUTRAL ? fallback : blockDir;
}

/**
 * Returns the direction of a block of text, based on the direction of its
 * first strong character (has Bidi_Class value of L, R, or AL), or a fallback
 * direction, if no strong character is found.
 *
 * NOTE: This function is similar to resolveBlockDir(), but uses the global
 * direction as the fallback, so it *always* returns a Strong direction,
 * making it useful for integration in places that you need to make the final
 * decision, like setting some CSS class.
 *
 * This function is supposed to be used in respect to Higher-Level Protocol
 * rule HL1. (http://www.unicode.org/reports/tr9/#HL1)
 *
 * @param str             A text block; e.g. paragraph, table cell
 * @param strongFallback  Fallback direction, used if no strong direction
 *                        detected for the block (default = global direction)
 * @return                The resolved Strong direction
 */
function getDirection(str, strongFallback) {
  if (!strongFallback) {
    strongFallback = UnicodeBidiDirection.getGlobalDir();
  }
  !UnicodeBidiDirection.isStrong(strongFallback) ?  true ? invariant(false, 'Fallback direction must be a strong direction') : invariant(false) : void 0;
  return resolveBlockDir(str, strongFallback);
}

/**
 * Returns true if getDirection(arguments...) returns LTR.
 *
 * @param str             A text block; e.g. paragraph, table cell
 * @param strongFallback  Fallback direction, used if no strong direction
 *                        detected for the block (default = global direction)
 * @return                True if the resolved direction is LTR
 */
function isDirectionLTR(str, strongFallback) {
  return getDirection(str, strongFallback) === UnicodeBidiDirection.LTR;
}

/**
 * Returns true if getDirection(arguments...) returns RTL.
 *
 * @param str             A text block; e.g. paragraph, table cell
 * @param strongFallback  Fallback direction, used if no strong direction
 *                        detected for the block (default = global direction)
 * @return                True if the resolved direction is RTL
 */
function isDirectionRTL(str, strongFallback) {
  return getDirection(str, strongFallback) === UnicodeBidiDirection.RTL;
}

var UnicodeBidi = {
  firstStrongChar: firstStrongChar,
  firstStrongCharDir: firstStrongCharDir,
  resolveBlockDir: resolveBlockDir,
  getDirection: getDirection,
  isDirectionLTR: isDirectionLTR,
  isDirectionRTL: isDirectionRTL
};

module.exports = UnicodeBidi;

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DefaultDraftInlineStyle
 * @format
 * 
 */



module.exports = {
  BOLD: {
    fontWeight: 'bold'
  },

  CODE: {
    fontFamily: 'monospace',
    wordWrap: 'break-word'
  },

  ITALIC: {
    fontStyle: 'italic'
  },

  STRIKETHROUGH: {
    textDecoration: 'line-through'
  },

  UNDERLINE: {
    textDecoration: 'underline'
  }
};

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isSelectionAtLeafStart
 * @format
 * 
 */



function isSelectionAtLeafStart(editorState) {
  var selection = editorState.getSelection();
  var anchorKey = selection.getAnchorKey();
  var blockTree = editorState.getBlockTree(anchorKey);
  var offset = selection.getStartOffset();

  var isAtStart = false;

  blockTree.some(function (leafSet) {
    if (offset === leafSet.get('start')) {
      isAtStart = true;
      return true;
    }

    if (offset < leafSet.get('end')) {
      return leafSet.get('leaves').some(function (leaf) {
        var leafStart = leaf.get('start');
        if (offset === leafStart) {
          isAtStart = true;
          return true;
        }

        return false;
      });
    }

    return false;
  });

  return isAtStart;
}

module.exports = isSelectionAtLeafStart;

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftEditorBlock.react
 * @format
 * 
 */



var _assign = __webpack_require__(18);

var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DraftEditorLeaf = __webpack_require__(410);
var DraftOffsetKey = __webpack_require__(347);
var React = __webpack_require__(1);
var ReactDOM = __webpack_require__(32);
var Scroll = __webpack_require__(370);
var Style = __webpack_require__(354);
var UnicodeBidi = __webpack_require__(366);
var UnicodeBidiDirection = __webpack_require__(350);

var cx = __webpack_require__(336);
var getElementPosition = __webpack_require__(421);
var getScrollPosition = __webpack_require__(355);
var getViewportDimensions = __webpack_require__(425);
var invariant = __webpack_require__(10);
var nullthrows = __webpack_require__(329);

var SCROLL_BUFFER = 10;

/**
 * Return whether a block overlaps with either edge of the `SelectionState`.
 */
var isBlockOnSelectionEdge = function isBlockOnSelectionEdge(selection, key) {
  return selection.getAnchorKey() === key || selection.getFocusKey() === key;
};

/**
 * The default block renderer for a `DraftEditor` component.
 *
 * A `DraftEditorBlock` is able to render a given `ContentBlock` to its
 * appropriate decorator and inline style components.
 */

var DraftEditorBlock = function (_React$Component) {
  _inherits(DraftEditorBlock, _React$Component);

  function DraftEditorBlock() {
    _classCallCheck(this, DraftEditorBlock);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  DraftEditorBlock.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    return this.props.block !== nextProps.block || this.props.tree !== nextProps.tree || this.props.direction !== nextProps.direction || isBlockOnSelectionEdge(nextProps.selection, nextProps.block.getKey()) && nextProps.forceSelection;
  };

  /**
   * When a block is mounted and overlaps the selection state, we need to make
   * sure that the cursor is visible to match native behavior. This may not
   * be the case if the user has pressed `RETURN` or pasted some content, since
   * programatically creating these new blocks and setting the DOM selection
   * will miss out on the browser natively scrolling to that position.
   *
   * To replicate native behavior, if the block overlaps the selection state
   * on mount, force the scroll position. Check the scroll state of the scroll
   * parent, and adjust it to align the entire block to the bottom of the
   * scroll parent.
   */


  DraftEditorBlock.prototype.componentDidMount = function componentDidMount() {
    var selection = this.props.selection;
    var endKey = selection.getEndKey();
    if (!selection.getHasFocus() || endKey !== this.props.block.getKey()) {
      return;
    }

    var blockNode = ReactDOM.findDOMNode(this);
    var scrollParent = Style.getScrollParent(blockNode);
    var scrollPosition = getScrollPosition(scrollParent);
    var scrollDelta = void 0;

    if (scrollParent === window) {
      var nodePosition = getElementPosition(blockNode);
      var nodeBottom = nodePosition.y + nodePosition.height;
      var viewportHeight = getViewportDimensions().height;
      scrollDelta = nodeBottom - viewportHeight;
      if (scrollDelta > 0) {
        window.scrollTo(scrollPosition.x, scrollPosition.y + scrollDelta + SCROLL_BUFFER);
      }
    } else {
      !(blockNode instanceof HTMLElement) ?  true ? invariant(false, 'blockNode is not an HTMLElement') : invariant(false) : void 0;
      var blockBottom = blockNode.offsetHeight + blockNode.offsetTop;
      var scrollBottom = scrollParent.offsetHeight + scrollPosition.y;
      scrollDelta = blockBottom - scrollBottom;
      if (scrollDelta > 0) {
        Scroll.setTop(scrollParent, Scroll.getTop(scrollParent) + scrollDelta + SCROLL_BUFFER);
      }
    }
  };

  DraftEditorBlock.prototype._renderChildren = function _renderChildren() {
    var _this2 = this;

    var block = this.props.block;
    var blockKey = block.getKey();
    var text = block.getText();
    var lastLeafSet = this.props.tree.size - 1;
    var hasSelection = isBlockOnSelectionEdge(this.props.selection, blockKey);

    return this.props.tree.map(function (leafSet, ii) {
      var leavesForLeafSet = leafSet.get('leaves');
      var lastLeaf = leavesForLeafSet.size - 1;
      var leaves = leavesForLeafSet.map(function (leaf, jj) {
        var offsetKey = DraftOffsetKey.encode(blockKey, ii, jj);
        var start = leaf.get('start');
        var end = leaf.get('end');
        return React.createElement(DraftEditorLeaf, {
          key: offsetKey,
          offsetKey: offsetKey,
          block: block,
          start: start,
          selection: hasSelection ? _this2.props.selection : null,
          forceSelection: _this2.props.forceSelection,
          text: text.slice(start, end),
          styleSet: block.getInlineStyleAt(start),
          customStyleMap: _this2.props.customStyleMap,
          customStyleFn: _this2.props.customStyleFn,
          isLast: ii === lastLeafSet && jj === lastLeaf
        });
      }).toArray();

      var decoratorKey = leafSet.get('decoratorKey');
      if (decoratorKey == null) {
        return leaves;
      }

      if (!_this2.props.decorator) {
        return leaves;
      }

      var decorator = nullthrows(_this2.props.decorator);

      var DecoratorComponent = decorator.getComponentForKey(decoratorKey);
      if (!DecoratorComponent) {
        return leaves;
      }

      var decoratorProps = decorator.getPropsForKey(decoratorKey);
      var decoratorOffsetKey = DraftOffsetKey.encode(blockKey, ii, 0);
      var decoratedText = text.slice(leavesForLeafSet.first().get('start'), leavesForLeafSet.last().get('end'));

      // Resetting dir to the same value on a child node makes Chrome/Firefox
      // confused on cursor movement. See http://jsfiddle.net/d157kLck/3/
      var dir = UnicodeBidiDirection.getHTMLDirIfDifferent(UnicodeBidi.getDirection(decoratedText), _this2.props.direction);

      return React.createElement(
        DecoratorComponent,
        _extends({}, decoratorProps, {
          contentState: _this2.props.contentState,
          decoratedText: decoratedText,
          dir: dir,
          key: decoratorOffsetKey,
          entityKey: block.getEntityAt(leafSet.get('start')),
          offsetKey: decoratorOffsetKey }),
        leaves
      );
    }).toArray();
  };

  DraftEditorBlock.prototype.render = function render() {
    var _props = this.props,
        direction = _props.direction,
        offsetKey = _props.offsetKey;

    var className = cx({
      'public/DraftStyleDefault/block': true,
      'public/DraftStyleDefault/ltr': direction === 'LTR',
      'public/DraftStyleDefault/rtl': direction === 'RTL'
    });

    return React.createElement(
      'div',
      { 'data-offset-key': offsetKey, className: className },
      this._renderChildren()
    );
  };

  return DraftEditorBlock;
}(React.Component);

module.exports = DraftEditorBlock;

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * @param {DOMElement} element
 * @param {DOMDocument} doc
 * @return {boolean}
 */
function _isViewportScrollElement(element, doc) {
  return !!doc && (element === doc.documentElement || element === doc.body);
}

/**
 * Scroll Module. This class contains 4 simple static functions
 * to be used to access Element.scrollTop/scrollLeft properties.
 * To solve the inconsistencies between browsers when either
 * document.body or document.documentElement is supplied,
 * below logic will be used to alleviate the issue:
 *
 * 1. If 'element' is either 'document.body' or 'document.documentElement,
 *    get whichever element's 'scroll{Top,Left}' is larger.
 * 2. If 'element' is either 'document.body' or 'document.documentElement',
 *    set the 'scroll{Top,Left}' on both elements.
 */

var Scroll = {
  /**
   * @param {DOMElement} element
   * @return {number}
   */
  getTop: function getTop(element) {
    var doc = element.ownerDocument;
    return _isViewportScrollElement(element, doc) ?
    // In practice, they will either both have the same value,
    // or one will be zero and the other will be the scroll position
    // of the viewport. So we can use `X || Y` instead of `Math.max(X, Y)`
    doc.body.scrollTop || doc.documentElement.scrollTop : element.scrollTop;
  },

  /**
   * @param {DOMElement} element
   * @param {number} newTop
   */
  setTop: function setTop(element, newTop) {
    var doc = element.ownerDocument;
    if (_isViewportScrollElement(element, doc)) {
      doc.body.scrollTop = doc.documentElement.scrollTop = newTop;
    } else {
      element.scrollTop = newTop;
    }
  },

  /**
   * @param {DOMElement} element
   * @return {number}
   */
  getLeft: function getLeft(element) {
    var doc = element.ownerDocument;
    return _isViewportScrollElement(element, doc) ? doc.body.scrollLeft || doc.documentElement.scrollLeft : element.scrollLeft;
  },

  /**
   * @param {DOMElement} element
   * @param {number} newLeft
   */
  setLeft: function setLeft(element, newLeft) {
    var doc = element.ownerDocument;
    if (_isViewportScrollElement(element, doc)) {
      doc.body.scrollLeft = doc.documentElement.scrollLeft = newLeft;
    } else {
      element.scrollLeft = newLeft;
    }
  }
};

module.exports = Scroll;

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var PhotosMimeType = __webpack_require__(428);

var createArrayFromMixed = __webpack_require__(429);
var emptyFunction = __webpack_require__(12);

var CR_LF_REGEX = new RegExp('\r\n', 'g');
var LF_ONLY = '\n';

var RICH_TEXT_TYPES = {
  'text/rtf': 1,
  'text/html': 1
};

/**
 * If DataTransferItem is a file then return the Blob of data.
 *
 * @param {object} item
 * @return {?blob}
 */
function getFileFromDataTransfer(item) {
  if (item.kind == 'file') {
    return item.getAsFile();
  }
}

var DataTransfer = function () {
  /**
   * @param {object} data
   */
  function DataTransfer(data) {
    _classCallCheck(this, DataTransfer);

    this.data = data;

    // Types could be DOMStringList or array
    this.types = data.types ? createArrayFromMixed(data.types) : [];
  }

  /**
   * Is this likely to be a rich text data transfer?
   *
   * @return {boolean}
   */


  DataTransfer.prototype.isRichText = function isRichText() {
    // If HTML is available, treat this data as rich text. This way, we avoid
    // using a pasted image if it is packaged with HTML -- this may occur with
    // pastes from MS Word, for example.  However this is only rich text if
    // there's accompanying text.
    if (this.getHTML() && this.getText()) {
      return true;
    }

    // When an image is copied from a preview window, you end up with two
    // DataTransferItems one of which is a file's metadata as text.  Skip those.
    if (this.isImage()) {
      return false;
    }

    return this.types.some(function (type) {
      return RICH_TEXT_TYPES[type];
    });
  };

  /**
   * Get raw text.
   *
   * @return {?string}
   */


  DataTransfer.prototype.getText = function getText() {
    var text;
    if (this.data.getData) {
      if (!this.types.length) {
        text = this.data.getData('Text');
      } else if (this.types.indexOf('text/plain') != -1) {
        text = this.data.getData('text/plain');
      }
    }
    return text ? text.replace(CR_LF_REGEX, LF_ONLY) : null;
  };

  /**
   * Get HTML paste data
   *
   * @return {?string}
   */


  DataTransfer.prototype.getHTML = function getHTML() {
    if (this.data.getData) {
      if (!this.types.length) {
        return this.data.getData('Text');
      } else if (this.types.indexOf('text/html') != -1) {
        return this.data.getData('text/html');
      }
    }
  };

  /**
   * Is this a link data transfer?
   *
   * @return {boolean}
   */


  DataTransfer.prototype.isLink = function isLink() {
    return this.types.some(function (type) {
      return type.indexOf('Url') != -1 || type.indexOf('text/uri-list') != -1 || type.indexOf('text/x-moz-url');
    });
  };

  /**
   * Get a link url.
   *
   * @return {?string}
   */


  DataTransfer.prototype.getLink = function getLink() {
    if (this.data.getData) {
      if (this.types.indexOf('text/x-moz-url') != -1) {
        var url = this.data.getData('text/x-moz-url').split('\n');
        return url[0];
      }
      return this.types.indexOf('text/uri-list') != -1 ? this.data.getData('text/uri-list') : this.data.getData('url');
    }

    return null;
  };

  /**
   * Is this an image data transfer?
   *
   * @return {boolean}
   */


  DataTransfer.prototype.isImage = function isImage() {
    var isImage = this.types.some(function (type) {
      // Firefox will have a type of application/x-moz-file for images during
      // dragging
      return type.indexOf('application/x-moz-file') != -1;
    });

    if (isImage) {
      return true;
    }

    var items = this.getFiles();
    for (var i = 0; i < items.length; i++) {
      var type = items[i].type;
      if (!PhotosMimeType.isImage(type)) {
        return false;
      }
    }

    return true;
  };

  DataTransfer.prototype.getCount = function getCount() {
    if (this.data.hasOwnProperty('items')) {
      return this.data.items.length;
    } else if (this.data.hasOwnProperty('mozItemCount')) {
      return this.data.mozItemCount;
    } else if (this.data.files) {
      return this.data.files.length;
    }
    return null;
  };

  /**
   * Get files.
   *
   * @return {array}
   */


  DataTransfer.prototype.getFiles = function getFiles() {
    if (this.data.items) {
      // createArrayFromMixed doesn't properly handle DataTransferItemLists.
      return Array.prototype.slice.call(this.data.items).map(getFileFromDataTransfer).filter(emptyFunction.thatReturnsArgument);
    } else if (this.data.files) {
      return Array.prototype.slice.call(this.data.files);
    } else {
      return [];
    }
  };

  /**
   * Are there any files to fetch?
   *
   * @return {boolean}
   */


  DataTransfer.prototype.hasFiles = function hasFiles() {
    return this.getFiles().length > 0;
  };

  return DataTransfer;
}();

module.exports = DataTransfer;

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getSelectionOffsetKeyForNode
 * @format
 * 
 */



/**
 * Get offset key from a node or it's child nodes. Return the first offset key
 * found on the DOM tree of given node.
 */

function getSelectionOffsetKeyForNode(node) {
  if (node instanceof Element) {
    var offsetKey = node.getAttribute('data-offset-key');
    if (offsetKey) {
      return offsetKey;
    }
    for (var ii = 0; ii < node.childNodes.length; ii++) {
      var childOffsetKey = getSelectionOffsetKeyForNode(node.childNodes[ii]);
      if (childOffsetKey) {
        return childOffsetKey;
      }
    }
  }
  return null;
}

module.exports = getSelectionOffsetKeyForNode;

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getTextContentFromFiles
 * @format
 * 
 */



var invariant = __webpack_require__(10);

var TEXT_CLIPPING_REGEX = /\.textClipping$/;

var TEXT_TYPES = {
  'text/plain': true,
  'text/html': true,
  'text/rtf': true
};

// Somewhat arbitrary upper bound on text size. Let's not lock up the browser.
var TEXT_SIZE_UPPER_BOUND = 5000;

/**
 * Extract the text content from a file list.
 */
function getTextContentFromFiles(files, callback) {
  var readCount = 0;
  var results = [];
  files.forEach(function ( /*blob*/file) {
    readFile(file, function ( /*string*/text) {
      readCount++;
      text && results.push(text.slice(0, TEXT_SIZE_UPPER_BOUND));
      if (readCount == files.length) {
        callback(results.join('\r'));
      }
    });
  });
}

/**
 * todo isaac: Do work to turn html/rtf into a content fragment.
 */
function readFile(file, callback) {
  if (!global.FileReader || file.type && !(file.type in TEXT_TYPES)) {
    callback('');
    return;
  }

  if (file.type === '') {
    var contents = '';
    // Special-case text clippings, which have an empty type but include
    // `.textClipping` in the file name. `readAsText` results in an empty
    // string for text clippings, so we force the file name to serve
    // as the text value for the file.
    if (TEXT_CLIPPING_REGEX.test(file.name)) {
      contents = file.name.replace(TEXT_CLIPPING_REGEX, '');
    }
    callback(contents);
    return;
  }

  var reader = new FileReader();
  reader.onload = function () {
    var result = reader.result;
    !(typeof result === 'string') ?  true ? invariant(false, 'We should be calling "FileReader.readAsText" which returns a string') : invariant(false) : void 0;
    callback(result);
  };
  reader.onerror = function () {
    callback('');
  };
  reader.readAsText(file);
}

module.exports = getTextContentFromFiles;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getUpdatedSelectionState
 * @format
 * 
 */



var DraftOffsetKey = __webpack_require__(347);

var nullthrows = __webpack_require__(329);

function getUpdatedSelectionState(editorState, anchorKey, anchorOffset, focusKey, focusOffset) {
  var selection = nullthrows(editorState.getSelection());
  if (true) {
    if (!anchorKey || !focusKey) {
      /*eslint-disable no-console */
      console.warn('Invalid selection state.', arguments, editorState.toJS());
      /*eslint-enable no-console */
      return selection;
    }
  }

  var anchorPath = DraftOffsetKey.decode(anchorKey);
  var anchorBlockKey = anchorPath.blockKey;
  var anchorLeaf = editorState.getBlockTree(anchorBlockKey).getIn([anchorPath.decoratorKey, 'leaves', anchorPath.leafKey]);

  var focusPath = DraftOffsetKey.decode(focusKey);
  var focusBlockKey = focusPath.blockKey;
  var focusLeaf = editorState.getBlockTree(focusBlockKey).getIn([focusPath.decoratorKey, 'leaves', focusPath.leafKey]);

  var anchorLeafStart = anchorLeaf.get('start');
  var focusLeafStart = focusLeaf.get('start');

  var anchorBlockOffset = anchorLeaf ? anchorLeafStart + anchorOffset : null;
  var focusBlockOffset = focusLeaf ? focusLeafStart + focusOffset : null;

  var areEqual = selection.getAnchorKey() === anchorBlockKey && selection.getAnchorOffset() === anchorBlockOffset && selection.getFocusKey() === focusBlockKey && selection.getFocusOffset() === focusBlockOffset;

  if (areEqual) {
    return selection;
  }

  var isBackward = false;
  if (anchorBlockKey === focusBlockKey) {
    var anchorLeafEnd = anchorLeaf.get('end');
    var focusLeafEnd = focusLeaf.get('end');
    if (focusLeafStart === anchorLeafStart && focusLeafEnd === anchorLeafEnd) {
      isBackward = focusOffset < anchorOffset;
    } else {
      isBackward = focusLeafStart < anchorLeafStart;
    }
  } else {
    var startKey = editorState.getCurrentContent().getBlockMap().keySeq().skipUntil(function (v) {
      return v === anchorBlockKey || v === focusBlockKey;
    }).first();
    isBackward = startKey === focusBlockKey;
  }

  return selection.merge({
    anchorKey: anchorBlockKey,
    anchorOffset: anchorBlockOffset,
    focusKey: focusBlockKey,
    focusOffset: focusBlockOffset,
    isBackward: isBackward
  });
}

module.exports = getUpdatedSelectionState;

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getFragmentFromSelection
 * @format
 * 
 */



var getContentStateFragment = __webpack_require__(345);

function getFragmentFromSelection(editorState) {
  var selectionState = editorState.getSelection();

  if (selectionState.isCollapsed()) {
    return null;
  }

  return getContentStateFragment(editorState.getCurrentContent(), selectionState);
}

module.exports = getFragmentFromSelection;

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getRangeClientRects
 * @format
 * 
 */



var UserAgent = __webpack_require__(330);

var invariant = __webpack_require__(10);

var isChrome = UserAgent.isBrowser('Chrome');

// In Chrome, the client rects will include the entire bounds of all nodes that
// begin (have a start tag) within the selection, even if the selection does
// not overlap the entire node. To resolve this, we split the range at each
// start tag and join the client rects together.
// https://code.google.com/p/chromium/issues/detail?id=324437
/* eslint-disable consistent-return */
function getRangeClientRectsChrome(range) {
  var tempRange = range.cloneRange();
  var clientRects = [];

  for (var ancestor = range.endContainer; ancestor != null; ancestor = ancestor.parentNode) {
    // If we've climbed up to the common ancestor, we can now use the
    // original start point and stop climbing the tree.
    var atCommonAncestor = ancestor === range.commonAncestorContainer;
    if (atCommonAncestor) {
      tempRange.setStart(range.startContainer, range.startOffset);
    } else {
      tempRange.setStart(tempRange.endContainer, 0);
    }
    var rects = Array.from(tempRange.getClientRects());
    clientRects.push(rects);
    if (atCommonAncestor) {
      var _ref;

      clientRects.reverse();
      return (_ref = []).concat.apply(_ref, clientRects);
    }
    tempRange.setEndBefore(ancestor);
  }

   true ?  true ? invariant(false, 'Found an unexpected detached subtree when getting range client rects.') : invariant(false) : void 0;
}
/* eslint-enable consistent-return */

/**
 * Like range.getClientRects() but normalizes for browser bugs.
 */
var getRangeClientRects = isChrome ? getRangeClientRectsChrome : function (range) {
  return Array.from(range.getClientRects());
};

module.exports = getRangeClientRects;

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getDraftEditorSelectionWithNodes
 * @format
 * 
 */



var findAncestorOffsetKey = __webpack_require__(356);
var getSelectionOffsetKeyForNode = __webpack_require__(372);
var getUpdatedSelectionState = __webpack_require__(374);
var invariant = __webpack_require__(10);
var nullthrows = __webpack_require__(329);

/**
 * Convert the current selection range to an anchor/focus pair of offset keys
 * and values that can be interpreted by components.
 */
function getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {
  var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;
  var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE;

  // If the selection range lies only on text nodes, the task is simple.
  // Find the nearest offset-aware elements and use the
  // offset values supplied by the selection range.
  if (anchorIsTextNode && focusIsTextNode) {
    return {
      selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),
      needsRecovery: false
    };
  }

  var anchorPoint = null;
  var focusPoint = null;
  var needsRecovery = true;

  // An element is selected. Convert this selection range into leaf offset
  // keys and offset values for consumption at the component level. This
  // is common in Firefox, where select-all and triple click behavior leads
  // to entire elements being selected.
  //
  // Note that we use the `needsRecovery` parameter in the callback here. This
  // is because when certain elements are selected, the behavior for subsequent
  // cursor movement (e.g. via arrow keys) is uncertain and may not match
  // expectations at the component level. For example, if an entire <div> is
  // selected and the user presses the right arrow, Firefox keeps the selection
  // on the <div>. If we allow subsequent keypresses to insert characters
  // natively, they will be inserted into a browser-created text node to the
  // right of that <div>. This is obviously undesirable.
  //
  // With the `needsRecovery` flag, we inform the caller that it is responsible
  // for manually setting the selection state on the rendered document to
  // ensure proper selection state maintenance.

  if (anchorIsTextNode) {
    anchorPoint = {
      key: nullthrows(findAncestorOffsetKey(anchorNode)),
      offset: anchorOffset
    };
    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);
  } else if (focusIsTextNode) {
    focusPoint = {
      key: nullthrows(findAncestorOffsetKey(focusNode)),
      offset: focusOffset
    };
    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);
  } else {
    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);
    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);

    // If the selection is collapsed on an empty block, don't force recovery.
    // This way, on arrow key selection changes, the browser can move the
    // cursor from a non-zero offset on one block, through empty blocks,
    // to a matching non-zero offset on other text blocks.
    if (anchorNode === focusNode && anchorOffset === focusOffset) {
      needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== 'BR';
    }
  }

  return {
    selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),
    needsRecovery: needsRecovery
  };
}

/**
 * Identify the first leaf descendant for the given node.
 */
function getFirstLeaf(node) {
  while (node.firstChild && (
  // data-blocks has no offset
  node.firstChild instanceof Element && node.firstChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.firstChild))) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Identify the last leaf descendant for the given node.
 */
function getLastLeaf(node) {
  while (node.lastChild && (
  // data-blocks has no offset
  node.lastChild instanceof Element && node.lastChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.lastChild))) {
    node = node.lastChild;
  }
  return node;
}

function getPointForNonTextNode(editorRoot, startNode, childOffset) {
  var node = startNode;
  var offsetKey = findAncestorOffsetKey(node);

  !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ?  true ? invariant(false, 'Unknown node in selection range.') : invariant(false) : void 0;

  // If the editorRoot is the selection, step downward into the content
  // wrapper.
  if (editorRoot === node) {
    node = node.firstChild;
    !(node instanceof Element && node.getAttribute('data-contents') === 'true') ?  true ? invariant(false, 'Invalid DraftEditorContents structure.') : invariant(false) : void 0;
    if (childOffset > 0) {
      childOffset = node.childNodes.length;
    }
  }

  // If the child offset is zero and we have an offset key, we're done.
  // If there's no offset key because the entire editor is selected,
  // find the leftmost ("first") leaf in the tree and use that as the offset
  // key.
  if (childOffset === 0) {
    var key = null;
    if (offsetKey != null) {
      key = offsetKey;
    } else {
      var firstLeaf = getFirstLeaf(node);
      key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));
    }
    return { key: key, offset: 0 };
  }

  var nodeBeforeCursor = node.childNodes[childOffset - 1];
  var leafKey = null;
  var textLength = null;

  if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {
    // Our target node may be a leaf or a text node, in which case we're
    // already where we want to be and can just use the child's length as
    // our offset.
    leafKey = nullthrows(offsetKey);
    textLength = getTextContentLength(nodeBeforeCursor);
  } else {
    // Otherwise, we'll look at the child to the left of the cursor and find
    // the last leaf node in its subtree.
    var lastLeaf = getLastLeaf(nodeBeforeCursor);
    leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));
    textLength = getTextContentLength(lastLeaf);
  }

  return {
    key: leafKey,
    offset: textLength
  };
}

/**
 * Return the length of a node's textContent, regarding single newline
 * characters as zero-length. This allows us to avoid problems with identifying
 * the correct selection offset for empty blocks in IE, in which we
 * render newlines instead of break tags.
 */
function getTextContentLength(node) {
  var textContent = node.textContent;
  return textContent === '\n' ? 0 : textContent.length;
}

module.exports = getDraftEditorSelectionWithNodes;

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftRemovableWord
 * @format
 * 
 */



var TokenizeUtil = __webpack_require__(447);

var punctuation = TokenizeUtil.getPunctuation();

// The apostrophe and curly single quotes behave in a curious way: when
// surrounded on both sides by word characters, they behave as word chars; when
// either neighbor is punctuation or an end of the string, they behave as
// punctuation.
var CHAMELEON_CHARS = '[\'\u2018\u2019]';

// Remove the underscore, which should count as part of the removable word. The
// "chameleon chars" also count as punctuation in this regex.
var WHITESPACE_AND_PUNCTUATION = '\\s|(?![_])' + punctuation;

var DELETE_STRING = '^' + '(?:' + WHITESPACE_AND_PUNCTUATION + ')*' + '(?:' + CHAMELEON_CHARS + '|(?!' + WHITESPACE_AND_PUNCTUATION + ').)*' + '(?:(?!' + WHITESPACE_AND_PUNCTUATION + ').)';
var DELETE_REGEX = new RegExp(DELETE_STRING);

var BACKSPACE_STRING = '(?:(?!' + WHITESPACE_AND_PUNCTUATION + ').)' + '(?:' + CHAMELEON_CHARS + '|(?!' + WHITESPACE_AND_PUNCTUATION + ').)*' + '(?:' + WHITESPACE_AND_PUNCTUATION + ')*' + '$';
var BACKSPACE_REGEX = new RegExp(BACKSPACE_STRING);

function getRemovableWord(text, isBackward) {
  var matches = isBackward ? BACKSPACE_REGEX.exec(text) : DELETE_REGEX.exec(text);
  return matches ? matches[0] : text;
}

var DraftRemovableWord = {
  getBackward: function getBackward(text) {
    return getRemovableWord(text, true);
  },

  getForward: function getForward(text) {
    return getRemovableWord(text, false);
  }
};

module.exports = DraftRemovableWord;

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule moveSelectionForward
 * @format
 * 
 */



/**
 * Given a collapsed selection, move the focus `maxDistance` forward within
 * the selected block. If the selection will go beyond the end of the block,
 * move focus to the start of the next block, but no further.
 *
 * This function is not Unicode-aware, so surrogate pairs will be treated
 * as having length 2.
 */
function moveSelectionForward(editorState, maxDistance) {
  var selection = editorState.getSelection();
  var key = selection.getStartKey();
  var offset = selection.getStartOffset();
  var content = editorState.getCurrentContent();

  var focusKey = key;
  var focusOffset;

  var block = content.getBlockForKey(key);

  if (maxDistance > block.getText().length - offset) {
    focusKey = content.getKeyAfter(key);
    focusOffset = 0;
  } else {
    focusOffset = offset + maxDistance;
  }

  return selection.merge({ focusKey: focusKey, focusOffset: focusOffset });
}

module.exports = moveSelectionForward;

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule convertFromHTMLToContentBlocks
 * @format
 * 
 */



var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _knownListItemDepthCl,
    _assign = __webpack_require__(18);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var CharacterMetadata = __webpack_require__(327);
var ContentBlock = __webpack_require__(333);
var ContentBlockNode = __webpack_require__(328);
var DefaultDraftBlockRenderMap = __webpack_require__(351);
var DraftEntity = __webpack_require__(346);
var DraftFeatureFlags = __webpack_require__(332);
var Immutable = __webpack_require__(324);

var _require = __webpack_require__(324),
    Set = _require.Set;

var URI = __webpack_require__(458);

var cx = __webpack_require__(336);
var generateRandomKey = __webpack_require__(331);
var getSafeBodyFromHTML = __webpack_require__(381);
var invariant = __webpack_require__(10);
var sanitizeDraftText = __webpack_require__(349);

var experimentalTreeDataSupport = DraftFeatureFlags.draft_tree_data_support;

var List = Immutable.List,
    OrderedSet = Immutable.OrderedSet;


var NBSP = '&nbsp;';
var SPACE = ' ';

// Arbitrary max indent
var MAX_DEPTH = 4;

// used for replacing characters in HTML
var REGEX_CR = new RegExp('\r', 'g');
var REGEX_LF = new RegExp('\n', 'g');
var REGEX_NBSP = new RegExp(NBSP, 'g');
var REGEX_CARRIAGE = new RegExp('&#13;?', 'g');
var REGEX_ZWS = new RegExp('&#8203;?', 'g');

// https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight
var boldValues = ['bold', 'bolder', '500', '600', '700', '800', '900'];
var notBoldValues = ['light', 'lighter', '100', '200', '300', '400'];

// Block tag flow is different because LIs do not have
// a deterministic style ;_;
var inlineTags = {
  b: 'BOLD',
  code: 'CODE',
  del: 'STRIKETHROUGH',
  em: 'ITALIC',
  i: 'ITALIC',
  s: 'STRIKETHROUGH',
  strike: 'STRIKETHROUGH',
  strong: 'BOLD',
  u: 'UNDERLINE'
};

var knownListItemDepthClasses = (_knownListItemDepthCl = {}, _defineProperty(_knownListItemDepthCl, cx('public/DraftStyleDefault/depth0'), 0), _defineProperty(_knownListItemDepthCl, cx('public/DraftStyleDefault/depth1'), 1), _defineProperty(_knownListItemDepthCl, cx('public/DraftStyleDefault/depth2'), 2), _defineProperty(_knownListItemDepthCl, cx('public/DraftStyleDefault/depth3'), 3), _defineProperty(_knownListItemDepthCl, cx('public/DraftStyleDefault/depth4'), 4), _knownListItemDepthCl);

var anchorAttr = ['className', 'href', 'rel', 'target', 'title'];

var imgAttr = ['alt', 'className', 'height', 'src', 'width'];

var lastBlock = void 0;

var EMPTY_CHUNK = {
  text: '',
  inlines: [],
  entities: [],
  blocks: []
};

var EMPTY_BLOCK = {
  children: List(),
  depth: 0,
  key: '',
  type: ''
};

var getListBlockType = function getListBlockType(tag, lastList) {
  if (tag === 'li') {
    return lastList === 'ol' ? 'ordered-list-item' : 'unordered-list-item';
  }
  return null;
};

var getBlockMapSupportedTags = function getBlockMapSupportedTags(blockRenderMap) {
  var unstyledElement = blockRenderMap.get('unstyled').element;
  var tags = Set([]);

  blockRenderMap.forEach(function (draftBlock) {
    if (draftBlock.aliasedElements) {
      draftBlock.aliasedElements.forEach(function (tag) {
        tags = tags.add(tag);
      });
    }

    tags = tags.add(draftBlock.element);
  });

  return tags.filter(function (tag) {
    return tag && tag !== unstyledElement;
  }).toArray().sort();
};

// custom element conversions
var getMultiMatchedType = function getMultiMatchedType(tag, lastList, multiMatchExtractor) {
  for (var ii = 0; ii < multiMatchExtractor.length; ii++) {
    var matchType = multiMatchExtractor[ii](tag, lastList);
    if (matchType) {
      return matchType;
    }
  }
  return null;
};

var getBlockTypeForTag = function getBlockTypeForTag(tag, lastList, blockRenderMap) {
  var matchedTypes = blockRenderMap.filter(function (draftBlock) {
    return draftBlock.element === tag || draftBlock.wrapper === tag || draftBlock.aliasedElements && draftBlock.aliasedElements.some(function (alias) {
      return alias === tag;
    });
  }).keySeq().toSet().toArray().sort();

  // if we dont have any matched type, return unstyled
  // if we have one matched type return it
  // if we have multi matched types use the multi-match function to gather type
  switch (matchedTypes.length) {
    case 0:
      return 'unstyled';
    case 1:
      return matchedTypes[0];
    default:
      return getMultiMatchedType(tag, lastList, [getListBlockType]) || 'unstyled';
  }
};

var processInlineTag = function processInlineTag(tag, node, currentStyle) {
  var styleToCheck = inlineTags[tag];
  if (styleToCheck) {
    currentStyle = currentStyle.add(styleToCheck).toOrderedSet();
  } else if (node instanceof HTMLElement) {
    var htmlElement = node;
    currentStyle = currentStyle.withMutations(function (style) {
      var fontWeight = htmlElement.style.fontWeight;
      var fontStyle = htmlElement.style.fontStyle;
      var textDecoration = htmlElement.style.textDecoration;

      if (boldValues.indexOf(fontWeight) >= 0) {
        style.add('BOLD');
      } else if (notBoldValues.indexOf(fontWeight) >= 0) {
        style.remove('BOLD');
      }

      if (fontStyle === 'italic') {
        style.add('ITALIC');
      } else if (fontStyle === 'normal') {
        style.remove('ITALIC');
      }

      if (textDecoration === 'underline') {
        style.add('UNDERLINE');
      }
      if (textDecoration === 'line-through') {
        style.add('STRIKETHROUGH');
      }
      if (textDecoration === 'none') {
        style.remove('UNDERLINE');
        style.remove('STRIKETHROUGH');
      }
    }).toOrderedSet();
  }
  return currentStyle;
};

var joinChunks = function joinChunks(A, B, experimentalHasNestedBlocks) {
  // Sometimes two blocks will touch in the DOM and we need to strip the
  // extra delimiter to preserve niceness.
  var lastInA = A.text.slice(-1);
  var firstInB = B.text.slice(0, 1);

  if (lastInA === '\r' && firstInB === '\r' && !experimentalHasNestedBlocks) {
    A.text = A.text.slice(0, -1);
    A.inlines.pop();
    A.entities.pop();
    A.blocks.pop();
  }

  // Kill whitespace after blocks
  if (lastInA === '\r') {
    if (B.text === SPACE || B.text === '\n') {
      return A;
    } else if (firstInB === SPACE || firstInB === '\n') {
      B.text = B.text.slice(1);
      B.inlines.shift();
      B.entities.shift();
    }
  }

  return {
    text: A.text + B.text,
    inlines: A.inlines.concat(B.inlines),
    entities: A.entities.concat(B.entities),
    blocks: A.blocks.concat(B.blocks)
  };
};

/**
 * Check to see if we have anything like <p> <blockquote> <h1>... to create
 * block tags from. If we do, we can use those and ignore <div> tags. If we
 * don't, we can treat <div> tags as meaningful (unstyled) blocks.
 */
var containsSemanticBlockMarkup = function containsSemanticBlockMarkup(html, blockTags) {
  return blockTags.some(function (tag) {
    return html.indexOf('<' + tag) !== -1;
  });
};

var hasValidLinkText = function hasValidLinkText(link) {
  !(link instanceof HTMLAnchorElement) ?  true ? invariant(false, 'Link must be an HTMLAnchorElement.') : invariant(false) : void 0;
  var protocol = link.protocol;
  return protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:';
};

var getWhitespaceChunk = function getWhitespaceChunk(inEntity) {
  var entities = new Array(1);
  if (inEntity) {
    entities[0] = inEntity;
  }
  return _extends({}, EMPTY_CHUNK, {
    text: SPACE,
    inlines: [OrderedSet()],
    entities: entities
  });
};

var getSoftNewlineChunk = function getSoftNewlineChunk() {
  return _extends({}, EMPTY_CHUNK, {
    text: '\n',
    inlines: [OrderedSet()],
    entities: new Array(1)
  });
};

var getChunkedBlock = function getChunkedBlock() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return _extends({}, EMPTY_BLOCK, props);
};

var getBlockDividerChunk = function getBlockDividerChunk(block, depth) {
  var parentKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  return {
    text: '\r',
    inlines: [OrderedSet()],
    entities: new Array(1),
    blocks: [getChunkedBlock({
      parent: parentKey,
      key: generateRandomKey(),
      type: block,
      depth: Math.max(0, Math.min(MAX_DEPTH, depth))
    })]
  };
};

/**
 *  If we're pasting from one DraftEditor to another we can check to see if
 *  existing list item depth classes are being used and preserve this style
 */
var getListItemDepth = function getListItemDepth(node) {
  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  Object.keys(knownListItemDepthClasses).some(function (depthClass) {
    if (node.classList.contains(depthClass)) {
      depth = knownListItemDepthClasses[depthClass];
    }
  });
  return depth;
};

var genFragment = function genFragment(entityMap, node, inlineStyle, lastList, inBlock, blockTags, depth, blockRenderMap, inEntity, parentKey) {
  var lastLastBlock = lastBlock;
  var nodeName = node.nodeName.toLowerCase();
  var newEntityMap = entityMap;
  var nextBlockType = 'unstyled';
  var newBlock = false;
  var inBlockType = inBlock && getBlockTypeForTag(inBlock, lastList, blockRenderMap);
  var chunk = _extends({}, EMPTY_CHUNK);
  var newChunk = null;
  var blockKey = void 0;

  // Base Case
  if (nodeName === '#text') {
    var _text = node.textContent;
    var nodeTextContent = _text.trim();

    // We should not create blocks for leading spaces that are
    // existing around ol/ul and their children list items
    if (lastList && nodeTextContent === '' && node.parentElement) {
      var parentNodeName = node.parentElement.nodeName.toLowerCase();
      if (parentNodeName === 'ol' || parentNodeName === 'ul') {
        return { chunk: _extends({}, EMPTY_CHUNK), entityMap: entityMap };
      }
    }

    if (nodeTextContent === '' && inBlock !== 'pre') {
      return { chunk: getWhitespaceChunk(inEntity), entityMap: entityMap };
    }
    if (inBlock !== 'pre') {
      // Can't use empty string because MSWord
      _text = _text.replace(REGEX_LF, SPACE);
    }

    // save the last block so we can use it later
    lastBlock = nodeName;

    return {
      chunk: {
        text: _text,
        inlines: Array(_text.length).fill(inlineStyle),
        entities: Array(_text.length).fill(inEntity),
        blocks: []
      },
      entityMap: entityMap
    };
  }

  // save the last block so we can use it later
  lastBlock = nodeName;

  // BR tags
  if (nodeName === 'br') {
    if (lastLastBlock === 'br' && (!inBlock || inBlockType === 'unstyled')) {
      return {
        chunk: getBlockDividerChunk('unstyled', depth, parentKey),
        entityMap: entityMap
      };
    }
    return { chunk: getSoftNewlineChunk(), entityMap: entityMap };
  }

  // IMG tags
  if (nodeName === 'img' && node instanceof HTMLImageElement && node.attributes.getNamedItem('src') && node.attributes.getNamedItem('src').value) {
    var image = node;
    var entityConfig = {};

    imgAttr.forEach(function (attr) {
      var imageAttribute = image.getAttribute(attr);
      if (imageAttribute) {
        entityConfig[attr] = imageAttribute;
      }
    });
    // Forcing this node to have children because otherwise no entity will be
    // created for this node.
    // The child text node cannot just have a space or return as content -
    // we strip those out.
    // See https://github.com/facebook/draft-js/issues/231 for some context.
    node.textContent = '\uD83D\uDCF7';

    // TODO: update this when we remove DraftEntity entirely
    inEntity = DraftEntity.__create('IMAGE', 'MUTABLE', entityConfig || {});
  }

  // Inline tags
  inlineStyle = processInlineTag(nodeName, node, inlineStyle);

  // Handle lists
  if (nodeName === 'ul' || nodeName === 'ol') {
    if (lastList) {
      depth += 1;
    }
    lastList = nodeName;
  }

  if (!experimentalTreeDataSupport && nodeName === 'li' && node instanceof HTMLElement) {
    depth = getListItemDepth(node, depth);
  }

  var blockType = getBlockTypeForTag(nodeName, lastList, blockRenderMap);
  var inListBlock = lastList && inBlock === 'li' && nodeName === 'li';
  var inBlockOrHasNestedBlocks = (!inBlock || experimentalTreeDataSupport) && blockTags.indexOf(nodeName) !== -1;

  // Block Tags
  if (inListBlock || inBlockOrHasNestedBlocks) {
    chunk = getBlockDividerChunk(blockType, depth, parentKey);
    blockKey = chunk.blocks[0].key;
    inBlock = nodeName;
    newBlock = !experimentalTreeDataSupport;
  }

  // this is required so that we can handle 'ul' and 'ol'
  if (inListBlock) {
    nextBlockType = lastList === 'ul' ? 'unordered-list-item' : 'ordered-list-item';
  }

  // Recurse through children
  var child = node.firstChild;
  if (child != null) {
    nodeName = child.nodeName.toLowerCase();
  }

  var entityId = null;

  while (child) {
    if (child instanceof HTMLAnchorElement && child.href && hasValidLinkText(child)) {
      (function () {
        var anchor = child;
        var entityConfig = {};

        anchorAttr.forEach(function (attr) {
          var anchorAttribute = anchor.getAttribute(attr);
          if (anchorAttribute) {
            entityConfig[attr] = anchorAttribute;
          }
        });

        entityConfig.url = new URI(anchor.href).toString();
        // TODO: update this when we remove DraftEntity completely
        entityId = DraftEntity.__create('LINK', 'MUTABLE', entityConfig || {});
      })();
    } else {
      entityId = undefined;
    }

    var _genFragment = genFragment(newEntityMap, child, inlineStyle, lastList, inBlock, blockTags, depth, blockRenderMap, entityId || inEntity, experimentalTreeDataSupport ? blockKey : null),
        generatedChunk = _genFragment.chunk,
        maybeUpdatedEntityMap = _genFragment.entityMap;

    newChunk = generatedChunk;
    newEntityMap = maybeUpdatedEntityMap;

    chunk = joinChunks(chunk, newChunk, experimentalTreeDataSupport);
    var sibling = child.nextSibling;

    // Put in a newline to break up blocks inside blocks
    if (!parentKey && sibling && blockTags.indexOf(nodeName) >= 0 && inBlock) {
      chunk = joinChunks(chunk, getSoftNewlineChunk());
    }
    if (sibling) {
      nodeName = sibling.nodeName.toLowerCase();
    }
    child = sibling;
  }

  if (newBlock) {
    chunk = joinChunks(chunk, getBlockDividerChunk(nextBlockType, depth, parentKey));
  }

  return { chunk: chunk, entityMap: newEntityMap };
};

var getChunkForHTML = function getChunkForHTML(html, DOMBuilder, blockRenderMap, entityMap) {
  html = html.trim().replace(REGEX_CR, '').replace(REGEX_NBSP, SPACE).replace(REGEX_CARRIAGE, '').replace(REGEX_ZWS, '');

  var supportedBlockTags = getBlockMapSupportedTags(blockRenderMap);

  var safeBody = DOMBuilder(html);
  if (!safeBody) {
    return null;
  }
  lastBlock = null;

  // Sometimes we aren't dealing with content that contains nice semantic
  // tags. In this case, use divs to separate everything out into paragraphs
  // and hope for the best.
  var workingBlocks = containsSemanticBlockMarkup(html, supportedBlockTags) ? supportedBlockTags : ['div'];

  // Start with -1 block depth to offset the fact that we are passing in a fake
  // UL block to start with.
  var fragment = genFragment(entityMap, safeBody, OrderedSet(), 'ul', null, workingBlocks, -1, blockRenderMap);

  var chunk = fragment.chunk;
  var newEntityMap = fragment.entityMap;

  // join with previous block to prevent weirdness on paste
  if (chunk.text.indexOf('\r') === 0) {
    chunk = {
      text: chunk.text.slice(1),
      inlines: chunk.inlines.slice(1),
      entities: chunk.entities.slice(1),
      blocks: chunk.blocks
    };
  }

  // Kill block delimiter at the end
  if (chunk.text.slice(-1) === '\r') {
    chunk.text = chunk.text.slice(0, -1);
    chunk.inlines = chunk.inlines.slice(0, -1);
    chunk.entities = chunk.entities.slice(0, -1);
    chunk.blocks.pop();
  }

  // If we saw no block tags, put an unstyled one in
  if (chunk.blocks.length === 0) {
    chunk.blocks.push(_extends({}, EMPTY_CHUNK, {
      type: 'unstyled',
      depth: 0
    }));
  }

  // Sometimes we start with text that isn't in a block, which is then
  // followed by blocks. Need to fix up the blocks to add in
  // an unstyled block for this content
  if (chunk.text.split('\r').length === chunk.blocks.length + 1) {
    chunk.blocks.unshift({ type: 'unstyled', depth: 0 });
  }

  return { chunk: chunk, entityMap: newEntityMap };
};

var convertChunkToContentBlocks = function convertChunkToContentBlocks(chunk) {
  if (!chunk || !chunk.text || !Array.isArray(chunk.blocks)) {
    return null;
  }

  var initialState = {
    cacheRef: {},
    contentBlocks: []
  };

  var start = 0;

  var rawBlocks = chunk.blocks,
      rawInlines = chunk.inlines,
      rawEntities = chunk.entities;


  var BlockNodeRecord = experimentalTreeDataSupport ? ContentBlockNode : ContentBlock;

  return chunk.text.split('\r').reduce(function (acc, textBlock, index) {
    // Make absolutely certain that our text is acceptable.
    textBlock = sanitizeDraftText(textBlock);

    var block = rawBlocks[index];
    var end = start + textBlock.length;
    var inlines = rawInlines.slice(start, end);
    var entities = rawEntities.slice(start, end);
    var characterList = List(inlines.map(function (style, index) {
      var data = { style: style, entity: null };
      if (entities[index]) {
        data.entity = entities[index];
      }
      return CharacterMetadata.create(data);
    }));
    start = end + 1;

    var depth = block.depth,
        type = block.type,
        parent = block.parent;


    var key = block.key || generateRandomKey();
    var parentTextNodeKey = null; // will be used to store container text nodes

    // childrens add themselves to their parents since we are iterating in order
    if (parent) {
      var parentIndex = acc.cacheRef[parent];
      var parentRecord = acc.contentBlocks[parentIndex];

      // if parent has text we need to split it into a separate unstyled element
      if (parentRecord.getChildKeys().isEmpty() && parentRecord.getText()) {
        var parentCharacterList = parentRecord.getCharacterList();
        var parentText = parentRecord.getText();
        parentTextNodeKey = generateRandomKey();

        var textNode = new ContentBlockNode({
          key: parentTextNodeKey,
          text: parentText,
          characterList: parentCharacterList,
          parent: parent,
          nextSibling: key
        });

        acc.contentBlocks.push(textNode);

        parentRecord = parentRecord.withMutations(function (block) {
          block.set('characterList', List()).set('text', '').set('children', parentRecord.children.push(textNode.getKey()));
        });
      }

      acc.contentBlocks[parentIndex] = parentRecord.set('children', parentRecord.children.push(key));
    }

    var blockNode = new BlockNodeRecord({
      key: key,
      parent: parent,
      type: type,
      depth: depth,
      text: textBlock,
      characterList: characterList,
      prevSibling: parentTextNodeKey || (index === 0 || rawBlocks[index - 1].parent !== parent ? null : rawBlocks[index - 1].key),
      nextSibling: index === rawBlocks.length - 1 || rawBlocks[index + 1].parent !== parent ? null : rawBlocks[index + 1].key
    });

    // insert node
    acc.contentBlocks.push(blockNode);

    // cache ref for building links
    acc.cacheRef[blockNode.key] = index;

    return acc;
  }, initialState).contentBlocks;
};

var convertFromHTMLtoContentBlocks = function convertFromHTMLtoContentBlocks(html) {
  var DOMBuilder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getSafeBodyFromHTML;
  var blockRenderMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultDraftBlockRenderMap;

  // Be ABSOLUTELY SURE that the dom builder you pass here won't execute
  // arbitrary code in whatever environment you're running this in. For an
  // example of how we try to do this in-browser, see getSafeBodyFromHTML.

  // TODO: replace DraftEntity with an OrderedMap here
  var chunkData = getChunkForHTML(html, DOMBuilder, blockRenderMap, DraftEntity);

  if (chunkData == null) {
    return null;
  }

  var chunk = chunkData.chunk,
      entityMap = chunkData.entityMap;

  var contentBlocks = convertChunkToContentBlocks(chunk);

  return {
    contentBlocks: contentBlocks,
    entityMap: entityMap
  };
};

module.exports = convertFromHTMLtoContentBlocks;

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getSafeBodyFromHTML
 * @format
 * 
 */



var UserAgent = __webpack_require__(330);

var invariant = __webpack_require__(10);

var isOldIE = UserAgent.isBrowser('IE <= 9');

// Provides a dom node that will not execute scripts
// https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation.createHTMLDocument
// https://developer.mozilla.org/en-US/Add-ons/Code_snippets/HTML_to_DOM

function getSafeBodyFromHTML(html) {
  var doc;
  var root = null;
  // Provides a safe context
  if (!isOldIE && document.implementation && document.implementation.createHTMLDocument) {
    doc = document.implementation.createHTMLDocument('foo');
    !doc.documentElement ?  true ? invariant(false, 'Missing doc.documentElement') : invariant(false) : void 0;
    doc.documentElement.innerHTML = html;
    root = doc.getElementsByTagName('body')[0];
  }
  return root;
}

module.exports = getSafeBodyFromHTML;

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule RichTextEditorUtil
 * @format
 * 
 */



var DraftModifier = __webpack_require__(326);
var EditorState = __webpack_require__(325);
var SelectionState = __webpack_require__(335);

var adjustBlockDepthForContentState = __webpack_require__(459);
var nullthrows = __webpack_require__(329);

var RichTextEditorUtil = {
  currentBlockContainsLink: function currentBlockContainsLink(editorState) {
    var selection = editorState.getSelection();
    var contentState = editorState.getCurrentContent();
    var entityMap = contentState.getEntityMap();
    return contentState.getBlockForKey(selection.getAnchorKey()).getCharacterList().slice(selection.getStartOffset(), selection.getEndOffset()).some(function (v) {
      var entity = v.getEntity();
      return !!entity && entityMap.__get(entity).getType() === 'LINK';
    });
  },

  getCurrentBlockType: function getCurrentBlockType(editorState) {
    var selection = editorState.getSelection();
    return editorState.getCurrentContent().getBlockForKey(selection.getStartKey()).getType();
  },

  getDataObjectForLinkURL: function getDataObjectForLinkURL(uri) {
    return { url: uri.toString() };
  },

  handleKeyCommand: function handleKeyCommand(editorState, command) {
    switch (command) {
      case 'bold':
        return RichTextEditorUtil.toggleInlineStyle(editorState, 'BOLD');
      case 'italic':
        return RichTextEditorUtil.toggleInlineStyle(editorState, 'ITALIC');
      case 'underline':
        return RichTextEditorUtil.toggleInlineStyle(editorState, 'UNDERLINE');
      case 'code':
        return RichTextEditorUtil.toggleCode(editorState);
      case 'backspace':
      case 'backspace-word':
      case 'backspace-to-start-of-line':
        return RichTextEditorUtil.onBackspace(editorState);
      case 'delete':
      case 'delete-word':
      case 'delete-to-end-of-block':
        return RichTextEditorUtil.onDelete(editorState);
      default:
        // they may have custom editor commands; ignore those
        return null;
    }
  },

  insertSoftNewline: function insertSoftNewline(editorState) {
    var contentState = DraftModifier.insertText(editorState.getCurrentContent(), editorState.getSelection(), '\n', editorState.getCurrentInlineStyle(), null);

    var newEditorState = EditorState.push(editorState, contentState, 'insert-characters');

    return EditorState.forceSelection(newEditorState, contentState.getSelectionAfter());
  },

  /**
   * For collapsed selections at the start of styled blocks, backspace should
   * just remove the existing style.
   */
  onBackspace: function onBackspace(editorState) {
    var selection = editorState.getSelection();
    if (!selection.isCollapsed() || selection.getAnchorOffset() || selection.getFocusOffset()) {
      return null;
    }

    // First, try to remove a preceding atomic block.
    var content = editorState.getCurrentContent();
    var startKey = selection.getStartKey();
    var blockBefore = content.getBlockBefore(startKey);

    if (blockBefore && blockBefore.getType() === 'atomic') {
      var blockMap = content.getBlockMap()['delete'](blockBefore.getKey());
      var withoutAtomicBlock = content.merge({
        blockMap: blockMap,
        selectionAfter: selection
      });
      if (withoutAtomicBlock !== content) {
        return EditorState.push(editorState, withoutAtomicBlock, 'remove-range');
      }
    }

    // If that doesn't succeed, try to remove the current block style.
    var withoutBlockStyle = RichTextEditorUtil.tryToRemoveBlockStyle(editorState);

    if (withoutBlockStyle) {
      return EditorState.push(editorState, withoutBlockStyle, 'change-block-type');
    }

    return null;
  },

  onDelete: function onDelete(editorState) {
    var selection = editorState.getSelection();
    if (!selection.isCollapsed()) {
      return null;
    }

    var content = editorState.getCurrentContent();
    var startKey = selection.getStartKey();
    var block = content.getBlockForKey(startKey);
    var length = block.getLength();

    // The cursor is somewhere within the text. Behave normally.
    if (selection.getStartOffset() < length) {
      return null;
    }

    var blockAfter = content.getBlockAfter(startKey);

    if (!blockAfter || blockAfter.getType() !== 'atomic') {
      return null;
    }

    var atomicBlockTarget = selection.merge({
      focusKey: blockAfter.getKey(),
      focusOffset: blockAfter.getLength()
    });

    var withoutAtomicBlock = DraftModifier.removeRange(content, atomicBlockTarget, 'forward');

    if (withoutAtomicBlock !== content) {
      return EditorState.push(editorState, withoutAtomicBlock, 'remove-range');
    }

    return null;
  },

  onTab: function onTab(event, editorState, maxDepth) {
    var selection = editorState.getSelection();
    var key = selection.getAnchorKey();
    if (key !== selection.getFocusKey()) {
      return editorState;
    }

    var content = editorState.getCurrentContent();
    var block = content.getBlockForKey(key);
    var type = block.getType();
    if (type !== 'unordered-list-item' && type !== 'ordered-list-item') {
      return editorState;
    }

    event.preventDefault();

    // Only allow indenting one level beyond the block above, and only if
    // the block above is a list item as well.
    var blockAbove = content.getBlockBefore(key);
    if (!blockAbove) {
      return editorState;
    }

    var typeAbove = blockAbove.getType();
    if (typeAbove !== 'unordered-list-item' && typeAbove !== 'ordered-list-item') {
      return editorState;
    }

    var depth = block.getDepth();
    if (!event.shiftKey && depth === maxDepth) {
      return editorState;
    }

    maxDepth = Math.min(blockAbove.getDepth() + 1, maxDepth);

    var withAdjustment = adjustBlockDepthForContentState(content, selection, event.shiftKey ? -1 : 1, maxDepth);

    return EditorState.push(editorState, withAdjustment, 'adjust-depth');
  },

  toggleBlockType: function toggleBlockType(editorState, blockType) {
    var selection = editorState.getSelection();
    var startKey = selection.getStartKey();
    var endKey = selection.getEndKey();
    var content = editorState.getCurrentContent();
    var target = selection;

    // Triple-click can lead to a selection that includes offset 0 of the
    // following block. The `SelectionState` for this case is accurate, but
    // we should avoid toggling block type for the trailing block because it
    // is a confusing interaction.
    if (startKey !== endKey && selection.getEndOffset() === 0) {
      var blockBefore = nullthrows(content.getBlockBefore(endKey));
      endKey = blockBefore.getKey();
      target = target.merge({
        anchorKey: startKey,
        anchorOffset: selection.getStartOffset(),
        focusKey: endKey,
        focusOffset: blockBefore.getLength(),
        isBackward: false
      });
    }

    var hasAtomicBlock = content.getBlockMap().skipWhile(function (_, k) {
      return k !== startKey;
    }).reverse().skipWhile(function (_, k) {
      return k !== endKey;
    }).some(function (v) {
      return v.getType() === 'atomic';
    });

    if (hasAtomicBlock) {
      return editorState;
    }

    var typeToSet = content.getBlockForKey(startKey).getType() === blockType ? 'unstyled' : blockType;

    return EditorState.push(editorState, DraftModifier.setBlockType(content, target, typeToSet), 'change-block-type');
  },

  toggleCode: function toggleCode(editorState) {
    var selection = editorState.getSelection();
    var anchorKey = selection.getAnchorKey();
    var focusKey = selection.getFocusKey();

    if (selection.isCollapsed() || anchorKey !== focusKey) {
      return RichTextEditorUtil.toggleBlockType(editorState, 'code-block');
    }

    return RichTextEditorUtil.toggleInlineStyle(editorState, 'CODE');
  },

  /**
   * Toggle the specified inline style for the selection. If the
   * user's selection is collapsed, apply or remove the style for the
   * internal state. If it is not collapsed, apply the change directly
   * to the document state.
   */
  toggleInlineStyle: function toggleInlineStyle(editorState, inlineStyle) {
    var selection = editorState.getSelection();
    var currentStyle = editorState.getCurrentInlineStyle();

    // If the selection is collapsed, toggle the specified style on or off and
    // set the result as the new inline style override. This will then be
    // used as the inline style for the next character to be inserted.
    if (selection.isCollapsed()) {
      return EditorState.setInlineStyleOverride(editorState, currentStyle.has(inlineStyle) ? currentStyle.remove(inlineStyle) : currentStyle.add(inlineStyle));
    }

    // If characters are selected, immediately apply or remove the
    // inline style on the document state itself.
    var content = editorState.getCurrentContent();
    var newContent;

    // If the style is already present for the selection range, remove it.
    // Otherwise, apply it.
    if (currentStyle.has(inlineStyle)) {
      newContent = DraftModifier.removeInlineStyle(content, selection, inlineStyle);
    } else {
      newContent = DraftModifier.applyInlineStyle(content, selection, inlineStyle);
    }

    return EditorState.push(editorState, newContent, 'change-inline-style');
  },

  toggleLink: function toggleLink(editorState, targetSelection, entityKey) {
    var withoutLink = DraftModifier.applyEntity(editorState.getCurrentContent(), targetSelection, entityKey);

    return EditorState.push(editorState, withoutLink, 'apply-entity');
  },

  /**
   * When a collapsed cursor is at the start of the first styled block, or
   * an empty styled block, changes block to 'unstyled'. Returns null if
   * block or selection does not meet that criteria.
   */
  tryToRemoveBlockStyle: function tryToRemoveBlockStyle(editorState) {
    var selection = editorState.getSelection();
    var offset = selection.getAnchorOffset();
    if (selection.isCollapsed() && offset === 0) {
      var key = selection.getAnchorKey();
      var content = editorState.getCurrentContent();
      var block = content.getBlockForKey(key);

      var firstBlock = content.getFirstBlock();
      if (block.getLength() > 0 && block !== firstBlock) {
        return null;
      }

      var type = block.getType();
      var blockBefore = content.getBlockBefore(key);
      if (type === 'code-block' && blockBefore && blockBefore.getType() === 'code-block' && blockBefore.getLength() !== 0) {
        return null;
      }

      if (type !== 'unstyled') {
        return DraftModifier.setBlockType(content, selection, 'unstyled');
      }
    }
    return null;
  }
};

module.exports = RichTextEditorUtil;

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getDefaultKeyBinding
 * @format
 * 
 */



var KeyBindingUtil = __webpack_require__(357);
var Keys = __webpack_require__(352);
var UserAgent = __webpack_require__(330);

var isOSX = UserAgent.isPlatform('Mac OS X');
var isWindows = UserAgent.isPlatform('Windows');

// Firefox on OSX had a bug resulting in navigation instead of cursor movement.
// This bug was fixed in Firefox 29. Feature detection is virtually impossible
// so we just check the version number. See #342765.
var shouldFixFirefoxMovement = isOSX && UserAgent.isBrowser('Firefox < 29');

var hasCommandModifier = KeyBindingUtil.hasCommandModifier,
    isCtrlKeyCommand = KeyBindingUtil.isCtrlKeyCommand;


function shouldRemoveWord(e) {
  return isOSX && e.altKey || isCtrlKeyCommand(e);
}

/**
 * Get the appropriate undo/redo command for a Z key command.
 */
function getZCommand(e) {
  if (!hasCommandModifier(e)) {
    return null;
  }
  return e.shiftKey ? 'redo' : 'undo';
}

function getDeleteCommand(e) {
  // Allow default "cut" behavior for Windows on Shift + Delete.
  if (isWindows && e.shiftKey) {
    return null;
  }
  return shouldRemoveWord(e) ? 'delete-word' : 'delete';
}

function getBackspaceCommand(e) {
  if (hasCommandModifier(e) && isOSX) {
    return 'backspace-to-start-of-line';
  }
  return shouldRemoveWord(e) ? 'backspace-word' : 'backspace';
}

/**
 * Retrieve a bound key command for the given event.
 */
function getDefaultKeyBinding(e) {
  switch (e.keyCode) {
    case 66:
      // B
      return hasCommandModifier(e) ? 'bold' : null;
    case 68:
      // D
      return isCtrlKeyCommand(e) ? 'delete' : null;
    case 72:
      // H
      return isCtrlKeyCommand(e) ? 'backspace' : null;
    case 73:
      // I
      return hasCommandModifier(e) ? 'italic' : null;
    case 74:
      // J
      return hasCommandModifier(e) ? 'code' : null;
    case 75:
      // K
      return !isWindows && isCtrlKeyCommand(e) ? 'secondary-cut' : null;
    case 77:
      // M
      return isCtrlKeyCommand(e) ? 'split-block' : null;
    case 79:
      // O
      return isCtrlKeyCommand(e) ? 'split-block' : null;
    case 84:
      // T
      return isOSX && isCtrlKeyCommand(e) ? 'transpose-characters' : null;
    case 85:
      // U
      return hasCommandModifier(e) ? 'underline' : null;
    case 87:
      // W
      return isOSX && isCtrlKeyCommand(e) ? 'backspace-word' : null;
    case 89:
      // Y
      if (isCtrlKeyCommand(e)) {
        return isWindows ? 'redo' : 'secondary-paste';
      }
      return null;
    case 90:
      // Z
      return getZCommand(e) || null;
    case Keys.RETURN:
      return 'split-block';
    case Keys.DELETE:
      return getDeleteCommand(e);
    case Keys.BACKSPACE:
      return getBackspaceCommand(e);
    // LEFT/RIGHT handlers serve as a workaround for a Firefox bug.
    case Keys.LEFT:
      return shouldFixFirefoxMovement && hasCommandModifier(e) ? 'move-selection-to-start-of-block' : null;
    case Keys.RIGHT:
      return shouldFixFirefoxMovement && hasCommandModifier(e) ? 'move-selection-to-end-of-block' : null;
    default:
      return null;
  }
}

module.exports = getDefaultKeyBinding;

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftStringKey
 * @format
 * 
 */



var DraftStringKey = {
  stringify: function stringify(key) {
    return '_' + String(key);
  },

  unstringify: function unstringify(key) {
    return key.slice(1);
  }
};

module.exports = DraftStringKey;

/***/ }),
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _draftJs = __webpack_require__(359);

var _reactDraftWysiwyg = __webpack_require__(474);

var _draftjsToHtml = __webpack_require__(476);

var _draftjsToHtml2 = _interopRequireDefault(_draftjsToHtml);

__webpack_require__(477);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WYSIWYG = function (_Component) {
  _inherits(WYSIWYG, _Component);

  function WYSIWYG(props) {
    _classCallCheck(this, WYSIWYG);

    var _this = _possibleConstructorReturn(this, (WYSIWYG.__proto__ || Object.getPrototypeOf(WYSIWYG)).call(this, props));

    _this.state = {
      editorState: _this.convertHtmlToEditorState(_this.props.value)
    };

    _this.onEditorStateChange = _this.onEditorStateChange.bind(_this);
    return _this;
  }

  _createClass(WYSIWYG, [{
    key: 'convertHtmlToEditorState',
    value: function convertHtmlToEditorState(value) {
      if (value) {
        var blocksFromHTML = (0, _draftJs.convertFromHTML)(value);
        var state = _draftJs.ContentState.createFromBlockArray(blocksFromHTML.contentBlocks, blocksFromHTML.entityMap);

        return _draftJs.EditorState.createWithContent(state);
      }
    }
  }, {
    key: 'onEditorStateChange',
    value: function onEditorStateChange(editorState) {
      this.setState({
        editorState: editorState
      });

      this.props.onChange((0, _draftjsToHtml2.default)((0, _draftJs.convertToRaw)(editorState.getCurrentContent())));
    }
  }, {
    key: 'render',
    value: function render() {
      var editorState = this.state.editorState;

      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(_reactDraftWysiwyg.Editor, {
          editorState: editorState,
          wrapperClassName: 'demo-wrapper',
          editorClassName: 'form-control',
          onEditorStateChange: this.onEditorStateChange
        })
      );
    }
  }]);

  return WYSIWYG;
}(_react.Component);

WYSIWYG.propTypes = {
  value: _propTypes2.default.string.isRequired,
  onChange: _propTypes2.default.func.isRequired
};
exports.default = WYSIWYG;

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule AtomicBlockUtils
 * @format
 * 
 */



var _assign = __webpack_require__(18);

var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var BlockMapBuilder = __webpack_require__(340);
var CharacterMetadata = __webpack_require__(327);
var ContentBlock = __webpack_require__(333);
var ContentBlockNode = __webpack_require__(328);
var DraftFeatureFlags = __webpack_require__(332);
var DraftModifier = __webpack_require__(326);
var EditorState = __webpack_require__(325);
var Immutable = __webpack_require__(324);
var SelectionState = __webpack_require__(335);

var generateRandomKey = __webpack_require__(331);
var moveBlockInContentState = __webpack_require__(404);

var experimentalTreeDataSupport = DraftFeatureFlags.draft_tree_data_support;
var ContentBlockRecord = experimentalTreeDataSupport ? ContentBlockNode : ContentBlock;

var List = Immutable.List,
    Repeat = Immutable.Repeat;


var AtomicBlockUtils = {
  insertAtomicBlock: function insertAtomicBlock(editorState, entityKey, character) {
    var contentState = editorState.getCurrentContent();
    var selectionState = editorState.getSelection();

    var afterRemoval = DraftModifier.removeRange(contentState, selectionState, 'backward');

    var targetSelection = afterRemoval.getSelectionAfter();
    var afterSplit = DraftModifier.splitBlock(afterRemoval, targetSelection);
    var insertionTarget = afterSplit.getSelectionAfter();

    var asAtomicBlock = DraftModifier.setBlockType(afterSplit, insertionTarget, 'atomic');

    var charData = CharacterMetadata.create({ entity: entityKey });

    var atomicBlockConfig = {
      key: generateRandomKey(),
      type: 'atomic',
      text: character,
      characterList: List(Repeat(charData, character.length))
    };

    var atomicDividerBlockConfig = {
      key: generateRandomKey(),
      type: 'unstyled'
    };

    if (experimentalTreeDataSupport) {
      atomicBlockConfig = _extends({}, atomicBlockConfig, {
        nextSibling: atomicDividerBlockConfig.key
      });
      atomicDividerBlockConfig = _extends({}, atomicDividerBlockConfig, {
        prevSibling: atomicBlockConfig.key
      });
    }

    var fragmentArray = [new ContentBlockRecord(atomicBlockConfig), new ContentBlockRecord(atomicDividerBlockConfig)];

    var fragment = BlockMapBuilder.createFromArray(fragmentArray);

    var withAtomicBlock = DraftModifier.replaceWithFragment(asAtomicBlock, insertionTarget, fragment);

    var newContent = withAtomicBlock.merge({
      selectionBefore: selectionState,
      selectionAfter: withAtomicBlock.getSelectionAfter().set('hasFocus', true)
    });

    return EditorState.push(editorState, newContent, 'insert-fragment');
  },

  moveAtomicBlock: function moveAtomicBlock(editorState, atomicBlock, targetRange, insertionMode) {
    var contentState = editorState.getCurrentContent();
    var selectionState = editorState.getSelection();

    var withMovedAtomicBlock = void 0;

    if (insertionMode === 'before' || insertionMode === 'after') {
      var targetBlock = contentState.getBlockForKey(insertionMode === 'before' ? targetRange.getStartKey() : targetRange.getEndKey());

      withMovedAtomicBlock = moveBlockInContentState(contentState, atomicBlock, targetBlock, insertionMode);
    } else {
      var afterRemoval = DraftModifier.removeRange(contentState, targetRange, 'backward');

      var selectionAfterRemoval = afterRemoval.getSelectionAfter();
      var _targetBlock = afterRemoval.getBlockForKey(selectionAfterRemoval.getFocusKey());

      if (selectionAfterRemoval.getStartOffset() === 0) {
        withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, 'before');
      } else if (selectionAfterRemoval.getEndOffset() === _targetBlock.getLength()) {
        withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, 'after');
      } else {
        var afterSplit = DraftModifier.splitBlock(afterRemoval, selectionAfterRemoval);

        var selectionAfterSplit = afterSplit.getSelectionAfter();
        var _targetBlock2 = afterSplit.getBlockForKey(selectionAfterSplit.getFocusKey());

        withMovedAtomicBlock = moveBlockInContentState(afterSplit, atomicBlock, _targetBlock2, 'before');
      }
    }

    var newContent = withMovedAtomicBlock.merge({
      selectionBefore: selectionState,
      selectionAfter: withMovedAtomicBlock.getSelectionAfter().set('hasFocus', true)
    });

    return EditorState.push(editorState, newContent, 'move-block');
  }
};

module.exports = AtomicBlockUtils;

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftFeatureFlags-core
 * @format
 * 
 */



var DraftFeatureFlags = {
  draft_killswitch_allow_nontextnodes: false,
  draft_segmented_entities_behavior: false,
  draft_handlebeforeinput_composed_text: false,
  draft_tree_data_support: false
};

module.exports = DraftFeatureFlags;

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ContentStateInlineStyle
 * @format
 * 
 */



var CharacterMetadata = __webpack_require__(327);

var _require = __webpack_require__(324),
    Map = _require.Map;

var ContentStateInlineStyle = {
  add: function add(contentState, selectionState, inlineStyle) {
    return modifyInlineStyle(contentState, selectionState, inlineStyle, true);
  },

  remove: function remove(contentState, selectionState, inlineStyle) {
    return modifyInlineStyle(contentState, selectionState, inlineStyle, false);
  }
};

function modifyInlineStyle(contentState, selectionState, inlineStyle, addOrRemove) {
  var blockMap = contentState.getBlockMap();
  var startKey = selectionState.getStartKey();
  var startOffset = selectionState.getStartOffset();
  var endKey = selectionState.getEndKey();
  var endOffset = selectionState.getEndOffset();

  var newBlocks = blockMap.skipUntil(function (_, k) {
    return k === startKey;
  }).takeUntil(function (_, k) {
    return k === endKey;
  }).concat(Map([[endKey, blockMap.get(endKey)]])).map(function (block, blockKey) {
    var sliceStart;
    var sliceEnd;

    if (startKey === endKey) {
      sliceStart = startOffset;
      sliceEnd = endOffset;
    } else {
      sliceStart = blockKey === startKey ? startOffset : 0;
      sliceEnd = blockKey === endKey ? endOffset : block.getLength();
    }

    var chars = block.getCharacterList();
    var current;
    while (sliceStart < sliceEnd) {
      current = chars.get(sliceStart);
      chars = chars.set(sliceStart, addOrRemove ? CharacterMetadata.applyStyle(current, inlineStyle) : CharacterMetadata.removeStyle(current, inlineStyle));
      sliceStart++;
    }

    return block.set('characterList', chars);
  });

  return contentState.merge({
    blockMap: blockMap.merge(newBlocks),
    selectionBefore: selectionState,
    selectionAfter: selectionState
  });
}

module.exports = ContentStateInlineStyle;

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule applyEntityToContentState
 * @format
 * 
 */



var Immutable = __webpack_require__(324);

var applyEntityToContentBlock = __webpack_require__(393);

function applyEntityToContentState(contentState, selectionState, entityKey) {
  var blockMap = contentState.getBlockMap();
  var startKey = selectionState.getStartKey();
  var startOffset = selectionState.getStartOffset();
  var endKey = selectionState.getEndKey();
  var endOffset = selectionState.getEndOffset();

  var newBlocks = blockMap.skipUntil(function (_, k) {
    return k === startKey;
  }).takeUntil(function (_, k) {
    return k === endKey;
  }).toOrderedMap().merge(Immutable.OrderedMap([[endKey, blockMap.get(endKey)]])).map(function (block, blockKey) {
    var sliceStart = blockKey === startKey ? startOffset : 0;
    var sliceEnd = blockKey === endKey ? endOffset : block.getLength();
    return applyEntityToContentBlock(block, sliceStart, sliceEnd, entityKey);
  });

  return contentState.merge({
    blockMap: blockMap.merge(newBlocks),
    selectionBefore: selectionState,
    selectionAfter: selectionState
  });
}

module.exports = applyEntityToContentState;

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule applyEntityToContentBlock
 * @format
 * 
 */



var CharacterMetadata = __webpack_require__(327);

function applyEntityToContentBlock(contentBlock, start, end, entityKey) {
  var characterList = contentBlock.getCharacterList();
  while (start < end) {
    characterList = characterList.set(start, CharacterMetadata.applyEntity(characterList.get(start), entityKey));
    start++;
  }
  return contentBlock.set('characterList', characterList);
}

module.exports = applyEntityToContentBlock;

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getCharacterRemovalRange
 * @format
 * 
 */



var DraftEntitySegments = __webpack_require__(395);

var getRangesForDraftEntity = __webpack_require__(396);
var invariant = __webpack_require__(10);

/**
 * Given a SelectionState and a removal direction, determine the entire range
 * that should be removed from a ContentState. This is based on any entities
 * within the target, with their `mutability` values taken into account.
 *
 * For instance, if we are attempting to remove part of an "immutable" entity
 * range, the entire entity must be removed. The returned `SelectionState`
 * will be adjusted accordingly.
 */
function getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {
  var start = selectionState.getStartOffset();
  var end = selectionState.getEndOffset();
  var startEntityKey = startBlock.getEntityAt(start);
  var endEntityKey = endBlock.getEntityAt(end - 1);
  if (!startEntityKey && !endEntityKey) {
    return selectionState;
  }
  var newSelectionState = selectionState;
  if (startEntityKey && startEntityKey === endEntityKey) {
    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);
  } else if (startEntityKey && endEntityKey) {
    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);
    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);
    newSelectionState = newSelectionState.merge({
      anchorOffset: startSelectionState.getAnchorOffset(),
      focusOffset: endSelectionState.getFocusOffset(),
      isBackward: false
    });
  } else if (startEntityKey) {
    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);
    newSelectionState = newSelectionState.merge({
      anchorOffset: _startSelectionState.getStartOffset(),
      isBackward: false
    });
  } else if (endEntityKey) {
    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);
    newSelectionState = newSelectionState.merge({
      focusOffset: _endSelectionState.getEndOffset(),
      isBackward: false
    });
  }
  return newSelectionState;
}

function getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {
  var start = selectionState.getStartOffset();
  var end = selectionState.getEndOffset();
  var entity = entityMap.__get(entityKey);
  var mutability = entity.getMutability();
  var sideToConsider = isEntityAtStart ? start : end;

  // `MUTABLE` entities can just have the specified range of text removed
  // directly. No adjustments are needed.
  if (mutability === 'MUTABLE') {
    return selectionState;
  }

  // Find the entity range that overlaps with our removal range.
  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {
    return sideToConsider <= range.end && sideToConsider >= range.start;
  });

  !(entityRanges.length == 1) ?  true ? invariant(false, 'There should only be one entity range within this removal range.') : invariant(false) : void 0;

  var entityRange = entityRanges[0];

  // For `IMMUTABLE` entity types, we will remove the entire entity range.
  if (mutability === 'IMMUTABLE') {
    return selectionState.merge({
      anchorOffset: entityRange.start,
      focusOffset: entityRange.end,
      isBackward: false
    });
  }

  // For `SEGMENTED` entity types, determine the appropriate segment to
  // remove.
  if (!isEntireSelectionWithinEntity) {
    if (isEntityAtStart) {
      end = entityRange.end;
    } else {
      start = entityRange.start;
    }
  }

  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);

  return selectionState.merge({
    anchorOffset: removalRange.start,
    focusOffset: removalRange.end,
    isBackward: false
  });
}

module.exports = getCharacterRemovalRange;

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftEntitySegments
 * @format
 * 
 */



/**
 * Identify the range to delete from a segmented entity.
 *
 * Rules:
 *
 *  Example: 'John F. Kennedy'
 *
 *   - Deletion from within any non-whitespace (i.e. ['John', 'F.', 'Kennedy'])
 *     will return the range of that text.
 *
 *       'John F. Kennedy' -> 'John F.'
 *                  ^
 *
 *   - Forward deletion of whitespace will remove the following section:
 *
 *       'John F. Kennedy' -> 'John Kennedy'
 *            ^
 *
 *   - Backward deletion of whitespace will remove the previous section:
 *
 *       'John F. Kennedy' -> 'F. Kennedy'
 *            ^
 */
var DraftEntitySegments = {
  getRemovalRange: function getRemovalRange(selectionStart, selectionEnd, text, entityStart, direction) {
    var segments = text.split(' ');
    segments = segments.map(function ( /*string*/segment, /*number*/ii) {
      if (direction === 'forward') {
        if (ii > 0) {
          return ' ' + segment;
        }
      } else if (ii < segments.length - 1) {
        return segment + ' ';
      }
      return segment;
    });

    var segmentStart = entityStart;
    var segmentEnd;
    var segment;
    var removalStart = null;
    var removalEnd = null;

    for (var jj = 0; jj < segments.length; jj++) {
      segment = segments[jj];
      segmentEnd = segmentStart + segment.length;

      // Our selection overlaps this segment.
      if (selectionStart < segmentEnd && segmentStart < selectionEnd) {
        if (removalStart !== null) {
          removalEnd = segmentEnd;
        } else {
          removalStart = segmentStart;
          removalEnd = segmentEnd;
        }
      } else if (removalStart !== null) {
        break;
      }

      segmentStart = segmentEnd;
    }

    var entityEnd = entityStart + text.length;
    var atStart = removalStart === entityStart;
    var atEnd = removalEnd === entityEnd;

    if (!atStart && atEnd || atStart && !atEnd) {
      if (direction === 'forward') {
        if (removalEnd !== entityEnd) {
          removalEnd++;
        }
      } else if (removalStart !== entityStart) {
        removalStart--;
      }
    }

    return {
      start: removalStart,
      end: removalEnd
    };
  }
};

module.exports = DraftEntitySegments;

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getRangesForDraftEntity
 * @format
 * 
 */



var invariant = __webpack_require__(10);

/**
 * Obtain the start and end positions of the range that has the
 * specified entity applied to it.
 *
 * Entity keys are applied only to contiguous stretches of text, so this
 * method searches for the first instance of the entity key and returns
 * the subsequent range.
 */
function getRangesForDraftEntity(block, key) {
  var ranges = [];
  block.findEntityRanges(function (c) {
    return c.getEntity() === key;
  }, function (start, end) {
    ranges.push({ start: start, end: end });
  });

  !!!ranges.length ?  true ? invariant(false, 'Entity key not found in this range.') : invariant(false) : void 0;

  return ranges;
}

module.exports = getRangesForDraftEntity;

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule insertFragmentIntoContentState
 * @format
 * 
 */



var BlockMapBuilder = __webpack_require__(340);
var ContentBlockNode = __webpack_require__(328);
var Immutable = __webpack_require__(324);

var insertIntoList = __webpack_require__(362);
var invariant = __webpack_require__(10);
var randomizeBlockMapKeys = __webpack_require__(360);

var List = Immutable.List;


var updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {
  var targetBlock = blockMap.get(targetKey);
  var text = targetBlock.getText();
  var chars = targetBlock.getCharacterList();
  var finalKey = targetKey;
  var finalOffset = targetOffset + fragmentBlock.getText().length;

  var newBlock = targetBlock.merge({
    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),
    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),
    data: fragmentBlock.getData()
  });

  return contentState.merge({
    blockMap: blockMap.set(targetKey, newBlock),
    selectionBefore: selectionState,
    selectionAfter: selectionState.merge({
      anchorKey: finalKey,
      anchorOffset: finalOffset,
      focusKey: finalKey,
      focusOffset: finalOffset,
      isBackward: false
    })
  });
};

/**
 * Appends text/characterList from the fragment first block to
 * target block.
 */
var updateHead = function updateHead(block, targetOffset, fragment) {
  var text = block.getText();
  var chars = block.getCharacterList();

  // Modify head portion of block.
  var headText = text.slice(0, targetOffset);
  var headCharacters = chars.slice(0, targetOffset);
  var appendToHead = fragment.first();

  return block.merge({
    text: headText + appendToHead.getText(),
    characterList: headCharacters.concat(appendToHead.getCharacterList()),
    type: headText ? block.getType() : appendToHead.getType(),
    data: appendToHead.getData()
  });
};

/**
 * Appends offset text/characterList from the target block to the last
 * fragment block.
 */
var updateTail = function updateTail(block, targetOffset, fragment) {
  // Modify tail portion of block.
  var text = block.getText();
  var chars = block.getCharacterList();

  // Modify head portion of block.
  var blockSize = text.length;
  var tailText = text.slice(targetOffset, blockSize);
  var tailCharacters = chars.slice(targetOffset, blockSize);
  var prependToTail = fragment.last();

  return prependToTail.merge({
    text: prependToTail.getText() + tailText,
    characterList: prependToTail.getCharacterList().concat(tailCharacters),
    data: prependToTail.getData()
  });
};

var getRootBlocks = function getRootBlocks(block, blockMap) {
  var headKey = block.getKey();
  var rootBlock = block;
  var rootBlocks = [];

  // sometimes the fragment head block will not be part of the blockMap itself this can happen when
  // the fragment head is used to update the target block, however when this does not happen we need
  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a
  // fragment root block
  if (blockMap.get(headKey)) {
    rootBlocks.push(headKey);
  }

  while (rootBlock && rootBlock.getNextSiblingKey()) {
    var lastSiblingKey = rootBlock.getNextSiblingKey();

    if (!lastSiblingKey) {
      break;
    }

    rootBlocks.push(lastSiblingKey);
    rootBlock = blockMap.get(lastSiblingKey);
  }

  return rootBlocks;
};

var updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {
  return blockMap.withMutations(function (blockMapState) {
    var targetKey = targetBlock.getKey();
    var headKey = fragmentHeadBlock.getKey();
    var targetNextKey = targetBlock.getNextSiblingKey();
    var targetParentKey = targetBlock.getParentKey();
    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);
    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];

    if (blockMapState.get(headKey)) {
      // update the fragment head when it is part of the blockMap otherwise
      blockMapState.setIn([targetKey, 'nextSibling'], headKey);
      blockMapState.setIn([headKey, 'prevSibling'], targetKey);
    } else {
      // update the target block that had the fragment head contents merged into it
      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());
      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);
    }

    // update the last root block fragment
    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey);

    // update the original target next block
    if (targetNextKey) {
      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);
    }

    // update fragment parent links
    fragmentRootBlocks.forEach(function (blockKey) {
      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);
    });

    // update targetBlock parent child links
    if (targetParentKey) {
      var targetParent = blockMap.get(targetParentKey);
      var originalTargetParentChildKeys = targetParent.getChildKeys();

      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);
      var insertionIndex = targetBlockIndex + 1;

      var newChildrenKeysArray = originalTargetParentChildKeys.toArray();

      // insert fragment children
      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));

      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));
    }
  });
};

var insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {
  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;
  var newBlockArr = [];
  var fragmentSize = fragment.size;
  var target = blockMap.get(targetKey);
  var head = fragment.first();
  var tail = fragment.last();
  var finalOffset = tail.getLength();
  var finalKey = tail.getKey();
  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());

  blockMap.forEach(function (block, blockKey) {
    if (blockKey !== targetKey) {
      newBlockArr.push(block);
      return;
    }

    if (shouldNotUpdateFromFragmentBlock) {
      newBlockArr.push(block);
    } else {
      newBlockArr.push(updateHead(block, targetOffset, fragment));
    }

    // Insert fragment blocks after the head and before the tail.
    fragment
    // when we are updating the target block with the head fragment block we skip the first fragment
    // head since its contents have already been merged with the target block otherwise we include
    // the whole fragment
    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {
      return newBlockArr.push(fragmentBlock);
    });

    // update tail
    newBlockArr.push(updateTail(block, targetOffset, fragment));
  });

  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);

  if (isTreeBasedBlockMap) {
    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);
  }

  return contentState.merge({
    blockMap: updatedBlockMap,
    selectionBefore: selectionState,
    selectionAfter: selectionState.merge({
      anchorKey: finalKey,
      anchorOffset: finalOffset,
      focusKey: finalKey,
      focusOffset: finalOffset,
      isBackward: false
    })
  });
};

var insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {
  !selectionState.isCollapsed() ?  true ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;

  var blockMap = contentState.getBlockMap();
  var fragment = randomizeBlockMapKeys(fragmentBlockMap);
  var targetKey = selectionState.getStartKey();
  var targetOffset = selectionState.getStartOffset();

  var targetBlock = blockMap.get(targetKey);

  if (targetBlock instanceof ContentBlockNode) {
    !targetBlock.getChildKeys().isEmpty() ?  true ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;
  }

  // When we insert a fragment with a single block we simply update the target block
  // with the contents of the inserted fragment block
  if (fragment.size === 1) {
    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset);
  }

  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);
};

module.exports = insertFragmentIntoContentState;

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule insertTextIntoContentState
 * @format
 * 
 */



var Immutable = __webpack_require__(324);

var insertIntoList = __webpack_require__(362);
var invariant = __webpack_require__(10);

var Repeat = Immutable.Repeat;


function insertTextIntoContentState(contentState, selectionState, text, characterMetadata) {
  !selectionState.isCollapsed() ?  true ? invariant(false, '`insertText` should only be called with a collapsed range.') : invariant(false) : void 0;

  var len = text.length;
  if (!len) {
    return contentState;
  }

  var blockMap = contentState.getBlockMap();
  var key = selectionState.getStartKey();
  var offset = selectionState.getStartOffset();
  var block = blockMap.get(key);
  var blockText = block.getText();

  var newBlock = block.merge({
    text: blockText.slice(0, offset) + text + blockText.slice(offset, block.getLength()),
    characterList: insertIntoList(block.getCharacterList(), Repeat(characterMetadata, len).toList(), offset)
  });

  var newOffset = offset + len;

  return contentState.merge({
    blockMap: blockMap.set(key, newBlock),
    selectionAfter: selectionState.merge({
      anchorOffset: newOffset,
      focusOffset: newOffset
    })
  });
}

module.exports = insertTextIntoContentState;

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule modifyBlockForContentState
 * @format
 * 
 */



var Immutable = __webpack_require__(324);

var Map = Immutable.Map;


function modifyBlockForContentState(contentState, selectionState, operation) {
  var startKey = selectionState.getStartKey();
  var endKey = selectionState.getEndKey();
  var blockMap = contentState.getBlockMap();
  var newBlocks = blockMap.toSeq().skipUntil(function (_, k) {
    return k === startKey;
  }).takeUntil(function (_, k) {
    return k === endKey;
  }).concat(Map([[endKey, blockMap.get(endKey)]])).map(operation);

  return contentState.merge({
    blockMap: blockMap.merge(newBlocks),
    selectionBefore: selectionState,
    selectionAfter: selectionState
  });
}

module.exports = modifyBlockForContentState;

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule removeRangeFromContentState
 * @format
 * 
 */



var ContentBlockNode = __webpack_require__(328);
var Immutable = __webpack_require__(324);

var getNextDelimiterBlockKey = __webpack_require__(363);

var List = Immutable.List,
    Map = Immutable.Map;


var transformBlock = function transformBlock(key, blockMap, func) {
  if (!key) {
    return;
  }

  var block = blockMap.get(key);

  if (!block) {
    return;
  }

  blockMap.set(key, func(block));
};

/**
 * Ancestors needs to be preserved when there are non selected
 * children to make sure we do not leave any orphans behind
 */
var getAncestorsKeys = function getAncestorsKeys(blockKey, blockMap) {
  var parents = [];

  if (!blockKey) {
    return parents;
  }

  var blockNode = blockMap.get(blockKey);
  while (blockNode && blockNode.getParentKey()) {
    var parentKey = blockNode.getParentKey();
    if (parentKey) {
      parents.push(parentKey);
    }
    blockNode = parentKey ? blockMap.get(parentKey) : null;
  }

  return parents;
};

/**
 * Get all next delimiter keys until we hit a root delimiter and return
 * an array of key references
 */
var getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys(block, blockMap) {
  var nextDelimiters = [];

  if (!block) {
    return nextDelimiters;
  }

  var nextDelimiter = getNextDelimiterBlockKey(block, blockMap);
  while (nextDelimiter && blockMap.get(nextDelimiter)) {
    var _block = blockMap.get(nextDelimiter);
    nextDelimiters.push(nextDelimiter);

    // we do not need to keep checking all root node siblings, just the first occurance
    nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey(_block, blockMap) : null;
  }

  return nextDelimiters;
};

var getNextValidSibling = function getNextValidSibling(block, blockMap, originalBlockMap) {
  if (!block) {
    return null;
  }

  // note that we need to make sure we refer to the original block since this
  // function is called within a withMutations
  var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();

  while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {
    nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;
  }

  return nextValidSiblingKey;
};

var getPrevValidSibling = function getPrevValidSibling(block, blockMap, originalBlockMap) {
  if (!block) {
    return null;
  }

  // note that we need to make sure we refer to the original block since this
  // function is called within a withMutations
  var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();

  while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {
    prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;
  }

  return prevValidSiblingKey;
};

var updateBlockMapLinks = function updateBlockMapLinks(blockMap, startBlock, endBlock, originalBlockMap) {
  return blockMap.withMutations(function (blocks) {
    // update start block if its retained
    transformBlock(startBlock.getKey(), blocks, function (block) {
      return block.merge({
        nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap),
        prevSibling: getPrevValidSibling(startBlock, blocks, originalBlockMap)
      });
    });

    // update endblock if its retained
    transformBlock(endBlock.getKey(), blocks, function (block) {
      return block.merge({
        nextSibling: getNextValidSibling(endBlock, blocks, originalBlockMap),
        prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)
      });
    });

    // update start block parent ancestors
    getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function (parentKey) {
      return transformBlock(parentKey, blocks, function (block) {
        return block.merge({
          children: block.getChildKeys().filter(function (key) {
            return blocks.get(key);
          }),
          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
        });
      });
    });

    // update start block next - can only happen if startBlock == endBlock
    transformBlock(startBlock.getNextSiblingKey(), blocks, function (block) {
      return block.merge({
        prevSibling: startBlock.getPrevSiblingKey()
      });
    });

    // update start block prev
    transformBlock(startBlock.getPrevSiblingKey(), blocks, function (block) {
      return block.merge({
        nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap)
      });
    });

    // update end block next
    transformBlock(endBlock.getNextSiblingKey(), blocks, function (block) {
      return block.merge({
        prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)
      });
    });

    // update end block prev
    transformBlock(endBlock.getPrevSiblingKey(), blocks, function (block) {
      return block.merge({
        nextSibling: endBlock.getNextSiblingKey()
      });
    });

    // update end block parent ancestors
    getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function (parentKey) {
      transformBlock(parentKey, blocks, function (block) {
        return block.merge({
          children: block.getChildKeys().filter(function (key) {
            return blocks.get(key);
          }),
          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
        });
      });
    });

    // update next delimiters all the way to a root delimiter
    getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function (delimiterKey) {
      return transformBlock(delimiterKey, blocks, function (block) {
        return block.merge({
          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
        });
      });
    });
  });
};

var removeRangeFromContentState = function removeRangeFromContentState(contentState, selectionState) {
  if (selectionState.isCollapsed()) {
    return contentState;
  }

  var blockMap = contentState.getBlockMap();
  var startKey = selectionState.getStartKey();
  var startOffset = selectionState.getStartOffset();
  var endKey = selectionState.getEndKey();
  var endOffset = selectionState.getEndOffset();

  var startBlock = blockMap.get(startKey);
  var endBlock = blockMap.get(endKey);

  // we assume that ContentBlockNode and ContentBlocks are not mixed together
  var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode;

  // used to retain blocks that should not be deleted to avoid orphan children
  var parentAncestors = [];

  if (isExperimentalTreeBlock) {
    var endBlockchildrenKeys = endBlock.getChildKeys();
    var endBlockAncestors = getAncestorsKeys(endKey, blockMap);

    // endBlock has unselected sibblings so we can not remove its ancestors parents
    if (endBlock.getNextSiblingKey()) {
      parentAncestors = parentAncestors.concat(endBlockAncestors);
    }

    // endBlock has children so can not remove this block or any of its ancestors
    if (!endBlockchildrenKeys.isEmpty()) {
      parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));
    }

    // we need to retain all ancestors of the next delimiter block
    parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey(endBlock, blockMap), blockMap));
  }

  var characterList = void 0;

  if (startBlock === endBlock) {
    characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);
  } else {
    characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));
  }

  var modifiedStart = startBlock.merge({
    text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),
    characterList: characterList
  });

  var newBlocks = blockMap.toSeq().skipUntil(function (_, k) {
    return k === startKey;
  }).takeUntil(function (_, k) {
    return k === endKey;
  }).filter(function (_, k) {
    return parentAncestors.indexOf(k) === -1;
  }).concat(Map([[endKey, null]])).map(function (_, k) {
    return k === startKey ? modifiedStart : null;
  });

  var updatedBlockMap = blockMap.merge(newBlocks).filter(function (block) {
    return !!block;
  });

  if (isExperimentalTreeBlock) {
    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, startBlock, endBlock, blockMap);
  }

  return contentState.merge({
    blockMap: updatedBlockMap,
    selectionBefore: selectionState,
    selectionAfter: selectionState.merge({
      anchorKey: startKey,
      anchorOffset: startOffset,
      focusKey: startKey,
      focusOffset: startOffset,
      isBackward: false
    })
  });
};

/**
 * Maintain persistence for target list when removing characters on the
 * head and tail of the character list.
 */
var removeFromList = function removeFromList(targetList, startOffset, endOffset) {
  if (startOffset === 0) {
    while (startOffset < endOffset) {
      targetList = targetList.shift();
      startOffset++;
    }
  } else if (endOffset === targetList.count()) {
    while (endOffset > startOffset) {
      targetList = targetList.pop();
      endOffset--;
    }
  } else {
    var head = targetList.slice(0, startOffset);
    var tail = targetList.slice(endOffset);
    targetList = head.concat(tail).toList();
  }
  return targetList;
};

module.exports = removeRangeFromContentState;

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule splitBlockInContentState
 * @format
 * 
 */



var ContentBlockNode = __webpack_require__(328);
var Immutable = __webpack_require__(324);

var generateRandomKey = __webpack_require__(331);
var invariant = __webpack_require__(10);

var List = Immutable.List,
    Map = Immutable.Map;


var transformBlock = function transformBlock(key, blockMap, func) {
  if (!key) {
    return;
  }

  var block = blockMap.get(key);

  if (!block) {
    return;
  }

  blockMap.set(key, func(block));
};

var updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlock, belowBlock) {
  return blockMap.withMutations(function (blocks) {
    var originalBlockKey = originalBlock.getKey();
    var belowBlockKey = belowBlock.getKey();

    // update block parent
    transformBlock(originalBlock.getParentKey(), blocks, function (block) {
      var parentChildrenList = block.getChildKeys();
      var insertionIndex = parentChildrenList.indexOf(originalBlockKey) + 1;
      var newChildrenArray = parentChildrenList.toArray();

      newChildrenArray.splice(insertionIndex, 0, belowBlockKey);

      return block.merge({
        children: List(newChildrenArray)
      });
    });

    // update original next block
    transformBlock(originalBlock.getNextSiblingKey(), blocks, function (block) {
      return block.merge({
        prevSibling: belowBlockKey
      });
    });

    // update original block
    transformBlock(originalBlockKey, blocks, function (block) {
      return block.merge({
        nextSibling: belowBlockKey
      });
    });

    // update below block
    transformBlock(belowBlockKey, blocks, function (block) {
      return block.merge({
        prevSibling: originalBlockKey
      });
    });
  });
};

var splitBlockInContentState = function splitBlockInContentState(contentState, selectionState) {
  !selectionState.isCollapsed() ?  true ? invariant(false, 'Selection range must be collapsed.') : invariant(false) : void 0;

  var key = selectionState.getAnchorKey();
  var offset = selectionState.getAnchorOffset();
  var blockMap = contentState.getBlockMap();
  var blockToSplit = blockMap.get(key);
  var text = blockToSplit.getText();
  var chars = blockToSplit.getCharacterList();
  var keyBelow = generateRandomKey();
  var isExperimentalTreeBlock = blockToSplit instanceof ContentBlockNode;

  var blockAbove = blockToSplit.merge({
    text: text.slice(0, offset),
    characterList: chars.slice(0, offset)
  });
  var blockBelow = blockAbove.merge({
    key: keyBelow,
    text: text.slice(offset),
    characterList: chars.slice(offset),
    data: Map()
  });

  var blocksBefore = blockMap.toSeq().takeUntil(function (v) {
    return v === blockToSplit;
  });
  var blocksAfter = blockMap.toSeq().skipUntil(function (v) {
    return v === blockToSplit;
  }).rest();
  var newBlocks = blocksBefore.concat([[key, blockAbove], [keyBelow, blockBelow]], blocksAfter).toOrderedMap();

  if (isExperimentalTreeBlock) {
    !blockToSplit.getChildKeys().isEmpty() ?  true ? invariant(false, 'ContentBlockNode must not have children') : invariant(false) : void 0;

    newBlocks = updateBlockMapLinks(newBlocks, blockAbove, blockBelow);
  }

  return contentState.merge({
    blockMap: newBlocks,
    selectionBefore: selectionState,
    selectionAfter: selectionState.merge({
      anchorKey: keyBelow,
      anchorOffset: 0,
      focusKey: keyBelow,
      focusOffset: 0,
      isBackward: false
    })
  });
};

module.exports = splitBlockInContentState;

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EditorBidiService
 * @format
 * 
 */



var Immutable = __webpack_require__(324);
var UnicodeBidiService = __webpack_require__(403);

var nullthrows = __webpack_require__(329);

var OrderedMap = Immutable.OrderedMap;


var bidiService;

var EditorBidiService = {
  getDirectionMap: function getDirectionMap(content, prevBidiMap) {
    if (!bidiService) {
      bidiService = new UnicodeBidiService();
    } else {
      bidiService.reset();
    }

    var blockMap = content.getBlockMap();
    var nextBidi = blockMap.valueSeq().map(function (block) {
      return nullthrows(bidiService).getDirection(block.getText());
    });
    var bidiMap = OrderedMap(blockMap.keySeq().zip(nextBidi));

    if (prevBidiMap != null && Immutable.is(prevBidiMap, bidiMap)) {
      return prevBidiMap;
    }

    return bidiMap;
  }
};

module.exports = EditorBidiService;

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/**
 * Stateful API for text direction detection
 *
 * This class can be used in applications where you need to detect the
 * direction of a sequence of text blocks, where each direction shall be used
 * as the fallback direction for the next one.
 *
 * NOTE: A default direction, if not provided, is set based on the global
 *       direction, as defined by `UnicodeBidiDirection`.
 *
 * == Example ==
 * ```
 * var UnicodeBidiService = require('UnicodeBidiService');
 *
 * var bidiService = new UnicodeBidiService();
 *
 * ...
 *
 * bidiService.reset();
 * for (var para in paragraphs) {
 *   var dir = bidiService.getDirection(para);
 *   ...
 * }
 * ```
 *
 * Part of our implementation of Unicode Bidirectional Algorithm (UBA)
 * Unicode Standard Annex #9 (UAX9)
 * http://www.unicode.org/reports/tr9/
 */



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UnicodeBidi = __webpack_require__(366);
var UnicodeBidiDirection = __webpack_require__(350);

var invariant = __webpack_require__(10);

var UnicodeBidiService = function () {

  /**
   * Stateful class for paragraph direction detection
   *
   * @param defaultDir  Default direction of the service
   */
  function UnicodeBidiService(defaultDir) {
    _classCallCheck(this, UnicodeBidiService);

    if (!defaultDir) {
      defaultDir = UnicodeBidiDirection.getGlobalDir();
    } else {
      !UnicodeBidiDirection.isStrong(defaultDir) ?  true ? invariant(false, 'Default direction must be a strong direction (LTR or RTL)') : invariant(false) : void 0;
    }
    this._defaultDir = defaultDir;
    this.reset();
  }

  /**
   * Reset the internal state
   *
   * Instead of creating a new instance, you can just reset() your instance
   * everytime you start a new loop.
   */


  UnicodeBidiService.prototype.reset = function reset() {
    this._lastDir = this._defaultDir;
  };

  /**
   * Returns the direction of a block of text, and remembers it as the
   * fall-back direction for the next paragraph.
   *
   * @param str  A text block, e.g. paragraph, table cell, tag
   * @return     The resolved direction
   */


  UnicodeBidiService.prototype.getDirection = function getDirection(str) {
    this._lastDir = UnicodeBidi.getDirection(str, this._lastDir);
    return this._lastDir;
  };

  return UnicodeBidiService;
}();

module.exports = UnicodeBidiService;

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule moveBlockInContentState
 * @format
 * 
 */



var ContentBlockNode = __webpack_require__(328);
var Immutable = __webpack_require__(324);

var getNextDelimiterBlockKey = __webpack_require__(363);
var invariant = __webpack_require__(10);

var OrderedMap = Immutable.OrderedMap,
    List = Immutable.List;


var transformBlock = function transformBlock(key, blockMap, func) {
  if (!key) {
    return;
  }

  var block = blockMap.get(key);

  if (!block) {
    return;
  }

  blockMap.set(key, func(block));
};

var updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {
  if (!isExperimentalTreeBlock) {
    return blockMap;
  }
  // possible values of 'insertionMode' are: 'after', 'before'
  var isInsertedAfterTarget = insertionMode === 'after';

  var originalBlockKey = originalBlockToBeMoved.getKey();
  var originalTargetKey = originalTargetBlock.getKey();
  var originalParentKey = originalBlockToBeMoved.getParentKey();
  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();
  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();
  var newParentKey = originalTargetBlock.getParentKey();
  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;
  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();

  return blockMap.withMutations(function (blocks) {
    // update old parent
    transformBlock(originalParentKey, blocks, function (block) {
      var parentChildrenList = block.getChildKeys();
      return block.merge({
        children: parentChildrenList['delete'](parentChildrenList.indexOf(originalBlockKey))
      });
    });

    // update old prev
    transformBlock(originalPrevSiblingKey, blocks, function (block) {
      return block.merge({
        nextSibling: originalNextSiblingKey
      });
    });

    // update old next
    transformBlock(originalNextSiblingKey, blocks, function (block) {
      return block.merge({
        prevSibling: originalPrevSiblingKey
      });
    });

    // update new next
    transformBlock(newNextSiblingKey, blocks, function (block) {
      return block.merge({
        prevSibling: originalBlockKey
      });
    });

    // update new prev
    transformBlock(newPrevSiblingKey, blocks, function (block) {
      return block.merge({
        nextSibling: originalBlockKey
      });
    });

    // update new parent
    transformBlock(newParentKey, blocks, function (block) {
      var newParentChildrenList = block.getChildKeys();
      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);

      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;

      var newChildrenArray = newParentChildrenList.toArray();
      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);

      return block.merge({
        children: List(newChildrenArray)
      });
    });

    // update block
    transformBlock(originalBlockKey, blocks, function (block) {
      return block.merge({
        nextSibling: newNextSiblingKey,
        prevSibling: newPrevSiblingKey,
        parent: newParentKey
      });
    });
  });
};

var moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {
  !(insertionMode !== 'replace') ?  true ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;

  var targetKey = targetBlock.getKey();
  var blockKey = blockToBeMoved.getKey();

  !(blockKey !== targetKey) ?  true ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;

  var blockMap = contentState.getBlockMap();
  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;

  var blocksToBeMoved = [blockToBeMoved];
  var blockMapWithoutBlocksToBeMoved = blockMap['delete'](blockKey);

  if (isExperimentalTreeBlock) {
    blocksToBeMoved = [];
    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {
      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();
      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);

      blocks.toSeq().skipUntil(function (block) {
        return block.getKey() === blockKey;
      }).takeWhile(function (block) {
        var key = block.getKey();
        var isBlockToBeMoved = key === blockKey;
        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;
        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);

        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);
      }).forEach(function (block) {
        blocksToBeMoved.push(block);
        blocks['delete'](block.getKey());
      });
    });
  }

  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {
    return v === targetBlock;
  });

  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {
    return v === targetBlock;
  }).skip(1);

  var slicedBlocks = blocksToBeMoved.map(function (block) {
    return [block.getKey(), block];
  });

  var newBlocks = OrderedMap();

  if (insertionMode === 'before') {
    var blockBefore = contentState.getBlockBefore(targetKey);

    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ?  true ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;

    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();
  } else if (insertionMode === 'after') {
    var blockAfter = contentState.getBlockAfter(targetKey);

    !(!blockAfter || blockAfter.getKey() !== blockKey) ?  true ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;

    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();
  }

  return contentState.merge({
    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),
    selectionBefore: contentState.getSelectionAfter(),
    selectionAfter: contentState.getSelectionAfter().merge({
      anchorKey: blockKey,
      focusKey: blockKey
    })
  });
};

module.exports = moveBlockInContentState;

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CompositeDraftDecorator
 * @format
 * 
 */



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Immutable = __webpack_require__(324);

var List = Immutable.List;


var DELIMITER = '.';

/**
 * A CompositeDraftDecorator traverses through a list of DraftDecorator
 * instances to identify sections of a ContentBlock that should be rendered
 * in a "decorated" manner. For example, hashtags, mentions, and links may
 * be intended to stand out visually, be rendered as anchors, etc.
 *
 * The list of decorators supplied to the constructor will be used in the
 * order they are provided. This allows the caller to specify a priority for
 * string matching, in case of match collisions among decorators.
 *
 * For instance, I may have a link with a `#` in its text. Though this section
 * of text may match our hashtag decorator, it should not be treated as a
 * hashtag. I should therefore list my link DraftDecorator
 * before my hashtag DraftDecorator when constructing this composite
 * decorator instance.
 *
 * Thus, when a collision like this is encountered, the earlier match is
 * preserved and the new match is discarded.
 */

var CompositeDraftDecorator = function () {
  function CompositeDraftDecorator(decorators) {
    _classCallCheck(this, CompositeDraftDecorator);

    // Copy the decorator array, since we use this array order to determine
    // precedence of decoration matching. If the array is mutated externally,
    // we don't want to be affected here.
    this._decorators = decorators.slice();
  }

  CompositeDraftDecorator.prototype.getDecorations = function getDecorations(block, contentState) {
    var decorations = Array(block.getText().length).fill(null);

    this._decorators.forEach(function ( /*object*/decorator, /*number*/ii) {
      var counter = 0;
      var strategy = decorator.strategy;
      var callback = function callback( /*number*/start, /*number*/end) {
        // Find out if any of our matching range is already occupied
        // by another decorator. If so, discard the match. Otherwise, store
        // the component key for rendering.
        if (canOccupySlice(decorations, start, end)) {
          occupySlice(decorations, start, end, ii + DELIMITER + counter);
          counter++;
        }
      };
      strategy(block, callback, contentState);
    });

    return List(decorations);
  };

  CompositeDraftDecorator.prototype.getComponentForKey = function getComponentForKey(key) {
    var componentKey = parseInt(key.split(DELIMITER)[0], 10);
    return this._decorators[componentKey].component;
  };

  CompositeDraftDecorator.prototype.getPropsForKey = function getPropsForKey(key) {
    var componentKey = parseInt(key.split(DELIMITER)[0], 10);
    return this._decorators[componentKey].props;
  };

  return CompositeDraftDecorator;
}();

/**
 * Determine whether we can occupy the specified slice of the decorations
 * array.
 */


function canOccupySlice(decorations, start, end) {
  for (var ii = start; ii < end; ii++) {
    if (decorations[ii] != null) {
      return false;
    }
  }
  return true;
}

/**
 * Splice the specified component into our decoration array at the desired
 * range.
 */
function occupySlice(targetArr, start, end, componentKey) {
  for (var ii = start; ii < end; ii++) {
    targetArr[ii] = componentKey;
  }
}

module.exports = CompositeDraftDecorator;

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftEditor.react
 * @format
 * 
 * @preventMunge
 */



var _assign = __webpack_require__(18);

var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DefaultDraftBlockRenderMap = __webpack_require__(351);
var DefaultDraftInlineStyle = __webpack_require__(367);
var DraftEditorCompositionHandler = __webpack_require__(407);
var DraftEditorContents = __webpack_require__(408);
var DraftEditorDragHandler = __webpack_require__(427);
var DraftEditorEditHandler = __webpack_require__(430);
var DraftEditorPlaceholder = __webpack_require__(463);
var EditorState = __webpack_require__(325);
var React = __webpack_require__(1);
var ReactDOM = __webpack_require__(32);
var Scroll = __webpack_require__(370);
var Style = __webpack_require__(354);
var UserAgent = __webpack_require__(330);

var cx = __webpack_require__(336);
var emptyFunction = __webpack_require__(12);
var generateRandomKey = __webpack_require__(331);
var getDefaultKeyBinding = __webpack_require__(383);
var getScrollPosition = __webpack_require__(355);
var invariant = __webpack_require__(10);
var nullthrows = __webpack_require__(329);

var isIE = UserAgent.isBrowser('IE');

// IE does not support the `input` event on contentEditable, so we can't
// observe spellcheck behavior.
var allowSpellCheck = !isIE;

// Define a set of handler objects to correspond to each possible `mode`
// of editor behavior.
var handlerMap = {
  edit: DraftEditorEditHandler,
  composite: DraftEditorCompositionHandler,
  drag: DraftEditorDragHandler,
  cut: null,
  render: null
};

/**
 * `DraftEditor` is the root editor component. It composes a `contentEditable`
 * div, and provides a wide variety of useful function props for managing the
 * state of the editor. See `DraftEditorProps` for details.
 */
var DraftEditor = function (_React$Component) {
  _inherits(DraftEditor, _React$Component);

  function DraftEditor(props) {
    _classCallCheck(this, DraftEditor);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.focus = function (scrollPosition) {
      var editorState = _this.props.editorState;

      var alreadyHasFocus = editorState.getSelection().getHasFocus();
      var editorNode = ReactDOM.findDOMNode(_this.editor);

      if (!editorNode) {
        // once in a while people call 'focus' in a setTimeout, and the node has
        // been deleted, so it can be null in that case.
        return;
      }

      var scrollParent = Style.getScrollParent(editorNode);

      var _ref = scrollPosition || getScrollPosition(scrollParent),
          x = _ref.x,
          y = _ref.y;

      !(editorNode instanceof HTMLElement) ?  true ? invariant(false, 'editorNode is not an HTMLElement') : invariant(false) : void 0;
      editorNode.focus();

      // Restore scroll position
      if (scrollParent === window) {
        window.scrollTo(x, y);
      } else {
        Scroll.setTop(scrollParent, y);
      }

      // On Chrome and Safari, calling focus on contenteditable focuses the
      // cursor at the first character. This is something you don't expect when
      // you're clicking on an input element but not directly on a character.
      // Put the cursor back where it was before the blur.
      if (!alreadyHasFocus) {
        _this.update(EditorState.forceSelection(editorState, editorState.getSelection()));
      }
    };

    _this.blur = function () {
      var editorNode = ReactDOM.findDOMNode(_this.editor);
      !(editorNode instanceof HTMLElement) ?  true ? invariant(false, 'editorNode is not an HTMLElement') : invariant(false) : void 0;
      editorNode.blur();
    };

    _this.setMode = function (mode) {
      _this._handler = handlerMap[mode];
    };

    _this.exitCurrentMode = function () {
      _this.setMode('edit');
    };

    _this.restoreEditorDOM = function (scrollPosition) {
      _this.setState({ contentsKey: _this.state.contentsKey + 1 }, function () {
        _this.focus(scrollPosition);
      });
    };

    _this.setClipboard = function (clipboard) {
      _this._clipboard = clipboard;
    };

    _this.getClipboard = function () {
      return _this._clipboard;
    };

    _this.update = function (editorState) {
      _this._latestEditorState = editorState;
      _this.props.onChange(editorState);
    };

    _this.onDragEnter = function () {
      _this._dragCount++;
    };

    _this.onDragLeave = function () {
      _this._dragCount--;
      if (_this._dragCount === 0) {
        _this.exitCurrentMode();
      }
    };

    _this._blockSelectEvents = false;
    _this._clipboard = null;
    _this._handler = null;
    _this._dragCount = 0;
    _this._editorKey = props.editorKey || generateRandomKey();
    _this._placeholderAccessibilityID = 'placeholder-' + _this._editorKey;
    _this._latestEditorState = props.editorState;
    _this._latestCommittedEditorState = props.editorState;

    _this._onBeforeInput = _this._buildHandler('onBeforeInput');
    _this._onBlur = _this._buildHandler('onBlur');
    _this._onCharacterData = _this._buildHandler('onCharacterData');
    _this._onCompositionEnd = _this._buildHandler('onCompositionEnd');
    _this._onCompositionStart = _this._buildHandler('onCompositionStart');
    _this._onCopy = _this._buildHandler('onCopy');
    _this._onCut = _this._buildHandler('onCut');
    _this._onDragEnd = _this._buildHandler('onDragEnd');
    _this._onDragOver = _this._buildHandler('onDragOver');
    _this._onDragStart = _this._buildHandler('onDragStart');
    _this._onDrop = _this._buildHandler('onDrop');
    _this._onInput = _this._buildHandler('onInput');
    _this._onFocus = _this._buildHandler('onFocus');
    _this._onKeyDown = _this._buildHandler('onKeyDown');
    _this._onKeyPress = _this._buildHandler('onKeyPress');
    _this._onKeyUp = _this._buildHandler('onKeyUp');
    _this._onMouseDown = _this._buildHandler('onMouseDown');
    _this._onMouseUp = _this._buildHandler('onMouseUp');
    _this._onPaste = _this._buildHandler('onPaste');
    _this._onSelect = _this._buildHandler('onSelect');

    _this.getEditorKey = function () {
      return _this._editorKey;
    };

    // See `restoreEditorDOM()`.
    _this.state = { contentsKey: 0 };
    return _this;
  }

  /**
   * Build a method that will pass the event to the specified handler method.
   * This allows us to look up the correct handler function for the current
   * editor mode, if any has been specified.
   */


  /**
   * Define proxies that can route events to the current handler.
   */


  DraftEditor.prototype._buildHandler = function _buildHandler(eventName) {
    var _this2 = this;

    return function (e) {
      if (!_this2.props.readOnly) {
        var method = _this2._handler && _this2._handler[eventName];
        method && method(_this2, e);
      }
    };
  };

  DraftEditor.prototype._showPlaceholder = function _showPlaceholder() {
    return !!this.props.placeholder && !this.props.editorState.isInCompositionMode() && !this.props.editorState.getCurrentContent().hasText();
  };

  DraftEditor.prototype._renderPlaceholder = function _renderPlaceholder() {
    if (this._showPlaceholder()) {
      var placeHolderProps = {
        text: nullthrows(this.props.placeholder),
        editorState: this.props.editorState,
        textAlignment: this.props.textAlignment,
        accessibilityID: this._placeholderAccessibilityID
      };

      return React.createElement(DraftEditorPlaceholder, placeHolderProps);
    }
    return null;
  };

  DraftEditor.prototype.render = function render() {
    var _this3 = this;

    var _props = this.props,
        blockRenderMap = _props.blockRenderMap,
        blockRendererFn = _props.blockRendererFn,
        blockStyleFn = _props.blockStyleFn,
        customStyleFn = _props.customStyleFn,
        customStyleMap = _props.customStyleMap,
        editorState = _props.editorState,
        readOnly = _props.readOnly,
        textAlignment = _props.textAlignment,
        textDirectionality = _props.textDirectionality;


    var rootClass = cx({
      'DraftEditor/root': true,
      'DraftEditor/alignLeft': textAlignment === 'left',
      'DraftEditor/alignRight': textAlignment === 'right',
      'DraftEditor/alignCenter': textAlignment === 'center'
    });

    var contentStyle = {
      outline: 'none',
      // fix parent-draggable Safari bug. #1326
      userSelect: 'text',
      WebkitUserSelect: 'text',
      whiteSpace: 'pre-wrap',
      wordWrap: 'break-word'
    };

    // The aria-expanded and aria-haspopup properties should only be rendered
    // for a combobox.
    var ariaRole = this.props.role || 'textbox';
    var ariaExpanded = ariaRole === 'combobox' ? !!this.props.ariaExpanded : null;

    var editorContentsProps = {
      blockRenderMap: blockRenderMap,
      blockRendererFn: blockRendererFn,
      blockStyleFn: blockStyleFn,
      customStyleMap: _extends({}, DefaultDraftInlineStyle, customStyleMap),
      customStyleFn: customStyleFn,
      editorKey: this._editorKey,
      editorState: editorState,
      key: 'contents' + this.state.contentsKey,
      textDirectionality: textDirectionality
    };

    return React.createElement(
      'div',
      { className: rootClass },
      this._renderPlaceholder(),
      React.createElement(
        'div',
        {
          className: cx('DraftEditor/editorContainer'),
          ref: function ref(_ref3) {
            return _this3.editorContainer = _ref3;
          } },
        React.createElement(
          'div',
          {
            'aria-activedescendant': readOnly ? null : this.props.ariaActiveDescendantID,
            'aria-autocomplete': readOnly ? null : this.props.ariaAutoComplete,
            'aria-controls': readOnly ? null : this.props.ariaControls,
            'aria-describedby': this.props.ariaDescribedBy || this._placeholderAccessibilityID,
            'aria-expanded': readOnly ? null : ariaExpanded,
            'aria-label': this.props.ariaLabel,
            'aria-labelledby': this.props.ariaLabelledBy,
            'aria-multiline': this.props.ariaMultiline,
            autoCapitalize: this.props.autoCapitalize,
            autoComplete: this.props.autoComplete,
            autoCorrect: this.props.autoCorrect,
            className: cx({
              // Chrome's built-in translation feature mutates the DOM in ways
              // that Draft doesn't expect (ex: adding <font> tags inside
              // DraftEditorLeaf spans) and causes problems. We add notranslate
              // here which makes its autotranslation skip over this subtree.
              notranslate: !readOnly,
              'public/DraftEditor/content': true
            }),
            contentEditable: !readOnly,
            'data-testid': this.props.webDriverTestID,
            onBeforeInput: this._onBeforeInput,
            onBlur: this._onBlur,
            onCompositionEnd: this._onCompositionEnd,
            onCompositionStart: this._onCompositionStart,
            onCopy: this._onCopy,
            onCut: this._onCut,
            onDragEnd: this._onDragEnd,
            onDragEnter: this.onDragEnter,
            onDragLeave: this.onDragLeave,
            onDragOver: this._onDragOver,
            onDragStart: this._onDragStart,
            onDrop: this._onDrop,
            onFocus: this._onFocus,
            onInput: this._onInput,
            onKeyDown: this._onKeyDown,
            onKeyPress: this._onKeyPress,
            onKeyUp: this._onKeyUp,
            onMouseUp: this._onMouseUp,
            onPaste: this._onPaste,
            onSelect: this._onSelect,
            ref: function ref(_ref2) {
              return _this3.editor = _ref2;
            },
            role: readOnly ? null : ariaRole,
            spellCheck: allowSpellCheck && this.props.spellCheck,
            style: contentStyle,
            suppressContentEditableWarning: true,
            tabIndex: this.props.tabIndex },
          React.createElement(DraftEditorContents, editorContentsProps)
        )
      )
    );
  };

  DraftEditor.prototype.componentDidMount = function componentDidMount() {
    this.setMode('edit');

    /**
     * IE has a hardcoded "feature" that attempts to convert link text into
     * anchors in contentEditable DOM. This breaks the editor's expectations of
     * the DOM, and control is lost. Disable it to make IE behave.
     * See: http://blogs.msdn.com/b/ieinternals/archive/2010/09/15/
     * ie9-beta-minor-change-list.aspx
     */
    if (isIE) {
      document.execCommand('AutoUrlDetect', false, false);
    }
  };

  /**
   * Prevent selection events from affecting the current editor state. This
   * is mostly intended to defend against IE, which fires off `selectionchange`
   * events regardless of whether the selection is set via the browser or
   * programmatically. We only care about selection events that occur because
   * of browser interaction, not re-renders and forced selections.
   */


  DraftEditor.prototype.componentWillUpdate = function componentWillUpdate(nextProps) {
    this._blockSelectEvents = true;
    this._latestEditorState = nextProps.editorState;
  };

  DraftEditor.prototype.componentDidUpdate = function componentDidUpdate() {
    this._blockSelectEvents = false;
    this._latestCommittedEditorState = this.props.editorState;
  };

  /**
   * Used via `this.focus()`.
   *
   * Force focus back onto the editor node.
   *
   * We attempt to preserve scroll position when focusing. You can also pass
   * a specified scroll position (for cases like `cut` behavior where it should
   * be restored to a known position).
   */


  /**
   * Used via `this.setMode(...)`.
   *
   * Set the behavior mode for the editor component. This switches the current
   * handler module to ensure that DOM events are managed appropriately for
   * the active mode.
   */


  /**
   * Used via `this.restoreEditorDOM()`.
   *
   * Force a complete re-render of the DraftEditorContents based on the current
   * EditorState. This is useful when we know we are going to lose control of
   * the DOM state (cut command, IME) and we want to make sure that
   * reconciliation occurs on a version of the DOM that is synchronized with
   * our EditorState.
   */


  /**
   * Used via `this.setClipboard(...)`.
   *
   * Set the clipboard state for a cut/copy event.
   */


  /**
   * Used via `this.getClipboard()`.
   *
   * Retrieve the clipboard state for a cut/copy event.
   */


  /**
   * Used via `this.update(...)`.
   *
   * Propagate a new `EditorState` object to higher-level components. This is
   * the method by which event handlers inform the `DraftEditor` component of
   * state changes. A component that composes a `DraftEditor` **must** provide
   * an `onChange` prop to receive state updates passed along from this
   * function.
   */


  /**
   * Used in conjunction with `onDragLeave()`, by counting the number of times
   * a dragged element enters and leaves the editor (or any of its children),
   * to determine when the dragged element absolutely leaves the editor.
   */


  /**
   * See `onDragEnter()`.
   */


  return DraftEditor;
}(React.Component);

DraftEditor.defaultProps = {
  blockRenderMap: DefaultDraftBlockRenderMap,
  blockRendererFn: emptyFunction.thatReturnsNull,
  blockStyleFn: emptyFunction.thatReturns(''),
  keyBindingFn: getDefaultKeyBinding,
  readOnly: false,
  spellCheck: false,
  stripPastedStyles: false
};


module.exports = DraftEditor;

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftEditorCompositionHandler
 * @format
 * 
 */



var DraftFeatureFlags = __webpack_require__(332);
var DraftModifier = __webpack_require__(326);
var EditorState = __webpack_require__(325);
var Keys = __webpack_require__(352);

var getEntityKeyForSelection = __webpack_require__(353);
var isEventHandled = __webpack_require__(342);
var isSelectionAtLeafStart = __webpack_require__(368);

/**
 * Millisecond delay to allow `compositionstart` to fire again upon
 * `compositionend`.
 *
 * This is used for Korean input to ensure that typing can continue without
 * the editor trying to render too quickly. More specifically, Safari 7.1+
 * triggers `compositionstart` a little slower than Chrome/FF, which
 * leads to composed characters being resolved and re-render occurring
 * sooner than we want.
 */
var RESOLVE_DELAY = 20;

/**
 * A handful of variables used to track the current composition and its
 * resolution status. These exist at the module level because it is not
 * possible to have compositions occurring in multiple editors simultaneously,
 * and it simplifies state management with respect to the DraftEditor component.
 */
var resolved = false;
var stillComposing = false;
var textInputData = '';

var DraftEditorCompositionHandler = {
  onBeforeInput: function onBeforeInput(editor, e) {
    textInputData = (textInputData || '') + e.data;
  },

  /**
   * A `compositionstart` event has fired while we're still in composition
   * mode. Continue the current composition session to prevent a re-render.
   */
  onCompositionStart: function onCompositionStart(editor) {
    stillComposing = true;
  },

  /**
   * Attempt to end the current composition session.
   *
   * Defer handling because browser will still insert the chars into active
   * element after `compositionend`. If a `compositionstart` event fires
   * before `resolveComposition` executes, our composition session will
   * continue.
   *
   * The `resolved` flag is useful because certain IME interfaces fire the
   * `compositionend` event multiple times, thus queueing up multiple attempts
   * at handling the composition. Since handling the same composition event
   * twice could break the DOM, we only use the first event. Example: Arabic
   * Google Input Tools on Windows 8.1 fires `compositionend` three times.
   */
  onCompositionEnd: function onCompositionEnd(editor) {
    resolved = false;
    stillComposing = false;
    setTimeout(function () {
      if (!resolved) {
        DraftEditorCompositionHandler.resolveComposition(editor);
      }
    }, RESOLVE_DELAY);
  },

  /**
   * In Safari, keydown events may fire when committing compositions. If
   * the arrow keys are used to commit, prevent default so that the cursor
   * doesn't move, otherwise it will jump back noticeably on re-render.
   */
  onKeyDown: function onKeyDown(editor, e) {
    if (!stillComposing) {
      // If a keydown event is received after compositionend but before the
      // 20ms timer expires (ex: type option-E then backspace, or type A then
      // backspace in 2-Set Korean), we should immediately resolve the
      // composition and reinterpret the key press in edit mode.
      DraftEditorCompositionHandler.resolveComposition(editor);
      editor._onKeyDown(e);
      return;
    }
    if (e.which === Keys.RIGHT || e.which === Keys.LEFT) {
      e.preventDefault();
    }
  },

  /**
   * Keypress events may fire when committing compositions. In Firefox,
   * pressing RETURN commits the composition and inserts extra newline
   * characters that we do not want. `preventDefault` allows the composition
   * to be committed while preventing the extra characters.
   */
  onKeyPress: function onKeyPress(editor, e) {
    if (e.which === Keys.RETURN) {
      e.preventDefault();
    }
  },

  /**
   * Attempt to insert composed characters into the document.
   *
   * If we are still in a composition session, do nothing. Otherwise, insert
   * the characters into the document and terminate the composition session.
   *
   * If no characters were composed -- for instance, the user
   * deleted all composed characters and committed nothing new --
   * force a re-render. We also re-render when the composition occurs
   * at the beginning of a leaf, to ensure that if the browser has
   * created a new text node for the composition, we will discard it.
   *
   * Resetting innerHTML will move focus to the beginning of the editor,
   * so we update to force it back to the correct place.
   */
  resolveComposition: function resolveComposition(editor) {
    if (stillComposing) {
      return;
    }

    resolved = true;
    var composedChars = textInputData;
    textInputData = '';

    var editorState = EditorState.set(editor._latestEditorState, {
      inCompositionMode: false
    });

    var currentStyle = editorState.getCurrentInlineStyle();
    var entityKey = getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection());

    var mustReset = !composedChars || isSelectionAtLeafStart(editorState) || currentStyle.size > 0 || entityKey !== null;

    if (mustReset) {
      editor.restoreEditorDOM();
    }

    editor.exitCurrentMode();

    if (composedChars) {
      if (DraftFeatureFlags.draft_handlebeforeinput_composed_text && editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(composedChars, editorState))) {
        return;
      }
      // If characters have been composed, re-rendering with the update
      // is sufficient to reset the editor.
      var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), composedChars, currentStyle, entityKey);
      editor.update(EditorState.push(editorState, contentState, 'insert-characters'));
      return;
    }

    if (mustReset) {
      editor.update(EditorState.set(editorState, {
        nativelyRenderedContent: null,
        forceSelection: true
      }));
    }
  }
};

module.exports = DraftEditorCompositionHandler;

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftEditorContents.react
 * @format
 * 
 */



var DraftEditorContents = __webpack_require__(409);

module.exports = DraftEditorContents;

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftEditorContents-core.react
 * @format
 * 
 */



var _assign = __webpack_require__(18);

var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DraftEditorBlock = __webpack_require__(369);
var DraftOffsetKey = __webpack_require__(347);
var EditorState = __webpack_require__(325);
var React = __webpack_require__(1);

var cx = __webpack_require__(336);
var joinClasses = __webpack_require__(426);
var nullthrows = __webpack_require__(329);

/**
 * Provide default styling for list items. This way, lists will be styled with
 * proper counters and indentation even if the caller does not specify
 * their own styling at all. If more than five levels of nesting are needed,
 * the necessary CSS classes can be provided via `blockStyleFn` configuration.
 */
var getListItemClasses = function getListItemClasses(type, depth, shouldResetCount, direction) {
  return cx({
    'public/DraftStyleDefault/unorderedListItem': type === 'unordered-list-item',
    'public/DraftStyleDefault/orderedListItem': type === 'ordered-list-item',
    'public/DraftStyleDefault/reset': shouldResetCount,
    'public/DraftStyleDefault/depth0': depth === 0,
    'public/DraftStyleDefault/depth1': depth === 1,
    'public/DraftStyleDefault/depth2': depth === 2,
    'public/DraftStyleDefault/depth3': depth === 3,
    'public/DraftStyleDefault/depth4': depth === 4,
    'public/DraftStyleDefault/listLTR': direction === 'LTR',
    'public/DraftStyleDefault/listRTL': direction === 'RTL'
  });
};

/**
 * `DraftEditorContents` is the container component for all block components
 * rendered for a `DraftEditor`. It is optimized to aggressively avoid
 * re-rendering blocks whenever possible.
 *
 * This component is separate from `DraftEditor` because certain props
 * (for instance, ARIA props) must be allowed to update without affecting
 * the contents of the editor.
 */

var DraftEditorContents = function (_React$Component) {
  _inherits(DraftEditorContents, _React$Component);

  function DraftEditorContents() {
    _classCallCheck(this, DraftEditorContents);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  DraftEditorContents.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    var prevEditorState = this.props.editorState;
    var nextEditorState = nextProps.editorState;

    var prevDirectionMap = prevEditorState.getDirectionMap();
    var nextDirectionMap = nextEditorState.getDirectionMap();

    // Text direction has changed for one or more blocks. We must re-render.
    if (prevDirectionMap !== nextDirectionMap) {
      return true;
    }

    var didHaveFocus = prevEditorState.getSelection().getHasFocus();
    var nowHasFocus = nextEditorState.getSelection().getHasFocus();

    if (didHaveFocus !== nowHasFocus) {
      return true;
    }

    var nextNativeContent = nextEditorState.getNativelyRenderedContent();

    var wasComposing = prevEditorState.isInCompositionMode();
    var nowComposing = nextEditorState.isInCompositionMode();

    // If the state is unchanged or we're currently rendering a natively
    // rendered state, there's nothing new to be done.
    if (prevEditorState === nextEditorState || nextNativeContent !== null && nextEditorState.getCurrentContent() === nextNativeContent || wasComposing && nowComposing) {
      return false;
    }

    var prevContent = prevEditorState.getCurrentContent();
    var nextContent = nextEditorState.getCurrentContent();
    var prevDecorator = prevEditorState.getDecorator();
    var nextDecorator = nextEditorState.getDecorator();
    return wasComposing !== nowComposing || prevContent !== nextContent || prevDecorator !== nextDecorator || nextEditorState.mustForceSelection();
  };

  DraftEditorContents.prototype.render = function render() {
    var _props = this.props,
        blockRenderMap = _props.blockRenderMap,
        blockRendererFn = _props.blockRendererFn,
        blockStyleFn = _props.blockStyleFn,
        customStyleMap = _props.customStyleMap,
        customStyleFn = _props.customStyleFn,
        editorState = _props.editorState,
        editorKey = _props.editorKey,
        textDirectionality = _props.textDirectionality;


    var content = editorState.getCurrentContent();
    var selection = editorState.getSelection();
    var forceSelection = editorState.mustForceSelection();
    var decorator = editorState.getDecorator();
    var directionMap = nullthrows(editorState.getDirectionMap());

    var blocksAsArray = content.getBlocksAsArray();
    var processedBlocks = [];

    var currentDepth = null;
    var lastWrapperTemplate = null;

    for (var ii = 0; ii < blocksAsArray.length; ii++) {
      var _block = blocksAsArray[ii];
      var key = _block.getKey();
      var blockType = _block.getType();

      var customRenderer = blockRendererFn(_block);
      var CustomComponent = void 0,
          customProps = void 0,
          customEditable = void 0;
      if (customRenderer) {
        CustomComponent = customRenderer.component;
        customProps = customRenderer.props;
        customEditable = customRenderer.editable;
      }

      var direction = textDirectionality ? textDirectionality : directionMap.get(key);
      var offsetKey = DraftOffsetKey.encode(key, 0, 0);
      var componentProps = {
        contentState: content,
        block: _block,
        blockProps: customProps,
        blockStyleFn: blockStyleFn,
        customStyleMap: customStyleMap,
        customStyleFn: customStyleFn,
        decorator: decorator,
        direction: direction,
        forceSelection: forceSelection,
        key: key,
        offsetKey: offsetKey,
        selection: selection,
        tree: editorState.getBlockTree(key)
      };

      var configForType = blockRenderMap.get(blockType) || blockRenderMap.get('unstyled');
      var wrapperTemplate = configForType.wrapper;

      var Element = configForType.element || blockRenderMap.get('unstyled').element;

      var depth = _block.getDepth();
      var className = '';
      if (blockStyleFn) {
        className = blockStyleFn(_block);
      }

      // List items are special snowflakes, since we handle nesting and
      // counters manually.
      if (Element === 'li') {
        var shouldResetCount = lastWrapperTemplate !== wrapperTemplate || currentDepth === null || depth > currentDepth;
        className = joinClasses(className, getListItemClasses(blockType, depth, shouldResetCount, direction));
      }

      var Component = CustomComponent || DraftEditorBlock;
      var childProps = {
        className: className,
        'data-block': true,
        'data-editor': editorKey,
        'data-offset-key': offsetKey,
        key: key
      };
      if (customEditable !== undefined) {
        childProps = _extends({}, childProps, {
          contentEditable: customEditable,
          suppressContentEditableWarning: true
        });
      }

      var child = React.createElement(Element, childProps, React.createElement(Component, componentProps));

      processedBlocks.push({
        block: child,
        wrapperTemplate: wrapperTemplate,
        key: key,
        offsetKey: offsetKey
      });

      if (wrapperTemplate) {
        currentDepth = _block.getDepth();
      } else {
        currentDepth = null;
      }
      lastWrapperTemplate = wrapperTemplate;
    }

    // Group contiguous runs of blocks that have the same wrapperTemplate
    var outputBlocks = [];
    for (var _ii = 0; _ii < processedBlocks.length;) {
      var info = processedBlocks[_ii];
      if (info.wrapperTemplate) {
        var blocks = [];
        do {
          blocks.push(processedBlocks[_ii].block);
          _ii++;
        } while (_ii < processedBlocks.length && processedBlocks[_ii].wrapperTemplate === info.wrapperTemplate);
        var wrapperElement = React.cloneElement(info.wrapperTemplate, {
          key: info.key + '-wrap',
          'data-offset-key': info.offsetKey
        }, blocks);
        outputBlocks.push(wrapperElement);
      } else {
        outputBlocks.push(info.block);
        _ii++;
      }
    }

    return React.createElement(
      'div',
      { 'data-contents': 'true' },
      outputBlocks
    );
  };

  return DraftEditorContents;
}(React.Component);

module.exports = DraftEditorContents;

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftEditorLeaf.react
 * @format
 * 
 */



var _assign = __webpack_require__(18);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DraftEditorTextNode = __webpack_require__(411);
var React = __webpack_require__(1);
var ReactDOM = __webpack_require__(32);

var invariant = __webpack_require__(10);
var setDraftEditorSelection = __webpack_require__(418);

/**
 * All leaf nodes in the editor are spans with single text nodes. Leaf
 * elements are styled based on the merging of an optional custom style map
 * and a default style map.
 *
 * `DraftEditorLeaf` also provides a wrapper for calling into the imperative
 * DOM Selection API. In this way, top-level components can declaratively
 * maintain the selection state.
 */
var DraftEditorLeaf = function (_React$Component) {
  _inherits(DraftEditorLeaf, _React$Component);

  function DraftEditorLeaf() {
    _classCallCheck(this, DraftEditorLeaf);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  DraftEditorLeaf.prototype._setSelection = function _setSelection() {
    var selection = this.props.selection;

    // If selection state is irrelevant to the parent block, no-op.

    if (selection == null || !selection.getHasFocus()) {
      return;
    }

    var _props = this.props,
        block = _props.block,
        start = _props.start,
        text = _props.text;

    var blockKey = block.getKey();
    var end = start + text.length;
    if (!selection.hasEdgeWithin(blockKey, start, end)) {
      return;
    }

    // Determine the appropriate target node for selection. If the child
    // is not a text node, it is a <br /> spacer. In this case, use the
    // <span> itself as the selection target.
    var node = ReactDOM.findDOMNode(this);
    !node ?  true ? invariant(false, 'Missing node') : invariant(false) : void 0;
    var child = node.firstChild;
    !child ?  true ? invariant(false, 'Missing child') : invariant(false) : void 0;
    var targetNode = void 0;

    if (child.nodeType === Node.TEXT_NODE) {
      targetNode = child;
    } else if (child.tagName === 'BR') {
      targetNode = node;
    } else {
      targetNode = child.firstChild;
      !targetNode ?  true ? invariant(false, 'Missing targetNode') : invariant(false) : void 0;
    }

    setDraftEditorSelection(selection, targetNode, blockKey, start, end);
  };
  /**
   * By making individual leaf instances aware of their context within
   * the text of the editor, we can set our selection range more
   * easily than we could in the non-React world.
   *
   * Note that this depends on our maintaining tight control over the
   * DOM structure of the DraftEditor component. If leaves had multiple
   * text nodes, this would be harder.
   */

  DraftEditorLeaf.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    var leafNode = ReactDOM.findDOMNode(this.leaf);
    !leafNode ?  true ? invariant(false, 'Missing leafNode') : invariant(false) : void 0;
    return leafNode.textContent !== nextProps.text || nextProps.styleSet !== this.props.styleSet || nextProps.forceSelection;
  };

  DraftEditorLeaf.prototype.componentDidUpdate = function componentDidUpdate() {
    this._setSelection();
  };

  DraftEditorLeaf.prototype.componentDidMount = function componentDidMount() {
    this._setSelection();
  };

  DraftEditorLeaf.prototype.render = function render() {
    var _this2 = this;

    var block = this.props.block;
    var text = this.props.text;

    // If the leaf is at the end of its block and ends in a soft newline, append
    // an extra line feed character. Browsers collapse trailing newline
    // characters, which leaves the cursor in the wrong place after a
    // shift+enter. The extra character repairs this.

    if (text.endsWith('\n') && this.props.isLast) {
      text += '\n';
    }

    var _props2 = this.props,
        customStyleMap = _props2.customStyleMap,
        customStyleFn = _props2.customStyleFn,
        offsetKey = _props2.offsetKey,
        styleSet = _props2.styleSet;

    var styleObj = styleSet.reduce(function (map, styleName) {
      var mergedStyles = {};
      var style = customStyleMap[styleName];

      if (style !== undefined && map.textDecoration !== style.textDecoration) {
        // .trim() is necessary for IE9/10/11 and Edge
        mergedStyles.textDecoration = [map.textDecoration, style.textDecoration].join(' ').trim();
      }

      return _assign(map, style, mergedStyles);
    }, {});

    if (customStyleFn) {
      var newStyles = customStyleFn(styleSet, block);
      styleObj = _assign(styleObj, newStyles);
    }

    return React.createElement(
      'span',
      {
        'data-offset-key': offsetKey,
        ref: function ref(_ref) {
          return _this2.leaf = _ref;
        },
        style: styleObj },
      React.createElement(
        DraftEditorTextNode,
        null,
        text
      )
    );
  };

  return DraftEditorLeaf;
}(React.Component);

module.exports = DraftEditorLeaf;

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftEditorTextNode.react
 * @format
 * 
 */



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = __webpack_require__(1);
var ReactDOM = __webpack_require__(32);
var UserAgent = __webpack_require__(330);

var invariant = __webpack_require__(10);

// In IE, spans with <br> tags render as two newlines. By rendering a span
// with only a newline character, we can be sure to render a single line.
var useNewlineChar = UserAgent.isBrowser('IE <= 11');

/**
 * Check whether the node should be considered a newline.
 */
function isNewline(node) {
  return useNewlineChar ? node.textContent === '\n' : node.tagName === 'BR';
}

/**
 * Placeholder elements for empty text content.
 *
 * What is this `data-text` attribute, anyway? It turns out that we need to
 * put an attribute on the lowest-level text node in order to preserve correct
 * spellcheck handling. If the <span> is naked, Chrome and Safari may do
 * bizarre things to do the DOM -- split text nodes, create extra spans, etc.
 * If the <span> has an attribute, this appears not to happen.
 * See http://jsfiddle.net/9khdavod/ for the failure case, and
 * http://jsfiddle.net/7pg143f7/ for the fixed case.
 */
var NEWLINE_A = useNewlineChar ? React.createElement(
  'span',
  { key: 'A', 'data-text': 'true' },
  '\n'
) : React.createElement('br', { key: 'A', 'data-text': 'true' });

var NEWLINE_B = useNewlineChar ? React.createElement(
  'span',
  { key: 'B', 'data-text': 'true' },
  '\n'
) : React.createElement('br', { key: 'B', 'data-text': 'true' });

/**
 * The lowest-level component in a `DraftEditor`, the text node component
 * replaces the default React text node implementation. This allows us to
 * perform custom handling of newline behavior and avoid re-rendering text
 * nodes with DOM state that already matches the expectations of our immutable
 * editor state.
 */
var DraftEditorTextNode = function (_React$Component) {
  _inherits(DraftEditorTextNode, _React$Component);

  function DraftEditorTextNode(props) {
    _classCallCheck(this, DraftEditorTextNode);

    // By flipping this flag, we also keep flipping keys which forces
    // React to remount this node every time it rerenders.
    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this._forceFlag = false;
    return _this;
  }

  DraftEditorTextNode.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    var node = ReactDOM.findDOMNode(this);
    var shouldBeNewline = nextProps.children === '';
    !(node instanceof Element) ?  true ? invariant(false, 'node is not an Element') : invariant(false) : void 0;
    if (shouldBeNewline) {
      return !isNewline(node);
    }
    return node.textContent !== nextProps.children;
  };

  DraftEditorTextNode.prototype.componentDidMount = function componentDidMount() {
    this._forceFlag = !this._forceFlag;
  };

  DraftEditorTextNode.prototype.componentDidUpdate = function componentDidUpdate() {
    this._forceFlag = !this._forceFlag;
  };

  DraftEditorTextNode.prototype.render = function render() {
    if (this.props.children === '') {
      return this._forceFlag ? NEWLINE_A : NEWLINE_B;
    }
    return React.createElement(
      'span',
      { key: this._forceFlag ? 'A' : 'B', 'data-text': 'true' },
      this.props.children
    );
  };

  return DraftEditorTextNode;
}(React.Component);

module.exports = DraftEditorTextNode;

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * Usage note:
 * This module makes a best effort to export the same data we would internally.
 * At Facebook we use a server-generated module that does the parsing and
 * exports the data for the client to use. We can't rely on a server-side
 * implementation in open source so instead we make use of an open source
 * library to do the heavy lifting and then make some adjustments as necessary.
 * It's likely there will be some differences. Some we can smooth over.
 * Others are going to be harder.
 */



var UAParser = __webpack_require__(413);

var UNKNOWN = 'Unknown';

var PLATFORM_MAP = {
  'Mac OS': 'Mac OS X'
};

/**
 * Convert from UAParser platform name to what we expect.
 */
function convertPlatformName(name) {
  return PLATFORM_MAP[name] || name;
}

/**
 * Get the version number in parts. This is very naive. We actually get major
 * version as a part of UAParser already, which is generally good enough, but
 * let's get the minor just in case.
 */
function getBrowserVersion(version) {
  if (!version) {
    return {
      major: '',
      minor: ''
    };
  }
  var parts = version.split('.');
  return {
    major: parts[0],
    minor: parts[1]
  };
}

/**
 * Get the UA data fom UAParser and then convert it to the format we're
 * expecting for our APIS.
 */
var parser = new UAParser();
var results = parser.getResult();

// Do some conversion first.
var browserVersionData = getBrowserVersion(results.browser.version);
var uaData = {
  browserArchitecture: results.cpu.architecture || UNKNOWN,
  browserFullVersion: results.browser.version || UNKNOWN,
  browserMinorVersion: browserVersionData.minor || UNKNOWN,
  browserName: results.browser.name || UNKNOWN,
  browserVersion: results.browser.major || UNKNOWN,
  deviceName: results.device.model || UNKNOWN,
  engineName: results.engine.name || UNKNOWN,
  engineVersion: results.engine.version || UNKNOWN,
  platformArchitecture: results.cpu.architecture || UNKNOWN,
  platformName: convertPlatformName(results.os.name) || UNKNOWN,
  platformVersion: results.os.version || UNKNOWN,
  platformFullVersion: results.os.version || UNKNOWN
};

module.exports = uaData;

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * UAParser.js v0.7.17
 * Lightweight JavaScript-based User-Agent string parser
 * https://github.com/faisalman/ua-parser-js
 *
 * Copyright © 2012-2016 Faisal Salman <fyzlman@gmail.com>
 * Dual licensed under GPLv2 & MIT
 */

(function (window, undefined) {

    'use strict';

    //////////////
    // Constants
    /////////////


    var LIBVERSION  = '0.7.17',
        EMPTY       = '',
        UNKNOWN     = '?',
        FUNC_TYPE   = 'function',
        UNDEF_TYPE  = 'undefined',
        OBJ_TYPE    = 'object',
        STR_TYPE    = 'string',
        MAJOR       = 'major', // deprecated
        MODEL       = 'model',
        NAME        = 'name',
        TYPE        = 'type',
        VENDOR      = 'vendor',
        VERSION     = 'version',
        ARCHITECTURE= 'architecture',
        CONSOLE     = 'console',
        MOBILE      = 'mobile',
        TABLET      = 'tablet',
        SMARTTV     = 'smarttv',
        WEARABLE    = 'wearable',
        EMBEDDED    = 'embedded';


    ///////////
    // Helper
    //////////


    var util = {
        extend : function (regexes, extensions) {
            var margedRegexes = {};
            for (var i in regexes) {
                if (extensions[i] && extensions[i].length % 2 === 0) {
                    margedRegexes[i] = extensions[i].concat(regexes[i]);
                } else {
                    margedRegexes[i] = regexes[i];
                }
            }
            return margedRegexes;
        },
        has : function (str1, str2) {
          if (typeof str1 === "string") {
            return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
          } else {
            return false;
          }
        },
        lowerize : function (str) {
            return str.toLowerCase();
        },
        major : function (version) {
            return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g,'').split(".")[0] : undefined;
        },
        trim : function (str) {
          return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
        }
    };


    ///////////////
    // Map helper
    //////////////


    var mapper = {

        rgx : function (ua, arrays) {

            //var result = {},
            var i = 0, j, k, p, q, matches, match;//, args = arguments;

            /*// construct object barebones
            for (p = 0; p < args[1].length; p++) {
                q = args[1][p];
                result[typeof q === OBJ_TYPE ? q[0] : q] = undefined;
            }*/

            // loop through all regexes maps
            while (i < arrays.length && !matches) {

                var regex = arrays[i],       // even sequence (0,2,4,..)
                    props = arrays[i + 1];   // odd sequence (1,3,5,..)
                j = k = 0;

                // try matching uastring with regexes
                while (j < regex.length && !matches) {

                    matches = regex[j++].exec(ua);

                    if (!!matches) {
                        for (p = 0; p < props.length; p++) {
                            match = matches[++k];
                            q = props[p];
                            // check if given property is actually array
                            if (typeof q === OBJ_TYPE && q.length > 0) {
                                if (q.length == 2) {
                                    if (typeof q[1] == FUNC_TYPE) {
                                        // assign modified match
                                        this[q[0]] = q[1].call(this, match);
                                    } else {
                                        // assign given value, ignore regex match
                                        this[q[0]] = q[1];
                                    }
                                } else if (q.length == 3) {
                                    // check whether function or regex
                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                        // call function (usually string mapper)
                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                    } else {
                                        // sanitize match using given regex
                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                    }
                                } else if (q.length == 4) {
                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                }
                            } else {
                                this[q] = match ? match : undefined;
                            }
                        }
                    }
                }
                i += 2;
            }
            // console.log(this);
            //return this;
        },

        str : function (str, map) {

            for (var i in map) {
                // check if array
                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                    for (var j = 0; j < map[i].length; j++) {
                        if (util.has(map[i][j], str)) {
                            return (i === UNKNOWN) ? undefined : i;
                        }
                    }
                } else if (util.has(map[i], str)) {
                    return (i === UNKNOWN) ? undefined : i;
                }
            }
            return str;
        }
    };


    ///////////////
    // String map
    //////////////


    var maps = {

        browser : {
            oldsafari : {
                version : {
                    '1.0'   : '/8',
                    '1.2'   : '/1',
                    '1.3'   : '/3',
                    '2.0'   : '/412',
                    '2.0.2' : '/416',
                    '2.0.3' : '/417',
                    '2.0.4' : '/419',
                    '?'     : '/'
                }
            }
        },

        device : {
            amazon : {
                model : {
                    'Fire Phone' : ['SD', 'KF']
                }
            },
            sprint : {
                model : {
                    'Evo Shift 4G' : '7373KT'
                },
                vendor : {
                    'HTC'       : 'APA',
                    'Sprint'    : 'Sprint'
                }
            }
        },

        os : {
            windows : {
                version : {
                    'ME'        : '4.90',
                    'NT 3.11'   : 'NT3.51',
                    'NT 4.0'    : 'NT4.0',
                    '2000'      : 'NT 5.0',
                    'XP'        : ['NT 5.1', 'NT 5.2'],
                    'Vista'     : 'NT 6.0',
                    '7'         : 'NT 6.1',
                    '8'         : 'NT 6.2',
                    '8.1'       : 'NT 6.3',
                    '10'        : ['NT 6.4', 'NT 10.0'],
                    'RT'        : 'ARM'
                }
            }
        }
    };


    //////////////
    // Regex map
    /////////////


    var regexes = {

        browser : [[

            // Presto based
            /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
            /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
            /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80
            ], [NAME, VERSION], [

            /(opios)[\/\s]+([\w\.]+)/i                                          // Opera mini on iphone >= 8.0
            ], [[NAME, 'Opera Mini'], VERSION], [

            /\s(opr)\/([\w\.]+)/i                                               // Opera Webkit
            ], [[NAME, 'Opera'], VERSION], [

            // Mixed
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]+)*/i,
                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer

            // Trident based
            /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,
                                                                                // Avant/IEMobile/SlimBrowser/Baidu
            /(?:ms|\()(ie)\s([\w\.]+)/i,                                        // Internet Explorer

            // Webkit/KHTML based
            /(rekonq)\/([\w\.]+)*/i,                                            // Rekonq
            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser)\/([\w\.-]+)/i
                                                                                // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser
            ], [NAME, VERSION], [

            /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
            ], [[NAME, 'IE'], VERSION], [

            /(edge)\/((\d+)?[\w\.]+)/i                                          // Microsoft Edge
            ], [NAME, VERSION], [

            /(yabrowser)\/([\w\.]+)/i                                           // Yandex
            ], [[NAME, 'Yandex'], VERSION], [

            /(puffin)\/([\w\.]+)/i                                              // Puffin
            ], [[NAME, 'Puffin'], VERSION], [

            /((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i
                                                                                // UCBrowser
            ], [[NAME, 'UCBrowser'], VERSION], [

            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
            ], [[NAME, /_/g, ' '], VERSION], [

            /(micromessenger)\/([\w\.]+)/i                                      // WeChat
            ], [[NAME, 'WeChat'], VERSION], [

            /(QQ)\/([\d\.]+)/i                                                  // QQ, aka ShouQ
            ], [NAME, VERSION], [

            /m?(qqbrowser)[\/\s]?([\w\.]+)/i                                    // QQBrowser
            ], [NAME, VERSION], [

            /xiaomi\/miuibrowser\/([\w\.]+)/i                                   // MIUI Browser
            ], [VERSION, [NAME, 'MIUI Browser']], [

            /;fbav\/([\w\.]+);/i                                                // Facebook App for iOS & Android
            ], [VERSION, [NAME, 'Facebook']], [

            /headlesschrome(?:\/([\w\.]+)|\s)/i                                 // Chrome Headless
            ], [VERSION, [NAME, 'Chrome Headless']], [

            /\swv\).+(chrome)\/([\w\.]+)/i                                      // Chrome WebView
            ], [[NAME, /(.+)/, '$1 WebView'], VERSION], [

            /((?:oculus|samsung)browser)\/([\w\.]+)/i
            ], [[NAME, /(.+(?:g|us))(.+)/, '$1 $2'], VERSION], [                // Oculus / Samsung Browser

            /android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i        // Android Browser
            ], [VERSION, [NAME, 'Android Browser']], [

            /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i
                                                                                // Chrome/OmniWeb/Arora/Tizen/Nokia
            ], [NAME, VERSION], [

            /(dolfin)\/([\w\.]+)/i                                              // Dolphin
            ], [[NAME, 'Dolphin'], VERSION], [

            /((?:android.+)crmo|crios)\/([\w\.]+)/i                             // Chrome for Android/iOS
            ], [[NAME, 'Chrome'], VERSION], [

            /(coast)\/([\w\.]+)/i                                               // Opera Coast
            ], [[NAME, 'Opera Coast'], VERSION], [

            /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
            ], [VERSION, [NAME, 'Firefox']], [

            /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
            ], [VERSION, [NAME, 'Mobile Safari']], [

            /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
            ], [VERSION, NAME], [

            /webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i  // Google Search Appliance on iOS
            ], [[NAME, 'GSA'], VERSION], [

            /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
            ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [

            /(konqueror)\/([\w\.]+)/i,                                          // Konqueror
            /(webkit|khtml)\/([\w\.]+)/i
            ], [NAME, VERSION], [

            // Gecko based
            /(navigator|netscape)\/([\w\.-]+)/i                                 // Netscape
            ], [[NAME, 'Netscape'], VERSION], [
            /(swiftfox)/i,                                                      // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/([\w\.-]+)/i,
                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla

            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir
            /(links)\s\(([\w\.]+)/i,                                            // Links
            /(gobrowser)\/?([\w\.]+)*/i,                                        // GoBrowser
            /(ice\s?browser)\/v?([\w\._]+)/i,                                   // ICE Browser
            /(mosaic)[\/\s]([\w\.]+)/i                                          // Mosaic
            ], [NAME, VERSION]

            /* /////////////////////
            // Media players BEGIN
            ////////////////////////

            , [

            /(apple(?:coremedia|))\/((\d+)[\w\._]+)/i,                          // Generic Apple CoreMedia
            /(coremedia) v((\d+)[\w\._]+)/i
            ], [NAME, VERSION], [

            /(aqualung|lyssna|bsplayer)\/((\d+)?[\w\.-]+)/i                     // Aqualung/Lyssna/BSPlayer
            ], [NAME, VERSION], [

            /(ares|ossproxy)\s((\d+)[\w\.-]+)/i                                 // Ares/OSSProxy
            ], [NAME, VERSION], [

            /(audacious|audimusicstream|amarok|bass|core|dalvik|gnomemplayer|music on console|nsplayer|psp-internetradioplayer|videos)\/((\d+)[\w\.-]+)/i,
                                                                                // Audacious/AudiMusicStream/Amarok/BASS/OpenCORE/Dalvik/GnomeMplayer/MoC
                                                                                // NSPlayer/PSP-InternetRadioPlayer/Videos
            /(clementine|music player daemon)\s((\d+)[\w\.-]+)/i,               // Clementine/MPD
            /(lg player|nexplayer)\s((\d+)[\d\.]+)/i,
            /player\/(nexplayer|lg player)\s((\d+)[\w\.-]+)/i                   // NexPlayer/LG Player
            ], [NAME, VERSION], [
            /(nexplayer)\s((\d+)[\w\.-]+)/i                                     // Nexplayer
            ], [NAME, VERSION], [

            /(flrp)\/((\d+)[\w\.-]+)/i                                          // Flip Player
            ], [[NAME, 'Flip Player'], VERSION], [

            /(fstream|nativehost|queryseekspider|ia-archiver|facebookexternalhit)/i
                                                                                // FStream/NativeHost/QuerySeekSpider/IA Archiver/facebookexternalhit
            ], [NAME], [

            /(gstreamer) souphttpsrc (?:\([^\)]+\)){0,1} libsoup\/((\d+)[\w\.-]+)/i
                                                                                // Gstreamer
            ], [NAME, VERSION], [

            /(htc streaming player)\s[\w_]+\s\/\s((\d+)[\d\.]+)/i,              // HTC Streaming Player
            /(java|python-urllib|python-requests|wget|libcurl)\/((\d+)[\w\.-_]+)/i,
                                                                                // Java/urllib/requests/wget/cURL
            /(lavf)((\d+)[\d\.]+)/i                                             // Lavf (FFMPEG)
            ], [NAME, VERSION], [

            /(htc_one_s)\/((\d+)[\d\.]+)/i                                      // HTC One S
            ], [[NAME, /_/g, ' '], VERSION], [

            /(mplayer)(?:\s|\/)(?:(?:sherpya-){0,1}svn)(?:-|\s)(r\d+(?:-\d+[\w\.-]+){0,1})/i
                                                                                // MPlayer SVN
            ], [NAME, VERSION], [

            /(mplayer)(?:\s|\/|[unkow-]+)((\d+)[\w\.-]+)/i                      // MPlayer
            ], [NAME, VERSION], [

            /(mplayer)/i,                                                       // MPlayer (no other info)
            /(yourmuze)/i,                                                      // YourMuze
            /(media player classic|nero showtime)/i                             // Media Player Classic/Nero ShowTime
            ], [NAME], [

            /(nero (?:home|scout))\/((\d+)[\w\.-]+)/i                           // Nero Home/Nero Scout
            ], [NAME, VERSION], [

            /(nokia\d+)\/((\d+)[\w\.-]+)/i                                      // Nokia
            ], [NAME, VERSION], [

            /\s(songbird)\/((\d+)[\w\.-]+)/i                                    // Songbird/Philips-Songbird
            ], [NAME, VERSION], [

            /(winamp)3 version ((\d+)[\w\.-]+)/i,                               // Winamp
            /(winamp)\s((\d+)[\w\.-]+)/i,
            /(winamp)mpeg\/((\d+)[\w\.-]+)/i
            ], [NAME, VERSION], [

            /(ocms-bot|tapinradio|tunein radio|unknown|winamp|inlight radio)/i  // OCMS-bot/tap in radio/tunein/unknown/winamp (no other info)
                                                                                // inlight radio
            ], [NAME], [

            /(quicktime|rma|radioapp|radioclientapplication|soundtap|totem|stagefright|streamium)\/((\d+)[\w\.-]+)/i
                                                                                // QuickTime/RealMedia/RadioApp/RadioClientApplication/
                                                                                // SoundTap/Totem/Stagefright/Streamium
            ], [NAME, VERSION], [

            /(smp)((\d+)[\d\.]+)/i                                              // SMP
            ], [NAME, VERSION], [

            /(vlc) media player - version ((\d+)[\w\.]+)/i,                     // VLC Videolan
            /(vlc)\/((\d+)[\w\.-]+)/i,
            /(xbmc|gvfs|xine|xmms|irapp)\/((\d+)[\w\.-]+)/i,                    // XBMC/gvfs/Xine/XMMS/irapp
            /(foobar2000)\/((\d+)[\d\.]+)/i,                                    // Foobar2000
            /(itunes)\/((\d+)[\d\.]+)/i                                         // iTunes
            ], [NAME, VERSION], [

            /(wmplayer)\/((\d+)[\w\.-]+)/i,                                     // Windows Media Player
            /(windows-media-player)\/((\d+)[\w\.-]+)/i
            ], [[NAME, /-/g, ' '], VERSION], [

            /windows\/((\d+)[\w\.-]+) upnp\/[\d\.]+ dlnadoc\/[\d\.]+ (home media server)/i
                                                                                // Windows Media Server
            ], [VERSION, [NAME, 'Windows']], [

            /(com\.riseupradioalarm)\/((\d+)[\d\.]*)/i                          // RiseUP Radio Alarm
            ], [NAME, VERSION], [

            /(rad.io)\s((\d+)[\d\.]+)/i,                                        // Rad.io
            /(radio.(?:de|at|fr))\s((\d+)[\d\.]+)/i
            ], [[NAME, 'rad.io'], VERSION]

            //////////////////////
            // Media players END
            ////////////////////*/

        ],

        cpu : [[

            /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i                     // AMD64
            ], [[ARCHITECTURE, 'amd64']], [

            /(ia32(?=;))/i                                                      // IA32 (quicktime)
            ], [[ARCHITECTURE, util.lowerize]], [

            /((?:i[346]|x)86)[;\)]/i                                            // IA32
            ], [[ARCHITECTURE, 'ia32']], [

            // PocketPC mistakenly identified as PowerPC
            /windows\s(ce|mobile);\sppc;/i
            ], [[ARCHITECTURE, 'arm']], [

            /((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i                           // PowerPC
            ], [[ARCHITECTURE, /ower/, '', util.lowerize]], [

            /(sun4\w)[;\)]/i                                                    // SPARC
            ], [[ARCHITECTURE, 'sparc']], [

            /((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+;))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i
                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ], [[ARCHITECTURE, util.lowerize]]
        ],

        device : [[

            /\((ipad|playbook);[\w\s\);-]+(rim|apple)/i                         // iPad/PlayBook
            ], [MODEL, VENDOR, [TYPE, TABLET]], [

            /applecoremedia\/[\w\.]+ \((ipad)/                                  // iPad
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [

            /(apple\s{0,1}tv)/i                                                 // Apple TV
            ], [[MODEL, 'Apple TV'], [VENDOR, 'Apple']], [

            /(archos)\s(gamepad2?)/i,                                           // Archos
            /(hp).+(touchpad)/i,                                                // HP TouchPad
            /(hp).+(tablet)/i,                                                  // HP Tablet
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /\s(nook)[\w\s]+build\/(\w+)/i,                                     // Nook
            /(dell)\s(strea[kpr\s\d]*[\dko])/i                                  // Dell Streak
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(kf[A-z]+)\sbuild\/[\w\.]+.*silk\//i                               // Kindle Fire HD
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
            /(sd|kf)[0349hijorstuw]+\sbuild\/[\w\.]+.*silk\//i                  // Fire Phone
            ], [[MODEL, mapper.str, maps.device.amazon.model], [VENDOR, 'Amazon'], [TYPE, MOBILE]], [

            /\((ip[honed|\s\w*]+);.+(apple)/i                                   // iPod/iPhone
            ], [MODEL, VENDOR, [TYPE, MOBILE]], [
            /\((ip[honed|\s\w*]+);/i                                            // iPod/iPhone
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [

            /(blackberry)[\s-]?(\w+)/i,                                         // BlackBerry
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]+)*/i,
                                                                                // BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
            /(hp)\s([\w\s]+\w)/i,                                               // HP iPAQ
            /(asus)-?(\w+)/i                                                    // Asus
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /\(bb10;\s(\w+)/i                                                   // BlackBerry 10
            ], [MODEL, [VENDOR, 'BlackBerry'], [TYPE, MOBILE]], [
                                                                                // Asus Tablets
            /android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i
            ], [MODEL, [VENDOR, 'Asus'], [TYPE, TABLET]], [

            /(sony)\s(tablet\s[ps])\sbuild\//i,                                  // Sony
            /(sony)?(?:sgp.+)\sbuild\//i
            ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Tablet'], [TYPE, TABLET]], [
            /android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i
            ], [MODEL, [VENDOR, 'Sony'], [TYPE, MOBILE]], [

            /\s(ouya)\s/i,                                                      // Ouya
            /(nintendo)\s([wids3u]+)/i                                          // Nintendo
            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [

            /android.+;\s(shield)\sbuild/i                                      // Nvidia
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [

            /(playstation\s[34portablevi]+)/i                                   // Playstation
            ], [MODEL, [VENDOR, 'Sony'], [TYPE, CONSOLE]], [

            /(sprint\s(\w+))/i                                                  // Sprint Phones
            ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [

            /(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i                         // Lenovo tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,                               // HTC
            /(zte)-(\w+)*/i,                                                    // ZTE
            /(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]+)*/i
                                                                                // Alcatel/GeeksPhone/Lenovo/Nexian/Panasonic/Sony
            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

            /(nexus\s9)/i                                                       // HTC Nexus 9
            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [

            /d\/huawei([\w\s-]+)[;\)]/i,
            /(nexus\s6p)/i                                                      // Huawei
            ], [MODEL, [VENDOR, 'Huawei'], [TYPE, MOBILE]], [

            /(microsoft);\s(lumia[\s\w]+)/i                                     // Microsoft Lumia
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /[\s\(;](xbox(?:\sone)?)[\s\);]/i                                   // Microsoft Xbox
            ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, CONSOLE]], [
            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
            ], [[MODEL, /\./g, ' '], [VENDOR, 'Microsoft'], [TYPE, MOBILE]], [

                                                                                // Motorola
            /\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?(:?\s4g)?)[\w\s]+build\//i,
            /mot[\s-]?(\w+)*/i,
            /(XT\d{3,4}) build\//i,
            /(nexus\s6)/i
            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, MOBILE]], [
            /android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i
            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, TABLET]], [

            /hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i            // HbbTV devices
            ], [[VENDOR, util.trim], [MODEL, util.trim], [TYPE, SMARTTV]], [

            /hbbtv.+maple;(\d+)/i
            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, 'Samsung'], [TYPE, SMARTTV]], [

            /\(dtv[\);].+(aquos)/i                                              // Sharp
            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [

            /android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,
            /((SM-T\w+))/i
            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, TABLET]], [                  // Samsung
            /smart-tv.+(samsung)/i
            ], [VENDOR, [TYPE, SMARTTV], MODEL], [
            /((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,
            /(sam[sung]*)[\s-]*(\w+-?[\w-]*)*/i,
            /sec-((sgh\w+))/i
            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, MOBILE]], [

            /sie-(\w+)*/i                                                       // Siemens
            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [

            /(maemo|nokia).*(n900|lumia\s\d+)/i,                                // Nokia
            /(nokia)[\s_-]?([\w-]+)*/i
            ], [[VENDOR, 'Nokia'], MODEL, [TYPE, MOBILE]], [

            /android\s3\.[\s\w;-]{10}(a\d{3})/i                                 // Acer
            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

            /android.+([vl]k\-?\d{3})\s+build/i                                 // LG Tablet
            ], [MODEL, [VENDOR, 'LG'], [TYPE, TABLET]], [
            /android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i                     // LG Tablet
            ], [[VENDOR, 'LG'], MODEL, [TYPE, TABLET]], [
            /(lg) netcast\.tv/i                                                 // LG SmartTV
            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
            /(nexus\s[45])/i,                                                   // LG
            /lg[e;\s\/-]+(\w+)*/i,
            /android.+lg(\-?[\d\w]+)\s+build/i
            ], [MODEL, [VENDOR, 'LG'], [TYPE, MOBILE]], [

            /android.+(ideatab[a-z0-9\-\s]+)/i                                  // Lenovo
            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [

            /linux;.+((jolla));/i                                               // Jolla
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /((pebble))app\/[\d\.]+\s/i                                         // Pebble
            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [

            /android.+;\s(oppo)\s?([\w\s]+)\sbuild/i                            // OPPO
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /crkey/i                                                            // Google Chromecast
            ], [[MODEL, 'Chromecast'], [VENDOR, 'Google']], [

            /android.+;\s(glass)\s\d/i                                          // Google Glass
            ], [MODEL, [VENDOR, 'Google'], [TYPE, WEARABLE]], [

            /android.+;\s(pixel c)\s/i                                          // Google Pixel C
            ], [MODEL, [VENDOR, 'Google'], [TYPE, TABLET]], [

            /android.+;\s(pixel xl|pixel)\s/i                                   // Google Pixel
            ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [

            /android.+(\w+)\s+build\/hm\1/i,                                    // Xiaomi Hongmi 'numeric' models
            /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,               // Xiaomi Hongmi
            /android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d\w)?)\s+build/i,    // Xiaomi Mi
            /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+)?)\s+build/i      // Redmi Phones
            ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [
            /android.+(mi[\s\-_]*(?:pad)?(?:[\s_]*[\w\s]+)?)\s+build/i          // Mi Pad tablets
            ],[[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, TABLET]], [
            /android.+;\s(m[1-5]\snote)\sbuild/i                                // Meizu Tablet
            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, TABLET]], [

            /android.+a000(1)\s+build/i                                         // OnePlus
            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

            /android.+[;\/]\s*(RCT[\d\w]+)\s+build/i                            // RCA Tablets
            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Venue[\d\s]*)\s+build/i                          // Dell Venue Tablets
            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i                         // Verizon Tablet
            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [

            /android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i     // Barnes & Noble Tablet
            ], [[VENDOR, 'Barnes & Noble'], MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i                           // Barnes & Noble Tablet
            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(zte)?.+(k\d{2})\s+build/i                        // ZTE K Series Tablet
            ], [[VENDOR, 'ZTE'], MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*(gen\d{3})\s+build.*49h/i                         // Swiss GEN Mobile
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [

            /android.+[;\/]\s*(zur\d{3})\s+build/i                              // Swiss ZUR Tablet
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [

            /android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i                         // Zeki Tablets
            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [

            /(android).+[;\/]\s+([YR]\d{2}x?.*)\s+build/i,
            /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(.+)\s+build/i          // Dragon Touch Tablet
            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*(NS-?.+)\s+build/i                                // Insignia Tablets
            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [

            /android.+[;\/]\s*((NX|Next)-?.+)\s+build/i                         // NextBook Tablets
            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Xtreme\_?)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i
            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [                    // Voice Xtreme Phones

            /android.+[;\/]\s*(LVTEL\-?)?(V1[12])\s+build/i                     // LvTel Phones
            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [

            /android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i          // Envizen Tablets
            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(.*\b)\s+build/i             // Le Pan Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i                         // MachSpeed Tablets
            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i                // Trinity Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*TU_(1491)\s+build/i                               // Rotor Tablets
            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [

            /android.+(KS(.+))\s+build/i                                        // Amazon Kindle Tablets
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [

            /android.+(Gigaset)[\s\-]+(Q.+)\s+build/i                           // Gigaset Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /\s(tablet|tab)[;\/]/i,                                             // Unidentifiable Tablet
            /\s(mobile)(?:[;\/]|\ssafari)/i                                     // Unidentifiable Mobile
            ], [[TYPE, util.lowerize], VENDOR, MODEL], [

            /(android.+)[;\/].+build/i                                          // Generic Android Device
            ], [MODEL, [VENDOR, 'Generic']]


        /*//////////////////////////
            // TODO: move to string map
            ////////////////////////////

            /(C6603)/i                                                          // Sony Xperia Z C6603
            ], [[MODEL, 'Xperia Z C6603'], [VENDOR, 'Sony'], [TYPE, MOBILE]], [
            /(C6903)/i                                                          // Sony Xperia Z 1
            ], [[MODEL, 'Xperia Z 1'], [VENDOR, 'Sony'], [TYPE, MOBILE]], [

            /(SM-G900[F|H])/i                                                   // Samsung Galaxy S5
            ], [[MODEL, 'Galaxy S5'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-G7102)/i                                                       // Samsung Galaxy Grand 2
            ], [[MODEL, 'Galaxy Grand 2'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-G530H)/i                                                       // Samsung Galaxy Grand Prime
            ], [[MODEL, 'Galaxy Grand Prime'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-G313HZ)/i                                                      // Samsung Galaxy V
            ], [[MODEL, 'Galaxy V'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-T805)/i                                                        // Samsung Galaxy Tab S 10.5
            ], [[MODEL, 'Galaxy Tab S 10.5'], [VENDOR, 'Samsung'], [TYPE, TABLET]], [
            /(SM-G800F)/i                                                       // Samsung Galaxy S5 Mini
            ], [[MODEL, 'Galaxy S5 Mini'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-T311)/i                                                        // Samsung Galaxy Tab 3 8.0
            ], [[MODEL, 'Galaxy Tab 3 8.0'], [VENDOR, 'Samsung'], [TYPE, TABLET]], [

            /(T3C)/i                                                            // Advan Vandroid T3C
            ], [MODEL, [VENDOR, 'Advan'], [TYPE, TABLET]], [
            /(ADVAN T1J\+)/i                                                    // Advan Vandroid T1J+
            ], [[MODEL, 'Vandroid T1J+'], [VENDOR, 'Advan'], [TYPE, TABLET]], [
            /(ADVAN S4A)/i                                                      // Advan Vandroid S4A
            ], [[MODEL, 'Vandroid S4A'], [VENDOR, 'Advan'], [TYPE, MOBILE]], [

            /(V972M)/i                                                          // ZTE V972M
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [

            /(i-mobile)\s(IQ\s[\d\.]+)/i                                        // i-mobile IQ
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /(IQ6.3)/i                                                          // i-mobile IQ IQ 6.3
            ], [[MODEL, 'IQ 6.3'], [VENDOR, 'i-mobile'], [TYPE, MOBILE]], [
            /(i-mobile)\s(i-style\s[\d\.]+)/i                                   // i-mobile i-STYLE
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /(i-STYLE2.1)/i                                                     // i-mobile i-STYLE 2.1
            ], [[MODEL, 'i-STYLE 2.1'], [VENDOR, 'i-mobile'], [TYPE, MOBILE]], [

            /(mobiistar touch LAI 512)/i                                        // mobiistar touch LAI 512
            ], [[MODEL, 'Touch LAI 512'], [VENDOR, 'mobiistar'], [TYPE, MOBILE]], [

            /////////////
            // END TODO
            ///////////*/

        ],

        engine : [[

            /windows.+\sedge\/([\w\.]+)/i                                       // EdgeHTML
            ], [VERSION, [NAME, 'EdgeHTML']], [

            /(presto)\/([\w\.]+)/i,                                             // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,     // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m
            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
            /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
            ], [NAME, VERSION], [

            /rv\:([\w\.]+).*(gecko)/i                                           // Gecko
            ], [VERSION, NAME]
        ],

        os : [[

            // Windows based
            /microsoft\s(windows)\s(vista|xp)/i                                 // Windows (iTunes)
            ], [NAME, VERSION], [
            /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
            /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s]+\w)*/i,                  // Windows Phone
            /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
            /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [

            // Mobile/Embedded OS
            /\((bb)(10);/i                                                      // BlackBerry 10
            ], [[NAME, 'BlackBerry'], VERSION], [
            /(blackberry)\w*\/?([\w\.]+)*/i,                                    // Blackberry
            /(tizen)[\/\s]([\w\.]+)/i,                                          // Tizen
            /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]+)*/i,
                                                                                // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki
            /linux;.+(sailfish);/i                                              // Sailfish OS
            ], [NAME, VERSION], [
            /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i                 // Symbian
            ], [[NAME, 'Symbian'], VERSION], [
            /\((series40);/i                                                    // Series 40
            ], [NAME], [
            /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
            ], [[NAME, 'Firefox OS'], VERSION], [

            // Console
            /(nintendo|playstation)\s([wids34portablevu]+)/i,                   // Nintendo/Playstation

            // GNU/Linux based
            /(mint)[\/\s\(]?(\w+)*/i,                                           // Mint
            /(mageia|vectorlinux)[;\s]/i,                                       // Mageia/VectorLinux
            /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]+)*/i,
                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus
            /(hurd|linux)\s?([\w\.]+)*/i,                                       // Hurd/Linux
            /(gnu)\s?([\w\.]+)*/i                                               // GNU
            ], [NAME, VERSION], [

            /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
            ], [[NAME, 'Chromium OS'], VERSION],[

            // Solaris
            /(sunos)\s?([\w\.]+\d)*/i                                           // Solaris
            ], [[NAME, 'Solaris'], VERSION], [

            // BSD based
            /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i                   // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
            ], [NAME, VERSION],[

            /(haiku)\s(\w+)/i                                                  // Haiku
            ], [NAME, VERSION],[

            /cfnetwork\/.+darwin/i,
            /ip[honead]+(?:.*os\s([\w]+)\slike\smac|;\sopera)/i                 // iOS
            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [

            /(mac\sos\sx)\s?([\w\s\.]+\w)*/i,
            /(macintosh|mac(?=_powerpc)\s)/i                                    // Mac OS
            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

            // Other
            /((?:open)?solaris)[\/\s-]?([\w\.]+)*/i,                            // Solaris
            /(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i,                               // AIX
            /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i,
                                                                                // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS
            /(unix)\s?([\w\.]+)*/i                                              // UNIX
            ], [NAME, VERSION]
        ]
    };


    /////////////////
    // Constructor
    ////////////////
    /*
    var Browser = function (name, version) {
        this[NAME] = name;
        this[VERSION] = version;
    };
    var CPU = function (arch) {
        this[ARCHITECTURE] = arch;
    };
    var Device = function (vendor, model, type) {
        this[VENDOR] = vendor;
        this[MODEL] = model;
        this[TYPE] = type;
    };
    var Engine = Browser;
    var OS = Browser;
    */
    var UAParser = function (uastring, extensions) {

        if (typeof uastring === 'object') {
            extensions = uastring;
            uastring = undefined;
        }

        if (!(this instanceof UAParser)) {
            return new UAParser(uastring, extensions).getResult();
        }

        var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
        var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;
        //var browser = new Browser();
        //var cpu = new CPU();
        //var device = new Device();
        //var engine = new Engine();
        //var os = new OS();

        this.getBrowser = function () {
            var browser = { name: undefined, version: undefined };
            mapper.rgx.call(browser, ua, rgxmap.browser);
            browser.major = util.major(browser.version); // deprecated
            return browser;
        };
        this.getCPU = function () {
            var cpu = { architecture: undefined };
            mapper.rgx.call(cpu, ua, rgxmap.cpu);
            return cpu;
        };
        this.getDevice = function () {
            var device = { vendor: undefined, model: undefined, type: undefined };
            mapper.rgx.call(device, ua, rgxmap.device);
            return device;
        };
        this.getEngine = function () {
            var engine = { name: undefined, version: undefined };
            mapper.rgx.call(engine, ua, rgxmap.engine);
            return engine;
        };
        this.getOS = function () {
            var os = { name: undefined, version: undefined };
            mapper.rgx.call(os, ua, rgxmap.os);
            return os;
        };
        this.getResult = function () {
            return {
                ua      : this.getUA(),
                browser : this.getBrowser(),
                engine  : this.getEngine(),
                os      : this.getOS(),
                device  : this.getDevice(),
                cpu     : this.getCPU()
            };
        };
        this.getUA = function () {
            return ua;
        };
        this.setUA = function (uastring) {
            ua = uastring;
            //browser = new Browser();
            //cpu = new CPU();
            //device = new Device();
            //engine = new Engine();
            //os = new OS();
            return this;
        };
        return this;
    };

    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER = {
        NAME    : NAME,
        MAJOR   : MAJOR, // deprecated
        VERSION : VERSION
    };
    UAParser.CPU = {
        ARCHITECTURE : ARCHITECTURE
    };
    UAParser.DEVICE = {
        MODEL   : MODEL,
        VENDOR  : VENDOR,
        TYPE    : TYPE,
        CONSOLE : CONSOLE,
        MOBILE  : MOBILE,
        SMARTTV : SMARTTV,
        TABLET  : TABLET,
        WEARABLE: WEARABLE,
        EMBEDDED: EMBEDDED
    };
    UAParser.ENGINE = {
        NAME    : NAME,
        VERSION : VERSION
    };
    UAParser.OS = {
        NAME    : NAME,
        VERSION : VERSION
    };
    //UAParser.Utils = util;

    ///////////
    // Export
    //////////


    // check js environment
    if (typeof(exports) !== UNDEF_TYPE) {
        // nodejs env
        if (typeof module !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
        }
        // TODO: test!!!!!!!!
        /*
        if (require && require.main === module && process) {
            // cli
            var jsonize = function (arr) {
                var res = [];
                for (var i in arr) {
                    res.push(new UAParser(arr[i]).getResult());
                }
                process.stdout.write(JSON.stringify(res, null, 2) + '\n');
            };
            if (process.stdin.isTTY) {
                // via args
                jsonize(process.argv.slice(2));
            } else {
                // via pipe
                var str = '';
                process.stdin.on('readable', function() {
                    var read = process.stdin.read();
                    if (read !== null) {
                        str += read;
                    }
                });
                process.stdin.on('end', function () {
                    jsonize(str.replace(/\n$/, '').split('\n'));
                });
            }
        }
        */
        exports.UAParser = UAParser;
    } else {
        // requirejs env (optional)
        if ("function" === FUNC_TYPE && __webpack_require__(414)) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
                return UAParser;
            }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else if (window) {
            // browser env
            window.UAParser = UAParser;
        }
    }

    // jQuery/Zepto specific (optional)
    // Note:
    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
    //   and we should catch that.
    var $ = window && (window.jQuery || window.Zepto);
    if (typeof $ !== UNDEF_TYPE) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function () {
            return parser.getUA();
        };
        $.ua.set = function (uastring) {
            parser.setUA(uastring);
            var result = parser.getResult();
            for (var prop in result) {
                $.ua[prop] = result[prop];
            }
        };
    }

})(typeof window === 'object' ? window : this);


/***/ }),
/* 414 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var invariant = __webpack_require__(10);

var componentRegex = /\./;
var orRegex = /\|\|/;
var rangeRegex = /\s+\-\s+/;
var modifierRegex = /^(<=|<|=|>=|~>|~|>|)?\s*(.+)/;
var numericRegex = /^(\d*)(.*)/;

/**
 * Splits input `range` on "||" and returns true if any subrange matches
 * `version`.
 *
 * @param {string} range
 * @param {string} version
 * @returns {boolean}
 */
function checkOrExpression(range, version) {
  var expressions = range.split(orRegex);

  if (expressions.length > 1) {
    return expressions.some(function (range) {
      return VersionRange.contains(range, version);
    });
  } else {
    range = expressions[0].trim();
    return checkRangeExpression(range, version);
  }
}

/**
 * Splits input `range` on " - " (the surrounding whitespace is required) and
 * returns true if version falls between the two operands.
 *
 * @param {string} range
 * @param {string} version
 * @returns {boolean}
 */
function checkRangeExpression(range, version) {
  var expressions = range.split(rangeRegex);

  !(expressions.length > 0 && expressions.length <= 2) ?  true ? invariant(false, 'the "-" operator expects exactly 2 operands') : invariant(false) : void 0;

  if (expressions.length === 1) {
    return checkSimpleExpression(expressions[0], version);
  } else {
    var startVersion = expressions[0],
        endVersion = expressions[1];

    !(isSimpleVersion(startVersion) && isSimpleVersion(endVersion)) ?  true ? invariant(false, 'operands to the "-" operator must be simple (no modifiers)') : invariant(false) : void 0;

    return checkSimpleExpression('>=' + startVersion, version) && checkSimpleExpression('<=' + endVersion, version);
  }
}

/**
 * Checks if `range` matches `version`. `range` should be a "simple" range (ie.
 * not a compound range using the " - " or "||" operators).
 *
 * @param {string} range
 * @param {string} version
 * @returns {boolean}
 */
function checkSimpleExpression(range, version) {
  range = range.trim();
  if (range === '') {
    return true;
  }

  var versionComponents = version.split(componentRegex);

  var _getModifierAndCompon = getModifierAndComponents(range),
      modifier = _getModifierAndCompon.modifier,
      rangeComponents = _getModifierAndCompon.rangeComponents;

  switch (modifier) {
    case '<':
      return checkLessThan(versionComponents, rangeComponents);
    case '<=':
      return checkLessThanOrEqual(versionComponents, rangeComponents);
    case '>=':
      return checkGreaterThanOrEqual(versionComponents, rangeComponents);
    case '>':
      return checkGreaterThan(versionComponents, rangeComponents);
    case '~':
    case '~>':
      return checkApproximateVersion(versionComponents, rangeComponents);
    default:
      return checkEqual(versionComponents, rangeComponents);
  }
}

/**
 * Checks whether `a` is less than `b`.
 *
 * @param {array<string>} a
 * @param {array<string>} b
 * @returns {boolean}
 */
function checkLessThan(a, b) {
  return compareComponents(a, b) === -1;
}

/**
 * Checks whether `a` is less than or equal to `b`.
 *
 * @param {array<string>} a
 * @param {array<string>} b
 * @returns {boolean}
 */
function checkLessThanOrEqual(a, b) {
  var result = compareComponents(a, b);
  return result === -1 || result === 0;
}

/**
 * Checks whether `a` is equal to `b`.
 *
 * @param {array<string>} a
 * @param {array<string>} b
 * @returns {boolean}
 */
function checkEqual(a, b) {
  return compareComponents(a, b) === 0;
}

/**
 * Checks whether `a` is greater than or equal to `b`.
 *
 * @param {array<string>} a
 * @param {array<string>} b
 * @returns {boolean}
 */
function checkGreaterThanOrEqual(a, b) {
  var result = compareComponents(a, b);
  return result === 1 || result === 0;
}

/**
 * Checks whether `a` is greater than `b`.
 *
 * @param {array<string>} a
 * @param {array<string>} b
 * @returns {boolean}
 */
function checkGreaterThan(a, b) {
  return compareComponents(a, b) === 1;
}

/**
 * Checks whether `a` is "reasonably close" to `b` (as described in
 * https://www.npmjs.org/doc/misc/semver.html). For example, if `b` is "1.3.1"
 * then "reasonably close" is defined as ">= 1.3.1 and < 1.4".
 *
 * @param {array<string>} a
 * @param {array<string>} b
 * @returns {boolean}
 */
function checkApproximateVersion(a, b) {
  var lowerBound = b.slice();
  var upperBound = b.slice();

  if (upperBound.length > 1) {
    upperBound.pop();
  }
  var lastIndex = upperBound.length - 1;
  var numeric = parseInt(upperBound[lastIndex], 10);
  if (isNumber(numeric)) {
    upperBound[lastIndex] = numeric + 1 + '';
  }

  return checkGreaterThanOrEqual(a, lowerBound) && checkLessThan(a, upperBound);
}

/**
 * Extracts the optional modifier (<, <=, =, >=, >, ~, ~>) and version
 * components from `range`.
 *
 * For example, given `range` ">= 1.2.3" returns an object with a `modifier` of
 * `">="` and `components` of `[1, 2, 3]`.
 *
 * @param {string} range
 * @returns {object}
 */
function getModifierAndComponents(range) {
  var rangeComponents = range.split(componentRegex);
  var matches = rangeComponents[0].match(modifierRegex);
  !matches ?  true ? invariant(false, 'expected regex to match but it did not') : invariant(false) : void 0;

  return {
    modifier: matches[1],
    rangeComponents: [matches[2]].concat(rangeComponents.slice(1))
  };
}

/**
 * Determines if `number` is a number.
 *
 * @param {mixed} number
 * @returns {boolean}
 */
function isNumber(number) {
  return !isNaN(number) && isFinite(number);
}

/**
 * Tests whether `range` is a "simple" version number without any modifiers
 * (">", "~" etc).
 *
 * @param {string} range
 * @returns {boolean}
 */
function isSimpleVersion(range) {
  return !getModifierAndComponents(range).modifier;
}

/**
 * Zero-pads array `array` until it is at least `length` long.
 *
 * @param {array} array
 * @param {number} length
 */
function zeroPad(array, length) {
  for (var i = array.length; i < length; i++) {
    array[i] = '0';
  }
}

/**
 * Normalizes `a` and `b` in preparation for comparison by doing the following:
 *
 * - zero-pads `a` and `b`
 * - marks any "x", "X" or "*" component in `b` as equivalent by zero-ing it out
 *   in both `a` and `b`
 * - marks any final "*" component in `b` as a greedy wildcard by zero-ing it
 *   and all of its successors in `a`
 *
 * @param {array<string>} a
 * @param {array<string>} b
 * @returns {array<array<string>>}
 */
function normalizeVersions(a, b) {
  a = a.slice();
  b = b.slice();

  zeroPad(a, b.length);

  // mark "x" and "*" components as equal
  for (var i = 0; i < b.length; i++) {
    var matches = b[i].match(/^[x*]$/i);
    if (matches) {
      b[i] = a[i] = '0';

      // final "*" greedily zeros all remaining components
      if (matches[0] === '*' && i === b.length - 1) {
        for (var j = i; j < a.length; j++) {
          a[j] = '0';
        }
      }
    }
  }

  zeroPad(b, a.length);

  return [a, b];
}

/**
 * Returns the numerical -- not the lexicographical -- ordering of `a` and `b`.
 *
 * For example, `10-alpha` is greater than `2-beta`.
 *
 * @param {string} a
 * @param {string} b
 * @returns {number} -1, 0 or 1 to indicate whether `a` is less than, equal to,
 * or greater than `b`, respectively
 */
function compareNumeric(a, b) {
  var aPrefix = a.match(numericRegex)[1];
  var bPrefix = b.match(numericRegex)[1];
  var aNumeric = parseInt(aPrefix, 10);
  var bNumeric = parseInt(bPrefix, 10);

  if (isNumber(aNumeric) && isNumber(bNumeric) && aNumeric !== bNumeric) {
    return compare(aNumeric, bNumeric);
  } else {
    return compare(a, b);
  }
}

/**
 * Returns the ordering of `a` and `b`.
 *
 * @param {string|number} a
 * @param {string|number} b
 * @returns {number} -1, 0 or 1 to indicate whether `a` is less than, equal to,
 * or greater than `b`, respectively
 */
function compare(a, b) {
  !(typeof a === typeof b) ?  true ? invariant(false, '"a" and "b" must be of the same type') : invariant(false) : void 0;

  if (a > b) {
    return 1;
  } else if (a < b) {
    return -1;
  } else {
    return 0;
  }
}

/**
 * Compares arrays of version components.
 *
 * @param {array<string>} a
 * @param {array<string>} b
 * @returns {number} -1, 0 or 1 to indicate whether `a` is less than, equal to,
 * or greater than `b`, respectively
 */
function compareComponents(a, b) {
  var _normalizeVersions = normalizeVersions(a, b),
      aNormalized = _normalizeVersions[0],
      bNormalized = _normalizeVersions[1];

  for (var i = 0; i < bNormalized.length; i++) {
    var result = compareNumeric(aNormalized[i], bNormalized[i]);
    if (result) {
      return result;
    }
  }

  return 0;
}

var VersionRange = {
  /**
   * Checks whether `version` satisfies the `range` specification.
   *
   * We support a subset of the expressions defined in
   * https://www.npmjs.org/doc/misc/semver.html:
   *
   *    version   Must match version exactly
   *    =version  Same as just version
   *    >version  Must be greater than version
   *    >=version Must be greater than or equal to version
   *    <version  Must be less than version
   *    <=version Must be less than or equal to version
   *    ~version  Must be at least version, but less than the next significant
   *              revision above version:
   *              "~1.2.3" is equivalent to ">= 1.2.3 and < 1.3"
   *    ~>version Equivalent to ~version
   *    1.2.x     Must match "1.2.x", where "x" is a wildcard that matches
   *              anything
   *    1.2.*     Similar to "1.2.x", but "*" in the trailing position is a
   *              "greedy" wildcard, so will match any number of additional
   *              components:
   *              "1.2.*" will match "1.2.1", "1.2.1.1", "1.2.1.1.1" etc
   *    *         Any version
   *    ""        (Empty string) Same as *
   *    v1 - v2   Equivalent to ">= v1 and <= v2"
   *    r1 || r2  Passes if either r1 or r2 are satisfied
   *
   * @param {string} range
   * @param {string} version
   * @returns {boolean}
   */
  contains: function contains(range, version) {
    return checkOrExpression(range.trim(), version.trim());
  }
};

module.exports = VersionRange;

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Executes the provided `callback` once for each enumerable own property in the
 * object and constructs a new object from the results. The `callback` is
 * invoked with three arguments:
 *
 *  - the property value
 *  - the property name
 *  - the object being traversed
 *
 * Properties that are added after the call to `mapObject` will not be visited
 * by `callback`. If the values of existing properties are changed, the value
 * passed to `callback` will be the value at the time `mapObject` visits them.
 * Properties that are deleted before being visited are not visited.
 *
 * @grep function objectMap()
 * @grep function objMap()
 *
 * @param {?object} object
 * @param {function} callback
 * @param {*} context
 * @return {?object}
 */
function mapObject(object, callback, context) {
  if (!object) {
    return null;
  }
  var result = {};
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result[name] = callback.call(context, object[name], name, object);
    }
  }
  return result;
}

module.exports = mapObject;

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @typechecks static-only
 */



/**
 * Memoizes the return value of a function that accepts one string argument.
 */

function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setDraftEditorSelection
 * @format
 * 
 */



var DraftJsDebugLogging = __webpack_require__(419);

var containsNode = __webpack_require__(193);
var getActiveElement = __webpack_require__(196);
var invariant = __webpack_require__(10);

function getAnonymizedDOM(node, getNodeLabels) {
  if (!node) {
    return '[empty]';
  }

  var anonymized = anonymizeTextWithin(node, getNodeLabels);
  if (anonymized.nodeType === Node.TEXT_NODE) {
    return anonymized.textContent;
  }

  !(anonymized instanceof Element) ?  true ? invariant(false, 'Node must be an Element if it is not a text node.') : invariant(false) : void 0;
  return anonymized.outerHTML;
}

function anonymizeTextWithin(node, getNodeLabels) {
  var labels = getNodeLabels !== undefined ? getNodeLabels(node) : [];

  if (node.nodeType === Node.TEXT_NODE) {
    var length = node.textContent.length;
    return document.createTextNode('[text ' + length + (labels.length ? ' | ' + labels.join(', ') : '') + ']');
  }

  var clone = node.cloneNode();
  if (clone.nodeType === 1 && labels.length) {
    clone.setAttribute('data-labels', labels.join(', '));
  }
  var childNodes = node.childNodes;
  for (var ii = 0; ii < childNodes.length; ii++) {
    clone.appendChild(anonymizeTextWithin(childNodes[ii], getNodeLabels));
  }

  return clone;
}

function getAnonymizedEditorDOM(node, getNodeLabels) {
  // grabbing the DOM content of the Draft editor
  var currentNode = node;
  while (currentNode) {
    if (currentNode instanceof Element && currentNode.hasAttribute('contenteditable')) {
      // found the Draft editor container
      return getAnonymizedDOM(currentNode, getNodeLabels);
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return 'Could not find contentEditable parent of node';
}

function getNodeLength(node) {
  return node.nodeValue === null ? node.childNodes.length : node.nodeValue.length;
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 */
function setDraftEditorSelection(selectionState, node, blockKey, nodeStart, nodeEnd) {
  // It's possible that the editor has been removed from the DOM but
  // our selection code doesn't know it yet. Forcing selection in
  // this case may lead to errors, so just bail now.
  if (!containsNode(document.documentElement, node)) {
    return;
  }

  var selection = global.getSelection();
  var anchorKey = selectionState.getAnchorKey();
  var anchorOffset = selectionState.getAnchorOffset();
  var focusKey = selectionState.getFocusKey();
  var focusOffset = selectionState.getFocusOffset();
  var isBackward = selectionState.getIsBackward();

  // IE doesn't support backward selection. Swap key/offset pairs.
  if (!selection.extend && isBackward) {
    var tempKey = anchorKey;
    var tempOffset = anchorOffset;
    anchorKey = focusKey;
    anchorOffset = focusOffset;
    focusKey = tempKey;
    focusOffset = tempOffset;
    isBackward = false;
  }

  var hasAnchor = anchorKey === blockKey && nodeStart <= anchorOffset && nodeEnd >= anchorOffset;

  var hasFocus = focusKey === blockKey && nodeStart <= focusOffset && nodeEnd >= focusOffset;

  // If the selection is entirely bound within this node, set the selection
  // and be done.
  if (hasAnchor && hasFocus) {
    selection.removeAllRanges();
    addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
    addFocusToSelection(selection, node, focusOffset - nodeStart, selectionState);
    return;
  }

  if (!isBackward) {
    // If the anchor is within this node, set the range start.
    if (hasAnchor) {
      selection.removeAllRanges();
      addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
    }

    // If the focus is within this node, we can assume that we have
    // already set the appropriate start range on the selection, and
    // can simply extend the selection.
    if (hasFocus) {
      addFocusToSelection(selection, node, focusOffset - nodeStart, selectionState);
    }
  } else {
    // If this node has the focus, set the selection range to be a
    // collapsed range beginning here. Later, when we encounter the anchor,
    // we'll use this information to extend the selection.
    if (hasFocus) {
      selection.removeAllRanges();
      addPointToSelection(selection, node, focusOffset - nodeStart, selectionState);
    }

    // If this node has the anchor, we may assume that the correct
    // focus information is already stored on the selection object.
    // We keep track of it, reset the selection range, and extend it
    // back to the focus point.
    if (hasAnchor) {
      var storedFocusNode = selection.focusNode;
      var storedFocusOffset = selection.focusOffset;

      selection.removeAllRanges();
      addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
      addFocusToSelection(selection, storedFocusNode, storedFocusOffset, selectionState);
    }
  }
}

/**
 * Extend selection towards focus point.
 */
function addFocusToSelection(selection, node, offset, selectionState) {
  var activeElement = getActiveElement();
  if (selection.extend && containsNode(activeElement, node)) {
    // If `extend` is called while another element has focus, an error is
    // thrown. We therefore disable `extend` if the active element is somewhere
    // other than the node we are selecting. This should only occur in Firefox,
    // since it is the only browser to support multiple selections.
    // See https://bugzilla.mozilla.org/show_bug.cgi?id=921444.

    // logging to catch bug that is being reported in t16250795
    if (offset > getNodeLength(node)) {
      // the call to 'selection.extend' is about to throw
      DraftJsDebugLogging.logSelectionStateFailure({
        anonymizedDom: getAnonymizedEditorDOM(node),
        extraParams: JSON.stringify({ offset: offset }),
        selectionState: JSON.stringify(selectionState.toJS())
      });
    }

    // logging to catch bug that is being reported in t18110632
    var nodeWasFocus = node === selection.focusNode;
    try {
      selection.extend(node, offset);
    } catch (e) {
      DraftJsDebugLogging.logSelectionStateFailure({
        anonymizedDom: getAnonymizedEditorDOM(node, function (n) {
          var labels = [];
          if (n === activeElement) {
            labels.push('active element');
          }
          if (n === selection.anchorNode) {
            labels.push('selection anchor node');
          }
          if (n === selection.focusNode) {
            labels.push('selection focus node');
          }
          return labels;
        }),
        extraParams: JSON.stringify({
          activeElementName: activeElement ? activeElement.nodeName : null,
          nodeIsFocus: node === selection.focusNode,
          nodeWasFocus: nodeWasFocus,
          selectionRangeCount: selection.rangeCount,
          selectionAnchorNodeName: selection.anchorNode ? selection.anchorNode.nodeName : null,
          selectionAnchorOffset: selection.anchorOffset,
          selectionFocusNodeName: selection.focusNode ? selection.focusNode.nodeName : null,
          selectionFocusOffset: selection.focusOffset,
          message: e ? '' + e : null,
          offset: offset
        }, null, 2),
        selectionState: JSON.stringify(selectionState.toJS(), null, 2)
      });
      // allow the error to be thrown -
      // better than continuing in a broken state
      throw e;
    }
  } else {
    // IE doesn't support extend. This will mean no backward selection.
    // Extract the existing selection range and add focus to it.
    // Additionally, clone the selection range. IE11 throws an
    // InvalidStateError when attempting to access selection properties
    // after the range is detached.
    var range = selection.getRangeAt(0);
    range.setEnd(node, offset);
    selection.addRange(range.cloneRange());
  }
}

function addPointToSelection(selection, node, offset, selectionState) {
  var range = document.createRange();
  // logging to catch bug that is being reported in t16250795
  if (offset > getNodeLength(node)) {
    // in this case we know that the call to 'range.setStart' is about to throw
    DraftJsDebugLogging.logSelectionStateFailure({
      anonymizedDom: getAnonymizedEditorDOM(node),
      extraParams: JSON.stringify({ offset: offset }),
      selectionState: JSON.stringify(selectionState.toJS())
    });
  }
  range.setStart(node, offset);
  selection.addRange(range);
}

module.exports = setDraftEditorSelection;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftJsDebugLogging
 */



module.exports = {
  logSelectionStateFailure: function logSelectionStateFailure() {
    return null;
  }
};

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var camelize = __webpack_require__(198);
var hyphenate = __webpack_require__(197);

function asString(value) /*?string*/{
  return value == null ? value : String(value);
}

function getStyleProperty( /*DOMNode*/node, /*string*/name) /*?string*/{
  var computedStyle = void 0;

  // W3C Standard
  if (window.getComputedStyle) {
    // In certain cases such as within an iframe in FF3, this returns null.
    computedStyle = window.getComputedStyle(node, null);
    if (computedStyle) {
      return asString(computedStyle.getPropertyValue(hyphenate(name)));
    }
  }
  // Safari
  if (document.defaultView && document.defaultView.getComputedStyle) {
    computedStyle = document.defaultView.getComputedStyle(node, null);
    // A Safari bug causes this to return null for `display: none` elements.
    if (computedStyle) {
      return asString(computedStyle.getPropertyValue(hyphenate(name)));
    }
    if (name === 'display') {
      return 'none';
    }
  }
  // Internet Explorer
  if (node.currentStyle) {
    if (name === 'float') {
      return asString(node.currentStyle.cssFloat || node.currentStyle.styleFloat);
    }
    return asString(node.currentStyle[camelize(name)]);
  }
  return asString(node.style && node.style[camelize(name)]);
}

module.exports = getStyleProperty;

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var getElementRect = __webpack_require__(422);

/**
 * Gets an element's position in pixels relative to the viewport. The returned
 * object represents the position of the element's top left corner.
 *
 * @param {DOMElement} element
 * @return {object}
 */
function getElementPosition(element) {
  var rect = getElementRect(element);
  return {
    x: rect.left,
    y: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };
}

module.exports = getElementPosition;

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var containsNode = __webpack_require__(193);

/**
 * Gets an element's bounding rect in pixels relative to the viewport.
 *
 * @param {DOMElement} elem
 * @return {object}
 */
function getElementRect(elem) {
  var docElem = elem.ownerDocument.documentElement;

  // FF 2, Safari 3 and Opera 9.5- do not support getBoundingClientRect().
  // IE9- will throw if the element is not in the document.
  if (!('getBoundingClientRect' in elem) || !containsNode(docElem, elem)) {
    return {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
  }

  // Subtracts clientTop/Left because IE8- added a 2px border to the
  // <html> element (see http://fburl.com/1493213). IE 7 in
  // Quicksmode does not report clientLeft/clientTop so there
  // will be an unaccounted offset of 2px when in quirksmode
  var rect = elem.getBoundingClientRect();

  return {
    left: Math.round(rect.left) - docElem.clientLeft,
    right: Math.round(rect.right) - docElem.clientLeft,
    top: Math.round(rect.top) - docElem.clientTop,
    bottom: Math.round(rect.bottom) - docElem.clientTop
  };
}

module.exports = getElementRect;

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var isWebkit = typeof navigator !== 'undefined' && navigator.userAgent.indexOf('AppleWebKit') > -1;

/**
 * Gets the element with the document scroll properties such as `scrollLeft` and
 * `scrollHeight`. This may differ across different browsers.
 *
 * NOTE: The return value can be null if the DOM is not yet ready.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */
function getDocumentScrollElement(doc) {
  doc = doc || document;
  if (doc.scrollingElement) {
    return doc.scrollingElement;
  }
  return !isWebkit && doc.compatMode === 'CSS1Compat' ? doc.documentElement : doc.body;
}

module.exports = getDocumentScrollElement;

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */

function getUnboundedScrollPosition(scrollable) {
  if (scrollable.Window && scrollable instanceof scrollable.Window) {
    return {
      x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
      y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getViewportWidth() {
  var width = void 0;
  if (document.documentElement) {
    width = document.documentElement.clientWidth;
  }

  if (!width && document.body) {
    width = document.body.clientWidth;
  }

  return width || 0;
} /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @typechecks
   */

function getViewportHeight() {
  var height = void 0;
  if (document.documentElement) {
    height = document.documentElement.clientHeight;
  }

  if (!height && document.body) {
    height = document.body.clientHeight;
  }

  return height || 0;
}

/**
 * Gets the viewport dimensions including any scrollbars.
 */
function getViewportDimensions() {
  return {
    width: window.innerWidth || getViewportWidth(),
    height: window.innerHeight || getViewportHeight()
  };
}

/**
 * Gets the viewport dimensions excluding any scrollbars.
 */
getViewportDimensions.withoutScrollbars = function () {
  return {
    width: getViewportWidth(),
    height: getViewportHeight()
  };
};

module.exports = getViewportDimensions;

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks static-only
 */



/**
 * Combines multiple className strings into one.
 * http://jsperf.com/joinclasses-args-vs-array
 *
 * @param {...?string} className
 * @return {string}
 */

function joinClasses(className /*, ... */) {
  if (!className) {
    className = '';
  }
  var nextClass = void 0;
  var argLength = arguments.length;
  if (argLength > 1) {
    for (var ii = 1; ii < argLength; ii++) {
      nextClass = arguments[ii];
      if (nextClass) {
        className = (className ? className + ' ' : '') + nextClass;
      }
    }
  }
  return className;
}

module.exports = joinClasses;

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftEditorDragHandler
 * @format
 * 
 */



var DataTransfer = __webpack_require__(371);
var DraftModifier = __webpack_require__(326);
var EditorState = __webpack_require__(325);

var findAncestorOffsetKey = __webpack_require__(356);
var getTextContentFromFiles = __webpack_require__(373);
var getUpdatedSelectionState = __webpack_require__(374);
var isEventHandled = __webpack_require__(342);
var nullthrows = __webpack_require__(329);

/**
 * Get a SelectionState for the supplied mouse event.
 */
function getSelectionForEvent(event, editorState) {
  var node = null;
  var offset = null;

  if (typeof document.caretRangeFromPoint === 'function') {
    var dropRange = document.caretRangeFromPoint(event.x, event.y);
    node = dropRange.startContainer;
    offset = dropRange.startOffset;
  } else if (event.rangeParent) {
    node = event.rangeParent;
    offset = event.rangeOffset;
  } else {
    return null;
  }

  node = nullthrows(node);
  offset = nullthrows(offset);
  var offsetKey = nullthrows(findAncestorOffsetKey(node));

  return getUpdatedSelectionState(editorState, offsetKey, offset, offsetKey, offset);
}

var DraftEditorDragHandler = {
  /**
   * Drag originating from input terminated.
   */
  onDragEnd: function onDragEnd(editor) {
    editor.exitCurrentMode();
  },

  /**
   * Handle data being dropped.
   */
  onDrop: function onDrop(editor, e) {
    var data = new DataTransfer(e.nativeEvent.dataTransfer);

    var editorState = editor._latestEditorState;
    var dropSelection = getSelectionForEvent(e.nativeEvent, editorState);

    e.preventDefault();
    editor.exitCurrentMode();

    if (dropSelection == null) {
      return;
    }

    var files = data.getFiles();
    if (files.length > 0) {
      if (editor.props.handleDroppedFiles && isEventHandled(editor.props.handleDroppedFiles(dropSelection, files))) {
        return;
      }

      getTextContentFromFiles(files, function (fileText) {
        fileText && editor.update(insertTextAtSelection(editorState, dropSelection, fileText));
      });
      return;
    }

    var dragType = editor._internalDrag ? 'internal' : 'external';
    if (editor.props.handleDrop && isEventHandled(editor.props.handleDrop(dropSelection, data, dragType))) {
      return;
    }

    if (editor._internalDrag) {
      editor.update(moveText(editorState, dropSelection));
      return;
    }

    editor.update(insertTextAtSelection(editorState, dropSelection, data.getText()));
  }
};

function moveText(editorState, targetSelection) {
  var newContentState = DraftModifier.moveText(editorState.getCurrentContent(), editorState.getSelection(), targetSelection);
  return EditorState.push(editorState, newContentState, 'insert-fragment');
}

/**
 * Insert text at a specified selection.
 */
function insertTextAtSelection(editorState, selection, text) {
  var newContentState = DraftModifier.insertText(editorState.getCurrentContent(), selection, text, editorState.getCurrentInlineStyle());
  return EditorState.push(editorState, newContentState, 'insert-fragment');
}

module.exports = DraftEditorDragHandler;

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
var PhotosMimeType = {
  isImage: function isImage(mimeString) {
    return getParts(mimeString)[0] === 'image';
  },
  isJpeg: function isJpeg(mimeString) {
    var parts = getParts(mimeString);
    return PhotosMimeType.isImage(mimeString) && (
    // see http://fburl.com/10972194
    parts[1] === 'jpeg' || parts[1] === 'pjpeg');
  }
};

function getParts(mimeString) {
  return mimeString.split('/');
}

module.exports = PhotosMimeType;

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var invariant = __webpack_require__(10);

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
  // in old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ?  true ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

  !(typeof length === 'number') ?  true ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

  !(length === 0 || length - 1 in obj) ?  true ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

  !(typeof obj.callee !== 'function') ?  true ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftEditorEditHandler
 * @format
 * 
 */



var onBeforeInput = __webpack_require__(431);
var onBlur = __webpack_require__(434);
var onCompositionStart = __webpack_require__(435);
var onCopy = __webpack_require__(436);
var onCut = __webpack_require__(437);
var onDragOver = __webpack_require__(438);
var onDragStart = __webpack_require__(439);
var onFocus = __webpack_require__(440);
var onInput = __webpack_require__(441);
var onKeyDown = __webpack_require__(442);
var onPaste = __webpack_require__(456);
var onSelect = __webpack_require__(461);

var DraftEditorEditHandler = {
  onBeforeInput: onBeforeInput,
  onBlur: onBlur,
  onCompositionStart: onCompositionStart,
  onCopy: onCopy,
  onCut: onCut,
  onDragOver: onDragOver,
  onDragStart: onDragStart,
  onFocus: onFocus,
  onInput: onInput,
  onKeyDown: onKeyDown,
  onPaste: onPaste,
  onSelect: onSelect
};

module.exports = DraftEditorEditHandler;

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule editOnBeforeInput
 * @format
 * 
 */



var BlockTree = __webpack_require__(364);
var DraftModifier = __webpack_require__(326);
var EditorState = __webpack_require__(325);
var UserAgent = __webpack_require__(330);

var getEntityKeyForSelection = __webpack_require__(353);
var isEventHandled = __webpack_require__(342);
var isSelectionAtLeafStart = __webpack_require__(368);
var nullthrows = __webpack_require__(329);
var setImmediate = __webpack_require__(432);

// When nothing is focused, Firefox regards two characters, `'` and `/`, as
// commands that should open and focus the "quickfind" search bar. This should
// *never* happen while a contenteditable is focused, but as of v28, it
// sometimes does, even when the keypress event target is the contenteditable.
// This breaks the input. Special case these characters to ensure that when
// they are typed, we prevent default on the event to make sure not to
// trigger quickfind.
var FF_QUICKFIND_CHAR = "'";
var FF_QUICKFIND_LINK_CHAR = '/';
var isFirefox = UserAgent.isBrowser('Firefox');

function mustPreventDefaultForCharacter(character) {
  return isFirefox && (character == FF_QUICKFIND_CHAR || character == FF_QUICKFIND_LINK_CHAR);
}

/**
 * Replace the current selection with the specified text string, with the
 * inline style and entity key applied to the newly inserted text.
 */
function replaceText(editorState, text, inlineStyle, entityKey) {
  var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), text, inlineStyle, entityKey);
  return EditorState.push(editorState, contentState, 'insert-characters');
}

/**
 * When `onBeforeInput` executes, the browser is attempting to insert a
 * character into the editor. Apply this character data to the document,
 * allowing native insertion if possible.
 *
 * Native insertion is encouraged in order to limit re-rendering and to
 * preserve spellcheck highlighting, which disappears or flashes if re-render
 * occurs on the relevant text nodes.
 */
function editOnBeforeInput(editor, e) {
  if (editor._pendingStateFromBeforeInput !== undefined) {
    editor.update(editor._pendingStateFromBeforeInput);
    editor._pendingStateFromBeforeInput = undefined;
  }

  var editorState = editor._latestEditorState;

  var chars = e.data;

  // In some cases (ex: IE ideographic space insertion) no character data
  // is provided. There's nothing to do when this happens.
  if (!chars) {
    return;
  }

  // Allow the top-level component to handle the insertion manually. This is
  // useful when triggering interesting behaviors for a character insertion,
  // Simple examples: replacing a raw text ':)' with a smile emoji or image
  // decorator, or setting a block to be a list item after typing '- ' at the
  // start of the block.
  if (editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(chars, editorState))) {
    e.preventDefault();
    return;
  }

  // If selection is collapsed, conditionally allow native behavior. This
  // reduces re-renders and preserves spellcheck highlighting. If the selection
  // is not collapsed, we will re-render.
  var selection = editorState.getSelection();
  var selectionStart = selection.getStartOffset();
  var selectionEnd = selection.getEndOffset();
  var anchorKey = selection.getAnchorKey();

  if (!selection.isCollapsed()) {
    e.preventDefault();

    // If the currently selected text matches what the user is trying to
    // replace it with, let's just update the `SelectionState`. If not, update
    // the `ContentState` with the new text.
    var currentlySelectedChars = editorState.getCurrentContent().getPlainText().slice(selectionStart, selectionEnd);
    if (chars === currentlySelectedChars) {
      editor.update(EditorState.forceSelection(editorState, selection.merge({
        focusOffset: selectionEnd
      })));
    } else {
      editor.update(replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())));
    }
    return;
  }

  var newEditorState = replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection()));

  // Bunch of different cases follow where we need to prevent native insertion.
  var mustPreventNative = false;
  if (!mustPreventNative) {
    // Browsers tend to insert text in weird places in the DOM when typing at
    // the start of a leaf, so we'll handle it ourselves.
    mustPreventNative = isSelectionAtLeafStart(editor._latestCommittedEditorState);
  }
  if (!mustPreventNative) {
    // Chrome will also split up a node into two pieces if it contains a Tab
    // char, for no explicable reason. Seemingly caused by this commit:
    // https://chromium.googlesource.com/chromium/src/+/013ac5eaf3%5E%21/
    var nativeSelection = global.getSelection();
    // Selection is necessarily collapsed at this point due to earlier check.
    if (nativeSelection.anchorNode && nativeSelection.anchorNode.nodeType === Node.TEXT_NODE) {
      // See isTabHTMLSpanElement in chromium EditingUtilities.cpp.
      var parentNode = nativeSelection.anchorNode.parentNode;
      mustPreventNative = parentNode.nodeName === 'SPAN' && parentNode.firstChild.nodeType === Node.TEXT_NODE && parentNode.firstChild.nodeValue.indexOf('\t') !== -1;
    }
  }
  if (!mustPreventNative) {
    // Check the old and new "fingerprints" of the current block to determine
    // whether this insertion requires any addition or removal of text nodes,
    // in which case we would prevent the native character insertion.
    var originalFingerprint = BlockTree.getFingerprint(editorState.getBlockTree(anchorKey));
    var newFingerprint = BlockTree.getFingerprint(newEditorState.getBlockTree(anchorKey));
    mustPreventNative = originalFingerprint !== newFingerprint;
  }
  if (!mustPreventNative) {
    mustPreventNative = mustPreventDefaultForCharacter(chars);
  }
  if (!mustPreventNative) {
    mustPreventNative = nullthrows(newEditorState.getDirectionMap()).get(anchorKey) !== nullthrows(editorState.getDirectionMap()).get(anchorKey);
  }

  if (mustPreventNative) {
    e.preventDefault();
    editor.update(newEditorState);
    return;
  }

  // We made it all the way! Let the browser do its thing and insert the char.
  newEditorState = EditorState.set(newEditorState, {
    nativelyRenderedContent: newEditorState.getCurrentContent()
  });
  // The native event is allowed to occur. To allow user onChange handlers to
  // change the inserted text, we wait until the text is actually inserted
  // before we actually update our state. That way when we rerender, the text
  // we see in the DOM will already have been inserted properly.
  editor._pendingStateFromBeforeInput = newEditorState;
  setImmediate(function () {
    if (editor._pendingStateFromBeforeInput !== undefined) {
      editor.update(editor._pendingStateFromBeforeInput);
      editor._pendingStateFromBeforeInput = undefined;
    }
  });
}

module.exports = editOnBeforeInput;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



// setimmediate adds setImmediate to the global. We want to make sure we export
// the actual function.

__webpack_require__(433);
module.exports = global.setImmediate;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(199)))

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule editOnBlur
 * @format
 * 
 */



var EditorState = __webpack_require__(325);

var containsNode = __webpack_require__(193);
var getActiveElement = __webpack_require__(196);

function editOnBlur(editor, e) {
  // In a contentEditable element, when you select a range and then click
  // another active element, this does trigger a `blur` event but will not
  // remove the DOM selection from the contenteditable.
  // This is consistent across all browsers, but we prefer that the editor
  // behave like a textarea, where a `blur` event clears the DOM selection.
  // We therefore force the issue to be certain, checking whether the active
  // element is `body` to force it when blurring occurs within the window (as
  // opposed to clicking to another tab or window).
  if (getActiveElement() === document.body) {
    var _selection = global.getSelection();
    var editorNode = editor.editor;
    if (_selection.rangeCount === 1 && containsNode(editorNode, _selection.anchorNode) && containsNode(editorNode, _selection.focusNode)) {
      _selection.removeAllRanges();
    }
  }

  var editorState = editor._latestEditorState;
  var currentSelection = editorState.getSelection();
  if (!currentSelection.getHasFocus()) {
    return;
  }

  var selection = currentSelection.set('hasFocus', false);
  editor.props.onBlur && editor.props.onBlur(e);
  editor.update(EditorState.acceptSelection(editorState, selection));
}

module.exports = editOnBlur;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule editOnCompositionStart
 * @format
 * 
 */



var EditorState = __webpack_require__(325);

/**
 * The user has begun using an IME input system. Switching to `composite` mode
 * allows handling composition input and disables other edit behavior.
 */
function editOnCompositionStart(editor, e) {
  editor.setMode('composite');
  editor.update(EditorState.set(editor._latestEditorState, { inCompositionMode: true }));
  // Allow composition handler to interpret the compositionstart event
  editor._onCompositionStart(e);
}

module.exports = editOnCompositionStart;

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule editOnCopy
 * @format
 * 
 */



var getFragmentFromSelection = __webpack_require__(375);

/**
 * If we have a selection, create a ContentState fragment and store
 * it in our internal clipboard. Subsequent paste events will use this
 * fragment if no external clipboard data is supplied.
 */
function editOnCopy(editor, e) {
  var editorState = editor._latestEditorState;
  var selection = editorState.getSelection();

  // No selection, so there's nothing to copy.
  if (selection.isCollapsed()) {
    e.preventDefault();
    return;
  }

  editor.setClipboard(getFragmentFromSelection(editor._latestEditorState));
}

module.exports = editOnCopy;

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule editOnCut
 * @format
 * 
 */



var DraftModifier = __webpack_require__(326);
var EditorState = __webpack_require__(325);
var Style = __webpack_require__(354);

var getFragmentFromSelection = __webpack_require__(375);
var getScrollPosition = __webpack_require__(355);

/**
 * On `cut` events, native behavior is allowed to occur so that the system
 * clipboard is set properly. This means that we need to take steps to recover
 * the editor DOM state after the `cut` has occurred in order to maintain
 * control of the component.
 *
 * In addition, we can keep a copy of the removed fragment, including all
 * styles and entities, for use as an internal paste.
 */
function editOnCut(editor, e) {
  var editorState = editor._latestEditorState;
  var selection = editorState.getSelection();
  var element = e.target;
  var scrollPosition = void 0;

  // No selection, so there's nothing to cut.
  if (selection.isCollapsed()) {
    e.preventDefault();
    return;
  }

  // Track the current scroll position so that it can be forced back in place
  // after the editor regains control of the DOM.
  if (element instanceof Node) {
    scrollPosition = getScrollPosition(Style.getScrollParent(element));
  }

  var fragment = getFragmentFromSelection(editorState);
  editor.setClipboard(fragment);

  // Set `cut` mode to disable all event handling temporarily.
  editor.setMode('cut');

  // Let native `cut` behavior occur, then recover control.
  setTimeout(function () {
    editor.restoreEditorDOM(scrollPosition);
    editor.exitCurrentMode();
    editor.update(removeFragment(editorState));
  }, 0);
}

function removeFragment(editorState) {
  var newContent = DraftModifier.removeRange(editorState.getCurrentContent(), editorState.getSelection(), 'forward');
  return EditorState.push(editorState, newContent, 'remove-range');
}

module.exports = editOnCut;

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule editOnDragOver
 * @format
 * 
 */



/**
 * Drag behavior has begun from outside the editor element.
 */
function editOnDragOver(editor, e) {
  editor._internalDrag = false;
  editor.setMode('drag');
  e.preventDefault();
}

module.exports = editOnDragOver;

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule editOnDragStart
 * @format
 * 
 */



/**
 * A `dragstart` event has begun within the text editor component.
 */
function editOnDragStart(editor) {
  editor._internalDrag = true;
  editor.setMode('drag');
}

module.exports = editOnDragStart;

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule editOnFocus
 * @format
 * 
 */



var EditorState = __webpack_require__(325);
var UserAgent = __webpack_require__(330);

function editOnFocus(editor, e) {
  var editorState = editor._latestEditorState;
  var currentSelection = editorState.getSelection();
  if (currentSelection.getHasFocus()) {
    return;
  }

  var selection = currentSelection.set('hasFocus', true);
  editor.props.onFocus && editor.props.onFocus(e);

  // When the tab containing this text editor is hidden and the user does a
  // find-in-page in a _different_ tab, Chrome on Mac likes to forget what the
  // selection was right after sending this focus event and (if you let it)
  // moves the cursor back to the beginning of the editor, so we force the
  // selection here instead of simply accepting it in order to preserve the
  // old cursor position. See https://crbug.com/540004.
  // But it looks like this is fixed in Chrome 60.0.3081.0.
  // Other browsers also don't have this bug, so we prefer to acceptSelection
  // when possible, to ensure that unfocusing and refocusing a Draft editor
  // doesn't preserve the selection, matching how textareas work.
  if (UserAgent.isBrowser('Chrome < 60.0.3081.0')) {
    editor.update(EditorState.forceSelection(editorState, selection));
  } else {
    editor.update(EditorState.acceptSelection(editorState, selection));
  }
}

module.exports = editOnFocus;

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule editOnInput
 * @format
 * 
 */



var DraftFeatureFlags = __webpack_require__(332);
var DraftModifier = __webpack_require__(326);
var DraftOffsetKey = __webpack_require__(347);
var EditorState = __webpack_require__(325);
var UserAgent = __webpack_require__(330);

var findAncestorOffsetKey = __webpack_require__(356);
var nullthrows = __webpack_require__(329);

var isGecko = UserAgent.isEngine('Gecko');

var DOUBLE_NEWLINE = '\n\n';

/**
 * This function is intended to handle spellcheck and autocorrect changes,
 * which occur in the DOM natively without any opportunity to observe or
 * interpret the changes before they occur.
 *
 * The `input` event fires in contentEditable elements reliably for non-IE
 * browsers, immediately after changes occur to the editor DOM. Since our other
 * handlers override or otherwise handle cover other varieties of text input,
 * the DOM state should match the model in all controlled input cases. Thus,
 * when an `input` change leads to a DOM/model mismatch, the change should be
 * due to a spellcheck change, and we can incorporate it into our model.
 */
function editOnInput(editor) {
  if (editor._pendingStateFromBeforeInput !== undefined) {
    editor.update(editor._pendingStateFromBeforeInput);
    editor._pendingStateFromBeforeInput = undefined;
  }

  var domSelection = global.getSelection();

  var anchorNode = domSelection.anchorNode,
      isCollapsed = domSelection.isCollapsed;

  var isNotTextNode = anchorNode.nodeType !== Node.TEXT_NODE;
  var isNotTextOrElementNode = anchorNode.nodeType !== Node.TEXT_NODE && anchorNode.nodeType !== Node.ELEMENT_NODE;

  if (DraftFeatureFlags.draft_killswitch_allow_nontextnodes) {
    if (isNotTextNode) {
      return;
    }
  } else {
    if (isNotTextOrElementNode) {
      // TODO: (t16149272) figure out context for this change
      return;
    }
  }

  if (anchorNode.nodeType === Node.TEXT_NODE && (anchorNode.previousSibling !== null || anchorNode.nextSibling !== null)) {
    // When typing at the beginning of a visual line, Chrome splits the text
    // nodes into two. Why? No one knows. This commit is suspicious:
    // https://chromium.googlesource.com/chromium/src/+/a3b600981286b135632371477f902214c55a1724
    // To work around, we'll merge the sibling text nodes back into this one.
    var span = anchorNode.parentNode;
    anchorNode.nodeValue = span.textContent;
    for (var child = span.firstChild; child !== null; child = child.nextSibling) {
      if (child !== anchorNode) {
        span.removeChild(child);
      }
    }
  }

  var domText = anchorNode.textContent;
  var editorState = editor._latestEditorState;
  var offsetKey = nullthrows(findAncestorOffsetKey(anchorNode));

  var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey),
      blockKey = _DraftOffsetKey$decod.blockKey,
      decoratorKey = _DraftOffsetKey$decod.decoratorKey,
      leafKey = _DraftOffsetKey$decod.leafKey;

  var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, 'leaves', leafKey]),
      start = _editorState$getBlock.start,
      end = _editorState$getBlock.end;

  var content = editorState.getCurrentContent();
  var block = content.getBlockForKey(blockKey);
  var modelText = block.getText().slice(start, end);

  // Special-case soft newlines here. If the DOM text ends in a soft newline,
  // we will have manually inserted an extra soft newline in DraftEditorLeaf.
  // We want to remove this extra newline for the purpose of our comparison
  // of DOM and model text.
  if (domText.endsWith(DOUBLE_NEWLINE)) {
    domText = domText.slice(0, -1);
  }

  // No change -- the DOM is up to date. Nothing to do here.
  if (domText === modelText) {
    // This can be buggy for some Android keyboards because they don't fire
    // standard onkeydown/pressed events and only fired editOnInput
    // so domText is already changed by the browser and ends up being equal
    // to modelText unexpectedly
    return;
  }

  var selection = editorState.getSelection();

  // We'll replace the entire leaf with the text content of the target.
  var targetRange = selection.merge({
    anchorOffset: start,
    focusOffset: end,
    isBackward: false
  });

  var entityKey = block.getEntityAt(start);
  var entity = entityKey && content.getEntity(entityKey);
  var entityType = entity && entity.getMutability();
  var preserveEntity = entityType === 'MUTABLE';

  // Immutable or segmented entities cannot properly be handled by the
  // default browser undo, so we have to use a different change type to
  // force using our internal undo method instead of falling through to the
  // native browser undo.
  var changeType = preserveEntity ? 'spellcheck-change' : 'apply-entity';

  var newContent = DraftModifier.replaceText(content, targetRange, domText, block.getInlineStyleAt(start), preserveEntity ? block.getEntityAt(start) : null);

  var anchorOffset, focusOffset, startOffset, endOffset;

  if (isGecko) {
    // Firefox selection does not change while the context menu is open, so
    // we preserve the anchor and focus values of the DOM selection.
    anchorOffset = domSelection.anchorOffset;
    focusOffset = domSelection.focusOffset;
    startOffset = start + Math.min(anchorOffset, focusOffset);
    endOffset = startOffset + Math.abs(anchorOffset - focusOffset);
    anchorOffset = startOffset;
    focusOffset = endOffset;
  } else {
    // Browsers other than Firefox may adjust DOM selection while the context
    // menu is open, and Safari autocorrect is prone to providing an inaccurate
    // DOM selection. Don't trust it. Instead, use our existing SelectionState
    // and adjust it based on the number of characters changed during the
    // mutation.
    var charDelta = domText.length - modelText.length;
    startOffset = selection.getStartOffset();
    endOffset = selection.getEndOffset();

    anchorOffset = isCollapsed ? endOffset + charDelta : startOffset;
    focusOffset = endOffset + charDelta;
  }

  // Segmented entities are completely or partially removed when their
  // text content changes. For this case we do not want any text to be selected
  // after the change, so we are not merging the selection.
  var contentWithAdjustedDOMSelection = newContent.merge({
    selectionBefore: content.getSelectionAfter(),
    selectionAfter: selection.merge({ anchorOffset: anchorOffset, focusOffset: focusOffset })
  });

  editor.update(EditorState.push(editorState, contentWithAdjustedDOMSelection, changeType));
}

module.exports = editOnInput;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule editOnKeyDown
 * @format
 * 
 */



var DraftModifier = __webpack_require__(326);
var EditorState = __webpack_require__(325);
var KeyBindingUtil = __webpack_require__(357);
var Keys = __webpack_require__(352);
var SecondaryClipboard = __webpack_require__(443);
var UserAgent = __webpack_require__(330);

var isEventHandled = __webpack_require__(342);
var keyCommandBackspaceToStartOfLine = __webpack_require__(444);
var keyCommandBackspaceWord = __webpack_require__(446);
var keyCommandDeleteWord = __webpack_require__(448);
var keyCommandInsertNewline = __webpack_require__(449);
var keyCommandMoveSelectionToEndOfBlock = __webpack_require__(450);
var keyCommandMoveSelectionToStartOfBlock = __webpack_require__(451);
var keyCommandPlainBackspace = __webpack_require__(452);
var keyCommandPlainDelete = __webpack_require__(453);
var keyCommandTransposeCharacters = __webpack_require__(454);
var keyCommandUndo = __webpack_require__(455);

var isOptionKeyCommand = KeyBindingUtil.isOptionKeyCommand;

var isChrome = UserAgent.isBrowser('Chrome');

/**
 * Map a `DraftEditorCommand` command value to a corresponding function.
 */
function onKeyCommand(command, editorState) {
  switch (command) {
    case 'redo':
      return EditorState.redo(editorState);
    case 'delete':
      return keyCommandPlainDelete(editorState);
    case 'delete-word':
      return keyCommandDeleteWord(editorState);
    case 'backspace':
      return keyCommandPlainBackspace(editorState);
    case 'backspace-word':
      return keyCommandBackspaceWord(editorState);
    case 'backspace-to-start-of-line':
      return keyCommandBackspaceToStartOfLine(editorState);
    case 'split-block':
      return keyCommandInsertNewline(editorState);
    case 'transpose-characters':
      return keyCommandTransposeCharacters(editorState);
    case 'move-selection-to-start-of-block':
      return keyCommandMoveSelectionToStartOfBlock(editorState);
    case 'move-selection-to-end-of-block':
      return keyCommandMoveSelectionToEndOfBlock(editorState);
    case 'secondary-cut':
      return SecondaryClipboard.cut(editorState);
    case 'secondary-paste':
      return SecondaryClipboard.paste(editorState);
    default:
      return editorState;
  }
}

/**
 * Intercept keydown behavior to handle keys and commands manually, if desired.
 *
 * Keydown combinations may be mapped to `DraftCommand` values, which may
 * correspond to command functions that modify the editor or its contents.
 *
 * See `getDefaultKeyBinding` for defaults. Alternatively, the top-level
 * component may provide a custom mapping via the `keyBindingFn` prop.
 */
function editOnKeyDown(editor, e) {
  var keyCode = e.which;
  var editorState = editor._latestEditorState;

  switch (keyCode) {
    case Keys.RETURN:
      e.preventDefault();
      // The top-level component may manually handle newline insertion. If
      // no special handling is performed, fall through to command handling.
      if (editor.props.handleReturn && isEventHandled(editor.props.handleReturn(e, editorState))) {
        return;
      }
      break;
    case Keys.ESC:
      e.preventDefault();
      editor.props.onEscape && editor.props.onEscape(e);
      return;
    case Keys.TAB:
      editor.props.onTab && editor.props.onTab(e);
      return;
    case Keys.UP:
      editor.props.onUpArrow && editor.props.onUpArrow(e);
      return;
    case Keys.RIGHT:
      editor.props.onRightArrow && editor.props.onRightArrow(e);
      return;
    case Keys.DOWN:
      editor.props.onDownArrow && editor.props.onDownArrow(e);
      return;
    case Keys.LEFT:
      editor.props.onLeftArrow && editor.props.onLeftArrow(e);
      return;
    case Keys.SPACE:
      // Handling for OSX where option + space scrolls.
      if (isChrome && isOptionKeyCommand(e)) {
        e.preventDefault();
        // Insert a nbsp into the editor.
        var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), '\xA0');
        editor.update(EditorState.push(editorState, contentState, 'insert-characters'));
        return;
      }
  }

  var command = editor.props.keyBindingFn(e);

  // If no command is specified, allow keydown event to continue.
  if (!command) {
    return;
  }

  if (command === 'undo') {
    // Since undo requires some special updating behavior to keep the editor
    // in sync, handle it separately.
    keyCommandUndo(e, editorState, editor.update);
    return;
  }

  // At this point, we know that we're handling a command of some kind, so
  // we don't want to insert a character following the keydown.
  e.preventDefault();

  // Allow components higher up the tree to handle the command first.
  if (editor.props.handleKeyCommand && isEventHandled(editor.props.handleKeyCommand(command, editorState))) {
    return;
  }

  var newState = onKeyCommand(command, editorState);
  if (newState !== editorState) {
    editor.update(newState);
  }
}

module.exports = editOnKeyDown;

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SecondaryClipboard
 * @format
 * 
 */



var DraftModifier = __webpack_require__(326);
var EditorState = __webpack_require__(325);

var getContentStateFragment = __webpack_require__(345);
var nullthrows = __webpack_require__(329);

var clipboard = null;

/**
 * Some systems offer a "secondary" clipboard to allow quick internal cut
 * and paste behavior. For instance, Ctrl+K (cut) and Ctrl+Y (paste).
 */
var SecondaryClipboard = {
  cut: function cut(editorState) {
    var content = editorState.getCurrentContent();
    var selection = editorState.getSelection();
    var targetRange = null;

    if (selection.isCollapsed()) {
      var anchorKey = selection.getAnchorKey();
      var blockEnd = content.getBlockForKey(anchorKey).getLength();

      if (blockEnd === selection.getAnchorOffset()) {
        return editorState;
      }

      targetRange = selection.set('focusOffset', blockEnd);
    } else {
      targetRange = selection;
    }

    targetRange = nullthrows(targetRange);
    clipboard = getContentStateFragment(content, targetRange);

    var afterRemoval = DraftModifier.removeRange(content, targetRange, 'forward');

    if (afterRemoval === content) {
      return editorState;
    }

    return EditorState.push(editorState, afterRemoval, 'remove-range');
  },

  paste: function paste(editorState) {
    if (!clipboard) {
      return editorState;
    }

    var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), clipboard);

    return EditorState.push(editorState, newContent, 'insert-fragment');
  }
};

module.exports = SecondaryClipboard;

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyCommandBackspaceToStartOfLine
 * @format
 * 
 */



var EditorState = __webpack_require__(325);

var expandRangeToStartOfLine = __webpack_require__(445);
var getDraftEditorSelectionWithNodes = __webpack_require__(377);
var moveSelectionBackward = __webpack_require__(358);
var removeTextWithStrategy = __webpack_require__(343);

function keyCommandBackspaceToStartOfLine(editorState) {
  var afterRemoval = removeTextWithStrategy(editorState, function (strategyState) {
    var selection = strategyState.getSelection();
    if (selection.isCollapsed() && selection.getAnchorOffset() === 0) {
      return moveSelectionBackward(strategyState, 1);
    }

    var domSelection = global.getSelection();
    var range = domSelection.getRangeAt(0);
    range = expandRangeToStartOfLine(range);

    return getDraftEditorSelectionWithNodes(strategyState, null, range.endContainer, range.endOffset, range.startContainer, range.startOffset).selectionState;
  }, 'backward');

  if (afterRemoval === editorState.getCurrentContent()) {
    return editorState;
  }

  return EditorState.push(editorState, afterRemoval, 'remove-range');
}

module.exports = keyCommandBackspaceToStartOfLine;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule expandRangeToStartOfLine
 * @format
 * 
 */

var UnicodeUtils = __webpack_require__(334);

var getRangeClientRects = __webpack_require__(376);
var invariant = __webpack_require__(10);

/**
 * Return the computed line height, in pixels, for the provided element.
 */
function getLineHeightPx(element) {
  var computed = getComputedStyle(element);
  var div = document.createElement('div');
  div.style.fontFamily = computed.fontFamily;
  div.style.fontSize = computed.fontSize;
  div.style.fontStyle = computed.fontStyle;
  div.style.fontWeight = computed.fontWeight;
  div.style.lineHeight = computed.lineHeight;
  div.style.position = 'absolute';
  div.textContent = 'M';

  var documentBody = document.body;
  !documentBody ?  true ? invariant(false, 'Missing document.body') : invariant(false) : void 0;

  // forced layout here
  documentBody.appendChild(div);
  var rect = div.getBoundingClientRect();
  documentBody.removeChild(div);

  return rect.height;
}

/**
 * Return whether every ClientRect in the provided list lies on the same line.
 *
 * We assume that the rects on the same line all contain the baseline, so the
 * lowest top line needs to be above the highest bottom line (i.e., if you were
 * to project the rects onto the y-axis, their intersection would be nonempty).
 *
 * In addition, we require that no two boxes are lineHeight (or more) apart at
 * either top or bottom, which helps protect against false positives for fonts
 * with extremely large glyph heights (e.g., with a font size of 17px, Zapfino
 * produces rects of height 58px!).
 */
function areRectsOnOneLine(rects, lineHeight) {
  var minTop = Infinity;
  var minBottom = Infinity;
  var maxTop = -Infinity;
  var maxBottom = -Infinity;

  for (var ii = 0; ii < rects.length; ii++) {
    var rect = rects[ii];
    if (rect.width === 0 || rect.width === 1) {
      // When a range starts or ends a soft wrap, many browsers (Chrome, IE,
      // Safari) include an empty rect on the previous or next line. When the
      // text lies in a container whose position is not integral (e.g., from
      // margin: auto), Safari makes these empty rects have width 1 (instead of
      // 0). Having one-pixel-wide characters seems unlikely (and most browsers
      // report widths in subpixel precision anyway) so it's relatively safe to
      // skip over them.
      continue;
    }
    minTop = Math.min(minTop, rect.top);
    minBottom = Math.min(minBottom, rect.bottom);
    maxTop = Math.max(maxTop, rect.top);
    maxBottom = Math.max(maxBottom, rect.bottom);
  }

  return maxTop <= minBottom && maxTop - minTop < lineHeight && maxBottom - minBottom < lineHeight;
}

/**
 * Return the length of a node, as used by Range offsets.
 */
function getNodeLength(node) {
  // http://www.w3.org/TR/dom/#concept-node-length
  switch (node.nodeType) {
    case Node.DOCUMENT_TYPE_NODE:
      return 0;
    case Node.TEXT_NODE:
    case Node.PROCESSING_INSTRUCTION_NODE:
    case Node.COMMENT_NODE:
      return node.length;
    default:
      return node.childNodes.length;
  }
}

/**
 * Given a collapsed range, move the start position backwards as far as
 * possible while the range still spans only a single line.
 */
function expandRangeToStartOfLine(range) {
  !range.collapsed ?  true ? invariant(false, 'expandRangeToStartOfLine: Provided range is not collapsed.') : invariant(false) : void 0;
  range = range.cloneRange();

  var containingElement = range.startContainer;
  if (containingElement.nodeType !== 1) {
    containingElement = containingElement.parentNode;
  }
  var lineHeight = getLineHeightPx(containingElement);

  // Imagine our text looks like:
  //   <div><span>once upon a time, there was a <em>boy
  //   who lived</em> </span><q><strong>under^ the
  //   stairs</strong> in a small closet.</q></div>
  // where the caret represents the cursor. First, we crawl up the tree until
  // the range spans multiple lines (setting the start point to before
  // "<strong>", then before "<div>"), then at each level we do a search to
  // find the latest point which is still on a previous line. We'll find that
  // the break point is inside the span, then inside the <em>, then in its text
  // node child, the actual break point before "who".

  var bestContainer = range.endContainer;
  var bestOffset = range.endOffset;
  range.setStart(range.startContainer, 0);

  while (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {
    bestContainer = range.startContainer;
    bestOffset = range.startOffset;
    !bestContainer.parentNode ?  true ? invariant(false, 'Found unexpected detached subtree when traversing.') : invariant(false) : void 0;
    range.setStartBefore(bestContainer);
    if (bestContainer.nodeType === 1 && getComputedStyle(bestContainer).display !== 'inline') {
      // The start of the line is never in a different block-level container.
      break;
    }
  }

  // In the above example, range now spans from "<div>" to "under",
  // bestContainer is <div>, and bestOffset is 1 (index of <q> inside <div>)].
  // Picking out which child to recurse into here is a special case since we
  // don't want to check past <q> -- once we find that the final range starts
  // in <span>, we can look at all of its children (and all of their children)
  // to find the break point.

  // At all times, (bestContainer, bestOffset) is the latest single-line start
  // point that we know of.
  var currentContainer = bestContainer;
  var maxIndexToConsider = bestOffset - 1;

  do {
    var nodeValue = currentContainer.nodeValue;

    for (var ii = maxIndexToConsider; ii >= 0; ii--) {
      if (nodeValue != null && ii > 0 && UnicodeUtils.isSurrogatePair(nodeValue, ii - 1)) {
        // We're in the middle of a surrogate pair -- skip over so we never
        // return a range with an endpoint in the middle of a code point.
        continue;
      }

      range.setStart(currentContainer, ii);
      if (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {
        bestContainer = currentContainer;
        bestOffset = ii;
      } else {
        break;
      }
    }

    if (ii === -1 || currentContainer.childNodes.length === 0) {
      // If ii === -1, then (bestContainer, bestOffset), which is equal to
      // (currentContainer, 0), was a single-line start point but a start
      // point before currentContainer wasn't, so the line break seems to
      // have occurred immediately after currentContainer's start tag
      //
      // If currentContainer.childNodes.length === 0, we're already at a
      // terminal node (e.g., text node) and should return our current best.
      break;
    }

    currentContainer = currentContainer.childNodes[ii];
    maxIndexToConsider = getNodeLength(currentContainer);
  } while (true);

  range.setStart(bestContainer, bestOffset);
  return range;
}

module.exports = expandRangeToStartOfLine;

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyCommandBackspaceWord
 * @format
 * 
 */



var DraftRemovableWord = __webpack_require__(378);
var EditorState = __webpack_require__(325);

var moveSelectionBackward = __webpack_require__(358);
var removeTextWithStrategy = __webpack_require__(343);

/**
 * Delete the word that is left of the cursor, as well as any spaces or
 * punctuation after the word.
 */
function keyCommandBackspaceWord(editorState) {
  var afterRemoval = removeTextWithStrategy(editorState, function (strategyState) {
    var selection = strategyState.getSelection();
    var offset = selection.getStartOffset();
    // If there are no words before the cursor, remove the preceding newline.
    if (offset === 0) {
      return moveSelectionBackward(strategyState, 1);
    }
    var key = selection.getStartKey();
    var content = strategyState.getCurrentContent();
    var text = content.getBlockForKey(key).getText().slice(0, offset);
    var toRemove = DraftRemovableWord.getBackward(text);
    return moveSelectionBackward(strategyState, toRemove.length || 1);
  }, 'backward');

  if (afterRemoval === editorState.getCurrentContent()) {
    return editorState;
  }

  return EditorState.push(editorState, afterRemoval, 'remove-range');
}

module.exports = keyCommandBackspaceWord;

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * @stub
 * 
 */



// \u00a1-\u00b1\u00b4-\u00b8\u00ba\u00bb\u00bf
//             is latin supplement punctuation except fractions and superscript
//             numbers
// \u2010-\u2027\u2030-\u205e
//             is punctuation from the general punctuation block:
//             weird quotes, commas, bullets, dashes, etc.
// \u30fb\u3001\u3002\u3008-\u3011\u3014-\u301f
//             is CJK punctuation
// \uff1a-\uff1f\uff01-\uff0f\uff3b-\uff40\uff5b-\uff65
//             is some full-width/half-width punctuation
// \u2E2E\u061f\u066a-\u066c\u061b\u060c\u060d\uFD3e\uFD3F
//             is some Arabic punctuation marks
// \u1801\u0964\u104a\u104b
//             is misc. other language punctuation marks

var PUNCTUATION = '[.,+*?$|#{}()\'\\^\\-\\[\\]\\\\\\/!@%"~=<>_:;' + '\u30FB\u3001\u3002\u3008-\u3011\u3014-\u301F\uFF1A-\uFF1F\uFF01-\uFF0F' + '\uFF3B-\uFF40\uFF5B-\uFF65\u2E2E\u061F\u066A-\u066C\u061B\u060C\u060D' + '\uFD3E\uFD3F\u1801\u0964\u104A\u104B\u2010-\u2027\u2030-\u205E' + '\xA1-\xB1\xB4-\xB8\xBA\xBB\xBF]';

module.exports = {
  getPunctuation: function getPunctuation() {
    return PUNCTUATION;
  }
};

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyCommandDeleteWord
 * @format
 * 
 */



var DraftRemovableWord = __webpack_require__(378);
var EditorState = __webpack_require__(325);

var moveSelectionForward = __webpack_require__(379);
var removeTextWithStrategy = __webpack_require__(343);

/**
 * Delete the word that is right of the cursor, as well as any spaces or
 * punctuation before the word.
 */
function keyCommandDeleteWord(editorState) {
  var afterRemoval = removeTextWithStrategy(editorState, function (strategyState) {
    var selection = strategyState.getSelection();
    var offset = selection.getStartOffset();
    var key = selection.getStartKey();
    var content = strategyState.getCurrentContent();
    var text = content.getBlockForKey(key).getText().slice(offset);
    var toRemove = DraftRemovableWord.getForward(text);

    // If there are no words in front of the cursor, remove the newline.
    return moveSelectionForward(strategyState, toRemove.length || 1);
  }, 'forward');

  if (afterRemoval === editorState.getCurrentContent()) {
    return editorState;
  }

  return EditorState.push(editorState, afterRemoval, 'remove-range');
}

module.exports = keyCommandDeleteWord;

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyCommandInsertNewline
 * @format
 * 
 */



var DraftModifier = __webpack_require__(326);
var EditorState = __webpack_require__(325);

function keyCommandInsertNewline(editorState) {
  var contentState = DraftModifier.splitBlock(editorState.getCurrentContent(), editorState.getSelection());
  return EditorState.push(editorState, contentState, 'split-block');
}

module.exports = keyCommandInsertNewline;

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyCommandMoveSelectionToEndOfBlock
 * @format
 * 
 */



var EditorState = __webpack_require__(325);

/**
 * See comment for `moveSelectionToStartOfBlock`.
 */
function keyCommandMoveSelectionToEndOfBlock(editorState) {
  var selection = editorState.getSelection();
  var endKey = selection.getEndKey();
  var content = editorState.getCurrentContent();
  var textLength = content.getBlockForKey(endKey).getLength();
  return EditorState.set(editorState, {
    selection: selection.merge({
      anchorKey: endKey,
      anchorOffset: textLength,
      focusKey: endKey,
      focusOffset: textLength,
      isBackward: false
    }),
    forceSelection: true
  });
}

module.exports = keyCommandMoveSelectionToEndOfBlock;

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyCommandMoveSelectionToStartOfBlock
 * @format
 * 
 */



var EditorState = __webpack_require__(325);

/**
 * Collapse selection at the start of the first selected block. This is used
 * for Firefox versions that attempt to navigate forward/backward instead of
 * moving the cursor. Other browsers are able to move the cursor natively.
 */
function keyCommandMoveSelectionToStartOfBlock(editorState) {
  var selection = editorState.getSelection();
  var startKey = selection.getStartKey();
  return EditorState.set(editorState, {
    selection: selection.merge({
      anchorKey: startKey,
      anchorOffset: 0,
      focusKey: startKey,
      focusOffset: 0,
      isBackward: false
    }),
    forceSelection: true
  });
}

module.exports = keyCommandMoveSelectionToStartOfBlock;

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyCommandPlainBackspace
 * @format
 * 
 */



var EditorState = __webpack_require__(325);
var UnicodeUtils = __webpack_require__(334);

var moveSelectionBackward = __webpack_require__(358);
var removeTextWithStrategy = __webpack_require__(343);

/**
 * Remove the selected range. If the cursor is collapsed, remove the preceding
 * character. This operation is Unicode-aware, so removing a single character
 * will remove a surrogate pair properly as well.
 */
function keyCommandPlainBackspace(editorState) {
  var afterRemoval = removeTextWithStrategy(editorState, function (strategyState) {
    var selection = strategyState.getSelection();
    var content = strategyState.getCurrentContent();
    var key = selection.getAnchorKey();
    var offset = selection.getAnchorOffset();
    var charBehind = content.getBlockForKey(key).getText()[offset - 1];
    return moveSelectionBackward(strategyState, charBehind ? UnicodeUtils.getUTF16Length(charBehind, 0) : 1);
  }, 'backward');

  if (afterRemoval === editorState.getCurrentContent()) {
    return editorState;
  }

  var selection = editorState.getSelection();
  return EditorState.push(editorState, afterRemoval.set('selectionBefore', selection), selection.isCollapsed() ? 'backspace-character' : 'remove-range');
}

module.exports = keyCommandPlainBackspace;

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyCommandPlainDelete
 * @format
 * 
 */



var EditorState = __webpack_require__(325);
var UnicodeUtils = __webpack_require__(334);

var moveSelectionForward = __webpack_require__(379);
var removeTextWithStrategy = __webpack_require__(343);

/**
 * Remove the selected range. If the cursor is collapsed, remove the following
 * character. This operation is Unicode-aware, so removing a single character
 * will remove a surrogate pair properly as well.
 */
function keyCommandPlainDelete(editorState) {
  var afterRemoval = removeTextWithStrategy(editorState, function (strategyState) {
    var selection = strategyState.getSelection();
    var content = strategyState.getCurrentContent();
    var key = selection.getAnchorKey();
    var offset = selection.getAnchorOffset();
    var charAhead = content.getBlockForKey(key).getText()[offset];
    return moveSelectionForward(strategyState, charAhead ? UnicodeUtils.getUTF16Length(charAhead, 0) : 1);
  }, 'forward');

  if (afterRemoval === editorState.getCurrentContent()) {
    return editorState;
  }

  var selection = editorState.getSelection();

  return EditorState.push(editorState, afterRemoval.set('selectionBefore', selection), selection.isCollapsed() ? 'delete-character' : 'remove-range');
}

module.exports = keyCommandPlainDelete;

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyCommandTransposeCharacters
 * @format
 * 
 */



var DraftModifier = __webpack_require__(326);
var EditorState = __webpack_require__(325);

var getContentStateFragment = __webpack_require__(345);

/**
 * Transpose the characters on either side of a collapsed cursor, or
 * if the cursor is at the end of the block, transpose the last two
 * characters.
 */
function keyCommandTransposeCharacters(editorState) {
  var selection = editorState.getSelection();
  if (!selection.isCollapsed()) {
    return editorState;
  }

  var offset = selection.getAnchorOffset();
  if (offset === 0) {
    return editorState;
  }

  var blockKey = selection.getAnchorKey();
  var content = editorState.getCurrentContent();
  var block = content.getBlockForKey(blockKey);
  var length = block.getLength();

  // Nothing to transpose if there aren't two characters.
  if (length <= 1) {
    return editorState;
  }

  var removalRange;
  var finalSelection;

  if (offset === length) {
    // The cursor is at the end of the block. Swap the last two characters.
    removalRange = selection.set('anchorOffset', offset - 1);
    finalSelection = selection;
  } else {
    removalRange = selection.set('focusOffset', offset + 1);
    finalSelection = removalRange.set('anchorOffset', offset + 1);
  }

  // Extract the character to move as a fragment. This preserves its
  // styling and entity, if any.
  var movedFragment = getContentStateFragment(content, removalRange);
  var afterRemoval = DraftModifier.removeRange(content, removalRange, 'backward');

  // After the removal, the insertion target is one character back.
  var selectionAfter = afterRemoval.getSelectionAfter();
  var targetOffset = selectionAfter.getAnchorOffset() - 1;
  var targetRange = selectionAfter.merge({
    anchorOffset: targetOffset,
    focusOffset: targetOffset
  });

  var afterInsert = DraftModifier.replaceWithFragment(afterRemoval, targetRange, movedFragment);

  var newEditorState = EditorState.push(editorState, afterInsert, 'insert-fragment');

  return EditorState.acceptSelection(newEditorState, finalSelection);
}

module.exports = keyCommandTransposeCharacters;

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyCommandUndo
 * @format
 * 
 */



var EditorState = __webpack_require__(325);

function keyCommandUndo(e, editorState, updateFn) {
  var undoneState = EditorState.undo(editorState);

  // If the last change to occur was a spellcheck change, allow the undo
  // event to fall through to the browser. This allows the browser to record
  // the unwanted change, which should soon lead it to learn not to suggest
  // the correction again.
  if (editorState.getLastChangeType() === 'spellcheck-change') {
    var nativelyRenderedContent = undoneState.getCurrentContent();
    updateFn(EditorState.set(undoneState, { nativelyRenderedContent: nativelyRenderedContent }));
    return;
  }

  // Otheriwse, manage the undo behavior manually.
  e.preventDefault();
  if (!editorState.getNativelyRenderedContent()) {
    updateFn(undoneState);
    return;
  }

  // Trigger a re-render with the current content state to ensure that the
  // component tree has up-to-date props for comparison.
  updateFn(EditorState.set(editorState, { nativelyRenderedContent: null }));

  // Wait to ensure that the re-render has occurred before performing
  // the undo action.
  setTimeout(function () {
    updateFn(undoneState);
  }, 0);
}

module.exports = keyCommandUndo;

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule editOnPaste
 * @format
 * 
 */



var BlockMapBuilder = __webpack_require__(340);
var CharacterMetadata = __webpack_require__(327);
var DataTransfer = __webpack_require__(371);
var DraftModifier = __webpack_require__(326);
var DraftPasteProcessor = __webpack_require__(457);
var EditorState = __webpack_require__(325);
var RichTextEditorUtil = __webpack_require__(382);

var getEntityKeyForSelection = __webpack_require__(353);
var getTextContentFromFiles = __webpack_require__(373);
var isEventHandled = __webpack_require__(342);
var splitTextIntoTextBlocks = __webpack_require__(460);

/**
 * Paste content.
 */
function editOnPaste(editor, e) {
  e.preventDefault();
  var data = new DataTransfer(e.clipboardData);

  // Get files, unless this is likely to be a string the user wants inline.
  if (!data.isRichText()) {
    var files = data.getFiles();
    var defaultFileText = data.getText();
    if (files.length > 0) {
      // Allow customized paste handling for images, etc. Otherwise, fall
      // through to insert text contents into the editor.
      if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {
        return;
      }

      getTextContentFromFiles(files, function ( /*string*/fileText) {
        fileText = fileText || defaultFileText;
        if (!fileText) {
          return;
        }

        var editorState = editor._latestEditorState;
        var blocks = splitTextIntoTextBlocks(fileText);
        var character = CharacterMetadata.create({
          style: editorState.getCurrentInlineStyle(),
          entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())
        });
        var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);

        var text = DraftPasteProcessor.processText(blocks, character, currentBlockType);
        var fragment = BlockMapBuilder.createFromArray(text);

        var withInsertedText = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);

        editor.update(EditorState.push(editorState, withInsertedText, 'insert-fragment'));
      });

      return;
    }
  }

  var textBlocks = [];
  var text = data.getText();
  var html = data.getHTML();
  var editorState = editor._latestEditorState;

  if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {
    return;
  }

  if (text) {
    textBlocks = splitTextIntoTextBlocks(text);
  }

  if (!editor.props.stripPastedStyles) {
    // If the text from the paste event is rich content that matches what we
    // already have on the internal clipboard, assume that we should just use
    // the clipboard fragment for the paste. This will allow us to preserve
    // styling and entities, if any are present. Note that newlines are
    // stripped during comparison -- this is because copy/paste within the
    // editor in Firefox and IE will not include empty lines. The resulting
    // paste will preserve the newlines correctly.
    var internalClipboard = editor.getClipboard();
    if (data.isRichText() && internalClipboard) {
      if (
      // If the editorKey is present in the pasted HTML, it should be safe to
      // assume this is an internal paste.
      html.indexOf(editor.getEditorKey()) !== -1 ||
      // The copy may have been made within a single block, in which case the
      // editor key won't be part of the paste. In this case, just check
      // whether the pasted text matches the internal clipboard.
      textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {
        editor.update(insertFragment(editor._latestEditorState, internalClipboard));
        return;
      }
    } else if (internalClipboard && data.types.includes('com.apple.webarchive') && !data.types.includes('text/html') && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {
      // Safari does not properly store text/html in some cases.
      // Use the internalClipboard if present and equal to what is on
      // the clipboard. See https://bugs.webkit.org/show_bug.cgi?id=19893.
      editor.update(insertFragment(editor._latestEditorState, internalClipboard));
      return;
    }

    // If there is html paste data, try to parse that.
    if (html) {
      var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);
      if (htmlFragment) {
        var contentBlocks = htmlFragment.contentBlocks,
            entityMap = htmlFragment.entityMap;

        if (contentBlocks) {
          var htmlMap = BlockMapBuilder.createFromArray(contentBlocks);
          editor.update(insertFragment(editor._latestEditorState, htmlMap, entityMap));
          return;
        }
      }
    }

    // Otherwise, create a new fragment from our pasted text. Also
    // empty the internal clipboard, since it's no longer valid.
    editor.setClipboard(null);
  }

  if (textBlocks.length) {
    var character = CharacterMetadata.create({
      style: editorState.getCurrentInlineStyle(),
      entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())
    });

    var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);

    var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);

    var textMap = BlockMapBuilder.createFromArray(textFragment);
    editor.update(insertFragment(editor._latestEditorState, textMap));
  }
}

function insertFragment(editorState, fragment, entityMap) {
  var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);
  // TODO: merge the entity map once we stop using DraftEntity
  // like this:
  // const mergedEntityMap = newContent.getEntityMap().merge(entityMap);

  return EditorState.push(editorState, newContent.set('entityMap', entityMap), 'insert-fragment');
}

function areTextBlocksAndClipboardEqual(textBlocks, blockMap) {
  return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function (block, ii) {
    return block.getText() === textBlocks[ii];
  });
}

module.exports = editOnPaste;

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftPasteProcessor
 * @format
 * 
 */



var _assign = __webpack_require__(18);

var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var CharacterMetadata = __webpack_require__(327);
var ContentBlock = __webpack_require__(333);
var ContentBlockNode = __webpack_require__(328);
var DraftFeatureFlags = __webpack_require__(332);
var Immutable = __webpack_require__(324);

var convertFromHTMLtoContentBlocks = __webpack_require__(380);
var generateRandomKey = __webpack_require__(331);
var getSafeBodyFromHTML = __webpack_require__(381);
var sanitizeDraftText = __webpack_require__(349);

var List = Immutable.List,
    Repeat = Immutable.Repeat;


var experimentalTreeDataSupport = DraftFeatureFlags.draft_tree_data_support;
var ContentBlockRecord = experimentalTreeDataSupport ? ContentBlockNode : ContentBlock;

var DraftPasteProcessor = {
  processHTML: function processHTML(html, blockRenderMap) {
    return convertFromHTMLtoContentBlocks(html, getSafeBodyFromHTML, blockRenderMap);
  },
  processText: function processText(textBlocks, character, type) {
    return textBlocks.reduce(function (acc, textLine, index) {
      textLine = sanitizeDraftText(textLine);
      var key = generateRandomKey();

      var blockNodeConfig = {
        key: key,
        type: type,
        text: textLine,
        characterList: List(Repeat(character, textLine.length))
      };

      // next block updates previous block
      if (experimentalTreeDataSupport && index !== 0) {
        var prevSiblingIndex = index - 1;
        // update previous block
        var previousBlock = acc[prevSiblingIndex] = acc[prevSiblingIndex].merge({
          nextSibling: key
        });
        blockNodeConfig = _extends({}, blockNodeConfig, {
          prevSibling: previousBlock.getKey()
        });
      }

      acc.push(new ContentBlockRecord(blockNodeConfig));

      return acc;
    }, []);
  }
};

module.exports = DraftPasteProcessor;

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var URI = function () {
  function URI(uri) {
    _classCallCheck(this, URI);

    this._uri = uri;
  }

  URI.prototype.toString = function toString() {
    return this._uri;
  };

  return URI;
}();

module.exports = URI;

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule adjustBlockDepthForContentState
 * @format
 * 
 */



function adjustBlockDepthForContentState(contentState, selectionState, adjustment, maxDepth) {
  var startKey = selectionState.getStartKey();
  var endKey = selectionState.getEndKey();
  var blockMap = contentState.getBlockMap();
  var blocks = blockMap.toSeq().skipUntil(function (_, k) {
    return k === startKey;
  }).takeUntil(function (_, k) {
    return k === endKey;
  }).concat([[endKey, blockMap.get(endKey)]]).map(function (block) {
    var depth = block.getDepth() + adjustment;
    depth = Math.max(0, Math.min(depth, maxDepth));
    return block.set('depth', depth);
  });

  blockMap = blockMap.merge(blocks);

  return contentState.merge({
    blockMap: blockMap,
    selectionBefore: selectionState,
    selectionAfter: selectionState
  });
}

module.exports = adjustBlockDepthForContentState;

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule splitTextIntoTextBlocks
 * @format
 * 
 */



var NEWLINE_REGEX = /\r\n?|\n/g;

function splitTextIntoTextBlocks(text) {
  return text.split(NEWLINE_REGEX);
}

module.exports = splitTextIntoTextBlocks;

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule editOnSelect
 * @format
 * 
 */



var EditorState = __webpack_require__(325);
var ReactDOM = __webpack_require__(32);

var getDraftEditorSelection = __webpack_require__(462);
var invariant = __webpack_require__(10);

function editOnSelect(editor) {
  if (editor._blockSelectEvents || editor._latestEditorState !== editor.props.editorState) {
    return;
  }

  var editorState = editor.props.editorState;
  var editorNode = ReactDOM.findDOMNode(editor.editorContainer);
  !editorNode ?  true ? invariant(false, 'Missing editorNode') : invariant(false) : void 0;
  !(editorNode.firstChild instanceof HTMLElement) ?  true ? invariant(false, 'editorNode.firstChild is not an HTMLElement') : invariant(false) : void 0;
  var documentSelection = getDraftEditorSelection(editorState, editorNode.firstChild);
  var updatedSelectionState = documentSelection.selectionState;

  if (updatedSelectionState !== editorState.getSelection()) {
    if (documentSelection.needsRecovery) {
      editorState = EditorState.forceSelection(editorState, updatedSelectionState);
    } else {
      editorState = EditorState.acceptSelection(editorState, updatedSelectionState);
    }
    editor.update(editorState);
  }
}

module.exports = editOnSelect;

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getDraftEditorSelection
 * @format
 * 
 */



var getDraftEditorSelectionWithNodes = __webpack_require__(377);

/**
 * Convert the current selection range to an anchor/focus pair of offset keys
 * and values that can be interpreted by components.
 */
function getDraftEditorSelection(editorState, root) {
  var selection = global.getSelection();

  // No active selection.
  if (selection.rangeCount === 0) {
    return {
      selectionState: editorState.getSelection().set('hasFocus', false),
      needsRecovery: false
    };
  }

  return getDraftEditorSelectionWithNodes(editorState, root, selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
}

module.exports = getDraftEditorSelection;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftEditorPlaceholder.react
 * @format
 * 
 */



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = __webpack_require__(1);

var cx = __webpack_require__(336);

/**
 * This component is responsible for rendering placeholder text for the
 * `DraftEditor` component.
 *
 * Override placeholder style via CSS.
 */
var DraftEditorPlaceholder = function (_React$Component) {
  _inherits(DraftEditorPlaceholder, _React$Component);

  function DraftEditorPlaceholder() {
    _classCallCheck(this, DraftEditorPlaceholder);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  DraftEditorPlaceholder.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    return this.props.text !== nextProps.text || this.props.editorState.getSelection().getHasFocus() !== nextProps.editorState.getSelection().getHasFocus();
  };

  DraftEditorPlaceholder.prototype.render = function render() {
    var hasFocus = this.props.editorState.getSelection().getHasFocus();

    var className = cx({
      'public/DraftEditorPlaceholder/root': true,
      'public/DraftEditorPlaceholder/hasFocus': hasFocus
    });

    var contentStyle = {
      whiteSpace: 'pre-wrap'
    };

    return React.createElement(
      'div',
      { className: className },
      React.createElement(
        'div',
        {
          className: cx('public/DraftEditorPlaceholder/inner'),
          id: this.props.accessibilityID,
          style: contentStyle },
        this.props.text
      )
    );
  };

  return DraftEditorPlaceholder;
}(React.Component);

module.exports = DraftEditorPlaceholder;

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule convertFromDraftStateToRaw
 * @format
 * 
 */



var _assign = __webpack_require__(18);

var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var ContentBlock = __webpack_require__(333);
var ContentBlockNode = __webpack_require__(328);
var DraftStringKey = __webpack_require__(384);

var encodeEntityRanges = __webpack_require__(465);
var encodeInlineStyleRanges = __webpack_require__(466);
var invariant = __webpack_require__(10);

var createRawBlock = function createRawBlock(block, entityStorageMap) {
  return {
    key: block.getKey(),
    text: block.getText(),
    type: block.getType(),
    depth: block.getDepth(),
    inlineStyleRanges: encodeInlineStyleRanges(block),
    entityRanges: encodeEntityRanges(block, entityStorageMap),
    data: block.getData().toObject()
  };
};

var insertRawBlock = function insertRawBlock(block, entityMap, rawBlocks, blockCacheRef) {
  if (block instanceof ContentBlock) {
    rawBlocks.push(createRawBlock(block, entityMap));
    return;
  }

  !(block instanceof ContentBlockNode) ?  true ? invariant(false, 'block is not a BlockNode') : invariant(false) : void 0;

  var parentKey = block.getParentKey();
  var rawBlock = blockCacheRef[block.getKey()] = _extends({}, createRawBlock(block, entityMap), {
    children: []
  });

  if (parentKey) {
    blockCacheRef[parentKey].children.push(rawBlock);
    return;
  }

  rawBlocks.push(rawBlock);
};

var encodeRawBlocks = function encodeRawBlocks(contentState, rawState) {
  var entityMap = rawState.entityMap;


  var rawBlocks = [];

  var blockCacheRef = {};
  var entityCacheRef = {};
  var entityStorageKey = 0;

  contentState.getBlockMap().forEach(function (block) {
    block.findEntityRanges(function (character) {
      return character.getEntity() !== null;
    }, function (start) {
      var entityKey = block.getEntityAt(start);
      // Stringify to maintain order of otherwise numeric keys.
      var stringifiedEntityKey = DraftStringKey.stringify(entityKey);
      // This makes this function resilient to two entities
      // erroneously having the same key
      if (entityCacheRef[stringifiedEntityKey]) {
        return;
      }
      entityCacheRef[stringifiedEntityKey] = entityKey;
      // we need the `any` casting here since this is a temporary state
      // where we will later on flip the entity map and populate it with
      // real entity, at this stage we just need to map back the entity
      // key used by the BlockNode
      entityMap[stringifiedEntityKey] = '' + entityStorageKey;
      entityStorageKey++;
    });

    insertRawBlock(block, entityMap, rawBlocks, blockCacheRef);
  });

  return {
    blocks: rawBlocks,
    entityMap: entityMap
  };
};

// Flip storage map so that our storage keys map to global
// DraftEntity keys.
var encodeRawEntityMap = function encodeRawEntityMap(contentState, rawState) {
  var blocks = rawState.blocks,
      entityMap = rawState.entityMap;


  var rawEntityMap = {};

  Object.keys(entityMap).forEach(function (key, index) {
    var entity = contentState.getEntity(DraftStringKey.unstringify(key));
    rawEntityMap[index] = {
      type: entity.getType(),
      mutability: entity.getMutability(),
      data: entity.getData()
    };
  });

  return {
    blocks: blocks,
    entityMap: rawEntityMap
  };
};

var convertFromDraftStateToRaw = function convertFromDraftStateToRaw(contentState) {
  var rawDraftContentState = {
    entityMap: {},
    blocks: []
  };

  // add blocks
  rawDraftContentState = encodeRawBlocks(contentState, rawDraftContentState);

  // add entities
  rawDraftContentState = encodeRawEntityMap(contentState, rawDraftContentState);

  return rawDraftContentState;
};

module.exports = convertFromDraftStateToRaw;

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule encodeEntityRanges
 * @format
 * 
 */



var DraftStringKey = __webpack_require__(384);
var UnicodeUtils = __webpack_require__(334);

var strlen = UnicodeUtils.strlen;

/**
 * Convert to UTF-8 character counts for storage.
 */

function encodeEntityRanges(block, storageMap) {
  var encoded = [];
  block.findEntityRanges(function (character) {
    return !!character.getEntity();
  }, function ( /*number*/start, /*number*/end) {
    var text = block.getText();
    var key = block.getEntityAt(start);
    encoded.push({
      offset: strlen(text.slice(0, start)),
      length: strlen(text.slice(start, end)),
      // Encode the key as a number for range storage.
      key: Number(storageMap[DraftStringKey.stringify(key)])
    });
  });
  return encoded;
}

module.exports = encodeEntityRanges;

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule encodeInlineStyleRanges
 * @format
 * 
 */



var UnicodeUtils = __webpack_require__(334);

var findRangesImmutable = __webpack_require__(341);

var areEqual = function areEqual(a, b) {
  return a === b;
};
var isTruthy = function isTruthy(a) {
  return !!a;
};
var EMPTY_ARRAY = [];

/**
 * Helper function for getting encoded styles for each inline style. Convert
 * to UTF-8 character counts for storage.
 */
function getEncodedInlinesForType(block, styleList, styleToEncode) {
  var ranges = [];

  // Obtain an array with ranges for only the specified style.
  var filteredInlines = styleList.map(function (style) {
    return style.has(styleToEncode);
  }).toList();

  findRangesImmutable(filteredInlines, areEqual,
  // We only want to keep ranges with nonzero style values.
  isTruthy, function (start, end) {
    var text = block.getText();
    ranges.push({
      offset: UnicodeUtils.strlen(text.slice(0, start)),
      length: UnicodeUtils.strlen(text.slice(start, end)),
      style: styleToEncode
    });
  });

  return ranges;
}

/*
 * Retrieve the encoded arrays of inline styles, with each individual style
 * treated separately.
 */
function encodeInlineStyleRanges(block) {
  var styleList = block.getCharacterList().map(function (c) {
    return c.getStyle();
  }).toList();
  var ranges = styleList.flatten().toSet().map(function (style) {
    return getEncodedInlinesForType(block, styleList, style);
  });

  return Array.prototype.concat.apply(EMPTY_ARRAY, ranges.toJS());
}

module.exports = encodeInlineStyleRanges;

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule convertFromRawToDraftState
 * @format
 * 
 */



var _assign = __webpack_require__(18);

var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var ContentBlock = __webpack_require__(333);
var ContentBlockNode = __webpack_require__(328);
var ContentState = __webpack_require__(348);
var DraftEntity = __webpack_require__(346);
var DraftFeatureFlags = __webpack_require__(332);
var DraftTreeAdapter = __webpack_require__(468);
var Immutable = __webpack_require__(324);
var SelectionState = __webpack_require__(335);

var createCharacterList = __webpack_require__(469);
var decodeEntityRanges = __webpack_require__(470);
var decodeInlineStyleRanges = __webpack_require__(471);
var generateRandomKey = __webpack_require__(331);
var invariant = __webpack_require__(10);

var experimentalTreeDataSupport = DraftFeatureFlags.draft_tree_data_support;

var List = Immutable.List,
    Map = Immutable.Map,
    OrderedMap = Immutable.OrderedMap;


var decodeBlockNodeConfig = function decodeBlockNodeConfig(block, entityMap) {
  var key = block.key,
      type = block.type,
      data = block.data,
      text = block.text,
      depth = block.depth;


  var blockNodeConfig = {
    text: text,
    depth: depth || 0,
    type: type || 'unstyled',
    key: key || generateRandomKey(),
    data: Map(data),
    characterList: decodeCharacterList(block, entityMap)
  };

  return blockNodeConfig;
};

var decodeCharacterList = function decodeCharacterList(block, entityMap) {
  var text = block.text,
      rawEntityRanges = block.entityRanges,
      rawInlineStyleRanges = block.inlineStyleRanges;


  var entityRanges = rawEntityRanges || [];
  var inlineStyleRanges = rawInlineStyleRanges || [];

  // Translate entity range keys to the DraftEntity map.
  return createCharacterList(decodeInlineStyleRanges(text, inlineStyleRanges), decodeEntityRanges(text, entityRanges.filter(function (range) {
    return entityMap.hasOwnProperty(range.key);
  }).map(function (range) {
    return _extends({}, range, { key: entityMap[range.key] });
  })));
};

var addKeyIfMissing = function addKeyIfMissing(block) {
  return _extends({}, block, {
    key: block.key || generateRandomKey()
  });
};

/**
 * Node stack is responsible to ensure we traverse the tree only once
 * in depth order, while also providing parent refs to inner nodes to
 * construct their links.
 */
var updateNodeStack = function updateNodeStack(stack, nodes, parentRef) {
  var nodesWithParentRef = nodes.map(function (block) {
    return _extends({}, block, {
      parentRef: parentRef
    });
  });

  // since we pop nodes from the stack we need to insert them in reverse
  return stack.concat(nodesWithParentRef.reverse());
};

/**
 * This will build a tree draft content state by creating the node
 * reference links into a single tree walk. Each node has a link
 * reference to "parent", "children", "nextSibling" and "prevSibling"
 * blockMap will be created using depth ordering.
 */
var decodeContentBlockNodes = function decodeContentBlockNodes(blocks, entityMap) {
  return blocks
  // ensure children have valid keys to enable sibling links
  .map(addKeyIfMissing).reduce(function (blockMap, block, index) {
    !Array.isArray(block.children) ?  true ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0;

    // ensure children have valid keys to enable sibling links
    var children = block.children.map(addKeyIfMissing);

    // root level nodes
    var contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(block, entityMap), {
      prevSibling: index === 0 ? null : blocks[index - 1].key,
      nextSibling: index === blocks.length - 1 ? null : blocks[index + 1].key,
      children: List(children.map(function (child) {
        return child.key;
      }))
    }));

    // push root node to blockMap
    blockMap = blockMap.set(contentBlockNode.getKey(), contentBlockNode);

    // this stack is used to ensure we visit all nodes respecting depth ordering
    var stack = updateNodeStack([], children, contentBlockNode);

    // start computing children nodes
    while (stack.length > 0) {
      // we pop from the stack and start processing this node
      var node = stack.pop();

      // parentRef already points to a converted ContentBlockNode
      var parentRef = node.parentRef;
      var siblings = parentRef.getChildKeys();
      var _index = siblings.indexOf(node.key);
      var isValidBlock = Array.isArray(node.children);

      if (!isValidBlock) {
        !isValidBlock ?  true ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0;
        break;
      }

      // ensure children have valid keys to enable sibling links
      var _children = node.children.map(addKeyIfMissing);

      var _contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(node, entityMap), {
        parent: parentRef.getKey(),
        children: List(_children.map(function (child) {
          return child.key;
        })),
        prevSibling: _index === 0 ? null : siblings.get(_index - 1),
        nextSibling: _index === siblings.size - 1 ? null : siblings.get(_index + 1)
      }));

      // push node to blockMap
      blockMap = blockMap.set(_contentBlockNode.getKey(), _contentBlockNode);

      // this stack is used to ensure we visit all nodes respecting depth ordering
      stack = updateNodeStack(stack, _children, _contentBlockNode);
    }

    return blockMap;
  }, OrderedMap());
};

var decodeContentBlocks = function decodeContentBlocks(blocks, entityMap) {
  return OrderedMap(blocks.map(function (block) {
    var contentBlock = new ContentBlock(decodeBlockNodeConfig(block, entityMap));
    return [contentBlock.getKey(), contentBlock];
  }));
};

var decodeRawBlocks = function decodeRawBlocks(rawState, entityMap) {
  var isTreeRawBlock = Array.isArray(rawState.blocks[0].children);
  var rawBlocks = experimentalTreeDataSupport && !isTreeRawBlock ? DraftTreeAdapter.fromRawStateToRawTreeState(rawState).blocks : rawState.blocks;

  if (!experimentalTreeDataSupport) {
    return decodeContentBlocks(isTreeRawBlock ? DraftTreeAdapter.fromRawTreeStateToRawState(rawState).blocks : rawBlocks, entityMap);
  }

  return decodeContentBlockNodes(rawBlocks, entityMap);
};

var decodeRawEntityMap = function decodeRawEntityMap(rawState) {
  var rawEntityMap = rawState.entityMap;

  var entityMap = {};

  // TODO: Update this once we completely remove DraftEntity
  Object.keys(rawEntityMap).forEach(function (rawEntityKey) {
    var _rawEntityMap$rawEnti = rawEntityMap[rawEntityKey],
        type = _rawEntityMap$rawEnti.type,
        mutability = _rawEntityMap$rawEnti.mutability,
        data = _rawEntityMap$rawEnti.data;

    // get the key reference to created entity

    entityMap[rawEntityKey] = DraftEntity.__create(type, mutability, data || {});
  });

  return entityMap;
};

var convertFromRawToDraftState = function convertFromRawToDraftState(rawState) {
  !Array.isArray(rawState.blocks) ?  true ? invariant(false, 'invalid RawDraftContentState') : invariant(false) : void 0;

  // decode entities
  var entityMap = decodeRawEntityMap(rawState);

  // decode blockMap
  var blockMap = decodeRawBlocks(rawState, entityMap);

  // create initial selection
  var selectionState = blockMap.isEmpty() ? new SelectionState() : SelectionState.createEmpty(blockMap.first().getKey());

  return new ContentState({
    blockMap: blockMap,
    entityMap: entityMap,
    selectionBefore: selectionState,
    selectionAfter: selectionState
  });
};

module.exports = convertFromRawToDraftState;

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _assign = __webpack_require__(18);

var _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DraftTreeAdapter
 * @format
 * 
 *
 * This is unstable and not part of the public API and should not be used by
 * production systems. This file may be update/removed without notice.
 */

var invariant = __webpack_require__(10);

var traverseInDepthOrder = function traverseInDepthOrder(blocks, fn) {
  var stack = [].concat(blocks).reverse();
  while (stack.length) {
    var _block = stack.pop();

    fn(_block);

    var children = _block.children;

    !Array.isArray(children) ?  true ? invariant(false, 'Invalid tree raw block') : invariant(false) : void 0;

    stack = stack.concat([].concat(children.reverse()));
  }
};

var isListBlock = function isListBlock(block) {
  if (!(block && block.type)) {
    return false;
  }
  var type = block.type;

  return type === 'unordered-list-item' || type === 'ordered-list-item';
};

var addDepthToChildren = function addDepthToChildren(block) {
  if (Array.isArray(block.children)) {
    block.children = block.children.map(function (child) {
      return child.type === block.type ? _extends({}, child, { depth: (block.depth || 0) + 1 }) : child;
    });
  }
};

/**
 * This adapter is intended to be be used as an adapter to draft tree data
 *
 * draft state <=====> draft tree state
 */
var DraftTreeAdapter = {
  /**
   * Converts from a tree raw state back to  draft raw state
   */
  fromRawTreeStateToRawState: function fromRawTreeStateToRawState(draftTreeState) {
    var blocks = draftTreeState.blocks;

    var transformedBlocks = [];

    !Array.isArray(blocks) ?  true ? invariant(false, 'Invalid raw state') : invariant(false) : void 0;

    if (!Array.isArray(blocks) || !blocks.length) {
      return draftTreeState;
    }

    traverseInDepthOrder(blocks, function (block) {
      var newBlock = _extends({}, block);

      if (isListBlock(block)) {
        newBlock.depth = newBlock.depth || 0;
        addDepthToChildren(block);
      }

      delete newBlock.children;

      transformedBlocks.push(newBlock);
    });

    draftTreeState.blocks = transformedBlocks;

    return _extends({}, draftTreeState, {
      blocks: transformedBlocks
    });
  },


  /**
   * Converts from draft raw state to tree draft state
   */
  fromRawStateToRawTreeState: function fromRawStateToRawTreeState(draftState) {
    var lastListDepthCacheRef = {};
    var transformedBlocks = [];

    draftState.blocks.forEach(function (block) {
      var isList = isListBlock(block);
      var depth = block.depth || 0;
      var treeBlock = _extends({}, block, {
        children: []
      });

      if (!isList) {
        // reset the cache path
        lastListDepthCacheRef = {};
        transformedBlocks.push(treeBlock);
        return;
      }

      // update our depth cache reference path
      lastListDepthCacheRef[depth] = treeBlock;

      // if we are greater than zero we must have seen a parent already
      if (depth > 0) {
        var parent = lastListDepthCacheRef[depth - 1];

        !parent ?  true ? invariant(false, 'Invalid depth for RawDraftContentBlock') : invariant(false) : void 0;

        // push nested list blocks
        parent.children.push(treeBlock);
        return;
      }

      // push root list blocks
      transformedBlocks.push(treeBlock);
    });

    return _extends({}, draftState, {
      blocks: transformedBlocks
    });
  }
};

module.exports = DraftTreeAdapter;

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createCharacterList
 * @format
 * 
 */



var CharacterMetadata = __webpack_require__(327);
var Immutable = __webpack_require__(324);

var List = Immutable.List;


function createCharacterList(inlineStyles, entities) {
  var characterArray = inlineStyles.map(function (style, ii) {
    var entity = entities[ii];
    return CharacterMetadata.create({ style: style, entity: entity });
  });
  return List(characterArray);
}

module.exports = createCharacterList;

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule decodeEntityRanges
 * @format
 * 
 */



var UnicodeUtils = __webpack_require__(334);

var substr = UnicodeUtils.substr;

/**
 * Convert to native JavaScript string lengths to determine ranges.
 */

function decodeEntityRanges(text, ranges) {
  var entities = Array(text.length).fill(null);
  if (ranges) {
    ranges.forEach(function (range) {
      // Using Unicode-enabled substrings converted to JavaScript lengths,
      // fill the output array with entity keys.
      var start = substr(text, 0, range.offset).length;
      var end = start + substr(text, range.offset, range.length).length;
      for (var ii = start; ii < end; ii++) {
        entities[ii] = range.key;
      }
    });
  }
  return entities;
}

module.exports = decodeEntityRanges;

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule decodeInlineStyleRanges
 * @format
 * 
 */



var _require = __webpack_require__(324),
    OrderedSet = _require.OrderedSet;

var UnicodeUtils = __webpack_require__(334);

var substr = UnicodeUtils.substr;


var EMPTY_SET = OrderedSet();

/**
 * Convert to native JavaScript string lengths to determine ranges.
 */
function decodeInlineStyleRanges(text, ranges) {
  var styles = Array(text.length).fill(EMPTY_SET);
  if (ranges) {
    ranges.forEach(function ( /*object*/range) {
      var cursor = substr(text, 0, range.offset).length;
      var end = cursor + substr(text, range.offset, range.length).length;
      while (cursor < end) {
        styles[cursor] = styles[cursor].add(range.style);
        cursor++;
      }
    });
  }
  return styles;
}

module.exports = decodeInlineStyleRanges;

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getVisibleSelectionRect
 * @format
 * 
 */



var getRangeBoundingClientRect = __webpack_require__(473);

/**
 * Return the bounding ClientRect for the visible DOM selection, if any.
 * In cases where there are no selected ranges or the bounding rect is
 * temporarily invalid, return null.
 */
function getVisibleSelectionRect(global) {
  var selection = global.getSelection();
  if (!selection.rangeCount) {
    return null;
  }

  var range = selection.getRangeAt(0);
  var boundingRect = getRangeBoundingClientRect(range);
  var top = boundingRect.top,
      right = boundingRect.right,
      bottom = boundingRect.bottom,
      left = boundingRect.left;

  // When a re-render leads to a node being removed, the DOM selection will
  // temporarily be placed on an ancestor node, which leads to an invalid
  // bounding rect. Discard this state.

  if (top === 0 && right === 0 && bottom === 0 && left === 0) {
    return null;
  }

  return boundingRect;
}

module.exports = getVisibleSelectionRect;

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getRangeBoundingClientRect
 * @format
 * 
 */



var getRangeClientRects = __webpack_require__(376);

/**
 * Like range.getBoundingClientRect() but normalizes for browser bugs.
 */
function getRangeBoundingClientRect(range) {
  // "Return a DOMRect object describing the smallest rectangle that includes
  // the first rectangle in list and all of the remaining rectangles of which
  // the height or width is not zero."
  // http://www.w3.org/TR/cssom-view/#dom-range-getboundingclientrect
  var rects = getRangeClientRects(range);
  var top = 0;
  var right = 0;
  var bottom = 0;
  var left = 0;

  if (rects.length) {
    // If the first rectangle has 0 width, we use the second, this is needed
    // because Chrome renders a 0 width rectangle when the selection contains
    // a line break.
    if (rects.length > 1 && rects[0].width === 0) {
      var _rects$ = rects[1];
      top = _rects$.top;
      right = _rects$.right;
      bottom = _rects$.bottom;
      left = _rects$.left;
    } else {
      var _rects$2 = rects[0];
      top = _rects$2.top;
      right = _rects$2.right;
      bottom = _rects$2.bottom;
      left = _rects$2.left;
    }

    for (var ii = 1; ii < rects.length; ii++) {
      var rect = rects[ii];
      if (rect.height !== 0 && rect.width !== 0) {
        top = Math.min(top, rect.top);
        right = Math.max(right, rect.right);
        bottom = Math.max(bottom, rect.bottom);
        left = Math.min(left, rect.left);
      }
    }
  }

  return {
    top: top,
    right: right,
    bottom: bottom,
    left: left,
    width: right - left,
    height: bottom - top
  };
}

module.exports = getRangeBoundingClientRect;

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(1),__webpack_require__(359),__webpack_require__(475)):"function"==typeof define&&define.amd?define(["react","draft-js","immutable"],t):"object"==typeof exports?exports.reactDraftWysiwyg=t(require("react"),require("draft-js"),require("immutable")):e.reactDraftWysiwyg=t(e.react,e["draft-js"],e.immutable)}("undefined"!=typeof self?self:this,function(e,t,n){return function(e){function t(o){if(n[o])return n[o].exports;var i=n[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:o})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=13)}([function(t,n){t.exports=e},function(e,t,n){"use strict";"function"==typeof Symbol&&Symbol.iterator;e.exports=n(16)()},function(e,t,n){"use strict";var o,i,r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
!function(){function l(){for(var e=[],t=0;t<arguments.length;t++){var n=arguments[t];if(n){var o=void 0===n?"undefined":r(n);if("string"===o||"number"===o)e.push(n);else if(Array.isArray(n))e.push(l.apply(null,n));else if("object"===o)for(var i in n)a.call(n,i)&&n[i]&&e.push(i)}}return e.join(" ")}var a={}.hasOwnProperty;void 0!==e&&e.exports?e.exports=l:"object"===r(n(10))&&n(10)?(o=[],void 0!==(i=function(){return l}.apply(t,o))&&(e.exports=i)):window.classNames=l}()},function(e,n){e.exports=t},function(e,t,n){!function(t,o){e.exports=o(n(3),n(9))}("undefined"!=typeof self&&self,function(e,t){return function(e){function t(o){if(n[o])return n[o].exports;var i=n[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:o})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=3)}([function(t,n){t.exports=e},function(e,t,n){"use strict";function o(e){var t=e.getSelection(),n=e.getCurrentContent(),o=t.getStartKey(),i=t.getEndKey(),r=n.getBlockMap();return r.toSeq().skipUntil(function(e,t){return t===o}).takeUntil(function(e,t){return t===i}).concat([[i,r.get(i)]])}function i(e){return o(e).toList()}function r(e){if(e)return i(e).get(0)}function l(e){if(e){var t=r(e),n=e.getCurrentContent(),o=n.getBlockMap().toSeq().toList(),i=0;if(o.forEach(function(e,n){e.get("key")===t.get("key")&&(i=n-1)}),i>-1)return o.get(i)}}function a(e){return e?e.getCurrentContent().getBlockMap().toList():new I.List}function c(e){var t=i(e);if(!t.some(function(e){return e.type!==t.get(0).type}))return t.get(0).type}function s(e){var t=D.RichUtils.tryToRemoveBlockStyle(e);return t?D.EditorState.push(e,t,"change-block-type"):e}function M(e){var t="",n=e.getSelection(),o=n.getAnchorOffset(),r=n.getFocusOffset(),l=i(e);if(l.size>0){if(n.getIsBackward()){var a=o;o=r,r=a}for(var c=0;c<l.size;c+=1){var s=0===c?o:0,M=c===l.size-1?r:l.get(c).getText().length;t+=l.get(c).getText().slice(s,M)}}return t}function u(e){var t=e.getCurrentContent(),n=e.getSelection(),o=D.Modifier.removeRange(t,n,"forward"),i=o.getSelectionAfter(),r=o.getBlockForKey(i.getStartKey());return o=D.Modifier.insertText(o,i,"\n",r.getInlineStyleAt(i.getStartOffset()),null),D.EditorState.push(e,o,"insert-fragment")}function g(e){var t=D.Modifier.splitBlock(e.getCurrentContent(),e.getSelection());return s(D.EditorState.push(e,t,"split-block"))}function d(e){var t=e.getCurrentContent().getBlockMap().toList(),n=e.getSelection().merge({anchorKey:t.first().get("key"),anchorOffset:0,focusKey:t.last().get("key"),focusOffset:t.last().getLength()}),o=D.Modifier.removeRange(e.getCurrentContent(),n,"forward");return D.EditorState.push(e,o,"remove-range")}function p(e,t){var n=D.Modifier.setBlockData(e.getCurrentContent(),e.getSelection(),t);return D.EditorState.push(e,n,"change-block-data")}function N(e){var t=new I.Map({}),n=i(e);if(n&&n.size>0)for(var o=0;o<n.size;o+=1){var r=function(e){var o=n.get(e).getData();if(!o||0===o.size)return t=t.clear(),"break";if(0===e)t=o;else if(t.forEach(function(e,n){o.get(n)&&o.get(n)===e||(t=t.delete(n))}),0===t.size)return t=t.clear(),"break"}(o);if("break"===r)break}return t}Object.defineProperty(t,"__esModule",{value:!0}),t.blockRenderMap=void 0,t.getSelectedBlocksMap=o,t.getSelectedBlocksList=i,t.getSelectedBlock=r,t.getBlockBeforeSelectedBlock=l,t.getAllBlocks=a,t.getSelectedBlocksType=c,t.removeSelectedBlocksStyle=s,t.getSelectionText=M,t.addLineBreakRemovingSelection=u,t.insertNewUnstyledBlock=g,t.clearEditorContent=d,t.setBlockData=p,t.getSelectedBlocksMetadata=N;var D=n(0),I=n(6),y=(0,I.Map)({code:{element:"pre"}});t.blockRenderMap=D.DefaultDraftBlockRenderMap.merge(y)},function(e,t,n){"use strict";function o(e){if(e){var t=e.getType();return"unordered-list-item"===t||"ordered-list-item"===t}return!1}function i(e,t,n){var o=e.getSelection(),i=e.getCurrentContent(),r=i.getBlockMap(),l=(0,a.getSelectedBlocksMap)(e).map(function(e){var o=e.getDepth()+t;return o=Math.max(0,Math.min(o,n)),e.set("depth",o)});return r=r.merge(l),i.merge({blockMap:r,selectionBefore:o,selectionAfter:o})}function r(e,t,n){var o=e.getSelection(),r=void 0;r=o.getIsBackward()?o.getFocusKey():o.getAnchorKey();var a=e.getCurrentContent(),c=a.getBlockForKey(r),s=c.getType();if("unordered-list-item"!==s&&"ordered-list-item"!==s)return e;var M=a.getBlockBefore(r);if(!M)return e;if(M.getType()!==s)return e;var u=c.getDepth();if(1===t&&u===n)return e;var g=Math.min(M.getDepth()+1,n),d=i(e,t,g);return l.EditorState.push(e,d,"adjust-depth")}Object.defineProperty(t,"__esModule",{value:!0}),t.isListBlock=o,t.changeDepth=r;var l=n(0),a=n(1)},function(e,t,n){e.exports=n(4)},function(e,t,n){"use strict";var o=n(5),i=n(1),r=n(7),l=function(e){return e&&e.__esModule?e:{default:e}}(r),a=n(2);e.exports={getSelectedBlocksMap:i.getSelectedBlocksMap,getSelectedBlocksList:i.getSelectedBlocksList,getSelectedBlock:i.getSelectedBlock,getBlockBeforeSelectedBlock:i.getBlockBeforeSelectedBlock,getAllBlocks:i.getAllBlocks,getSelectedBlocksType:i.getSelectedBlocksType,removeSelectedBlocksStyle:i.removeSelectedBlocksStyle,getSelectionText:i.getSelectionText,addLineBreakRemovingSelection:i.addLineBreakRemovingSelection,insertNewUnstyledBlock:i.insertNewUnstyledBlock,clearEditorContent:i.clearEditorContent,setBlockData:i.setBlockData,getSelectedBlocksMetadata:i.getSelectedBlocksMetadata,blockRenderMap:i.blockRenderMap,getEntityRange:o.getEntityRange,getCustomStyleMap:o.getCustomStyleMap,toggleCustomInlineStyle:o.toggleCustomInlineStyle,getSelectionEntity:o.getSelectionEntity,extractInlineStyle:o.extractInlineStyle,removeAllInlineStyles:o.removeAllInlineStyles,getSelectionInlineStyle:o.getSelectionInlineStyle,getSelectionCustomInlineStyle:o.getSelectionCustomInlineStyle,handleNewLine:l.default,isListBlock:a.isListBlock,changeDepth:a.changeDepth}},function(e,t,n){"use strict";function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e){var t=e.getSelection();if(t.isCollapsed()){var n={},o=e.getCurrentInlineStyle().toList().toJS();if(o)return["BOLD","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT"].forEach(function(e){n[e]=o.indexOf(e)>=0}),n}var i=t.getStartOffset(),r=t.getEndOffset(),l=(0,D.getSelectedBlocksList)(e);if(l.size>0){var a=function(){for(var e={BOLD:!0,ITALIC:!0,UNDERLINE:!0,STRIKETHROUGH:!0,CODE:!0,SUPERSCRIPT:!0,SUBSCRIPT:!0},t=0;t<l.size;t+=1){var n=0===t?i:0,o=t===l.size-1?r:l.get(t).getText().length;n===o&&0===n?(n=1,o=2):n===o&&(n-=1);for(var a=n;a<o;a+=1)!function(n){var o=l.get(t).getInlineStyleAt(n);["BOLD","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT"].forEach(function(t){e[t]=e[t]&&o.get(t)===t})}(a)}return{v:e}}();if("object"===(void 0===a?"undefined":p(a)))return a.v}return{}}function r(e){var t=void 0,n=e.getSelection(),o=n.getStartOffset(),i=n.getEndOffset();o===i&&0===o?i=1:o===i&&(o-=1);for(var r=(0,D.getSelectedBlock)(e),l=o;l<i;l+=1){var a=r.getEntityAt(l);if(!a){t=void 0;break}if(l===o)t=a;else if(t!==a){t=void 0;break}}return t}function l(e,t){var n=(0,D.getSelectedBlock)(e),o=void 0;return n.findEntityRanges(function(e){return e.get("entity")===t},function(e,t){o={start:e,end:t,text:n.get("text").slice(e,t)}}),o}function a(e,t,n){var o=e.getSelection(),i=Object.keys(I[t]).reduce(function(e,t){return N.Modifier.removeInlineStyle(e,o,t)},e.getCurrentContent()),r=N.EditorState.push(e,i,"changeinline-style"),l=e.getCurrentInlineStyle();if(o.isCollapsed()&&(r=l.reduce(function(e,t){return N.RichUtils.toggleInlineStyle(e,t)},r)),"SUPERSCRIPT"===t||"SUBSCRIPT"==t)l.has(n)||(r=N.RichUtils.toggleInlineStyle(r,n));else{var a="bgcolor"===t?"backgroundColor":t;l.has(a+"-"+n)||(r=N.RichUtils.toggleInlineStyle(r,t.toLowerCase()+"-"+n),y(t,a,n))}return r}function c(e){e&&e.getCurrentContent().getBlockMap().map(function(e){return e.get("characterList")}).toList().flatten().forEach(function(e){e&&0===e.indexOf("color-")?y("color","color",e.substr(6)):e&&0===e.indexOf("bgcolor-")?y("bgcolor","backgroundColor",e.substr(8)):e&&0===e.indexOf("fontsize-")?y("fontSize","fontSize",+e.substr(9)):e&&0===e.indexOf("fontfamily-")&&y("fontFamily","fontFamily",e.substr(11))})}function s(e,t,n){var o=e.getInlineStyleAt(n).toList(),i=o.filter(function(e){return e.startsWith(t.toLowerCase())});if(i&&i.size>0)return i.get(0)}function M(e,t){var n=e.getCurrentInlineStyle().toList(),o=n.filter(function(e){return e.startsWith(t.toLowerCase())});if(o&&o.size>0)return o.get(0)}function u(e,t){if(e&&t&&t.length>0){var n=function(){var n=e.getSelection(),o={};if(n.isCollapsed())return t.forEach(function(t){o[t]=M(e,t)}),{v:o};var i=n.getStartOffset(),r=n.getEndOffset(),l=(0,D.getSelectedBlocksList)(e);if(l.size>0){for(var a=0;a<l.size;a+=1)!function(e){var n=0===e?i:0,a=e===l.size-1?r:l.get(e).getText().length;n===a&&0===n?(n=1,a=2):n===a&&(n-=1);for(var c=n;c<a;c+=1)!function(i){i===n?t.forEach(function(t){o[t]=s(l.get(e),t,i)}):t.forEach(function(t){o[t]&&o[t]!==s(l.get(e),t,i)&&(o[t]=void 0)})}(c)}(a);return{v:o}}}();if("object"===(void 0===n?"undefined":p(n)))return n.v}return{}}function g(e){var t=e.getCurrentInlineStyle(),n=e.getCurrentContent();return t.forEach(function(t){n=N.Modifier.removeInlineStyle(n,e.getSelection(),t)}),N.EditorState.push(e,n,"change-inline-style")}Object.defineProperty(t,"__esModule",{value:!0}),t.getCustomStyleMap=void 0;var d=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},p="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};t.getSelectionInlineStyle=i,t.getSelectionEntity=r,t.getEntityRange=l,t.toggleCustomInlineStyle=a,t.extractInlineStyle=c,t.getSelectionCustomInlineStyle=u,t.removeAllInlineStyles=g;var N=n(0),D=n(1),I={color:{},bgcolor:{},fontSize:{},fontFamily:{},CODE:{fontFamily:"monospace",wordWrap:"break-word",background:"#f1f1f1",borderRadius:3,padding:"1px 3px"},SUPERSCRIPT:{fontSize:11,position:"relative",top:-8,display:"inline-flex"},SUBSCRIPT:{fontSize:11,position:"relative",bottom:-8,display:"inline-flex"}},y=function(e,t,n){I[e][e.toLowerCase()+"-"+n]=o({},""+t,n)};t.getCustomStyleMap=function(){return d({},I.color,I.bgcolor,I.fontSize,I.fontFamily,{CODE:I.CODE,SUPERSCRIPT:I.SUPERSCRIPT,SUBSCRIPT:I.SUBSCRIPT})}},function(e,n){e.exports=t},function(e,t,n){"use strict";function o(e){var t=e.getSelection();if(t.isCollapsed()){var n=e.getCurrentContent(),o=t.getStartKey(),i=n.getBlockForKey(o);if(!(0,c.isListBlock)(i)&&"unstyled"!==i.getType()&&i.getLength()===t.getStartOffset())return(0,a.insertNewUnstyledBlock)(e);if((0,c.isListBlock)(i)&&0===i.getLength()){var r=i.getDepth();if(0===r)return(0,a.removeSelectedBlocksStyle)(e);if(r>0)return(0,c.changeDepth)(e,-1,r)}}}function i(e){return 13===e.which&&(e.getModifierState("Shift")||e.getModifierState("Alt")||e.getModifierState("Control"))}function r(e,t){return i(t)?e.getSelection().isCollapsed()?l.RichUtils.insertSoftNewline(e):(0,a.addLineBreakRemovingSelection)(e):o(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.default=r;var l=n(0),a=n(1),c=n(2)}])})},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function l(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var c=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),M=o(s),u=n(1),g=o(u),d=n(2),p=o(d);n(29);var N=function(e){function t(){var e,n,o,i;r(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=l(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.onClick=function(){var e=o.props,t=e.disabled,n=e.onClick,i=e.value;t||n(i)},i=n,l(o,i)}return a(t,e),c(t,[{key:"render",value:function(){var e,t=this.props,n=t.children,o=t.className,r=t.activeClassName,l=t.active,a=t.disabled,c=t.title;return M.default.createElement("div",{className:(0,p.default)("rdw-option-wrapper",o,(e={},i(e,"rdw-option-active "+r,l),i(e,"rdw-option-disabled",a),e)),onClick:this.onClick,"aria-selected":l,title:c},n)}}]),t}(s.Component);N.propTypes={onClick:g.default.func.isRequired,children:g.default.any,value:g.default.string,className:g.default.string,activeClassName:g.default.string,active:g.default.bool,disabled:g.default.bool,title:g.default.string},t.default=N},function(e,t,n){"use strict";function o(e,t){if(e)for(var n in e)({}).hasOwnProperty.call(e,n)&&t(n,e[n])}function i(e,t){var n=!1;if(e)for(var o in e)if({}.hasOwnProperty.call(e,o)&&t===o){n=!0;break}return n}function r(e){return!e||!e.trim()}function l(e){return"[object Object]"===Object.prototype.toString.call(e)}function a(e,t){var n=Object.keys(e).filter(function(e){return t.indexOf(e)<0}),o={};return n&&n.length>0&&n.forEach(function(t){o[t]=e[t]}),o}function c(e){e.stopPropagation()}Object.defineProperty(t,"__esModule",{value:!0}),t.forEach=o,t.hasProperty=i,t.isEmptyString=r,t.isMap=l,t.filter=a,t.stopPropagation=c},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}var i=n(30),r=o(i),l=n(32),a=o(l);e.exports={Dropdown:r.default,DropdownOption:a.default}},function(e,t,n){"use strict";var o=n(6),i=function(e){return e[e.options[0]].icon},r=function e(t,n){if(t&&void 0===n)return t;var i={};return(0,o.forEach)(t,function(t,r){(0,o.isMap)(r)?i[t]=e(r,n[t]):i[t]=void 0!==n[t]?n[t]:r}),i};e.exports={getFirstIcon:i,mergeRecursive:r}},function(e,t){e.exports=n},function(e,t){(function(t){e.exports=t}).call(t,{})},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=[];t.default={onKeyDown:function(e){o.forEach(function(t){t(e)})},registerCallBack:function(e){o.push(e)},deregisterCallBack:function(e){o=o.filter(function(t){return t!==e})}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=void 0;t.default={open:function(){o=!0},close:function(){o=!1},isOpen:function(){return o}}},function(e,t,n){e.exports=n(14)},function(e,t,n){"use strict";var o=n(15),i=function(e){return e&&e.__esModule?e:{default:e}}(o);e.exports={Editor:i.default}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function l(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var c=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),M=n(0),u=o(M),g=n(1),d=o(g),p=n(3),N=n(4),D=n(2),I=o(D),y=n(20),j=o(y),f=n(21),w=o(f),m=n(11),C=o(m),z=n(12),A=o(z),T=n(22),E=o(T),L=n(8),x=n(6),O=n(23),k=n(26),h=o(k),b=n(79),S=o(b),v=n(82),U=o(v),Q=n(88),Y=o(Q),_=n(90),P=o(_),B=n(94),Z=o(B),G=n(120),F=o(G);n(135),n(136);var R=function(e){function t(e){r(this,t);var n=l(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));W.call(n);var o=(0,L.mergeRecursive)(Z.default,e.toolbar);n.state={editorState:void 0,editorFocused:!1,toolbar:o};var i=e.wrapperId?e.wrapperId:Math.floor(1e4*Math.random());return n.wrapperId="rdw-wrapper-"+i,n.modalHandler=new j.default,n.focusHandler=new w.default,n.blockRendererFn=(0,P.default)({isReadOnly:n.isReadOnly,isImageAlignmentEnabled:n.isImageAlignmentEnabled,getEditorState:n.getEditorState,onChange:n.onChange},e.customBlockRenderFunc),n.editorProps=n.filterEditorProps(e),n.customStyleMap=(0,N.getCustomStyleMap)(),n}return a(t,e),s(t,[{key:"componentWillMount",value:function(){this.compositeDecorator=this.getCompositeDecorator();var e=this.createEditorState(this.compositeDecorator);(0,N.extractInlineStyle)(e),this.setState({editorState:e})}},{key:"componentDidMount",value:function(){this.modalHandler.init(this.wrapperId)}},{key:"componentWillReceiveProps",value:function(e){var t={};if(this.props.toolbar!==e.toolbar){var n=(0,L.mergeRecursive)(Z.default,e.toolbar);t.toolbar=n}if((0,x.hasProperty)(e,"editorState")&&this.props.editorState!==e.editorState)e.editorState?t.editorState=p.EditorState.set(e.editorState,{decorator:this.compositeDecorator}):t.editorState=p.EditorState.createEmpty(this.compositeDecorator);else if((0,x.hasProperty)(e,"contentState")&&this.props.contentState!==e.contentState)if(e.contentState){var o=this.changeEditorState(e.contentState);o&&(t.editorState=o)}else t.editorState=p.EditorState.createEmpty(this.compositeDecorator);e.editorState===this.props.editorState&&e.contentState===this.props.contentState||(0,N.extractInlineStyle)(t.editorState),this.setState(t),this.editorProps=this.filterEditorProps(e),this.customStyleMap=(0,N.getCustomStyleMap)()}},{key:"render",value:function(){var e=this.state,t=e.editorState,n=e.editorFocused,o=e.toolbar,i=this.props,r=i.locale,l=i.localization,a=l.locale,s=l.translations,M=i.toolbarCustomButtons,g=i.toolbarOnFocus,d=i.toolbarClassName,D=i.toolbarHidden,y=i.editorClassName,j=i.wrapperClassName,f=i.toolbarStyle,w=i.editorStyle,m=i.wrapperStyle,z=i.uploadCallback,A=i.ariaLabel,T={modalHandler:this.modalHandler,editorState:t,onChange:this.onChange,translations:c({},F.default[r||a],s)},L=n||this.focusHandler.isInputFocused()||!g;return u.default.createElement("div",{id:this.wrapperId,className:(0,I.default)(j,"rdw-editor-wrapper"),style:m,onClick:this.modalHandler.onEditorClick,onBlur:this.onWrapperBlur,"aria-label":"rdw-wrapper"},!D&&u.default.createElement("div",{className:(0,I.default)("rdw-editor-toolbar",d),style:c({visibility:L?"visible":"hidden"},f),onMouseDown:this.preventDefault,"aria-label":"rdw-toolbar","aria-hidden":(!n&&g).toString(),onFocus:this.onToolbarFocus},o.options.map(function(e,t){var n=h.default[e],i=o[e];return"image"===e&&z&&(i.uploadCallback=z),u.default.createElement(n,c({key:t},T,{config:i}))}),M&&M.map(function(e,t){return u.default.cloneElement(e,c({key:t},T))})),u.default.createElement("div",{ref:this.setWrapperReference,className:(0,I.default)(y,"rdw-editor-main"),style:w,onClick:this.focusEditor,onFocus:this.onEditorFocus,onBlur:this.onEditorBlur,onKeyDown:C.default.onKeyDown,onMouseDown:this.onEditorMouseDown},u.default.createElement(p.Editor,c({ref:this.setEditorReference,onTab:this.onTab,onUpArrow:this.onUpDownArrow,onDownArrow:this.onUpDownArrow,editorState:t,onChange:this.onChange,blockStyleFn:E.default,customStyleMap:(0,N.getCustomStyleMap)(),handleReturn:this.handleReturn,handlePastedText:this.handlePastedText,blockRendererFn:this.blockRendererFn,handleKeyCommand:this.handleKeyCommand,ariaLabel:A||"rdw-editor",blockRenderMap:N.blockRenderMap},this.editorProps))))}}]),t}(M.Component);R.propTypes={onChange:d.default.func,onEditorStateChange:d.default.func,onContentStateChange:d.default.func,initialContentState:d.default.object,defaultContentState:d.default.object,contentState:d.default.object,editorState:d.default.object,defaultEditorState:d.default.object,toolbarOnFocus:d.default.bool,spellCheck:d.default.bool,stripPastedStyles:d.default.bool,toolbar:d.default.object,toolbarCustomButtons:d.default.array,toolbarClassName:d.default.string,toolbarHidden:d.default.bool,locale:d.default.string,localization:d.default.object,editorClassName:d.default.string,wrapperClassName:d.default.string,toolbarStyle:d.default.object,editorStyle:d.default.object,wrapperStyle:d.default.object,uploadCallback:d.default.func,onFocus:d.default.func,onBlur:d.default.func,onTab:d.default.func,mention:d.default.object,hashtag:d.default.object,textAlignment:d.default.string,readOnly:d.default.bool,tabIndex:d.default.number,placeholder:d.default.string,ariaLabel:d.default.string,ariaOwneeID:d.default.string,ariaActiveDescendantID:d.default.string,ariaAutoComplete:d.default.string,ariaDescribedBy:d.default.string,ariaExpanded:d.default.string,ariaHasPopup:d.default.string,customBlockRenderFunc:d.default.func,wrapperId:d.default.number,customDecorators:d.default.array,editorRef:d.default.func},R.defaultProps={toolbarOnFocus:!1,toolbarHidden:!1,stripPastedStyles:!1,localization:{locale:"en",translations:{}},customDecorators:[]};var W=function(){var e=this;this.onEditorBlur=function(){e.setState({editorFocused:!1})},this.onEditorFocus=function(t){var n=e.props.onFocus;e.setState({editorFocused:!0});var o=e.focusHandler.isEditorFocused();n&&o&&n(t)},this.onEditorMouseDown=function(){e.focusHandler.onEditorMouseDown()},this.onTab=function(t){var n=e.props.onTab;if(!n||!n(t)){var o=(0,N.changeDepth)(e.state.editorState,t.shiftKey?-1:1,4);o&&o!==e.state.editorState&&(e.onChange(o),t.preventDefault())}},this.onUpDownArrow=function(e){A.default.isOpen()&&e.preventDefault()},this.onToolbarFocus=function(t){var n=e.props.onFocus;n&&e.focusHandler.isToolbarFocused()&&n(t)},this.onWrapperBlur=function(t){var n=e.props.onBlur;n&&e.focusHandler.isEditorBlur(t)&&n(t,e.getEditorState())},this.onChange=function(t){var n=e.props,o=n.readOnly,i=n.onEditorStateChange;o||"atomic"===(0,N.getSelectedBlocksType)(t)&&t.getSelection().isCollapsed||(i&&i(t,e.props.wrapperId),(0,x.hasProperty)(e.props,"editorState")?e.afterChange(t):e.setState({editorState:t},e.afterChange(t)))},this.setWrapperReference=function(t){e.wrapper=t},this.setEditorReference=function(t){e.props.editorRef&&e.props.editorRef(t),e.editor=t},this.getCompositeDecorator=function(){var t=[].concat(i(e.props.customDecorators),[(0,S.default)({showOpenOptionOnHover:e.state.toolbar.link.showOpenOptionOnHover})]);return e.props.mention&&t.push.apply(t,i((0,U.default)(c({},e.props.mention,{onChange:e.onChange,getEditorState:e.getEditorState,getSuggestions:e.getSuggestions,getWrapperRef:e.getWrapperRef,modalHandler:e.modalHandler})))),e.props.hashtag&&t.push((0,Y.default)(e.props.hashtag)),new p.CompositeDecorator(t)},this.getWrapperRef=function(){return e.wrapper},this.getEditorState=function(){return e.state.editorState},this.getSuggestions=function(){return e.props.mention&&e.props.mention.suggestions},this.afterChange=function(t){setTimeout(function(){var n=e.props,o=n.onChange,i=n.onContentStateChange;o&&o((0,p.convertToRaw)(t.getCurrentContent())),i&&i((0,p.convertToRaw)(t.getCurrentContent()))})},this.isReadOnly=function(){return e.props.readOnly},this.isImageAlignmentEnabled=function(){return e.state.toolbar.image.alignmentEnabled},this.createEditorState=function(t){var n=void 0;if((0,x.hasProperty)(e.props,"editorState"))e.props.editorState&&(n=p.EditorState.set(e.props.editorState,{decorator:t}));else if((0,x.hasProperty)(e.props,"defaultEditorState"))e.props.defaultEditorState&&(n=p.EditorState.set(e.props.defaultEditorState,{decorator:t}));else if((0,x.hasProperty)(e.props,"contentState")){if(e.props.contentState){var o=(0,p.convertFromRaw)(e.props.contentState);n=p.EditorState.createWithContent(o,t),n=p.EditorState.moveSelectionToEnd(n)}}else if((0,x.hasProperty)(e.props,"defaultContentState")||(0,x.hasProperty)(e.props,"initialContentState")){var i=e.props.defaultContentState||e.props.initialContentState;i&&(i=(0,p.convertFromRaw)(i),n=p.EditorState.createWithContent(i,t),n=p.EditorState.moveSelectionToEnd(n))}return n||(n=p.EditorState.createEmpty(t)),n},this.filterEditorProps=function(e){return(0,x.filter)(e,["onChange","onEditorStateChange","onContentStateChange","initialContentState","defaultContentState","contentState","editorState","defaultEditorState","locale","localization","toolbarOnFocus","toolbar","toolbarCustomButtons","toolbarClassName","editorClassName","toolbarHidden","wrapperClassName","toolbarStyle","editorStyle","wrapperStyle","uploadCallback","onFocus","onBlur","onTab","mention","hashtag","ariaLabel","customBlockRenderFunc","customDecorators","handlePastedText"])},this.changeEditorState=function(t){var n=(0,p.convertFromRaw)(t),o=e.state.editorState;return o=p.EditorState.push(o,n,"insert-characters"),o=p.EditorState.moveSelectionToEnd(o)},this.focusEditor=function(){setTimeout(function(){e.editor.focus()})},this.handleKeyCommand=function(t){var n=e.state,o=n.editorState,i=n.toolbar.inline;if(i&&i.options.indexOf(t)>=0){var r=p.RichUtils.handleKeyCommand(o,t);if(r)return e.onChange(r),!0}return!1},this.handleReturn=function(t){if(A.default.isOpen())return!0;var n=(0,N.handleNewLine)(e.state.editorState,t);return!!n&&(e.onChange(n),!0)},this.handlePastedText=function(t,n){var o=e.state.editorState;return e.props.handlePastedText?e.props.handlePastedText(t,n,o,e.onChange):!e.props.stripPastedStyles&&(0,O.handlePastedText)(t,n,o,e.onChange)},this.preventDefault=function(t){"INPUT"===t.target.tagName||"LABEL"===t.target.tagName?e.focusHandler.onInputMouseDown():t.preventDefault()}};t.default=R},function(e,t,n){"use strict";var o=n(17),i=n(18),r=n(19);e.exports=function(){function e(e,t,n,o,l,a){a!==r&&i(!1,"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types")}function t(){return e}e.isRequired=e;var n={array:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t};return n.checkPropTypes=o,n.PropTypes=n,n}},function(e,t,n){"use strict";function o(e){return function(){return e}}var i=function(){};i.thatReturns=o,i.thatReturnsFalse=o(!1),i.thatReturnsTrue=o(!0),i.thatReturnsNull=o(null),i.thatReturnsThis=function(){return this},i.thatReturnsArgument=function(e){return e},e.exports=i},function(e,t,n){"use strict";function o(e,t,n,o,r,l,a,c){if(i(t),!e){var s;if(void 0===t)s=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var M=[n,o,r,l,a,c],u=0;s=new Error(t.replace(/%s/g,function(){return M[u++]})),s.name="Invariant Violation"}throw s.framesToPop=1,s}}var i=function(e){};e.exports=o},function(e,t,n){"use strict";e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},function(e,t,n){"use strict";function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function e(){var t=this;o(this,e),this.callBacks=[],this.suggestionCallback=void 0,this.editorFlag=!1,this.suggestionFlag=!1,this.closeAllModals=function(e){t.callBacks.forEach(function(t){t(e)})},this.init=function(e){var n=document.getElementById(e);n&&n.addEventListener("click",function(){t.editorFlag=!0}),document&&(document.addEventListener("click",function(){t.editorFlag?t.editorFlag=!1:(t.closeAllModals(),t.suggestionCallback&&t.suggestionCallback())}),document.addEventListener("keydown",function(e){"Escape"===e.key&&t.closeAllModals()}))},this.onEditorClick=function(){t.closeModals(),!t.suggestionFlag&&t.suggestionCallback?t.suggestionCallback():t.suggestionFlag=!1},this.closeModals=function(e){t.closeAllModals(e)},this.registerCallBack=function(e){t.callBacks.push(e)},this.deregisterCallBack=function(e){t.callBacks=t.callBacks.filter(function(t){return t!==e})},this.setSuggestionCallback=function(e){t.suggestionCallback=e},this.removeSuggestionCallback=function(){t.suggestionCallback=void 0},this.onSuggestionClick=function(){t.suggestionFlag=!0}};t.default=i},function(e,t,n){"use strict";function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function e(){var t=this;o(this,e),this.inputFocused=!1,this.editorMouseDown=!1,this.onEditorMouseDown=function(){t.editorFocused=!0},this.onInputMouseDown=function(){t.inputFocused=!0},this.isEditorBlur=function(e){return"INPUT"!==e.target.tagName&&"LABEL"!==e.target.tagName||t.editorFocused?!("INPUT"===e.target.tagName&&"LABEL"===e.target.tagName||t.inputFocused)&&(t.editorFocused=!1,!0):(t.inputFocused=!1,!0)},this.isEditorFocused=function(){return!t.inputFocused||(t.inputFocused=!1,!1)},this.isToolbarFocused=function(){return!t.editorFocused||(t.editorFocused=!1,!1)},this.isInputFocused=function(){return t.inputFocused}};t.default=i},function(e,t,n){"use strict";function o(e){var t=e.getData()&&e.getData().get("text-align");return t?"rdw-"+t+"-aligned-block":""}Object.defineProperty(t,"__esModule",{value:!0}),t.default=o},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.handlePastedText=void 0;var o=n(4),i=n(3),r=n(24),l=function(e){return e&&e.__esModule?e:{default:e}}(r),a=n(9);t.handlePastedText=function(e,t,n,r){var c=(0,o.getSelectedBlock)(n);if(c&&"code"===c.type){var s=i.Modifier.replaceText(n.getCurrentContent(),n.getSelection(),e,n.getCurrentInlineStyle());return r(i.EditorState.push(n,s,"insert-characters")),!0}if(t){var M=(0,l.default)(t),u=n.getCurrentContent();return M.entityMap.forEach(function(e,t){u=u.mergeEntityData(t,e)}),u=i.Modifier.replaceWithFragment(u,n.getSelection(),new a.List(M.contentBlocks)),r(i.EditorState.push(n,u,"insert-characters")),!0}return!1}},function(e,t,n){"use strict";(function(e){var o,i,r,l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};!function(a,c){"object"==l(t)&&"object"==l(e)?e.exports=c(n(9),n(3)):(i=[n(9),n(3)],o=c,void 0!==(r="function"==typeof o?o.apply(t,i):o)&&(e.exports=r))}("undefined"!=typeof self&&self,function(e,t){return function(e){function t(o){if(n[o])return n[o].exports;var i=n[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:o})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=2)}([function(t,n){t.exports=e},function(e,n){e.exports=t},function(e,t,n){e.exports=n(3)},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t,n,o,r,l){var c=e.nodeName.toLowerCase();if(l){var s=l(c,e);if(s){var M=a.Entity.__create(s.type,s.mutability,s.data||{});return{chunk:(0,u.getAtomicBlockChunk)(M)}}}if("#text"===c&&"\n"!==e.textContent)return(0,u.createTextChunk)(e,t,r);if("br"===c)return{chunk:(0,u.getSoftNewlineChunk)()};if("img"===c&&e instanceof HTMLImageElement){var g={};g.src=e.getAttribute?e.getAttribute("src")||e.src:e.src,g.alt=e.alt,g.height=e.style.height,g.width=e.style.width,e.style.float&&(g.alignment=e.style.float);var p=a.Entity.__create("IMAGE","MUTABLE",g);return{chunk:(0,u.getAtomicBlockChunk)(p)}}if("iframe"===c&&e instanceof HTMLIFrameElement){var D={};D.src=e.getAttribute?e.getAttribute("src")||e.src:e.src,D.height=e.height,D.width=e.width;var y=a.Entity.__create("EMBEDDED_LINK","MUTABLE",D);return{chunk:(0,u.getAtomicBlockChunk)(y)}}var f=(0,d.default)(c,o),w=void 0;f&&("ul"===c||"ol"===c?(o=c,n+=1):("unordered-list-item"!==f&&"ordered-list-item"!==f&&(o="",n=-1),m?(w=(0,u.getFirstBlockChunk)(f,(0,I.default)(e)),m=!1):w=(0,u.getBlockDividerChunk)(f,n,(0,I.default)(e)))),w||(w=(0,u.getEmptyChunk)()),t=(0,N.default)(c,e,t);for(var C=e.firstChild;C;){var z=(0,j.default)(C),A=i(C,t,n,o,z||r,l),T=A.chunk;w=(0,u.joinChunks)(w,T),C=C.nextSibling}return{chunk:w}}function r(e,t){var n=e.trim().replace(w,f),o=(0,M.default)(n);return o?(m=!0,{chunk:i(o,new c.OrderedSet,-1,"",void 0,t).chunk}):null}function l(e,t){var n=r(e,t);if(n){var o=n.chunk,i=new c.OrderedMap({});o.entities&&o.entities.forEach(function(e){e&&(i=i.set(e,a.Entity.__get(e)))});var l=0;return{contentBlocks:o.text.split("\r").map(function(e,t){var n=l+e.length,i=o&&o.inlines.slice(l,n),r=o&&o.entities.slice(l,n),s=new c.List(i.map(function(e,t){var n={style:e,entity:null};return r[t]&&(n.entity=r[t]),a.CharacterMetadata.create(n)}));return l=n,new a.ContentBlock({key:(0,a.genKey)(),type:o&&o.blocks[t]&&o.blocks[t].type||"unstyled",depth:o&&o.blocks[t]&&o.blocks[t].depth,data:o&&o.blocks[t]&&o.blocks[t].data||new c.Map({}),text:e,characterList:s})}),entityMap:i}}return null}Object.defineProperty(t,"__esModule",{value:!0}),t.default=l;var a=n(1),c=n(0),s=n(4),M=o(s),u=n(5),g=n(6),d=o(g),p=n(7),N=o(p),D=n(8),I=o(D),y=n(9),j=o(y),f=" ",w=new RegExp("&nbsp;","g"),m=!0},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var o=function(e){var t,n=null;return document.implementation&&document.implementation.createHTMLDocument&&(t=document.implementation.createHTMLDocument("foo"),t.documentElement.innerHTML=e,n=t.getElementsByTagName("body")[0]),n};t.default=o},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.joinChunks=t.getAtomicBlockChunk=t.getBlockDividerChunk=t.getFirstBlockChunk=t.getEmptyChunk=t.getSoftNewlineChunk=t.createTextChunk=t.getWhitespaceChunk=void 0;var o=n(0),i=t.getWhitespaceChunk=function(e){return{text:" ",inlines:[new o.OrderedSet],entities:[e],blocks:[]}};t.createTextChunk=function(e,t,n){var o=e.textContent;return""===o.trim()?{chunk:i(n)}:{chunk:{text:o,inlines:Array(o.length).fill(t),entities:Array(o.length).fill(n),blocks:[]}}},t.getSoftNewlineChunk=function(){return{text:"\n",inlines:[new o.OrderedSet],entities:new Array(1),blocks:[]}},t.getEmptyChunk=function(){return{text:"",inlines:[],entities:[],blocks:[]}},t.getFirstBlockChunk=function(e,t){return{text:"",inlines:[],entities:[],blocks:[{type:e,depth:0,data:t||new o.Map({})}]}},t.getBlockDividerChunk=function(e,t,n){return{text:"\r",inlines:[],entities:[],blocks:[{type:e,depth:Math.max(0,Math.min(4,t)),data:n||new o.Map({})}]}},t.getAtomicBlockChunk=function(e){return{text:"\r ",inlines:[new o.OrderedSet],entities:[e],blocks:[{type:"atomic",depth:0,data:new o.Map({})}]}},t.joinChunks=function(e,t){return{text:e.text+t.text,inlines:e.inlines.concat(t.inlines),entities:e.entities.concat(t.entities),blocks:e.blocks.concat(t.blocks)}}},function(e,t,n){function o(e,t){var n=r.filter(function(n){return n.element===e&&(!n.wrapper||n.wrapper===t)||n.wrapper===e||n.aliasedElements&&n.aliasedElements.indexOf(e)>-1}).keySeq().toSet().toArray();if(1===n.length)return n[0]}Object.defineProperty(t,"__esModule",{value:!0}),t.default=o;var i=n(0),r=new i.Map({"header-one":{element:"h1"},"header-two":{element:"h2"},"header-three":{element:"h3"},"header-four":{element:"h4"},"header-five":{element:"h5"},"header-six":{element:"h6"},"unordered-list-item":{element:"li",wrapper:"ul"},"ordered-list-item":{element:"li",wrapper:"ol"},blockquote:{element:"blockquote"},code:{element:"pre"},atomic:{element:"figure"},unstyled:{element:"p",aliasedElements:["div"]}})},function(e,t,n){function o(e,t,n){var o=i[e],r=void 0;if(o)r=n.add(o).toOrderedSet();else if(t instanceof HTMLElement){r=n;var l=t;r=r.withMutations(function(e){var t=l.style.color,n=l.style.backgroundColor,o=l.style.fontSize,i=l.style.fontFamily.replace(/^"|"$/g,"");t&&e.add("color-"+t.replace(/ /g,"")),n&&e.add("bgcolor-"+n.replace(/ /g,"")),o&&e.add("fontsize-"+o.replace(/px$/g,"")),i&&e.add("fontfamily-"+i)}).toOrderedSet()}return r}Object.defineProperty(t,"__esModule",{value:!0}),t.default=o;var i={code:"CODE",del:"STRIKETHROUGH",em:"ITALIC",strong:"BOLD",ins:"UNDERLINE",sub:"SUBSCRIPT",sup:"SUPERSCRIPT"}},function(e,t,n){function o(e){if(e.style.textAlign)return new i.Map({"text-align":e.style.textAlign})}Object.defineProperty(t,"__esModule",{value:!0}),t.default=o;var i=n(0)},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var o=n(1),i=function(e){var t=void 0;if(e instanceof HTMLAnchorElement){var n={};e.dataset&&void 0!==e.dataset.mention?(n.url=e.href,n.text=e.innerHTML,n.value=e.dataset.value,t=o.Entity.__create("MENTION","IMMUTABLE",n)):(n.url=e.getAttribute?e.getAttribute("href")||e.href:e.href,n.title=e.innerHTML,n.targetOption=e.target,t=o.Entity.__create("LINK","MUTABLE",n))}return t};t.default=i}])})}).call(t,n(25)(e))},function(e,t,n){"use strict";e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}var i=n(27),r=o(i),l=n(35),a=o(l),c=n(38),s=o(c),M=n(41),u=o(M),g=n(44),d=o(g),p=n(47),N=o(p),D=n(50),I=o(D),y=n(53),j=o(y),f=n(62),w=o(f),m=n(65),C=o(m),z=n(68),A=o(z),T=n(73),E=o(T),L=n(76),x=o(L);e.exports={inline:r.default,blockType:a.default,fontSize:s.default,fontFamily:u.default,list:d.default,textAlign:N.default,colorPicker:I.default,link:j.default,embedded:w.default,emoji:C.default,image:A.default,remove:E.default,history:x.default}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(4),d=n(3),p=n(6),N=n(28),D=o(N),I=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={currentStyles:{}},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1},o.toggleInlineStyle=function(e){var t="monospace"===e?"CODE":e.toUpperCase(),n=o.props,i=n.editorState,r=n.onChange,l=d.RichUtils.toggleInlineStyle(i,t);if("subscript"===e||"superscript"===e){var a="subscript"===e?"SUPERSCRIPT":"SUBSCRIPT",c=d.Modifier.removeInlineStyle(l.getCurrentContent(),l.getSelection(),a);l=d.EditorState.push(l,c,"change-inline-style")}l&&r(l)},o.changeKeys=function(e){if(e){var t={};return(0,p.forEach)(e,function(e,n){t["CODE"===e?"monospace":e.toLowerCase()]=n}),t}},o.doExpand=function(){o.setState({expanded:!0})},o.doCollapse=function(){o.setState({expanded:!1})},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentStyles:this.changeKeys((0,g.getSelectionInlineStyle)(t))}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(e){e.editorState&&this.props.editorState!==e.editorState&&this.setState({currentStyles:this.changeKeys((0,g.getSelectionInlineStyle)(e.editorState))})}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,i=o.expanded,r=o.currentStyles,l=t.component||D.default;return s.default.createElement(l,{config:t,translations:n,currentState:r,expanded:i,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onChange:this.toggleInlineStyle})}}]),t}(c.Component);I.propTypes={onChange:u.default.func.isRequired,editorState:u.default.object.isRequired,modalHandler:u.default.object,config:u.default.object,translations:u.default.object},t.default=I},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(2),d=o(g),p=n(8),N=n(5),D=o(N),I=n(7);n(34);var y=function(e){function t(){return i(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return l(t,e),a(t,[{key:"renderInFlatList",value:function(){var e=this.props,t=e.config,n=e.currentState,o=e.onChange,i=e.translations;return s.default.createElement("div",{className:(0,d.default)("rdw-inline-wrapper",t.className),"aria-label":"rdw-inline-control"},t.options.map(function(e,r){return s.default.createElement(D.default,{key:r,value:e,onClick:o,className:(0,d.default)(t[e].className),active:!0===n[e]||"MONOSPACE"===e&&n.CODE,title:t[e].title||i["components.controls.inline."+e]},s.default.createElement("img",{alt:"",src:t[e].icon}))}))}},{key:"renderInDropDown",value:function(){var e=this.props,t=e.config,n=e.expanded,o=e.doExpand,i=e.onExpandEvent,r=e.doCollapse,l=e.currentState,a=e.onChange,c=e.translations,M=t.className,u=t.dropdownClassName,g=t.title;return s.default.createElement(I.Dropdown,{className:(0,d.default)("rdw-inline-dropdown",M),optionWrapperClassName:(0,d.default)(u),onChange:a,expanded:n,doExpand:o,doCollapse:r,onExpandEvent:i,"aria-label":"rdw-inline-control",title:g},s.default.createElement("img",{src:(0,p.getFirstIcon)(t),alt:""}),t.options.map(function(e,n){return s.default.createElement(I.DropdownOption,{key:n,value:e,className:(0,d.default)("rdw-inline-dropdownoption",t[e].className),active:!0===l[e]||"MONOSPACE"===e&&l.CODE,title:t[e].title||c["components.controls.inline."+e]},s.default.createElement("img",{src:t[e].icon,alt:""}))}))}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),t}(c.Component);y.propTypes={expanded:u.default.bool,doExpand:u.default.func,doCollapse:u.default.func,onExpandEvent:u.default.func,config:u.default.object,onChange:u.default.func,currentState:u.default.object,translations:u.default.object},t.default=y},function(e,t){e.exports={"rdw-option-wrapper":"rdw-option-wrapper","rdw-option-active":"rdw-option-active","rdw-option-disabled":"rdw-option-disabled"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(2),d=o(g);n(31);var p=n(6),N=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={highlighted:-1},o.onChange=function(e){var t=o.props.onChange;t&&t(e),o.toggleExpansion()},o.setHighlighted=function(e){o.setState({highlighted:e})},o.toggleExpansion=function(){var e=o.props,t=e.doExpand,n=e.doCollapse;e.expanded?n():t()},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillReceiveProps",value:function(e){this.props.expanded&&!e.expanded&&this.setState({highlighted:-1})}},{key:"render",value:function(){var e=this,t=this.props,n=t.expanded,o=t.children,i=t.className,r=t.optionWrapperClassName,l=t.ariaLabel,a=t.onExpandEvent,c=t.title,M=this.state.highlighted,u=o.slice(1,o.length);return s.default.createElement("div",{className:(0,d.default)("rdw-dropdown-wrapper",i),"aria-expanded":n,"aria-label":l||"rdw-dropdown"},s.default.createElement("a",{className:"rdw-dropdown-selectedtext",onClick:a,title:c},o[0],s.default.createElement("div",{className:(0,d.default)({"rdw-dropdown-carettoclose":n,"rdw-dropdown-carettoopen":!n})})),n?s.default.createElement("ul",{className:(0,d.default)("rdw-dropdown-optionwrapper",r),onClick:p.stopPropagation},s.default.Children.map(u,function(t,n){return t&&s.default.cloneElement(t,{onSelect:e.onChange,highlighted:M===n,setHighlighted:e.setHighlighted,index:n})})):void 0)}}]),t}(c.Component);N.propTypes={children:u.default.any,onChange:u.default.func,className:u.default.string,expanded:u.default.bool,doExpand:u.default.func,doCollapse:u.default.func,onExpandEvent:u.default.func,optionWrapperClassName:u.default.string,ariaLabel:u.default.string,title:u.default.string},t.default=N},function(e,t){e.exports={"rdw-dropdown-wrapper":"rdw-dropdown-wrapper","rdw-dropdown-carettoopen":"rdw-dropdown-carettoopen","rdw-dropdown-carettoclose":"rdw-dropdown-carettoclose","rdw-dropdown-selectedtext":"rdw-dropdown-selectedtext","rdw-dropdown-optionwrapper":"rdw-dropdown-optionwrapper"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function l(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var c=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),M=o(s),u=n(1),g=o(u),d=n(2),p=o(d);n(33);var N=function(e){function t(){var e,n,o,i;r(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=l(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.onClick=function(e){var t=o.props,n=t.onSelect,i=t.onClick,r=t.value;t.disabled||(n&&n(r),i&&(e.stopPropagation(),i(r)))},o.setHighlighted=function(){var e=o.props;(0,e.setHighlighted)(e.index)},o.resetHighlighted=function(){(0,o.props.setHighlighted)(-1)},i=n,l(o,i)}return a(t,e),c(t,[{key:"render",value:function(){var e,t=this.props,n=t.children,o=t.active,r=t.disabled,l=t.highlighted,a=t.className,c=t.activeClassName,s=t.disabledClassName,u=t.highlightedClassName,g=t.title;return M.default.createElement("li",{className:(0,p.default)("rdw-dropdownoption-default",a,(e={},i(e,"rdw-dropdownoption-active "+c,o),i(e,"rdw-dropdownoption-highlighted "+u,l),i(e,"rdw-dropdownoption-disabled "+s,r),e)),onMouseEnter:this.setHighlighted,onMouseLeave:this.resetHighlighted,onClick:this.onClick,title:g},n)}}]),t}(s.Component);N.propTypes={children:g.default.any,value:g.default.any,onClick:g.default.func,onSelect:g.default.func,setHighlighted:g.default.func,index:g.default.number,disabled:g.default.bool,active:g.default.bool,highlighted:g.default.bool,className:g.default.string,activeClassName:g.default.string,disabledClassName:g.default.string,highlightedClassName:g.default.string,title:g.default.string},t.default=N},function(e,t){e.exports={"rdw-dropdownoption-default":"rdw-dropdownoption-default","rdw-dropdownoption-highlighted":"rdw-dropdownoption-highlighted","rdw-dropdownoption-active":"rdw-dropdownoption-active","rdw-dropdownoption-disabled":"rdw-dropdownoption-disabled"}},function(e,t){e.exports={"rdw-inline-wrapper":"rdw-inline-wrapper","rdw-inline-dropdown":"rdw-inline-dropdown","rdw-inline-dropdownoption":"rdw-inline-dropdownoption"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(4),d=n(3),p=n(36),N=o(p),D=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1,currentBlockType:"unstyled"},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1},o.blocksTypes=[{label:"Normal",style:"unstyled"},{label:"H1",style:"header-one"},{label:"H2",style:"header-two"},{label:"H3",style:"header-three"},{label:"H4",style:"header-four"},{label:"H5",style:"header-five"},{label:"H6",style:"header-six"},{label:"Blockquote",style:"blockquote"},{label:"Code",style:"code"}],o.doExpand=function(){o.setState({expanded:!0})},o.doCollapse=function(){o.setState({expanded:!1})},o.toggleBlockType=function(e){var t=o.blocksTypes.find(function(t){return t.label===e}).style,n=o.props,i=n.editorState,r=n.onChange,l=d.RichUtils.toggleBlockType(i,t);l&&r(l)},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentBlockType:(0,g.getSelectedBlocksType)(t)}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(e){e.editorState&&this.props.editorState!==e.editorState&&this.setState({currentBlockType:(0,g.getSelectedBlocksType)(e.editorState)})}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,i=o.expanded,r=o.currentBlockType,l=t.component||N.default,a=this.blocksTypes.find(function(e){return e.style===r});return s.default.createElement(l,{config:t,translations:n,currentState:{blockType:a&&a.label},onChange:this.toggleBlockType,expanded:i,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),t}(c.Component);D.propTypes={onChange:u.default.func.isRequired,editorState:u.default.object,modalHandler:u.default.object,config:u.default.object,translations:u.default.object},t.default=D},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(2),d=o(g),p=n(5),N=o(p),D=n(7);n(37);var I=function(e){function t(e){i(this,t);var n=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.getBlockTypes=function(e){return[{label:"Normal",displayName:e["components.controls.blocktype.normal"]},{label:"H1",displayName:e["components.controls.blocktype.h1"]},{label:"H2",displayName:e["components.controls.blocktype.h2"]},{label:"H3",displayName:e["components.controls.blocktype.h3"]},{label:"H4",displayName:e["components.controls.blocktype.h4"]},{label:"H5",displayName:e["components.controls.blocktype.h5"]},{label:"H6",displayName:e["components.controls.blocktype.h6"]},{label:"Blockquote",displayName:e["components.controls.blocktype.blockquote"]},{label:"Code",displayName:e["components.controls.blocktype.code"]}]},n.state={blockTypes:n.getBlockTypes(e.translations)},n}return l(t,e),a(t,[{key:"componentWillReceiveProps",value:function(e){this.props.translations!==e.translations&&this.setState({blockTypes:this.getBlockTypes(e.translations)})}},{key:"renderFlat",value:function(e){var t=this.props,n=t.config.className,o=t.onChange,i=t.currentState.blockType;return s.default.createElement("div",{className:(0,d.default)("rdw-inline-wrapper",n)},e.map(function(e,t){return s.default.createElement(N.default,{key:t,value:e.label,active:i===e.label,onClick:o},e.displayName)}))}},{key:"renderInDropdown",value:function(e){var t=this.props,n=t.config,o=n.className,i=n.dropdownClassName,r=n.title,l=t.currentState.blockType,a=t.expanded,c=t.doExpand,M=t.onExpandEvent,u=t.doCollapse,g=t.onChange,p=t.translations,N=this.state.blockTypes,I=N.filter(function(e){return e.label===l}),y=I&&I[0]&&I[0].displayName;return s.default.createElement("div",{className:"rdw-block-wrapper","aria-label":"rdw-block-control"},s.default.createElement(D.Dropdown,{className:(0,d.default)("rdw-block-dropdown",o),optionWrapperClassName:(0,d.default)(i),onChange:g,expanded:a,doExpand:c,doCollapse:u,onExpandEvent:M,title:r||p["components.controls.blocktype.blocktype"]},s.default.createElement("span",null,y||p["components.controls.blocktype.blocktype"]),e.map(function(e,t){return s.default.createElement(D.DropdownOption,{active:l===e.label,value:e.label,key:t},e.displayName)})))}},{key:"render",value:function(){var e=this.props.config,t=e.inDropdown,n=this.state.blockTypes,o=n.filter(function(t){var n=t.label;return e.options.includes(n)});return t?this.renderInDropdown(o):this.renderFlat(o)}}]),t}(c.Component);I.propTypes={expanded:u.default.bool,onExpandEvent:u.default.func,doExpand:u.default.func,doCollapse:u.default.func,onChange:u.default.func,config:u.default.object,currentState:u.default.object,translations:u.default.object},t.default=I},function(e,t){e.exports={"rdw-block-wrapper":"rdw-block-wrapper","rdw-block-dropdown":"rdw-block-dropdown"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(4),d=n(39),p=o(d),N=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:void 0,currentFontSize:void 0},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1},o.doExpand=function(){o.setState({expanded:!0})},o.doCollapse=function(){o.setState({expanded:!1})},o.toggleFontSize=function(e){var t=o.props,n=t.editorState,i=t.onChange,r=(0,g.toggleCustomInlineStyle)(n,"fontSize",e);r&&i(r)},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentFontSize:(0,g.getSelectionCustomInlineStyle)(t,["FONTSIZE"]).FONTSIZE}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(e){e.editorState&&this.props.editorState!==e.editorState&&this.setState({currentFontSize:(0,g.getSelectionCustomInlineStyle)(e.editorState,["FONTSIZE"]).FONTSIZE})}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,i=o.expanded,r=o.currentFontSize,l=t.component||p.default,a=r&&Number(r.substring(9));return s.default.createElement(l,{config:t,translations:n,currentState:{fontSize:a},onChange:this.toggleFontSize,expanded:i,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),t}(c.Component);N.propTypes={onChange:u.default.func.isRequired,editorState:u.default.object,modalHandler:u.default.object,config:u.default.object,translations:u.default.object},t.default=N},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(2),d=o(g),p=n(7);n(40);var N=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={defaultFontSize:void 0},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentDidMount",value:function(){var e=document.getElementsByClassName("DraftEditor-root");if(e&&e.length>0){var t=window.getComputedStyle(e[0]),n=t.getPropertyValue("font-size");n=n.substring(0,n.length-2),this.setState({defaultFontSize:n})}}},{key:"render",value:function(){var e=this.props,t=e.config,n=t.icon,o=t.className,i=t.dropdownClassName,r=t.options,l=t.title,a=e.onChange,c=e.expanded,M=e.doCollapse,u=e.onExpandEvent,g=e.doExpand,N=e.translations,D=this.props.currentState.fontSize,I=this.state.defaultFontSize;return I=Number(I),D=D||r&&r.indexOf(I)>=0&&I,s.default.createElement("div",{className:"rdw-fontsize-wrapper","aria-label":"rdw-font-size-control"},s.default.createElement(p.Dropdown,{className:(0,d.default)("rdw-fontsize-dropdown",o),optionWrapperClassName:(0,d.default)(i),onChange:a,expanded:c,doExpand:g,doCollapse:M,onExpandEvent:u,title:l||N["components.controls.fontsize.fontsize"]},D?s.default.createElement("span",null,D):s.default.createElement("img",{src:n,alt:""}),r.map(function(e,t){return s.default.createElement(p.DropdownOption,{className:"rdw-fontsize-option",active:D===e,value:e,key:t},e)})))}}]),t}(c.Component);N.propTypes={expanded:u.default.bool,onExpandEvent:u.default.func,doExpand:u.default.func,doCollapse:u.default.func,onChange:u.default.func,config:u.default.object,currentState:u.default.object,translations:u.default.object},t.default=N},function(e,t){e.exports={"rdw-fontsize-wrapper":"rdw-fontsize-wrapper","rdw-fontsize-dropdown":"rdw-fontsize-dropdown","rdw-fontsize-option":"rdw-fontsize-option"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(4),d=n(42),p=o(d),N=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:void 0,currentFontFamily:void 0},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1},o.doExpand=function(){o.setState({expanded:!0})},o.doCollapse=function(){o.setState({expanded:!1})},o.toggleFontFamily=function(e){var t=o.props,n=t.editorState,i=t.onChange,r=(0,g.toggleCustomInlineStyle)(n,"fontFamily",e);r&&i(r)},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentFontFamily:(0,g.getSelectionCustomInlineStyle)(t,["FONTFAMILY"]).FONTFAMILY}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(e){e.editorState&&this.props.editorState!==e.editorState&&this.setState({currentFontFamily:(0,g.getSelectionCustomInlineStyle)(e.editorState,["FONTFAMILY"]).FONTFAMILY})}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,i=o.expanded,r=o.currentFontFamily,l=t.component||p.default,a=r&&r.substring(11);return s.default.createElement(l,{translations:n,config:t,currentState:{fontFamily:a},onChange:this.toggleFontFamily,expanded:i,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),t}(c.Component);N.propTypes={onChange:u.default.func.isRequired,editorState:u.default.object,modalHandler:u.default.object,config:u.default.object,translations:u.default.object},t.default=N},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(2),d=o(g),p=n(7);n(43);var N=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={defaultFontFamily:void 0},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentDidMount",value:function(){var e=document.getElementsByClassName("DraftEditor-root");if(e&&e.length>0){var t=window.getComputedStyle(e[0]),n=t.getPropertyValue("font-family");this.setState({defaultFontFamily:n})}}},{key:"render",value:function(){var e=this.state.defaultFontFamily,t=this.props,n=t.config,o=n.className,i=n.dropdownClassName,r=n.options,l=n.title,a=t.translations,c=t.onChange,M=t.expanded,u=t.doCollapse,g=t.onExpandEvent,N=t.doExpand,D=this.props.currentState.fontFamily;return D=D||r&&e&&r.some(function(t){return t.toLowerCase()===e.toLowerCase()})&&e,s.default.createElement("div",{className:"rdw-fontfamily-wrapper","aria-label":"rdw-font-family-control"},s.default.createElement(p.Dropdown,{className:(0,d.default)("rdw-fontfamily-dropdown",o),optionWrapperClassName:(0,d.default)("rdw-fontfamily-optionwrapper",i),onChange:c,expanded:M,doExpand:N,doCollapse:u,onExpandEvent:g,title:l||a["components.controls.fontfamily.fontfamily"]},s.default.createElement("span",{className:"rdw-fontfamily-placeholder"},D||a["components.controls.fontfamily.fontfamily"]),r.map(function(e,t){return s.default.createElement(p.DropdownOption,{active:D===e,value:e,key:t},e)})))}}]),t}(c.Component);N.propTypes={expanded:u.default.bool,onExpandEvent:u.default.func,doExpand:u.default.func,doCollapse:u.default.func,onChange:u.default.func,config:u.default.object,currentState:u.default.object,translations:u.default.object},t.default=N},function(e,t){e.exports={"rdw-fontfamily-wrapper":"rdw-fontfamily-wrapper","rdw-fontfamily-dropdown":"rdw-fontfamily-dropdown","rdw-fontfamily-placeholder":"rdw-fontfamily-placeholder","rdw-fontfamily-optionwrapper":"rdw-fontfamily-optionwrapper"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(3),d=n(4),p=n(45),N=o(p),D=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1,currentBlock:void 0},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded},o.onChange=function(e){"unordered"===e?o.toggleBlockType("unordered-list-item"):"ordered"===e?o.toggleBlockType("ordered-list-item"):"indent"===e?o.adjustDepth(1):o.adjustDepth(-1)},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1},o.doExpand=function(){o.setState({expanded:!0})},o.doCollapse=function(){o.setState({expanded:!1})},o.toggleBlockType=function(e){var t=o.props,n=t.onChange,i=t.editorState,r=g.RichUtils.toggleBlockType(i,e);r&&n(r)},o.adjustDepth=function(e){var t=o.props,n=t.onChange,i=t.editorState,r=(0,d.changeDepth)(i,e,4);r&&n(r)},o.isIndentDisabled=function(){var e=o.props.editorState,t=o.state.currentBlock,n=(0,d.getBlockBeforeSelectedBlock)(e);return!n||!(0,d.isListBlock)(t)||n.get("type")!==t.get("type")||n.get("depth")<t.get("depth")},o.isOutdentDisabled=function(){var e=o.state.currentBlock;return!e||!(0,d.isListBlock)(e)||e.get("depth")<=0},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentBlock:(0,d.getSelectedBlock)(t)}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(e){if(e.editorState&&this.props.editorState!==e.editorState){(0,d.getSelectedBlock)(e.editorState);this.setState({currentBlock:(0,d.getSelectedBlock)(e.editorState)})}}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,i=o.expanded,r=o.currentBlock,l=t.component||N.default,a=void 0;"unordered-list-item"===r.get("type")?a="unordered":"ordered-list-item"===r.get("type")&&(a="ordered");var c=this.isIndentDisabled(),M=this.isOutdentDisabled();return s.default.createElement(l,{config:t,translations:n,currentState:{listType:a},expanded:i,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onChange:this.onChange,indentDisabled:c,outdentDisabled:M})}}]),t}(c.Component);D.propTypes={onChange:u.default.func.isRequired,editorState:u.default.object.isRequired,modalHandler:u.default.object,config:u.default.object,translations:u.default.object},t.default=D},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(2),d=o(g),p=n(8),N=n(7),D=n(5),I=o(D);n(46);var y=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.options=["unordered","ordered","indent","outdent"],o.toggleBlockType=function(e){(0,o.props.onChange)(e)},o.indent=function(){(0,o.props.onChange)("indent")},o.outdent=function(){(0,o.props.onChange)("outdent")},l=n,r(o,l)}return l(t,e),a(t,[{key:"renderInFlatList",value:function(){var e=this.props,t=e.config,n=e.currentState.listType,o=e.translations,i=e.indentDisabled,r=e.outdentDisabled,l=t.options,a=t.unordered,c=t.ordered,M=t.indent,u=t.outdent,g=t.className;return s.default.createElement("div",{className:(0,d.default)("rdw-list-wrapper",g),"aria-label":"rdw-list-control"},l.indexOf("unordered")>=0&&s.default.createElement(I.default,{value:"unordered",onClick:this.toggleBlockType,className:(0,d.default)(a.className),active:"unordered"===n,title:a.title||o["components.controls.list.unordered"]},s.default.createElement("img",{src:a.icon,alt:""})),l.indexOf("ordered")>=0&&s.default.createElement(I.default,{value:"ordered",onClick:this.toggleBlockType,className:(0,d.default)(c.className),active:"ordered"===n,title:c.title||o["components.controls.list.ordered"]},s.default.createElement("img",{src:c.icon,alt:""})),l.indexOf("indent")>=0&&s.default.createElement(I.default,{onClick:this.indent,disabled:i,className:(0,d.default)(M.className),title:M.title||o["components.controls.list.indent"]},s.default.createElement("img",{src:M.icon,alt:""})),l.indexOf("outdent")>=0&&s.default.createElement(I.default,{onClick:this.outdent,disabled:r,className:(0,d.default)(u.className),title:u.title||o["components.controls.list.outdent"]},s.default.createElement("img",{src:u.icon,alt:""})))}},{key:"renderInDropDown",value:function(){var e=this,t=this.props,n=t.config,o=t.expanded,i=t.doCollapse,r=t.doExpand,l=t.onExpandEvent,a=t.onChange,c=t.currentState.listType,M=t.translations,u=n.options,g=n.className,D=n.dropdownClassName,I=n.title;return s.default.createElement(N.Dropdown,{className:(0,d.default)("rdw-list-dropdown",g),optionWrapperClassName:(0,d.default)(D),onChange:a,expanded:o,doExpand:r,doCollapse:i,onExpandEvent:l,"aria-label":"rdw-list-control",title:I||M["components.controls.list.list"]},s.default.createElement("img",{src:(0,p.getFirstIcon)(n),alt:""}),this.options.filter(function(e){return u.indexOf(e)>=0}).map(function(t,o){return s.default.createElement(N.DropdownOption,{key:o,value:t,disabled:e.props[t+"Disabled"],className:(0,d.default)("rdw-list-dropdownOption",n[t].className),active:c===t,title:n[t].title||M["components.controls.list."+t]},s.default.createElement("img",{src:n[t].icon,alt:""}))}))}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),t}(c.Component);y.propTypes={expanded:u.default.bool,doExpand:u.default.func,doCollapse:u.default.func,onExpandEvent:u.default.func,config:u.default.object,onChange:u.default.func,currentState:u.default.object,translations:u.default.object,indentDisabled:u.default.bool,outdentDisabled:u.default.bool},t.default=y},function(e,t){e.exports={"rdw-list-wrapper":"rdw-list-wrapper","rdw-list-dropdown":"rdw-list-dropdown","rdw-list-dropdownOption":"rdw-list-dropdownOption"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(4),d=n(48),p=o(d),N=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={currentTextAlignment:void 0},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1},o.doExpand=function(){o.setState({expanded:!0})},o.doCollapse=function(){o.setState({expanded:!1})},o.addBlockAlignmentData=function(e){var t=o.props,n=t.editorState,i=t.onChange;i(o.state.currentTextAlignment!==e?(0,g.setBlockData)(n,{"text-align":e}):(0,g.setBlockData)(n,{"text-align":void 0}))},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(e){e.editorState!==this.props.editorState&&this.setState({currentTextAlignment:(0,g.getSelectedBlocksMetadata)(e.editorState).get("text-align")})}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,i=o.expanded,r=o.currentTextAlignment,l=t.component||p.default;return s.default.createElement(l,{config:t,translations:n,expanded:i,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,currentState:{textAlignment:r},onChange:this.addBlockAlignmentData})}}]),t}(c.Component);N.propTypes={editorState:u.default.object.isRequired,onChange:u.default.func.isRequired,modalHandler:u.default.object,config:u.default.object,translations:u.default.object},t.default=N},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(2),d=o(g),p=n(5),N=o(p),D=n(7),I=n(8);n(49);var y=function(e){function t(){return i(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return l(t,e),a(t,[{key:"renderInFlatList",value:function(){var e=this.props,t=e.config,n=t.options,o=t.left,i=t.center,r=t.right,l=t.justify,a=t.className,c=e.onChange,M=e.currentState.textAlignment,u=e.translations;return s.default.createElement("div",{className:(0,d.default)("rdw-text-align-wrapper",a),"aria-label":"rdw-textalign-control"},n.indexOf("left")>=0&&s.default.createElement(N.default,{value:"left",className:(0,d.default)(o.className),active:"left"===M,onClick:c,title:o.title||u["components.controls.textalign.left"]},s.default.createElement("img",{src:o.icon,alt:""})),n.indexOf("center")>=0&&s.default.createElement(N.default,{value:"center",className:(0,d.default)(i.className),active:"center"===M,onClick:c,title:i.title||u["components.controls.textalign.center"]},s.default.createElement("img",{src:i.icon,alt:""})),n.indexOf("right")>=0&&s.default.createElement(N.default,{value:"right",className:(0,d.default)(r.className),active:"right"===M,onClick:c,title:r.title||u["components.controls.textalign.right"]},s.default.createElement("img",{src:r.icon,alt:""})),n.indexOf("justify")>=0&&s.default.createElement(N.default,{value:"justify",className:(0,d.default)(l.className),active:"justify"===M,onClick:c,title:l.title||u["components.controls.textalign.justify"]},s.default.createElement("img",{src:l.icon,alt:""})))}},{key:"renderInDropDown",value:function(){var e=this.props,t=e.config,n=e.expanded,o=e.doExpand,i=e.onExpandEvent,r=e.doCollapse,l=e.currentState.textAlignment,a=e.onChange,c=e.translations,M=t.options,u=t.left,g=t.center,p=t.right,N=t.justify,y=t.className,j=t.dropdownClassName,f=t.title;return s.default.createElement(D.Dropdown,{className:(0,d.default)("rdw-text-align-dropdown",y),optionWrapperClassName:(0,d.default)(j),onChange:a,expanded:n,doExpand:o,doCollapse:r,onExpandEvent:i,"aria-label":"rdw-textalign-control",title:f||c["components.controls.textalign.textalign"]},s.default.createElement("img",{src:l&&t[l]&&t[l].icon||(0,I.getFirstIcon)(t),alt:""}),M.indexOf("left")>=0&&s.default.createElement(D.DropdownOption,{value:"left",active:"left"===l,className:(0,d.default)("rdw-text-align-dropdownOption",u.className),title:u.title||c["components.controls.textalign.left"]},s.default.createElement("img",{src:u.icon,alt:""})),M.indexOf("center")>=0&&s.default.createElement(D.DropdownOption,{value:"center",active:"center"===l,className:(0,d.default)("rdw-text-align-dropdownOption",g.className),title:g.title||c["components.controls.textalign.center"]},s.default.createElement("img",{src:g.icon,alt:""})),M.indexOf("right")>=0&&s.default.createElement(D.DropdownOption,{value:"right",active:"right"===l,className:(0,d.default)("rdw-text-align-dropdownOption",p.className),title:p.title||c["components.controls.textalign.right"]},s.default.createElement("img",{src:p.icon,alt:""})),M.indexOf("justify")>=0&&s.default.createElement(D.DropdownOption,{value:"justify",active:"justify"===l,className:(0,d.default)("rdw-text-align-dropdownOption",N.className),title:N.title||c["components.controls.textalign.justify"]},s.default.createElement("img",{src:N.icon,alt:""})))}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),t}(c.Component);y.propTypes={expanded:u.default.bool,doExpand:u.default.func,doCollapse:u.default.func,onExpandEvent:u.default.func,config:u.default.object,onChange:u.default.func,currentState:u.default.object,translations:u.default.object},t.default=y},function(e,t){e.exports={"rdw-text-align-wrapper":"rdw-text-align-wrapper","rdw-text-align-dropdown":"rdw-text-align-dropdown","rdw-text-align-dropdownOption":"rdw-text-align-dropdownOption","rdw-right-aligned-block":"rdw-right-aligned-block","rdw-left-aligned-block":"rdw-left-aligned-block","rdw-center-aligned-block":"rdw-center-aligned-block","rdw-justify-aligned-block":"rdw-justify-aligned-block"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(4),d=n(51),p=o(d),N=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1,currentColor:void 0,currentBgColor:void 0},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1},o.doExpand=function(){o.setState({expanded:!0})},o.doCollapse=function(){o.setState({expanded:!1})},o.toggleColor=function(e,t){var n=o.props,i=n.editorState,r=n.onChange,l=(0,g.toggleCustomInlineStyle)(i,e,t);l&&r(l),o.doCollapse()},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentColor:(0,g.getSelectionCustomInlineStyle)(t,["COLOR"]).COLOR,currentBgColor:(0,g.getSelectionCustomInlineStyle)(t,["BGCOLOR"]).BGCOLOR}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(e){var t={};e.editorState&&this.props.editorState!==e.editorState&&(t.currentColor=(0,g.getSelectionCustomInlineStyle)(e.editorState,["COLOR"]).COLOR,t.currentBgColor=(0,g.getSelectionCustomInlineStyle)(e.editorState,["BGCOLOR"]).BGCOLOR),this.setState(t)}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,i=o.currentColor,r=o.currentBgColor,l=o.expanded,a=t.component||p.default,c=i&&i.substring(6),M=r&&r.substring(8);return s.default.createElement(a,{config:t,translations:n,onChange:this.toggleColor,expanded:l,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,currentState:{color:c,bgColor:M}})}}]),t}(c.Component);N.propTypes={onChange:u.default.func.isRequired,editorState:u.default.object.isRequired,modalHandler:u.default.object,config:u.default.object,translations:u.default.object},t.default=N},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(2),d=o(g),p=n(6),N=n(5),D=o(N);n(52);var I=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),M=0;M<a;M++)c[M]=arguments[M];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={currentStyle:"color"},o.onChange=function(e){(0,o.props.onChange)(o.state.currentStyle,e)},o.setCurrentStyleColor=function(){o.setState({currentStyle:"color"})},o.setCurrentStyleBgcolor=function(){o.setState({currentStyle:"bgcolor"})},o.renderModal=function(){var e=o.props,t=e.config,n=t.popupClassName,i=t.colors,r=e.currentState,l=r.color,a=r.bgColor,c=e.translations,M=o.state.currentStyle,u="color"===M?l:a;return s.default.createElement("div",{className:(0,d.default)("rdw-colorpicker-modal",n),onClick:p.stopPropagation},s.default.createElement("span",{className:"rdw-colorpicker-modal-header"},s.default.createElement("span",{className:(0,d.default)("rdw-colorpicker-modal-style-label",{"rdw-colorpicker-modal-style-label-active":"color"===M}),onClick:o.setCurrentStyleColor},c["components.controls.colorpicker.text"]),s.default.createElement("span",{className:(0,d.default)("rdw-colorpicker-modal-style-label",{"rdw-colorpicker-modal-style-label-active":"bgcolor"===M}),onClick:o.setCurrentStyleBgcolor},c["components.controls.colorpicker.background"])),s.default.createElement("span",{className:"rdw-colorpicker-modal-options"},i.map(function(e,t){return s.default.createElement(D.default,{value:e,key:t,className:"rdw-colorpicker-option",activeClassName:"rdw-colorpicker-option-active",active:u===e,onClick:o.onChange},s.default.createElement("span",{style:{backgroundColor:e},className:"rdw-colorpicker-cube"}))})))},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillReceiveProps",value:function(e){!this.props.expanded&&e.expanded&&this.setState({currentStyle:"color"})}},{key:"render",value:function(){var e=this.props,t=e.config,n=t.icon,o=t.className,i=t.title,r=e.expanded,l=e.onExpandEvent,a=e.translations;return s.default.createElement("div",{className:"rdw-colorpicker-wrapper","aria-haspopup":"true","aria-expanded":r,"aria-label":"rdw-color-picker",title:i||a["components.controls.colorpicker.colorpicker"]},s.default.createElement(D.default,{onClick:l,className:(0,d.default)(o)},s.default.createElement("img",{src:n,alt:""})),r?this.renderModal():void 0)}}]),t}(c.Component);I.propTypes={expanded:u.default.bool,onExpandEvent:u.default.func,onChange:u.default.func,config:u.default.object,currentState:u.default.object,translations:u.default.object},t.default=I},function(e,t){e.exports={"rdw-colorpicker-wrapper":"rdw-colorpicker-wrapper","rdw-colorpicker-modal":"rdw-colorpicker-modal","rdw-colorpicker-modal-header":"rdw-colorpicker-modal-header","rdw-colorpicker-modal-style-label":"rdw-colorpicker-modal-style-label","rdw-colorpicker-modal-style-label-active":"rdw-colorpicker-modal-style-label-active","rdw-colorpicker-modal-options":"rdw-colorpicker-modal-options","rdw-colorpicker-cube":"rdw-colorpicker-cube","rdw-colorpicker-option":"rdw-colorpicker-option","rdw-colorpicker-option-active":"rdw-colorpicker-option-active"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(3),d=n(4),p=n(54),N=o(p),D=n(60),I=o(D),y=(0,N.default)(),j=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1,link:void 0,selectionText:void 0},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded},o.onChange=function(e,t,n,i){if("link"===e){var r=y.match(n),l=r&&r[0]?r[0].url:"";o.addLink(t,l,i)}else o.removeLink()},o.getCurrentValues=function(){var e=o.props.editorState,t=o.state.currentEntity,n=e.getCurrentContent(),i={};if(t&&"LINK"===n.getEntity(t).get("type")){i.link={};var r=t&&(0,d.getEntityRange)(e,t);i.link.target=t&&n.getEntity(t).get("data").url,i.link.targetOption=t&&n.getEntity(t).get("data").targetOption,i.link.title=r&&r.text}return i.selectionText=(0,d.getSelectionText)(e),i},o.doExpand=function(){o.setState({expanded:!0})},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1},o.doCollapse=function(){o.setState({expanded:!1})},o.removeLink=function(){var e=o.props,t=e.editorState,n=e.onChange,i=o.state.currentEntity,r=t.getSelection();if(i){var l=(0,d.getEntityRange)(t,i);r=r.merge({anchorOffset:l.start,focusOffset:l.end}),n(g.RichUtils.toggleLink(t,r,null))}},o.addLink=function(e,t,n){var i=o.props,r=i.editorState,l=i.onChange,a=o.state.currentEntity,c=r.getSelection();if(a){var s=(0,d.getEntityRange)(r,a);c=c.merge({anchorOffset:s.start,focusOffset:s.end})}var M=r.getCurrentContent().createEntity("LINK","MUTABLE",{url:t,targetOption:n}).getLastCreatedEntityKey(),u=g.Modifier.replaceText(r.getCurrentContent(),c,""+e,r.getCurrentInlineStyle(),M),p=g.EditorState.push(r,u,"insert-characters");c=p.getSelection().merge({anchorOffset:c.get("anchorOffset")+e.length,focusOffset:c.get("anchorOffset")+e.length}),p=g.EditorState.acceptSelection(p,c),u=g.Modifier.insertText(p.getCurrentContent(),c," ",p.getCurrentInlineStyle(),void 0),l(g.EditorState.push(p,u,"insert-characters")),o.doCollapse()},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentEntity:(0,d.getSelectionEntity)(t)}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(e){var t={};e.editorState&&this.props.editorState!==e.editorState&&(t.currentEntity=(0,d.getSelectionEntity)(e.editorState)),this.setState(t)}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state.expanded,i=this.getCurrentValues(),r=i.link,l=i.selectionText,a=t.component||I.default;return s.default.createElement(a,{config:t,translations:n,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,currentState:{link:r,selectionText:l},onChange:this.onChange})}}]),t}(c.Component);j.propTypes={editorState:u.default.object.isRequired,onChange:u.default.func.isRequired,modalHandler:u.default.object,config:u.default.object,translations:u.default.object},t.default=j},function(e,t,n){"use strict";function o(e){return Array.prototype.slice.call(arguments,1).forEach(function(t){t&&Object.keys(t).forEach(function(n){e[n]=t[n]})}),e}function i(e){return Object.prototype.toString.call(e)}function r(e){return"[object String]"===i(e)}function l(e){return"[object Object]"===i(e)}function a(e){return"[object RegExp]"===i(e)}function c(e){return"[object Function]"===i(e)}function s(e){return e.replace(/[.?*+^$[\]\\(){}|-]/g,"\\$&")}function M(e){return Object.keys(e||{}).reduce(function(e,t){return e||y.hasOwnProperty(t)},!1)}function u(e){e.__index__=-1,e.__text_cache__=""}function g(e){return function(t,n){var o=t.slice(n);return e.test(o)?o.match(e)[0].length:0}}function d(){return function(e,t){t.normalize(e)}}function p(e){function t(e){return e.replace("%TLDS%",i.src_tlds)}function o(e,t){throw new Error('(LinkifyIt) Invalid schema "'+e+'": '+t)}var i=e.re=n(55)(e.__opts__),M=e.__tlds__.slice();e.onCompile(),e.__tlds_replaced__||M.push(f),M.push(i.src_xn),i.src_tlds=M.join("|"),i.email_fuzzy=RegExp(t(i.tpl_email_fuzzy),"i"),i.link_fuzzy=RegExp(t(i.tpl_link_fuzzy),"i"),i.link_no_ip_fuzzy=RegExp(t(i.tpl_link_no_ip_fuzzy),"i"),i.host_fuzzy_test=RegExp(t(i.tpl_host_fuzzy_test),"i");var p=[];e.__compiled__={},Object.keys(e.__schemas__).forEach(function(t){var n=e.__schemas__[t];if(null!==n){var i={validate:null,link:null};return e.__compiled__[t]=i,l(n)?(a(n.validate)?i.validate=g(n.validate):c(n.validate)?i.validate=n.validate:o(t,n),void(c(n.normalize)?i.normalize=n.normalize:n.normalize?o(t,n):i.normalize=d())):r(n)?void p.push(t):void o(t,n)}}),p.forEach(function(t){e.__compiled__[e.__schemas__[t]]&&(e.__compiled__[t].validate=e.__compiled__[e.__schemas__[t]].validate,e.__compiled__[t].normalize=e.__compiled__[e.__schemas__[t]].normalize)}),e.__compiled__[""]={validate:null,normalize:d()};var N=Object.keys(e.__compiled__).filter(function(t){return t.length>0&&e.__compiled__[t]}).map(s).join("|");e.re.schema_test=RegExp("(^|(?!_)(?:[><｜]|"+i.src_ZPCc+"))("+N+")","i"),e.re.schema_search=RegExp("(^|(?!_)(?:[><｜]|"+i.src_ZPCc+"))("+N+")","ig"),e.re.pretest=RegExp("("+e.re.schema_test.source+")|("+e.re.host_fuzzy_test.source+")|@","i"),u(e)}function N(e,t){var n=e.__index__,o=e.__last_index__,i=e.__text_cache__.slice(n,o);this.schema=e.__schema__.toLowerCase(),this.index=n+t,this.lastIndex=o+t,this.raw=i,this.text=i,this.url=i}function D(e,t){var n=new N(e,t);return e.__compiled__[n.schema].normalize(n,e),n}function I(e,t){if(!(this instanceof I))return new I(e,t);t||M(e)&&(t=e,e={}),this.__opts__=o({},y,t),this.__index__=-1,this.__last_index__=-1,this.__schema__="",this.__text_cache__="",this.__schemas__=o({},j,e),this.__compiled__={},this.__tlds__=w,this.__tlds_replaced__=!1,this.re={},p(this)}var y={fuzzyLink:!0,fuzzyEmail:!0,fuzzyIP:!1},j={"http:":{validate:function(e,t,n){var o=e.slice(t);return n.re.http||(n.re.http=new RegExp("^\\/\\/"+n.re.src_auth+n.re.src_host_port_strict+n.re.src_path,"i")),n.re.http.test(o)?o.match(n.re.http)[0].length:0}},"https:":"http:","ftp:":"http:","//":{validate:function(e,t,n){var o=e.slice(t);return n.re.no_http||(n.re.no_http=new RegExp("^"+n.re.src_auth+"(?:localhost|(?:(?:"+n.re.src_domain+")\\.)+"+n.re.src_domain_root+")"+n.re.src_port+n.re.src_host_terminator+n.re.src_path,"i")),n.re.no_http.test(o)?t>=3&&":"===e[t-3]?0:t>=3&&"/"===e[t-3]?0:o.match(n.re.no_http)[0].length:0}},"mailto:":{validate:function(e,t,n){var o=e.slice(t);return n.re.mailto||(n.re.mailto=new RegExp("^"+n.re.src_email_name+"@"+n.re.src_host_strict,"i")),n.re.mailto.test(o)?o.match(n.re.mailto)[0].length:0}}},f="a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",w="biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");I.prototype.add=function(e,t){return this.__schemas__[e]=t,p(this),this},I.prototype.set=function(e){return this.__opts__=o(this.__opts__,e),this},I.prototype.test=function(e){if(this.__text_cache__=e,this.__index__=-1,!e.length)return!1;var t,n,o,i,r,l,a,c;if(this.re.schema_test.test(e))for(a=this.re.schema_search,a.lastIndex=0;null!==(t=a.exec(e));)if(i=this.testSchemaAt(e,t[2],a.lastIndex)){this.__schema__=t[2],this.__index__=t.index+t[1].length,this.__last_index__=t.index+t[0].length+i;break}return this.__opts__.fuzzyLink&&this.__compiled__["http:"]&&(c=e.search(this.re.host_fuzzy_test))>=0&&(this.__index__<0||c<this.__index__)&&null!==(n=e.match(this.__opts__.fuzzyIP?this.re.link_fuzzy:this.re.link_no_ip_fuzzy))&&(r=n.index+n[1].length,(this.__index__<0||r<this.__index__)&&(this.__schema__="",this.__index__=r,this.__last_index__=n.index+n[0].length)),this.__opts__.fuzzyEmail&&this.__compiled__["mailto:"]&&e.indexOf("@")>=0&&null!==(o=e.match(this.re.email_fuzzy))&&(r=o.index+o[1].length,l=o.index+o[0].length,(this.__index__<0||r<this.__index__||r===this.__index__&&l>this.__last_index__)&&(this.__schema__="mailto:",this.__index__=r,this.__last_index__=l)),this.__index__>=0},I.prototype.pretest=function(e){return this.re.pretest.test(e)},I.prototype.testSchemaAt=function(e,t,n){return this.__compiled__[t.toLowerCase()]?this.__compiled__[t.toLowerCase()].validate(e,n,this):0},I.prototype.match=function(e){var t=0,n=[];this.__index__>=0&&this.__text_cache__===e&&(n.push(D(this,t)),t=this.__last_index__);for(var o=t?e.slice(t):e;this.test(o);)n.push(D(this,t)),o=o.slice(this.__last_index__),t+=this.__last_index__;return n.length?n:null},I.prototype.tlds=function(e,t){return e=Array.isArray(e)?e:[e],t?(this.__tlds__=this.__tlds__.concat(e).sort().filter(function(e,t,n){return e!==n[t-1]}).reverse(),p(this),this):(this.__tlds__=e.slice(),this.__tlds_replaced__=!0,p(this),this)},I.prototype.normalize=function(e){e.schema||(e.url="http://"+e.url),"mailto:"!==e.schema||/^mailto:/i.test(e.url)||(e.url="mailto:"+e.url)},I.prototype.onCompile=function(){},e.exports=I},function(e,t,n){"use strict";e.exports=function(e){var t={};t.src_Any=n(56).source,t.src_Cc=n(57).source,t.src_Z=n(58).source,t.src_P=n(59).source,t.src_ZPCc=[t.src_Z,t.src_P,t.src_Cc].join("|"),t.src_ZCc=[t.src_Z,t.src_Cc].join("|");return t.src_pseudo_letter="(?:(?![><｜]|"+t.src_ZPCc+")"+t.src_Any+")",t.src_ip4="(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)",t.src_auth="(?:(?:(?!"+t.src_ZCc+"|[@/\\[\\]()]).)+@)?",t.src_port="(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?",t.src_host_terminator="(?=$|[><｜]|"+t.src_ZPCc+")(?!-|_|:\\d|\\.-|\\.(?!$|"+t.src_ZPCc+"))",t.src_path="(?:[/?#](?:(?!"+t.src_ZCc+"|[><｜]|[()[\\]{}.,\"'?!\\-]).|\\[(?:(?!"+t.src_ZCc+"|\\]).)*\\]|\\((?:(?!"+t.src_ZCc+"|[)]).)*\\)|\\{(?:(?!"+t.src_ZCc+'|[}]).)*\\}|\\"(?:(?!'+t.src_ZCc+'|["]).)+\\"|\\\'(?:(?!'+t.src_ZCc+"|[']).)+\\'|\\'(?="+t.src_pseudo_letter+"|[-]).|\\.{2,3}[a-zA-Z0-9%/]|\\.(?!"+t.src_ZCc+"|[.]).|"+(e&&e["---"]?"\\-(?!--(?:[^-]|$))(?:-*)|":"\\-+|")+"\\,(?!"+t.src_ZCc+").|\\!(?!"+t.src_ZCc+"|[!]).|\\?(?!"+t.src_ZCc+"|[?]).)+|\\/)?",t.src_email_name='[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+',t.src_xn="xn--[a-z0-9\\-]{1,59}",t.src_domain_root="(?:"+t.src_xn+"|"+t.src_pseudo_letter+"{1,63})",t.src_domain="(?:"+t.src_xn+"|(?:"+t.src_pseudo_letter+")|(?:"+t.src_pseudo_letter+"(?:-(?!-)|"+t.src_pseudo_letter+"){0,61}"+t.src_pseudo_letter+"))",t.src_host="(?:(?:(?:(?:"+t.src_domain+")\\.)*"+t.src_domain+"))",t.tpl_host_fuzzy="(?:"+t.src_ip4+"|(?:(?:(?:"+t.src_domain+")\\.)+(?:%TLDS%)))",t.tpl_host_no_ip_fuzzy="(?:(?:(?:"+t.src_domain+")\\.)+(?:%TLDS%))",t.src_host_strict=t.src_host+t.src_host_terminator,t.tpl_host_fuzzy_strict=t.tpl_host_fuzzy+t.src_host_terminator,t.src_host_port_strict=t.src_host+t.src_port+t.src_host_terminator,t.tpl_host_port_fuzzy_strict=t.tpl_host_fuzzy+t.src_port+t.src_host_terminator,t.tpl_host_port_no_ip_fuzzy_strict=t.tpl_host_no_ip_fuzzy+t.src_port+t.src_host_terminator,t.tpl_host_fuzzy_test="localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:"+t.src_ZPCc+"|>|$))",t.tpl_email_fuzzy="(^|[><｜]|\\(|"+t.src_ZCc+")("+t.src_email_name+"@"+t.tpl_host_fuzzy_strict+")",t.tpl_link_fuzzy="(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|"+t.src_ZPCc+"))((?![$+<=>^`|｜])"+t.tpl_host_port_fuzzy_strict+t.src_path+")",t.tpl_link_no_ip_fuzzy="(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|"+t.src_ZPCc+"))((?![$+<=>^`|｜])"+t.tpl_host_port_no_ip_fuzzy_strict+t.src_path+")",t}},function(e,t,n){"use strict";e.exports=/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/},function(e,t,n){"use strict";e.exports=/[\0-\x1F\x7F-\x9F]/},function(e,t,n){"use strict";e.exports=/[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/},function(e,t,n){"use strict";e.exports=/[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function l(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var c=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),M=o(s),u=n(1),g=o(u),d=n(2),p=o(d),N=n(6),D=n(8),I=n(5),y=o(I),j=n(7);n(61);var f=function(e){function t(){var e,n,o,a;r(this,t);for(var c=arguments.length,s=Array(c),M=0;M<c;M++)s[M]=arguments[M];return n=o=l(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(s))),o.state={showModal:!1,linkTarget:"",linkTitle:"",linkTargetOption:o.props.config.defaultTargetOption},o.removeLink=function(){(0,o.props.onChange)("unlink")},o.addLink=function(){var e=o.props.onChange,t=o.state;e("link",t.linkTitle,t.linkTarget,t.linkTargetOption)},o.updateValue=function(e){o.setState(i({},""+e.target.name,e.target.value))},o.updateTargetOption=function(e){o.setState({linkTargetOption:e.target.checked?"_blank":"_self"})},o.hideModal=function(){o.setState({showModal:!1})},o.signalExpandShowModal=function(){var e=o.props,t=e.onExpandEvent,n=e.currentState,i=n.link,r=n.selectionText,l=o.state.linkTargetOption;t(),o.setState({showModal:!0,linkTarget:i&&i.target||"",linkTargetOption:i&&i.targetOption||l,linkTitle:i&&i.title||r})},o.forceExpandAndShowModal=function(){var e=o.props,t=e.doExpand,n=e.currentState,i=n.link,r=n.selectionText,l=o.state.linkTargetOption;t(),o.setState({showModal:!0,linkTarget:i&&i.target,linkTargetOption:i&&i.targetOption||l,linkTitle:i&&i.title||r})},a=n,l(o,a)}return a(t,e),c(t,[{key:"componentWillReceiveProps",value:function(e){this.props.expanded&&!e.expanded&&this.setState({showModal:!1,linkTarget:"",linkTitle:"",linkTargetOption:this.props.config.defaultTargetOption})}},{key:"renderAddLinkModal",value:function(){var e=this.props,t=e.config.popupClassName,n=e.doCollapse,o=e.translations,i=this.state,r=i.linkTitle,l=i.linkTarget,a=i.linkTargetOption;return M.default.createElement("div",{className:(0,p.default)("rdw-link-modal",t),onClick:N.stopPropagation},M.default.createElement("label",{className:"rdw-link-modal-label",htmlFor:"linkTitle"},o["components.controls.link.linkTitle"]),M.default.createElement("input",{id:"linkTitle",className:"rdw-link-modal-input",onChange:this.updateValue,onBlur:this.updateValue,name:"linkTitle",value:r}),M.default.createElement("label",{className:"rdw-link-modal-label",htmlFor:"linkTarget"},o["components.controls.link.linkTarget"]),M.default.createElement("input",{id:"linkTarget",className:"rdw-link-modal-input",onChange:this.updateValue,onBlur:this.updateValue,name:"linkTarget",value:l}),M.default.createElement("label",{className:"rdw-link-modal-target-option",htmlFor:"openLinkInNewWindow"},M.default.createElement("input",{id:"openLinkInNewWindow",type:"checkbox",defaultChecked:"_blank"===a,value:"_blank",onChange:this.updateTargetOption}),M.default.createElement("span",null,o["components.controls.link.linkTargetOption"])),M.default.createElement("span",{className:"rdw-link-modal-buttonsection"},M.default.createElement("button",{className:"rdw-link-modal-btn",onClick:this.addLink,disabled:!l||!r},o["generic.add"]),M.default.createElement("button",{className:"rdw-link-modal-btn",onClick:n},o["generic.cancel"])))}},{key:"renderInFlatList",value:function(){var e=this.props,t=e.config,n=t.options,o=t.link,i=t.unlink,r=t.className,l=e.currentState,a=e.expanded,c=e.translations,s=this.state.showModal;return M.default.createElement("div",{className:(0,p.default)("rdw-link-wrapper",r),"aria-label":"rdw-link-control"},n.indexOf("link")>=0&&M.default.createElement(y.default,{value:"unordered-list-item",className:(0,p.default)(o.className),onClick:this.signalExpandShowModal,"aria-haspopup":"true","aria-expanded":s,title:o.title||c["components.controls.link.link"]},M.default.createElement("img",{src:o.icon,alt:""})),n.indexOf("unlink")>=0&&M.default.createElement(y.default,{disabled:!l.link,value:"ordered-list-item",className:(0,p.default)(i.className),onClick:this.removeLink,title:i.title||c["components.controls.link.unlink"]},M.default.createElement("img",{src:i.icon,alt:""})),a&&s?this.renderAddLinkModal():void 0)}},{key:"renderInDropDown",value:function(){var e=this.props,t=e.expanded,n=e.onExpandEvent,o=e.doCollapse,i=e.doExpand,r=e.onChange,l=e.config,a=e.currentState,c=e.translations,s=l.options,u=l.link,g=l.unlink,d=l.className,N=l.dropdownClassName,I=l.title,y=this.state.showModal;return M.default.createElement("div",{className:"rdw-link-wrapper","aria-haspopup":"true","aria-label":"rdw-link-control","aria-expanded":t,title:I},M.default.createElement(j.Dropdown,{className:(0,p.default)("rdw-link-dropdown",d),optionWrapperClassName:(0,p.default)(N),onChange:r,expanded:t&&!y,doExpand:i,doCollapse:o,onExpandEvent:n},M.default.createElement("img",{src:(0,D.getFirstIcon)(l),alt:""}),s.indexOf("link")>=0&&M.default.createElement(j.DropdownOption,{onClick:this.forceExpandAndShowModal,className:(0,p.default)("rdw-link-dropdownoption",u.className),title:u.title||c["components.controls.link.link"]},M.default.createElement("img",{src:u.icon,alt:""})),s.indexOf("unlink")>=0&&M.default.createElement(j.DropdownOption,{onClick:this.removeLink,disabled:!a.link,className:(0,p.default)("rdw-link-dropdownoption",g.className),title:g.title||c["components.controls.link.unlink"]},M.default.createElement("img",{src:g.icon,alt:""}))),t&&y?this.renderAddLinkModal():void 0)}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),t}(s.Component);f.propTypes={expanded:g.default.bool,doExpand:g.default.func,doCollapse:g.default.func,onExpandEvent:g.default.func,config:g.default.object,onChange:g.default.func,currentState:g.default.object,translations:g.default.object},t.default=f},function(e,t){e.exports={"rdw-link-wrapper":"rdw-link-wrapper","rdw-link-dropdown":"rdw-link-dropdown","rdw-link-dropdownOption":"rdw-link-dropdownOption","rdw-link-dropdownPlaceholder":"rdw-link-dropdownPlaceholder","rdw-link-modal":"rdw-link-modal","rdw-link-modal-label":"rdw-link-modal-label","rdw-link-modal-input":"rdw-link-modal-input","rdw-link-modal-buttonsection":"rdw-link-modal-buttonsection","rdw-link-modal-target-option":"rdw-link-modal-target-option","rdw-link-modal-btn":"rdw-link-modal-btn","rdw-link-dropdownoption":"rdw-link-dropdownoption","rdw-history-dropdown":"rdw-history-dropdown"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(3),d=n(63),p=o(d),N=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1},o.doExpand=function(){o.setState({expanded:!0})},o.doCollapse=function(){o.setState({expanded:!1})},o.addEmbeddedLink=function(e,t,n){var i=o.props,r=i.editorState,l=i.onChange,a=r.getCurrentContent().createEntity("EMBEDDED_LINK","MUTABLE",{src:e,height:t,width:n}).getLastCreatedEntityKey();l(g.AtomicBlockUtils.insertAtomicBlock(r,a," ")),o.doCollapse()},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse)}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state.expanded,i=t.component||p.default;return s.default.createElement(i,{config:t,translations:n,onChange:this.addEmbeddedLink,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),t}(c.Component);N.propTypes={editorState:u.default.object.isRequired,onChange:u.default.func.isRequired,modalHandler:u.default.object,config:u.default.object,translations:u.default.object},t.default=N},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function l(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var c=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),M=o(s),u=n(1),g=o(u),d=n(2),p=o(d),N=n(6),D=n(5),I=o(D);n(64);var y=function(e){function t(){var e,n,o,a;r(this,t);for(var c=arguments.length,s=Array(c),M=0;M<c;M++)s[M]=arguments[M];return n=o=l(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(s))),o.state={embeddedLink:"",height:o.props.config.defaultSize.height,width:o.props.config.defaultSize.width},o.onChange=function(){var e=o.props.onChange,t=o.state;e(t.embeddedLink,t.height,t.width)},o.updateValue=function(e){o.setState(i({},""+e.target.name,e.target.value))},a=n,l(o,a)}return a(t,e),c(t,[{key:"componentWillReceiveProps",value:function(e){if(this.props.expanded&&!e.expanded){var t=this.props.config.defaultSize,n=t.height,o=t.width;this.setState({embeddedLink:"",height:n,width:o})}}},{key:"rendeEmbeddedLinkModal",value:function(){var e=this.state,t=e.embeddedLink,n=e.height,o=e.width,i=this.props,r=i.config.popupClassName,l=i.doCollapse,a=i.translations;return M.default.createElement("div",{className:(0,p.default)("rdw-embedded-modal",r),onClick:N.stopPropagation},M.default.createElement("div",{className:"rdw-embedded-modal-header"},M.default.createElement("span",{className:"rdw-embedded-modal-header-option"},a["components.controls.embedded.embeddedlink"],M.default.createElement("span",{className:"rdw-embedded-modal-header-label"}))),M.default.createElement("div",{className:"rdw-embedded-modal-link-section"},M.default.createElement("span",{className:"rdw-embedded-modal-link-input-wrapper"},M.default.createElement("input",{className:"rdw-embedded-modal-link-input",placeholder:a["components.controls.embedded.enterlink"],onChange:this.updateValue,onBlur:this.updateValue,value:t,name:"embeddedLink"}),M.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")),M.default.createElement("div",{className:"rdw-embedded-modal-size"},M.default.createElement("span",null,M.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:n,name:"height",className:"rdw-embedded-modal-size-input",placeholder:"Height"}),M.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")),M.default.createElement("span",null,M.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:o,name:"width",className:"rdw-embedded-modal-size-input",placeholder:"Width"}),M.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")))),M.default.createElement("span",{className:"rdw-embedded-modal-btn-section"},M.default.createElement("button",{type:"button",className:"rdw-embedded-modal-btn",onClick:this.onChange,disabled:!t||!n||!o},a["generic.add"]),M.default.createElement("button",{type:"button",className:"rdw-embedded-modal-btn",onClick:l},a["generic.cancel"])))}},{key:"render",value:function(){var e=this.props,t=e.config,n=t.icon,o=t.className,i=t.title,r=e.expanded,l=e.onExpandEvent,a=e.translations;return M.default.createElement("div",{className:"rdw-embedded-wrapper","aria-haspopup":"true","aria-expanded":r,"aria-label":"rdw-embedded-control"},M.default.createElement(I.default,{className:(0,p.default)(o),value:"unordered-list-item",onClick:l,title:i||a["components.controls.embedded.embedded"]},M.default.createElement("img",{src:n,alt:""})),r?this.rendeEmbeddedLinkModal():void 0)}}]),t}(s.Component);y.propTypes={expanded:g.default.bool,onExpandEvent:g.default.func,onChange:g.default.func,config:g.default.object,translations:g.default.object,doCollapse:g.default.func},t.default=y},function(e,t){e.exports={"rdw-embedded-wrapper":"rdw-embedded-wrapper","rdw-embedded-modal":"rdw-embedded-modal","rdw-embedded-modal-header":"rdw-embedded-modal-header","rdw-embedded-modal-header-option":"rdw-embedded-modal-header-option","rdw-embedded-modal-header-label":"rdw-embedded-modal-header-label","rdw-embedded-modal-link-section":"rdw-embedded-modal-link-section","rdw-embedded-modal-link-input":"rdw-embedded-modal-link-input","rdw-embedded-modal-link-input-wrapper":"rdw-embedded-modal-link-input-wrapper","rdw-embedded-modal-btn-section":"rdw-embedded-modal-btn-section","rdw-embedded-modal-btn":"rdw-embedded-modal-btn","rdw-embedded-modal-size":"rdw-embedded-modal-size","rdw-embedded-modal-size-input":"rdw-embedded-modal-size-input"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(3),d=n(66),p=o(d),N=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1},o.doExpand=function(){o.setState({expanded:!0})},o.doCollapse=function(){o.setState({expanded:!1})},o.addEmoji=function(e){var t=o.props,n=t.editorState,i=t.onChange,r=g.Modifier.replaceText(n.getCurrentContent(),n.getSelection(),e,n.getCurrentInlineStyle());i(g.EditorState.push(n,r,"insert-characters")),o.doCollapse()},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse)}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state.expanded,i=t.component||p.default;return s.default.createElement(i,{config:t,translations:n,onChange:this.addEmoji,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onCollpase:this.closeModal})}}]),t}(c.Component);N.propTypes={editorState:u.default.object.isRequired,onChange:u.default.func.isRequired,modalHandler:u.default.object,config:u.default.object,translations:u.default.object},t.default=N},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(2),d=o(g),p=n(6),N=n(5),D=o(N);n(67);var I=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.onChange=function(e){(0,o.props.onChange)(e.target.innerHTML)},l=n,r(o,l)}return l(t,e),a(t,[{key:"renderEmojiModal",value:function(){var e=this,t=this.props.config,n=t.popupClassName,o=t.emojis;return s.default.createElement("div",{className:(0,d.default)("rdw-emoji-modal",n),onClick:p.stopPropagation},o.map(function(t,n){return s.default.createElement("span",{key:n,className:"rdw-emoji-icon",alt:"",onClick:e.onChange},t)}))}},{key:"render",value:function(){var e=this.props,t=e.config,n=t.icon,o=t.className,i=t.title,r=e.expanded,l=e.onExpandEvent,a=e.translations;return s.default.createElement("div",{className:"rdw-emoji-wrapper","aria-haspopup":"true","aria-label":"rdw-emoji-control","aria-expanded":r,title:i||a["components.controls.emoji.emoji"]},s.default.createElement(D.default,{className:(0,d.default)(o),value:"unordered-list-item",onClick:l},s.default.createElement("img",{src:n,alt:""})),r?this.renderEmojiModal():void 0)}}]),t}(c.Component);I.propTypes={expanded:u.default.bool,onExpandEvent:u.default.func,onChange:u.default.func,config:u.default.object,translations:u.default.object},t.default=I},function(e,t){e.exports={"rdw-emoji-wrapper":"rdw-emoji-wrapper","rdw-emoji-modal":"rdw-emoji-modal","rdw-emoji-icon":"rdw-emoji-icon"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(3),d=n(69),p=o(d),N=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded},o.doExpand=function(){o.setState({expanded:!0})},o.doCollapse=function(){o.setState({expanded:!1})},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1},o.addImage=function(e,t,n,i){var r=o.props,l=r.editorState,a=r.onChange,c=r.config,s={src:e,height:t,width:n};c.alt.present&&(s.alt=i);var M=l.getCurrentContent().createEntity("IMAGE","MUTABLE",s).getLastCreatedEntityKey();a(g.AtomicBlockUtils.insertAtomicBlock(l,M," ")),o.doCollapse()},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse)}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state.expanded,i=t.component||p.default;return s.default.createElement(i,{config:t,translations:n,onChange:this.addImage,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),t}(c.Component);N.propTypes={editorState:u.default.object.isRequired,onChange:u.default.func.isRequired,modalHandler:u.default.object,config:u.default.object,translations:u.default.object},t.default=N},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function l(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var c=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),M=o(s),u=n(1),g=o(u),d=n(2),p=o(d),N=n(5),D=o(N),I=n(70),y=o(I);n(72);var j=function(e){function t(){var e,n,o,a;r(this,t);for(var c=arguments.length,s=Array(c),M=0;M<c;M++)s[M]=arguments[M];return n=o=l(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(s))),o.state={imgSrc:"",dragEnter:!1,uploadHighlighted:o.props.config.uploadEnabled&&!!o.props.config.uploadCallback,showImageLoading:!1,height:o.props.config.defaultSize.height,width:o.props.config.defaultSize.width,alt:""},o.onDragEnter=function(e){o.stopPropagation(e),o.setState({dragEnter:!0})},o.onImageDrop=function(e){e.preventDefault(),e.stopPropagation(),o.setState({dragEnter:!1});var t=void 0,n=void 0;e.dataTransfer.items?(t=e.dataTransfer.items,n=!0):(t=e.dataTransfer.files,n=!1);for(var i=0;i<t.length;i+=1)if((!n||"file"===t[i].kind)&&t[i].type.match("^image/")){var r=n?t[i].getAsFile():t[i];o.uploadImage(r)}},o.showImageUploadOption=function(){o.setState({uploadHighlighted:!0})},o.addImageFromState=function(){var e=o.state,t=e.imgSrc,n=e.alt,i=o.state,r=i.height,l=i.width,a=o.props.onChange;isNaN(r)||(r+="px"),isNaN(l)||(l+="px"),a(t,r,l,n)},o.showImageURLOption=function(){o.setState({uploadHighlighted:!1})},o.toggleShowImageLoading=function(){var e=!o.state.showImageLoading;o.setState({showImageLoading:e})},o.updateValue=function(e){o.setState(i({},""+e.target.name,e.target.value))},o.selectImage=function(e){e.target.files&&e.target.files.length>0&&o.uploadImage(e.target.files[0])},o.uploadImage=function(e){o.toggleShowImageLoading(),(0,o.props.config.uploadCallback)(e).then(function(e){var t=e.data;o.setState({showImageLoading:!1,dragEnter:!1,imgSrc:t.link}),o.fileUpload=!1}).catch(function(){o.setState({showImageLoading:!1,dragEnter:!1})})},o.fileUploadClick=function(e){o.fileUpload=!0,e.stopPropagation()},o.stopPropagation=function(e){o.fileUpload?o.fileUpload=!1:(e.preventDefault(),e.stopPropagation())},a=n,l(o,a)}return a(t,e),c(t,[{key:"componentWillReceiveProps",value:function(e){this.props.expanded&&!e.expanded?this.setState({imgSrc:"",dragEnter:!1,uploadHighlighted:this.props.config.uploadEnabled&&!!this.props.config.uploadCallback,showImageLoading:!1,height:this.props.config.defaultSize.height,width:this.props.config.defaultSize.width,alt:""}):e.config.uploadCallback===this.props.config.uploadCallback&&e.config.uploadEnabled===this.props.config.uploadEnabled||this.setState({uploadHighlighted:e.config.uploadEnabled&&!!e.config.uploadCallback})}},{key:"renderAddImageModal",value:function(){var e=this.state,t=e.imgSrc,n=e.uploadHighlighted,o=e.showImageLoading,i=e.dragEnter,r=e.height,l=e.width,a=e.alt,c=this.props,s=c.config,u=s.popupClassName,g=s.uploadCallback,d=s.uploadEnabled,N=s.urlEnabled,D=s.previewImage,I=s.inputAccept,j=s.alt,f=c.doCollapse,w=c.translations;return M.default.createElement("div",{className:(0,p.default)("rdw-image-modal",u),onClick:this.stopPropagation},M.default.createElement("div",{className:"rdw-image-modal-header"},d&&g&&M.default.createElement("span",{onClick:this.showImageUploadOption,className:"rdw-image-modal-header-option"},w["components.controls.image.fileUpload"],M.default.createElement("span",{className:(0,p.default)("rdw-image-modal-header-label",{"rdw-image-modal-header-label-highlighted":n})})),N&&M.default.createElement("span",{onClick:this.showImageURLOption,className:"rdw-image-modal-header-option"},w["components.controls.image.byURL"],M.default.createElement("span",{className:(0,p.default)("rdw-image-modal-header-label",{"rdw-image-modal-header-label-highlighted":!n})}))),n?M.default.createElement("div",{onClick:this.fileUploadClick},M.default.createElement("div",{onDragEnter:this.onDragEnter,onDragOver:this.stopPropagation,onDrop:this.onImageDrop,className:(0,p.default)("rdw-image-modal-upload-option",{"rdw-image-modal-upload-option-highlighted":i})},M.default.createElement("label",{htmlFor:"file",className:"rdw-image-modal-upload-option-label"},D&&t?M.default.createElement("img",{src:t,alt:t,className:"rdw-image-modal-upload-option-image-preview"}):t||w["components.controls.image.dropFileText"])),M.default.createElement("input",{type:"file",id:"file",accept:I,onChange:this.selectImage,className:"rdw-image-modal-upload-option-input"})):M.default.createElement("div",{className:"rdw-image-modal-url-section"},M.default.createElement("input",{className:"rdw-image-modal-url-input",placeholder:w["components.controls.image.enterlink"],name:"imgSrc",onChange:this.updateValue,onBlur:this.updateValue,value:t}),M.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")),j.present&&M.default.createElement("div",{className:"rdw-image-modal-size"},M.default.createElement("span",{className:"rdw-image-modal-alt-lbl"},"Alt Text"),M.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:a,name:"alt",className:"rdw-image-modal-alt-input",placeholder:"alt"}),M.default.createElement("span",{className:"rdw-image-mandatory-sign"},j.mandatory&&"*")),M.default.createElement("div",{className:"rdw-image-modal-size"},"↕ ",M.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:r,name:"height",className:"rdw-image-modal-size-input",placeholder:"Height"}),M.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")," ↔ ",M.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:l,name:"width",className:"rdw-image-modal-size-input",placeholder:"Width"}),M.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")),M.default.createElement("span",{className:"rdw-image-modal-btn-section"},M.default.createElement("button",{className:"rdw-image-modal-btn",onClick:this.addImageFromState,disabled:!t||!r||!l||j.mandatory&&!a},w["generic.add"]),M.default.createElement("button",{className:"rdw-image-modal-btn",onClick:f},w["generic.cancel"])),o?M.default.createElement("div",{className:"rdw-image-modal-spinner"},M.default.createElement(y.default,null)):void 0)}},{key:"render",value:function(){var e=this.props,t=e.config,n=t.icon,o=t.className,i=t.title,r=e.expanded,l=e.onExpandEvent,a=e.translations;return M.default.createElement("div",{className:"rdw-image-wrapper","aria-haspopup":"true","aria-expanded":r,"aria-label":"rdw-image-control"},M.default.createElement(D.default,{className:(0,p.default)(o),value:"unordered-list-item",onClick:l,title:i||a["components.controls.image.image"]},M.default.createElement("img",{src:n,alt:""})),r?this.renderAddImageModal():void 0)}}]),t}(s.Component);j.propTypes={expanded:g.default.bool,onExpandEvent:g.default.func,doCollapse:g.default.func,onChange:g.default.func,config:g.default.object,translations:g.default.object},t.default=j},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=n(0),i=function(e){return e&&e.__esModule?e:{default:e}}(o);n(71),t.default=function(){return i.default.createElement("div",{className:"rdw-spinner"},i.default.createElement("div",{className:"rdw-bounce1"}),i.default.createElement("div",{className:"rdw-bounce2"}),i.default.createElement("div",{className:"rdw-bounce3"}))}},function(e,t){e.exports={"rdw-spinner":"rdw-spinner","sk-bouncedelay":"sk-bouncedelay","rdw-bounce1":"rdw-bounce1","rdw-bounce2":"rdw-bounce2"}},function(e,t){e.exports={"rdw-image-wrapper":"rdw-image-wrapper","rdw-image-modal":"rdw-image-modal","rdw-image-modal-header":"rdw-image-modal-header","rdw-image-modal-header-option":"rdw-image-modal-header-option","rdw-image-modal-header-label":"rdw-image-modal-header-label","rdw-image-modal-header-label-highlighted":"rdw-image-modal-header-label-highlighted","rdw-image-modal-upload-option":"rdw-image-modal-upload-option","rdw-image-modal-upload-option-highlighted":"rdw-image-modal-upload-option-highlighted","rdw-image-modal-upload-option-label":"rdw-image-modal-upload-option-label","rdw-image-modal-upload-option-image-preview":"rdw-image-modal-upload-option-image-preview","rdw-image-modal-upload-option-input":"rdw-image-modal-upload-option-input","rdw-image-modal-url-section":"rdw-image-modal-url-section","rdw-image-modal-url-input":"rdw-image-modal-url-input","rdw-image-modal-btn-section":"rdw-image-modal-btn-section","rdw-image-modal-btn":"rdw-image-modal-btn","rdw-image-modal-spinner":"rdw-image-modal-spinner","rdw-image-modal-alt-input":"rdw-image-modal-alt-input","rdw-image-modal-alt-lbl":"rdw-image-modal-alt-lbl","rdw-image-modal-size":"rdw-image-modal-size","rdw-image-modal-size-input":"rdw-image-modal-size-input","rdw-image-mandatory-sign":"rdw-image-mandatory-sign"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(3),d=n(4),p=n(6),N=n(74),D=o(N),I=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1},o.removeInlineStyles=function(){var e=o.props,t=e.editorState;(0,e.onChange)(o.removeAllInlineStyles(t))},o.removeAllInlineStyles=function(e){var t=e.getCurrentContent();["BOLD","ITALIC","UNDERLINE","STRIKETHROUGH","MONOSPACE","SUPERSCRIPT","SUBSCRIPT"].forEach(function(n){t=g.Modifier.removeInlineStyle(t,e.getSelection(),n)});var n=(0,d.getSelectionCustomInlineStyle)(e,["FONTSIZE","FONTFAMILY","COLOR","BGCOLOR"]);return(0,p.forEach)(n,function(n,o){o&&(t=g.Modifier.removeInlineStyle(t,e.getSelection(),o))}),g.EditorState.push(e,t,"change-inline-style")},o.doExpand=function(){o.setState({expanded:!0})},o.doCollapse=function(){o.setState({expanded:!1})},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse)}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state.expanded,i=t.component||D.default;return s.default.createElement(i,{config:t,translations:n,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onChange:this.removeInlineStyles})}}]),t}(c.Component);I.propTypes={onChange:u.default.func.isRequired,editorState:u.default.object.isRequired,config:u.default.object,translations:u.default.object,modalHandler:u.default.object},t.default=I},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var i=n(0),r=o(i),l=n(1),a=o(l),c=n(2),s=o(c),M=n(5),u=o(M);n(75);var g=function(e){var t=e.config,n=e.onChange,o=e.translations,i=t.icon,l=t.className,a=t.title;return r.default.createElement("div",{className:"rdw-remove-wrapper","aria-label":"rdw-remove-control"},r.default.createElement(u.default,{className:(0,s.default)(l),onClick:n,title:a||o["components.controls.remove.remove"]},r.default.createElement("img",{src:i,alt:""})))};g.propTypes={onChange:a.default.func,config:a.default.object,translations:a.default.object},t.default=g},function(e,t){e.exports={"rdw-remove-wrapper":"rdw-remove-wrapper"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(3),d=n(77),p=o(d),N=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1,undoDisabled:!1,redoDisabled:!1},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded},o.onChange=function(e){var t=o.props,n=t.editorState,i=t.onChange,r=g.EditorState[e](n);r&&i(r)},o.doExpand=function(){o.setState({expanded:!0})},o.doCollapse=function(){o.setState({expanded:!1})},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1},l=n,r(o,l)}return l(t,e),a(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({undoDisabled:0===t.getUndoStack().size,redoDisabled:0===t.getRedoStack().size}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(e){e.editorState&&this.props.editorState!==e.editorState&&this.setState({undoDisabled:0===e.editorState.getUndoStack().size,redoDisabled:0===e.editorState.getRedoStack().size})}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,i=o.undoDisabled,r=o.redoDisabled,l=o.expanded,a=t.component||p.default;return s.default.createElement(a,{config:t,translations:n,currentState:{undoDisabled:i,redoDisabled:r},expanded:l,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onChange:this.onChange})}}]),t}(c.Component);N.propTypes={onChange:u.default.func.isRequired,editorState:u.default.object,modalHandler:u.default.object,config:u.default.object,translations:u.default.object},t.default=N},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(2),d=o(g),p=n(8),N=n(5),D=o(N),I=n(7);n(78);var y=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.onChange=function(e){(0,o.props.onChange)(e)},l=n,r(o,l)}return l(t,e),a(t,[{key:"renderInDropDown",value:function(){var e=this.props,t=e.config,n=e.expanded,o=e.doExpand,i=e.onExpandEvent,r=e.doCollapse,l=e.currentState,a=l.undoDisabled,c=l.redoDisabled,M=e.translations,u=t.options,g=t.undo,N=t.redo,D=t.className,y=t.dropdownClassName,j=t.title;return s.default.createElement(I.Dropdown,{className:(0,d.default)("rdw-history-dropdown",D),optionWrapperClassName:(0,d.default)(y),expanded:n,doExpand:o,doCollapse:r,onExpandEvent:i,"aria-label":"rdw-history-control",title:j||M["components.controls.history.history"]},s.default.createElement("img",{src:(0,p.getFirstIcon)(t),alt:""}),u.indexOf("undo")>=0&&s.default.createElement(I.DropdownOption,{value:"undo",onClick:this.onChange,disabled:a,className:(0,d.default)("rdw-history-dropdownoption",g.className),title:g.title||M["components.controls.history.undo"]},s.default.createElement("img",{src:g.icon,alt:""})),u.indexOf("redo")>=0&&s.default.createElement(I.DropdownOption,{value:"redo",onClick:this.onChange,disabled:c,className:(0,d.default)("rdw-history-dropdownoption",N.className),title:N.title||M["components.controls.history.redo"]},s.default.createElement("img",{src:N.icon,alt:""})))}},{key:"renderInFlatList",value:function(){var e=this.props,t=e.config,n=t.options,o=t.undo,i=t.redo,r=t.className,l=e.currentState,a=l.undoDisabled,c=l.redoDisabled,M=e.translations;return s.default.createElement("div",{className:(0,d.default)("rdw-history-wrapper",r),"aria-label":"rdw-history-control"},n.indexOf("undo")>=0&&s.default.createElement(D.default,{value:"undo",onClick:this.onChange,className:(0,d.default)(o.className),disabled:a,title:o.title||M["components.controls.history.undo"]},s.default.createElement("img",{src:o.icon,alt:""})),n.indexOf("redo")>=0&&s.default.createElement(D.default,{value:"redo",onClick:this.onChange,className:(0,d.default)(i.className),disabled:c,title:i.title||M["components.controls.history.redo"]},s.default.createElement("img",{src:i.icon,alt:""})))}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),t}(c.Component);y.propTypes={expanded:u.default.bool,doExpand:u.default.func,doCollapse:u.default.func,onExpandEvent:u.default.func,config:u.default.object,onChange:u.default.func,currentState:u.default.object,translations:u.default.object},t.default=y},function(e,t){e.exports={"rdw-history-wrapper":"rdw-history-wrapper","rdw-history-dropdownoption":"rdw-history-dropdownoption","rdw-history-dropdown":"rdw-history-dropdown"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}function a(e,t,n){e.findEntityRanges(function(e){var t=e.getEntity();return null!==t&&"LINK"===n.getEntity(t).getType()},t)}function c(e){var t,n,o=e.showOpenOptionOnHover;return n=t=function(e){function t(){var e,n,o,l;i(this,t);for(var a=arguments.length,c=Array(a),s=0;s<a;s++)c[s]=arguments[s];return n=o=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={showPopOver:!1},o.openLink=function(){var e=o.props,t=e.entityKey,n=e.contentState,i=n.getEntity(t).getData(),r=i.url,l=window.open(r,"blank");l&&l.focus()},o.toggleShowPopOver=function(){var e=!o.state.showPopOver;o.setState({showPopOver:e})},l=n,r(o,l)}return l(t,e),s(t,[{key:"render",value:function(){var e=this.props,t=e.children,n=e.entityKey,i=e.contentState,r=i.getEntity(n).getData(),l=r.url,a=r.targetOption,c=this.state.showPopOver;return u.default.createElement("span",{className:"rdw-link-decorator-wrapper",onMouseEnter:this.toggleShowPopOver,onMouseLeave:this.toggleShowPopOver},u.default.createElement("a",{href:l,target:a},t),c&&o?u.default.createElement("img",{src:N.default,alt:"",onClick:this.openLink,className:"rdw-link-decorator-icon"}):void 0)}}]),t}(M.Component),t.propTypes={entityKey:d.default.string.isRequired,children:d.default.array,contentState:d.default.object},n}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),M=n(0),u=o(M),g=n(1),d=o(g),p=n(80),N=o(p);n(81),t.default=function(e){return{strategy:a,component:c(e)}}},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+b3Blbmxpbms8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0ib3BlbmxpbmsiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICA8ZyBpZD0iQ2FwYV8xIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjA3MTU4NDUsMCBMOC45MTUzMzQ1MSwwIEM4LjQwNTY1MTQxLDAgNy45OTEwMzg3MywwLjQxNDY2NTQ5MyA3Ljk5MTAzODczLDAuOTI0Mjk1Nzc1IEM3Ljk5MTAzODczLDEuNDMzOTI2MDYgOC40MDU2NTE0MSwxLjg0ODU5MTU1IDguOTE1MzM0NTEsMS44NDg1OTE1NSBMMTEuODQwMTc2MSwxLjg0ODU5MTU1IEw2Ljk2MTIxNDc5LDYuNzI3NSBDNi43ODY1NDkzLDYuOTAyMDU5ODYgNi42OTA0MjI1NCw3LjEzNDEzNzMyIDYuNjkwNDIyNTQsNy4zODExMDkxNSBDNi42OTA0MjI1NCw3LjYyODA4MDk5IDYuNzg2NDk2NDgsNy44NjAxMDU2MyA2Ljk2MTEwOTE1LDguMDM0NTA3MDQgQzcuMTM1NzIxODMsOC4yMDkyNzgxNyA3LjM2Nzc0NjQ4LDguMzA1NDU3NzUgNy42MTQ3MTgzMSw4LjMwNTQ1Nzc1IEM3Ljg2MTU4NDUxLDguMzA1NDU3NzUgOC4wOTM3MTQ3OSw4LjIwOTMzMDk5IDguMjY4MzgwMjgsOC4wMzQ2NjU0OSBMMTMuMTQ3Mjg4NywzLjE1NTcwNDIzIEwxMy4xNDcyODg3LDYuMDgwNTQ1NzcgQzEzLjE0NzI4ODcsNi41OTAxNzYwNiAxMy41NjE5NTQyLDcuMDA0ODQxNTUgMTQuMDcxNTg0NSw3LjAwNDg0MTU1IEMxNC41ODEyMTQ4LDcuMDA0ODQxNTUgMTQuOTk1ODgwMyw2LjU5MDE3NjA2IDE0Ljk5NTg4MDMsNi4wODA1NDU3NyBMMTQuOTk1ODgwMywwLjkyNDI5NTc3NSBDMTQuOTk1ODgwMywwLjQxNDY2NTQ5MyAxNC41ODEyMTQ4LDAgMTQuMDcxNTg0NSwwIEwxNC4wNzE1ODQ1LDAgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEwLjYyMzQzMzEsMTMuNDExMzczMiBMMS41ODQ1MDcwNCwxMy40MTEzNzMyIEwxLjU4NDUwNzA0LDQuMzcyNDQ3MTggTDguMzgyNjIzMjQsNC4zNzI0NDcxOCBMOS45NjcxMzAyOCwyLjc4Nzk0MDE0IEwwLjc5MjI1MzUyMSwyLjc4Nzk0MDE0IEMwLjM1NDcxODMxLDIuNzg3OTQwMTQgMCwzLjE0MjY1ODQ1IDAsMy41ODAxOTM2NiBMMCwxNC4yMDM2MjY4IEMwLDE0LjY0MTE2MiAwLjM1NDcxODMxLDE0Ljk5NTg4MDMgMC43OTIyNTM1MjEsMTQuOTk1ODgwMyBMMTEuNDE1Njg2NiwxNC45OTU4ODAzIEMxMS44NTMyMjE4LDE0Ljk5NTg4MDMgMTIuMjA3OTQwMSwxNC42NDExNjIgMTIuMjA3OTQwMSwxNC4yMDM2MjY4IEwxMi4yMDc5NDAxLDUuMDI4NzUgTDEwLjYyMzQzMzEsNi42MTMyNTcwNCBMMTAuNjIzNDMzMSwxMy40MTEzNzMyIEwxMC42MjM0MzMxLDEzLjQxMTM3MzIgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="},function(e,t){e.exports={"rdw-link-decorator-wrapper":"rdw-link-decorator-wrapper","rdw-link-decorator-icon":"rdw-link-decorator-icon"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}var i=n(83),r=o(i),l=n(85),a=o(l),c=function(e){return[new r.default(e.mentionClassName).getMentionDecorator(),new a.default(e).getSuggestionDecorator()]};e.exports=c},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var r=n(0),l=o(r),a=n(1),c=o(a),s=n(2),M=o(s);n(84);var u=function e(t){i(this,e),g.call(this),this.className=t},g=function(){var e=this;this.getMentionComponent=function(){var t=e.className,n=function(e){var n=e.entityKey,o=e.children,i=e.contentState,r=i.getEntity(n).getData(),a=r.url,c=r.value;return l.default.createElement("a",{href:a||c,className:(0,M.default)("rdw-mention-link",t)},o)};return n.propTypes={entityKey:c.default.number,children:c.default.array,contentState:c.default.object},n},this.getMentionDecorator=function(){return{strategy:e.findMentionEntities,component:e.getMentionComponent()}}};u.prototype.findMentionEntities=function(e,t,n){e.findEntityRanges(function(e){var t=e.getEntity();return null!==t&&"MENTION"===n.getEntity(t).getType()},t)},e.exports=u},function(e,t){e.exports={"rdw-mention-link":"rdw-mention-link"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function r(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}function l(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(){var e,t,n=this.config;return t=e=function(e){function t(){var e,o,r,a;l(this,t);for(var c=arguments.length,s=Array(c),M=0;M<c;M++)s[M]=arguments[M];return o=r=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(s))),r.state={style:{left:15},activeOption:-1,showSuggestions:!0},r.onEditorKeyDown=function(e){var t=r.state.activeOption,n={};"ArrowDown"===e.key?(e.preventDefault(),t===r.filteredSuggestions.length-1?n.activeOption=0:n.activeOption=t+1):"ArrowUp"===e.key?n.activeOption=t<=0?r.filteredSuggestions.length-1:t-1:"Escape"===e.key?(n.showSuggestions=!1,f.default.close()):"Enter"===e.key&&r.addMention(),r.setState(n)},r.onOptionMouseEnter=function(e){var t=e.target.getAttribute("data-index");r.setState({activeOption:t})},r.onOptionMouseLeave=function(){r.setState({activeOption:-1})},r.setSuggestionReference=function(e){r.suggestion=e},r.setDropdownReference=function(e){r.dropdown=e},r.closeSuggestionDropdown=function(){r.setState({showSuggestions:!1})},r.filteredSuggestions=[],r.filterSuggestions=function(e){var t=e.children[0].props.text.substr(1),o=n.getSuggestions();r.filteredSuggestions=o&&o.filter(function(e){return!t||0===t.length||(n.caseSensitive?e.value.indexOf(t)>=0:e.value.toLowerCase().indexOf(t&&t.toLowerCase())>=0)})},r.addMention=function(){var e=r.state.activeOption,t=n.getEditorState(),o=n.onChange,i=n.separator,l=n.trigger,a=r.filteredSuggestions[e];a&&(0,D.default)(t,o,i,l,a)},a=o,i(r,a)}return r(t,e),c(t,[{key:"componentDidMount",value:function(){var e=n.getWrapperRef().getBoundingClientRect(),t=this.suggestion.getBoundingClientRect(),o=this.dropdown.getBoundingClientRect(),i=void 0,r=void 0,l=void 0;e.width<t.left-e.left+o.width?r=15:i=15,e.bottom<o.bottom&&(l=0),this.setState({style:{left:i,right:r,bottom:l}}),y.default.registerCallBack(this.onEditorKeyDown),f.default.open(),n.modalHandler.setSuggestionCallback(this.closeSuggestionDropdown),this.filterSuggestions(this.props)}},{key:"componentWillReceiveProps",value:function(e){this.props.children!==e.children&&(this.filterSuggestions(e),this.setState({showSuggestions:!0}))}},{key:"componentWillUnmount",value:function(){y.default.deregisterCallBack(this.onEditorKeyDown),f.default.close(),n.modalHandler.removeSuggestionCallback()}},{key:"render",value:function(){var e=this,t=this.props.children,o=this.state,i=o.activeOption,r=o.showSuggestions,l=n.dropdownClassName,a=n.optionClassName;return M.default.createElement("span",{className:"rdw-suggestion-wrapper",ref:this.setSuggestionReference,onClick:n.modalHandler.onSuggestionClick,"aria-haspopup":"true","aria-label":"rdw-suggestion-popup"},M.default.createElement("span",null,t),r&&M.default.createElement("span",{className:(0,p.default)("rdw-suggestion-dropdown",l),contentEditable:"false",suppressContentEditableWarning:!0,style:this.state.style,ref:this.setDropdownReference},this.filteredSuggestions.map(function(t,n){return M.default.createElement("span",{key:n,spellCheck:!1,onClick:e.addMention,"data-index":n,onMouseEnter:e.onOptionMouseEnter,onMouseLeave:e.onOptionMouseLeave,className:(0,p.default)("rdw-suggestion-option",a,{"rdw-suggestion-option-active":n===i})},t.text)})))}}]),t}(s.Component),e.propTypes={children:g.default.array},t}var c=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),M=o(s),u=n(1),g=o(u),d=n(2),p=o(d),N=n(86),D=o(N),I=n(11),y=o(I),j=n(12),f=o(j);n(87);var w=function e(t){l(this,e),m.call(this);var n=t.separator,o=t.trigger,i=t.getSuggestions,r=t.onChange,a=t.getEditorState,c=t.getWrapperRef,s=t.caseSensitive,M=t.dropdownClassName,u=t.optionClassName,g=t.modalHandler;this.config={separator:n,trigger:o,getSuggestions:i,onChange:r,getEditorState:a,getWrapperRef:c,caseSensitive:s,dropdownClassName:M,optionClassName:u,modalHandler:g}},m=function(){var e=this;this.findSuggestionEntities=function(t,n){if(e.config.getEditorState()){var o=e.config,i=o.separator,r=o.trigger,l=o.getSuggestions,a=o.getEditorState,c=a().getSelection();if(c.get("anchorKey")===t.get("key")&&c.get("anchorKey")===c.get("focusKey")){var s=t.getText();s=s.substr(0,c.get("focusOffset")===s.length-1?s.length:c.get("focusOffset")+1);var M=s.lastIndexOf(i+r),u=i+r;if((void 0===M||M<0)&&s[0]===r&&(M=0,u=r),M>=0){var g=s.substr(M+u.length,s.length);l().some(function(t){return!!t.value&&(e.config.caseSensitive?t.value.indexOf(g)>=0:t.value.toLowerCase().indexOf(g&&g.toLowerCase())>=0)})&&n(0===M?0:M+1,s.length)}}}},this.getSuggestionComponent=a.bind(this),this.getSuggestionDecorator=function(){return{strategy:e.findSuggestionEntities,component:e.getSuggestionComponent()}}};e.exports=w},function(e,t,n){"use strict";function o(e,t,n,o,l){var a=l.value,c=l.url,s=e.getCurrentContent().createEntity("MENTION","IMMUTABLE",{text:""+o+a,value:a,url:c}).getLastCreatedEntityKey(),M=(0,r.getSelectedBlock)(e),u=M.getText(),g=e.getSelection().focusOffset,d=(u.lastIndexOf(n+o,g)||0)+1,p=!1;u.length===d+1&&(g=u.length)," "===u[g]&&(p=!0);var N=e.getSelection().merge({anchorOffset:d,focusOffset:g}),D=i.EditorState.acceptSelection(e,N),I=i.Modifier.replaceText(D.getCurrentContent(),N,""+o+a,D.getCurrentInlineStyle(),s);D=i.EditorState.push(D,I,"insert-characters"),p||(N=D.getSelection().merge({anchorOffset:d+a.length+o.length,focusOffset:d+a.length+o.length}),D=i.EditorState.acceptSelection(D,N),I=i.Modifier.insertText(D.getCurrentContent(),N," ",D.getCurrentInlineStyle(),void 0)),t(i.EditorState.push(D,I,"insert-characters"))}Object.defineProperty(t,"__esModule",{value:!0}),t.default=o;var i=n(3),r=n(4)},function(e,t){e.exports={"rdw-suggestion-wrapper":"rdw-suggestion-wrapper","rdw-suggestion-dropdown":"rdw-suggestion-dropdown","rdw-suggestion-option":"rdw-suggestion-option","rdw-suggestion-option-active":"rdw-suggestion-option-active"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var r=n(0),l=o(r),a=n(1),c=o(a),s=n(2),M=o(s);n(89);var u=function e(t){var n=this;i(this,e),this.getHashtagComponent=function(){var e=n.className,t=function(t){var n=t.children,o=n[0].props.text;return l.default.createElement("a",{href:o,className:(0,M.default)("rdw-hashtag-link",e)},n)};return t.propTypes={children:c.default.object},t},this.findHashtagEntities=function(e,t){for(var o=e.getText(),i=0,r=0;o.length>0&&i>=0;)if(o[0]===n.hashCharacter?(i=0,r=0,o=o.substr(n.hashCharacter.length)):(i=o.indexOf(n.separator+n.hashCharacter))>=0&&(o=o.substr(i+(n.separator+n.hashCharacter).length),r+=i+n.separator.length),i>=0){var l=o.indexOf(n.separator)>=0?o.indexOf(n.separator):o.length,a=o.substr(0,l);a&&a.length>0&&(t(r,r+a.length+n.hashCharacter.length),r+=n.hashCharacter.length)}},this.getHashtagDecorator=function(){return{strategy:n.findHashtagEntities,component:n.getHashtagComponent()}},this.className=t.className,this.hashCharacter=t.hashCharacter||"#",this.separator=t.separator||" "},g=function(e){return new u(e).getHashtagDecorator()};e.exports=g},function(e,t){e.exports={"rdw-hashtag-link":"rdw-hashtag-link"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var i=n(91),r=o(i),l=n(92),a=o(l),c=function(e,t){return function(n){if("function"==typeof t){var o=t(n,e,e.getEditorState);if(o)return o}if("atomic"===n.getType()){var i=e.getEditorState().getCurrentContent(),l=i.getEntity(n.getEntityAt(0));if(l&&"IMAGE"===l.type)return{component:(0,a.default)(e),editable:!1};if(l&&"EMBEDDED_LINK"===l.type)return{component:r.default,editable:!1}}}};t.default=c},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var i=n(0),r=o(i),l=n(1),a=o(l),c=function(e){var t=e.block,n=e.contentState,o=n.getEntity(t.getEntityAt(0)),i=o.getData(),l=i.src,a=i.height,c=i.width;return r.default.createElement("iframe",{height:a,width:c,src:l,frameBorder:"0",allowFullScreen:!0,title:"Wysiwyg Embedded Content"})};c.propTypes={block:a.default.object,contentState:a.default.object},t.default=c},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),M=n(1),u=o(M),g=n(3),d=n(2),p=o(d),N=n(5),D=o(N);n(93);var I=function(e){var t,n;return n=t=function(t){function n(){var t,o,l,a;i(this,n);for(var c=arguments.length,s=Array(c),M=0;M<c;M++)s[M]=arguments[M];return o=l=r(this,(t=n.__proto__||Object.getPrototypeOf(n)).call.apply(t,[this].concat(s))),l.state={hovered:!1},l.setEntityAlignmentLeft=function(){l.setEntityAlignment("left")},l.setEntityAlignmentRight=function(){l.setEntityAlignment("right")},l.setEntityAlignmentCenter=function(){l.setEntityAlignment("none")},l.setEntityAlignment=function(t){var n=l.props,o=n.block,i=n.contentState,r=o.getEntityAt(0);i.mergeEntityData(r,{alignment:t}),e.onChange(g.EditorState.push(e.getEditorState(),i,"change-block-data")),l.setState({dummy:!0})},l.toggleHovered=function(){var e=!l.state.hovered;l.setState({hovered:e})},a=o,r(l,a)}return l(n,t),a(n,[{key:"renderAlignmentOptions",value:function(e){return s.default.createElement("div",{className:(0,p.default)("rdw-image-alignment-options-popup",{"rdw-image-alignment-options-popup-right":"right"===e})},s.default.createElement(D.default,{onClick:this.setEntityAlignmentLeft,className:"rdw-image-alignment-option"},"L"),s.default.createElement(D.default,{onClick:this.setEntityAlignmentCenter,className:"rdw-image-alignment-option"},"C"),s.default.createElement(D.default,{onClick:this.setEntityAlignmentRight,className:"rdw-image-alignment-option"},"R"))}},{key:"render",value:function(){var t=this.props,n=t.block,o=t.contentState,i=this.state.hovered,r=e.isReadOnly,l=e.isImageAlignmentEnabled,a=o.getEntity(n.getEntityAt(0)),c=a.getData(),M=c.src,u=c.alignment,g=c.height,d=c.width,N=c.alt;return s.default.createElement("span",{onMouseEnter:this.toggleHovered,onMouseLeave:this.toggleHovered,className:(0,p.default)("rdw-image-alignment",{"rdw-image-left":"left"===u,"rdw-image-right":"right"===u,"rdw-image-center":!u||"none"===u})},s.default.createElement("span",{className:"rdw-image-imagewrapper"},s.default.createElement("img",{src:M,alt:N,style:{height:g,width:d}}),!r()&&i&&l()?this.renderAlignmentOptions(u):void 0))}}]),n}(c.Component),t.propTypes={block:u.default.object,contentState:u.default.object},n};t.default=I},function(e,t){e.exports={"rdw-image-alignment-options-popup":"rdw-image-alignment-options-popup","rdw-alignment-option-left":"rdw-alignment-option-left","rdw-image-alignment-option":"rdw-image-alignment-option","rdw-image-alignment":"rdw-image-alignment","rdw-image-imagewrapper":"rdw-image-imagewrapper","rdw-image-center":"rdw-image-center","rdw-image-left":"rdw-image-left","rdw-image-right":"rdw-image-right","rdw-image-alignment-options-popup-right":"rdw-image-alignment-options-popup-right"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var i=n(95),r=o(i),l=n(96),a=o(l),c=n(97),s=o(c),M=n(98),u=o(M),g=n(99),d=o(g),p=n(100),N=o(p),D=n(101),I=o(D),y=n(102),j=o(y),f=n(103),w=o(f),m=n(104),C=o(m),z=n(105),A=o(z),T=n(106),E=o(T),L=n(107),x=o(L),O=n(108),k=o(O),h=n(109),b=o(h),S=n(110),v=o(S),U=n(111),Q=o(U),Y=n(112),_=o(Y),P=n(113),B=o(P),Z=n(114),G=o(Z),F=n(115),R=o(F),W=n(116),H=o(W),J=n(117),V=o(J),K=n(118),X=o(K),q=n(119),$=o(q);t.default={options:["inline","blockType","fontSize","fontFamily","list","textAlign","colorPicker","link","embedded","emoji","image","remove","history"],inline:{inDropdown:!1,className:void 0,component:void 0,dropdownClassName:void 0,options:["bold","italic","underline","strikethrough","monospace","superscript","subscript"],bold:{icon:r.default,className:void 0,title:void 0},italic:{icon:a.default,className:void 0,title:void 0},underline:{icon:s.default,className:void 0,title:void 0},strikethrough:{icon:u.default,className:void 0,title:void 0},monospace:{icon:d.default,className:void 0,title:void 0},superscript:{icon:$.default,className:void 0,title:void 0},subscript:{icon:X.default,className:void 0,title:void 0}},blockType:{inDropdown:!0,options:["Normal","H1","H2","H3","H4","H5","H6","Blockquote","Code"],className:void 0,component:void 0,dropdownClassName:void 0,title:void 0},fontSize:{icon:N.default,options:[8,9,10,11,12,14,16,18,24,30,36,48,60,72,96],className:void 0,component:void 0,dropdownClassName:void 0,title:void 0},fontFamily:{options:["Arial","Georgia","Impact","Tahoma","Times New Roman","Verdana"],className:void 0,component:void 0,dropdownClassName:void 0,title:void 0},list:{inDropdown:!1,className:void 0,component:void 0,dropdownClassName:void 0,options:["unordered","ordered","indent","outdent"],unordered:{icon:C.default,className:void 0,title:void 0},ordered:{icon:w.default,className:void 0,title:void 0},indent:{icon:I.default,className:void 0,title:void 0},outdent:{icon:j.default,className:void 0,title:void 0},title:void 0},textAlign:{inDropdown:!1,className:void 0,component:void 0,dropdownClassName:void 0,options:["left","center","right","justify"],left:{icon:A.default,className:void 0,title:void 0},center:{icon:E.default,className:void 0,title:void 0},right:{icon:x.default,className:void 0,title:void 0},justify:{icon:k.default,className:void 0,title:void 0},title:void 0},colorPicker:{icon:b.default,className:void 0,component:void 0,popupClassName:void 0,colors:["rgb(97,189,109)","rgb(26,188,156)","rgb(84,172,210)","rgb(44,130,201)","rgb(147,101,184)","rgb(71,85,119)","rgb(204,204,204)","rgb(65,168,95)","rgb(0,168,133)","rgb(61,142,185)","rgb(41,105,176)","rgb(85,57,130)","rgb(40,50,78)","rgb(0,0,0)","rgb(247,218,100)","rgb(251,160,38)","rgb(235,107,86)","rgb(226,80,65)","rgb(163,143,132)","rgb(239,239,239)","rgb(255,255,255)","rgb(250,197,28)","rgb(243,121,52)","rgb(209,72,65)","rgb(184,49,47)","rgb(124,112,107)","rgb(209,213,216)"],title:void 0},link:{inDropdown:!1,className:void 0,component:void 0,popupClassName:void 0,dropdownClassName:void 0,showOpenOptionOnHover:!0,defaultTargetOption:"_self",options:["link","unlink"],link:{icon:Q.default,className:void 0,title:void 0},unlink:{icon:_.default,className:void 0,title:void 0}},emoji:{icon:B.default,className:void 0,component:void 0,popupClassName:void 0,emojis:["😀","😁","😂","😃","😉","😋","😎","😍","😗","🤗","🤔","😣","😫","😴","😌","🤓","😛","😜","😠","😇","😷","😈","👻","😺","😸","😹","😻","😼","😽","🙀","🙈","🙉","🙊","👼","👮","🕵","💂","👳","🎅","👸","👰","👲","🙍","🙇","🚶","🏃","💃","⛷","🏂","🏌","🏄","🚣","🏊","⛹","🏋","🚴","👫","💪","👈","👉","👉","👆","🖕","👇","🖖","🤘","🖐","👌","👍","👎","✊","👊","👏","🙌","🙏","🐵","🐶","🐇","🐥","🐸","🐌","🐛","🐜","🐝","🍉","🍄","🍔","🍤","🍨","🍪","🎂","🍰","🍾","🍷","🍸","🍺","🌍","🚑","⏰","🌙","🌝","🌞","⭐","🌟","🌠","🌨","🌩","⛄","🔥","🎄","🎈","🎉","🎊","🎁","🎗","🏀","🏈","🎲","🔇","🔈","📣","🔔","🎵","🎷","💰","🖊","📅","✅","❎","💯"],title:void 0},embedded:{icon:G.default,className:void 0,component:void 0,popupClassName:void 0,defaultSize:{height:"auto",width:"auto"},title:void 0},image:{icon:R.default,className:void 0,component:void 0,popupClassName:void 0,urlEnabled:!0,uploadEnabled:!0,previewImage:!1,alignmentEnabled:!0,uploadCallback:void 0,inputAccept:"image/gif,image/jpeg,image/jpg,image/png,image/svg",alt:{present:!1,mandatory:!1},defaultSize:{height:"auto",width:"auto"},title:void 0},remove:{icon:v.default,className:void 0,component:void 0,title:void 0},history:{inDropdown:!1,className:void 0,component:void 0,dropdownClassName:void 0,options:["undo","redo"],undo:{icon:H.default,className:void 0,title:void 0},redo:{icon:V.default,className:void 0,title:void 0},title:void 0}}},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjEycHgiIGhlaWdodD0iMTNweCIgdmlld0JveD0iMCAwIDEyIDEzIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Ym9sZDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJib2xkIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IlBhZ2UtMSI+CiAgICAgICAgICAgICAgICA8Zz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iYm9sZCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxnIGlkPSJDYWxxdWVfMSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNi4yMzY0LDAgQzcuODg3NiwwIDkuMTc2NCwwLjI5NzkxNjY2NyAxMC4xMDE2LDAuODkyNjY2NjY3IEMxMS4wMjY4LDEuNDg4NSAxMS40OSwyLjM3NzkxNjY3IDExLjQ5LDMuNTYyIEMxMS40OSw0LjE2MzI1IDExLjMxNzIsNC43MDA1ODMzMyAxMC45NzQsNS4xNzI5MTY2NyBDMTAuNjMwOCw1LjY0NjMzMzMzIDEwLjEzMDQsNi4wMDI3NSA5LjQ3NTIsNi4yNCBDMTAuMzE3Niw2LjQwNjgzMzMzIDEwLjk0ODgsNi43NjMyNSAxMS4zNyw3LjMxMTQxNjY3IEMxMS43ODg4LDcuODYwNjY2NjcgMTIsOC40OTQ0MTY2NyAxMiw5LjIxMzc1IEMxMiwxMC40NTg1IDExLjU1NiwxMS40MDEgMTAuNjcwNCwxMi4wMzkwODMzIEM5Ljc4MzYsMTIuNjgwNDE2NyA4LjUyNiwxMyA2LjkwMTIsMTMgTDAsMTMgTDAsMTAuODMzMzMzMyBMMS40OTQsMTAuODMzMzMzMyBMMS40OTQsMi4xNjY2NjY2NyBMMCwyLjE2NjY2NjY3IEwwLDAgTDEuNDk0LDAgTDYuMjM2NCwwIEw2LjIzNjQsMCBMNi4yMzY0LDAgWiBNNC4zMDgsNS40NDU5MTY2NyBMNi4zMzI0LDUuNDQ1OTE2NjcgQzcuMDgzNiw1LjQ0NTkxNjY3IDcuNjYyLDUuMzAyOTE2NjcgOC4wNjY0LDUuMDE2OTE2NjcgQzguNDcwOCw0LjczMDkxNjY3IDguNjczNiw0LjMxNDkxNjY3IDguNjczNiwzLjc2Njc1IEM4LjY3MzYsMy4xNjU1IDguNDY5NiwyLjcyMjQxNjY3IDguMDYxNiwyLjQzNjQxNjY3IEM3LjY1MzYsMi4xNTA0MTY2NyA3LjA0NjQsMi4wMDg1IDYuMjM2NCwyLjAwODUgTDQuMzA4LDIuMDA4NSBMNC4zMDgsNS40NDU5MTY2NyBMNC4zMDgsNS40NDU5MTY2NyBMNC4zMDgsNS40NDU5MTY2NyBaIE00LjMwOCw3LjI0OTY2NjY3IEw0LjMwOCwxMC45OTkwODMzIEw2LjkwMTIsMTAuOTk5MDgzMyBDNy42NDc2LDEwLjk5OTA4MzMgOC4yMTUyLDEwLjg0ODUgOC42MDc2LDEwLjU0ODQxNjcgQzguOTk4OCwxMC4yNDgzMzMzIDkuMTk1Niw5LjgwMzA4MzMzIDkuMTk1Niw5LjIxMzc1IEM5LjE5NTYsOC41Nzc4MzMzMyA5LjAyNzYsOC4wOTAzMzMzMyA4LjY5NTIsNy43NTQ1IEM4LjM2MDQsNy40MTg2NjY2NyA3LjgzMjQsNy4yNDk2NjY2NyA3LjExMzYsNy4yNDk2NjY2NyBMNC4zMDgsNy4yNDk2NjY2NyBMNC4zMDgsNy4yNDk2NjY2NyBMNC4zMDgsNy4yNDk2NjY2NyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE1LjAuMiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhbHF1ZV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iMTZweCIgaGVpZ2h0PSIxNnB4IiB2aWV3Qm94PSIwIDAgMTYgMTYiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDE2IDE2IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8cGF0aCBkPSJNNywzVjJoNHYxSDkuNzUzbC0zLDEwSDh2MUg0di0xaDEuMjQ3bDMtMTBIN3oiLz4KPC9nPgo8L3N2Zz4K"},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE1LjAuMiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhbHF1ZV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iMTZweCIgaGVpZ2h0PSIxNnB4IiB2aWV3Qm94PSIwIDAgMTYgMTYiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDE2IDE2IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8cGF0aCBkPSJNNi4wNDUsMnYwLjk5Mkw0Ljc4NSwzdjUuMTcyYzAsMC44NTksMC4yNDMsMS41MTIsMC43MjcsMS45NTdzMS4xMjQsMC42NjgsMS45MTgsMC42NjhjMC44MzYsMCwxLjUwOS0wLjIyMSwyLjAxOS0wLjY2NAoJCWMwLjUxMS0wLjQ0MiwwLjc2Ni0xLjA5NiwwLjc2Ni0xLjk2MVYzbC0xLjI2LTAuMDA4VjJoMi43ODRIMTN2MC45OTJMMTEuNzM5LDN2NS4xNzJjMCwxLjIzNC0wLjM5OCwyLjE4MS0xLjE5NSwyLjg0CgkJQzkuNzQ3LDExLjY3MSw4LjcwOSwxMiw3LjQzLDEyYy0xLjI0MiwwLTIuMjQ4LTAuMzI5LTMuMDE3LTAuOTg4Yy0wLjc2OS0wLjY1OS0xLjE1Mi0xLjYwNS0xLjE1Mi0yLjg0VjNMMiwyLjk5MlYyaDEuMjYxSDYuMDQ1eiIKCQkvPgo8L2c+CjxyZWN0IHg9IjIiIHk9IjEzIiB3aWR0aD0iMTEiIGhlaWdodD0iMSIvPgo8L3N2Zz4K"},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTNweCIgdmlld0JveD0iMCAwIDE1IDEzIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+c3RyaWtldGhyb3VnaDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJzdHJpa2V0aHJvdWdoIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IlBhZ2UtMSI+CiAgICAgICAgICAgICAgICA8Zz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0ic3RyaWtldGhyb3VnaCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxnIGlkPSJDYXBhXzEiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNC4wNDAwNjgzNiw1Ljk1NDM4NDA5IEwxMC4yNTQ2Mzg2LDUuOTU0Mzg0MDkgQzEwLjA0ODMzMDEsNS44MTk1NjgxOCA5Ljc4MzQyNzc2LDUuNjczMjU5MDkgOS40NTk5OTAyNiw1LjUxNTc4MTgyIEM4Ljg4MDMyMjI0LDUuMjU3MTQwOTEgOC4zOTc2NTYyNSw1LjA3MTUwNjgyIDguMDEyODQxNzksNC45NTkwODYzNyBDNi44MjUyMzQzNyw0LjYxMDUwOTA5IDYuMDQ3MzQzNzUsNC4yNDc2OTA5MSA1LjY3OTI4NzExLDMuODcwOTU2ODIgQzUuMzExMjMwNDcsMy40OTQxNjM2MyA1LjEyNzI0NjEsMy4xMDA1NTkwOSA1LjEyNzI0NjEsMi42ODk5OTU0NSBDNS4xMjcyNDYxLDIuMTk1MDIwNDUgNS4zMTQxMzA4NiwxLjc4NDQ1NjgyIDUuNjg3Njk1MzEsMS40NTgzMzQwOSBDNi4wNjY4ODQ3NiwxLjEyNjYyNzI3IDYuNTc0MzM1OTQsMC45NjA2MTEzNjggNy4yMTAwMTk1MywwLjk2MDYxMTM2OCBDNy44OTAzMjIyNiwwLjk2MDYxMTM2OCA4LjQ3NTgyMDMxLDEuMjE2NDc1IDguOTY2NjAxNTMsMS43MjgyMzE4MiBDOS4yNjIwNjA1OSwyLjA0MzA2ODE4IDkuNTQ5NDA0MjksMi42MTk1IDkuODI4MTA1NDQsMy40NTc0OTc3MyBMOS45NDU0MTAxMiwzLjQ3NDI3OTU1IEwxMC42NDgwMDc4LDMuNTI0ODYxMzcgTDEwLjc0ODQ5NjEsMy40OTk2Mjk1NSBDMTAuNzc2MzU3NCwzLjM0NzcwNjgyIDEwLjc5MDM5MDYsMy4yMjEzNDA5MSAxMC43OTAzOTA2LDMuMTE5OTcwNDUgQzEwLjc5MDM5MDYsMi43ODI1MzE4MiAxMC43NTEzMDg2LDIuMjY4MDg2MzcgMTAuNjczMDg2LDEuNTc2MzM4NjMgQzEwLjYxMTUzMzIsMS4xMjY1OTc3MyAxMC41NTMxNzM5LDAuNzk0NjU0NTQ1IDEwLjQ5NzQ1MTEsMC41ODA5MjI3MjcgQzkuODc4NjQyNTYsMC4zNzg1NjU5MDkgOS4zODQ5NjA5NywwLjI0MzU0MzE4MiA5LjAxNjkzMzU5LDAuMTc2MTIwNDU1IEM4LjM2NDU1MDc4LDAuMDY5MjU0NTQ1NSA3Ljg5ODc1OTc2LDAuMDE1ODA2ODE4MiA3LjYyMDIzNDM4LDAuMDE1ODA2ODE4MiBDNi4xNzAyNDQxNCwwLjAxNTgwNjgxODIgNS4wNzQ1OTk2MSwwLjM3MzA0MDkwOSA0LjMzMjg2MTMzLDEuMDg3MTI1IEMzLjU4NTY0NDUzLDEuODA2OTExMzcgMy4yMTIwODAwOCwyLjY3NTkwMjI3IDMuMjEyMDgwMDgsMy42OTM3NzI3MyBDMy4yMTIwODAwOCw0LjIwNTQ0MDkxIDMuMzQ1OTA4MjEsNC43MzQwMDkwOSAzLjYxMzYyMzA0LDUuMjc5NTM2MzcgQzMuNzQxNzA4OTksNS41MzI2ODE4MiAzLjg4MzkxNjAxLDUuNzU3NjQwOTEgNC4wNDAwNjgzNiw1Ljk1NDM4NDA5IEw0LjA0MDA2ODM2LDUuOTU0Mzg0MDkgTDQuMDQwMDY4MzYsNS45NTQzODQwOSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOC4yODA3NjE3Miw4LjExMzg5MDkxIEM4Ljg1NTEyNjkxLDguMzUwMDc3MjcgOS4yMzcyMTY3OSw4LjU0OTg2MzYzIDkuNDI2NzA4OTcsOC43MTI3NzcyNyBDOS44Nzg0NjY3OSw5LjEyMzM3MDQ1IDEwLjEwNDI1NzgsOS41NjQ4MDkwNiAxMC4xMDQyNTc4LDEwLjAzNzA5MzIgQzEwLjEwNDI1NzgsMTAuNDE5NTg4NyA5Ljk3MzA5NTcxLDEwLjc4MjI4ODcgOS43MTEwMzUxMiwxMS4xMjUzNDA5IEM5LjQ2MDE5NTMyLDExLjQ2MjYzMTggOS4xMjAxMTcxOCwxMS43MDQ3ODYzIDguNjkwNjI1LDExLjg1MDcxMTMgQzguMjcyNjE3MTksMTIuMDAyODcwNSA3Ljg4NDkzMTY0LDEyLjA3ODU5NTUgNy41MjgyMTI4OSwxMi4wNzg1OTU1IEM3LjEyMTE5MTQsMTIuMDc4NTk1NSA2Ljc1MzE2NDA2LDEyLjAxNjYwOTEgNi40MjQxNjAxNSwxMS44OTI5NjEzIEM2LjA3ODQ1NzAzLDExLjc3NDc3OTUgNS43ODU2NjQwNiwxMS42MTQ3MDIzIDUuNTQ1ODM5ODUsMTEuNDEyMTA5MSBDNS4yOTQ5NDE0LDExLjIwNDAyMDUgNS4wNzE4MTY0LDEwLjkzOTczNjMgNC44NzY2Njk5MiwxMC42MTkxMDkxIEM0Ljg0ODc1LDEwLjU3NDI4ODcgNC44MTM4NTc0MiwxMC40OTgyNjgyIDQuNzcyMDUwNzgsMTAuMzkxNTIwNSBDNC43MzAzMDI3NCwxMC4yODQ1MzYzIDQuNjY3NDMxNjQsMTAuMTI3MjA2OCA0LjU4Mzg3Njk2LDkuOTE5MjM2MzIgQzQuNTAwMjA1MDgsOS43MTEwNTkwNiA0LjQxNjY1MDM5LDkuNTExNDUgNC4zMzI5Nzg1MSw5LjMyMDI5MDk0IEwzLjQ3OTgyNDIyLDkuMzM3MTYxMzIgTDMuNDc5ODI0MjIsOS43MDgzMTEzMiBMMy40NjMwOTU3MSwxMC4wMjA2MzYzIEMzLjQ1NzU4Nzg5LDEwLjIzNDE5MDkgMy40NTc1ODc4OSwxMC40MjUzNzk1IDMuNDYzMDk1NzEsMTAuNTk0MTEzNyBDMy40NzQxNjk5MiwxMC44NjM5ODE4IDMuNDc5ODI0MjIsMTEuMzAyNjcyNyAzLjQ3OTgyNDIyLDExLjkxMDE1NjggTDMuNDc5ODI0MjIsMTIuMDE5ODU5MSBDMy40Nzk4MjQyMiwxMi4wOTg2MjczIDMuNTAyMDg5ODUsMTIuMTYwMzE4MiAzLjU0NjY1MDM5LDEyLjIwNTQ5MzIgQzMuNjMwMjkyOTcsMTIuMjcyNzA5MSAzLjgzMTAzNTE1LDEyLjM1MTU5NTUgNC4xNDg5MDYyNSwxMi40NDE1OTA5IEw1LjMxOTg3MzA0LDEyLjc3ODk3MDUgQzUuNzcxNDg0MzcsMTIuOTA4NDA5MSA2LjMxNTIzNDM3LDEyLjk3MzExMzcgNi45NTA5MTc5NywxMi45NzMxMTM3IEM3LjYzNjg3NSwxMi45NzMxMTM3IDguMjAyNTY4MzYsMTIuOTE0MDUyMyA4LjY0ODkwNjI1LDEyLjc5NTg3MDUgQzkuMDU2MDQ0OTQsMTIuNjk0NDQwOSA5LjQ4MjIyNjUzLDEyLjUwODg5NTUgOS45Mjg3MTA5NywxMi4yMzkxNDU1IEMxMC4zMzAxMzY3LDExLjk4MDI5NzcgMTAuNjM0MTIxMSwxMS43NTI3MDkxIDEwLjg0MDQ1OSwxMS41NTU2NDA5IEMxMS4xMDc4NTE1LDExLjI4MDIxODIgMTEuMzA2MDc0MiwxMC45ODc4MDY4IDExLjQzNDMwNjcsMTAuNjc4MzE4MiBDMTEuNjYzMTE1MywxMC4xMTAzOTU1IDExLjc3NzI4NTEsOS41MTQyNTY3OSAxMS43NzcyODUxLDguODkwMTk3NzMgQzExLjc3NzI4NTEsOC41OTIwMjUgMTEuNzU3OTQ5Miw4LjMzMzQ3MjczIDExLjcxOTA0MjksOC4xMTQwNjgxOCBMOC4yODA3NjE3Miw4LjExNDA2ODE4IEw4LjI4MDc2MTcyLDguMTEzODkwOTEgTDguMjgwNzYxNzIsOC4xMTM4OTA5MSBMOC4yODA3NjE3Miw4LjExMzg5MDkxIFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC45MTM4NjcyLDYuNTcwMTQwOTEgQzE0Ljg2MzUzNTEsNi41MTk1ODg2MyAxNC43OTk1ODAxLDYuNDk0MzI3MjcgMTQuNzIxMzg2Nyw2LjQ5NDMyNzI3IEwwLjI2NzYyNjk1Myw2LjQ5NDMyNzI3IEMwLjE4OTUyMTQ4NSw2LjQ5NDMyNzI3IDAuMTI1NDQ5MjE5LDYuNTE5NTg4NjMgMC4wNzUyMzQzNzUsNi41NzAxNDA5MSBDMC4wMjUxNjYwMTU2LDYuNjIwNjkzMTggMCw2LjY4NTM5NzczIDAsNi43NjQyODQwOSBMMCw3LjMwMzk5MDkxIEMwLDcuMzgyODc3MjcgMC4wMjUwNDg4MjgxLDcuNDQ3NDYzNjMgMC4wNzUyMzQzNzUsNy40OTgxMzQwOSBDMC4xMjU0NDkyMTksNy41NDg2ODYzNyAwLjE4OTYzODY3Miw3LjU3Mzc3MDQ1IDAuMjY3NjI2OTUzLDcuNTczNzcwNDUgTDE0LjcyMTM4NjcsNy41NzM3NzA0NSBDMTQuNzk5NTgwMSw3LjU3Mzc3MDQ1IDE0Ljg2MzU2NDQsNy41NDg2ODYzNyAxNC45MTM4NjcyLDcuNDk4MTM0MDkgQzE0Ljk2Mzk5NDIsNy40NDc0NjM2MyAxNC45ODkwNDI5LDcuMzgyODc3MjcgMTQuOTg5MDQyOSw3LjMwMzk5MDkxIEwxNC45ODkwNDI5LDYuNzY0Mjg0MDkgQzE0Ljk4OTA0MjksNi42ODUzOTc3MyAxNC45NjM5OTQyLDYuNjIwNjkzMTggMTQuOTEzODY3Miw2LjU3MDE0MDkxIEwxNC45MTM4NjcyLDYuNTcwMTQwOTEgTDE0LjkxMzg2NzIsNi41NzAxNDA5MSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjEzcHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDEzIDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Y29kZTwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJjb2RlIiBmaWxsPSIjNDQ0NDQ0Ij4KICAgICAgICAgICAgPGcgaWQ9IlBhZ2UtMSI+CiAgICAgICAgICAgICAgICA8Zz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iY29kZSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMS4wMjE0Mjg1NywyLjkwNjI1IEMxLjIwNzE0Mjg2LDQuMTI1IDEuMzkyODU3MTQsNC40MDYyNSAxLjM5Mjg1NzE0LDUuNjI1IEMxLjM5Mjg1NzE0LDYuMzc1IDAsNy4wMzEyNSAwLDcuMDMxMjUgTDAsNy45Njg3NSBDMCw3Ljk2ODc1IDEuMzkyODU3MTQsOC42MjUgMS4zOTI4NTcxNCw5LjM3NSBDMS4zOTI4NTcxNCwxMC41OTM3NSAxLjIwNzE0Mjg2LDEwLjg3NSAxLjAyMTQyODU3LDEyLjA5Mzc1IEMwLjc0Mjg1NzE0MywxNC4wNjI1IDEuNzY0Mjg1NzEsMTUgMi42OTI4NTcxNCwxNSBMNC42NDI4NTcxNCwxNSBMNC42NDI4NTcxNCwxMy4xMjUgQzQuNjQyODU3MTQsMTMuMTI1IDIuOTcxNDI4NTcsMTMuMzEyNSAyLjk3MTQyODU3LDEyLjE4NzUgQzIuOTcxNDI4NTcsMTEuMzQzNzUgMy4xNTcxNDI4NiwxMS4zNDM3NSAzLjM0Mjg1NzE0LDkuNDY4NzUgQzMuNDM1NzE0MjksOC42MjUgMi44Nzg1NzE0Myw3Ljk2ODc1IDIuMzIxNDI4NTcsNy41IEMyLjg3ODU3MTQzLDcuMDMxMjUgMy40MzU3MTQyOSw2LjQ2ODc1IDMuMzQyODU3MTQsNS42MjUgQzMuMDY0Mjg1NzEsMy43NSAyLjk3MTQyODU3LDMuNzUgMi45NzE0Mjg1NywyLjkwNjI1IEMyLjk3MTQyODU3LDEuNzgxMjUgNC42NDI4NTcxNCwxLjg3NSA0LjY0Mjg1NzE0LDEuODc1IEw0LjY0Mjg1NzE0LDAgTDIuNjkyODU3MTQsMCBDMS42NzE0Mjg1NywwIDAuNzQyODU3MTQzLDAuOTM3NSAxLjAyMTQyODU3LDIuOTA2MjUgTDEuMDIxNDI4NTcsMi45MDYyNSBMMS4wMjE0Mjg1NywyLjkwNjI1IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExLjk3ODU3MTQsMi45MDYyNSBDMTEuNzkyODU3MSw0LjEyNSAxMS42MDcxNDI5LDQuNDA2MjUgMTEuNjA3MTQyOSw1LjYyNSBDMTEuNjA3MTQyOSw2LjM3NSAxMyw3LjAzMTI1IDEzLDcuMDMxMjUgTDEzLDcuOTY4NzUgQzEzLDcuOTY4NzUgMTEuNjA3MTQyOSw4LjYyNSAxMS42MDcxNDI5LDkuMzc1IEMxMS42MDcxNDI5LDEwLjU5Mzc1IDExLjc5Mjg1NzEsMTAuODc1IDExLjk3ODU3MTQsMTIuMDkzNzUgQzEyLjI1NzE0MjksMTQuMDYyNSAxMS4yMzU3MTQzLDE1IDEwLjMwNzE0MjksMTUgTDguMzU3MTQyODYsMTUgTDguMzU3MTQyODYsMTMuMTI1IEM4LjM1NzE0Mjg2LDEzLjEyNSAxMC4wMjg1NzE0LDEzLjMxMjUgMTAuMDI4NTcxNCwxMi4xODc1IEMxMC4wMjg1NzE0LDExLjM0Mzc1IDkuODQyODU3MTQsMTEuMzQzNzUgOS42NTcxNDI4Niw5LjQ2ODc1IEM5LjU2NDI4NTcxLDguNjI1IDEwLjEyMTQyODYsNy45Njg3NSAxMC42Nzg1NzE0LDcuNSBDMTAuMTIxNDI4Niw3LjAzMTI1IDkuNTY0Mjg1NzEsNi40Njg3NSA5LjY1NzE0Mjg2LDUuNjI1IEM5Ljg0Mjg1NzE0LDMuNzUgMTAuMDI4NTcxNCwzLjc1IDEwLjAyODU3MTQsMi45MDYyNSBDMTAuMDI4NTcxNCwxLjc4MTI1IDguMzU3MTQyODYsMS44NzUgOC4zNTcxNDI4NiwxLjg3NSBMOC4zNTcxNDI4NiwwIEwxMC4zMDcxNDI5LDAgQzExLjMyODU3MTQsMCAxMi4yNTcxNDI5LDAuOTM3NSAxMS45Nzg1NzE0LDIuOTA2MjUgTDExLjk3ODU3MTQsMi45MDYyNSBMMTEuOTc4NTcxNCwyLjkwNjI1IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE0cHgiIGhlaWdodD0iMTRweCIgdmlld0JveD0iMCAwIDE0IDE0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Zm9udC1zaXplPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImZvbnQtc2l6ZSIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgIDxnIGlkPSJQYWdlLTEiPgogICAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9ImZvbnQtc2l6ZSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxnIGlkPSJDYXBhXzEiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEuOTIwOTU3MSwzLjExOTAyNSBDMTIuMDAyNDY2MywzLjIyMjQwNjI1IDEyLjEyNTYzMTksMy4yODI1MTg3NSAxMi4yNTU3OTc2LDMuMjgyNTE4NzUgTDEzLjIyNTgzNDMsMy4yODI1MTg3NSBDMTMuMzQwMDY3NCwzLjI4MjUxODc1IDEzLjQ0OTYxOTYsMy4yMzYxIDEzLjUzMDIyNywzLjE1MzYzMTI1IEMxMy42MTA4MzQzLDMuMDcxMTYyNSAxMy42NTU4ODM1LDIuOTU5MzM3NSAxMy42NTUyODIyLDIuODQyOTE4NzUgTDEzLjY1Njc4NTIsMC40MzM4Njg3NSBDMTMuNjU0MDM2OSwwLjE5NDE2MjUgMTMuNDYyNTQ2LDAuMDAxMjY4NzUgMTMuMjI3MzM3NCwwLjAwMTI2ODc1IEwwLjQyOTQ0Nzg1MiwwLjAwMTI2ODc1IEMwLjE5MjI2MzgwNCwwLjAwMTI2ODc1IDAsMC4xOTcxODEyNSAwLDAuNDM4NzY4NzUgTDAsMi44NDUwMTg3NSBDMCwzLjA4NjYwNjI1IDAuMTkyMjYzODA0LDMuMjgyNTE4NzUgMC40Mjk0NDc4NTIsMy4yODI1MTg3NSBMMS4zOTk4MjgyMiwzLjI4MjUxODc1IEMxLjUzMDMzNzQyLDMuMjgyNTE4NzUgMS42NTM3MTc3OSwzLjIyMjEgMS43MzUxODQwNSwzLjExODMyNSBMMi40NjUxNTk1MSwyLjE4ODgxMjUgTDUuNTM5NjYyNTgsMi4xODg4MTI1IEw1LjUzOTY2MjU4LDEzLjU0Nzg0MzggQzUuNTM5NjYyNTgsMTMuNzg5Mzg3NSA1LjczMTkyNjM4LDEzLjk4NTM0MzggNS45NjkxMTA0MywxMy45ODUzNDM4IEw3LjY4NjkwMTg0LDEzLjk4NTM0MzggQzcuOTI0LDEzLjk4NTM0MzggOC4xMTYzNDk3LDEzLjc4OTM4NzUgOC4xMTYzNDk3LDEzLjU0Nzg0MzggTDguMTE2MzQ5NywyLjE4ODg1NjI1IEwxMS4xODc0NjAxLDIuMTg4ODU2MjUgTDExLjkyMDk1NzEsMy4xMTkwMjUgTDExLjkyMDk1NzEsMy4xMTkwMjUgTDExLjkyMDk1NzEsMy4xMTkwMjUgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEzLjg5NzY2MjYsMTEuMjYzMzUgQzEzLjc4NDg0NjYsMTEuMTE0MjA2MiAxMy41OTA5MDgsMTEuMDU1MzYyNSAxMy40MTYzODA0LDExLjExNzEzNzUgTDEyLjg2ODU3NjcsMTEuMzExMjU2MiBMMTIuODY4NjYyNiw5LjYxNzEyNSBDMTIuODY4NjYyNiw5LjUwMTEgMTIuODIzNDQxNyw5LjM4OTggMTIuNzQyOTIwMiw5LjMwNzcyNSBDMTIuNjYyMzk4Nyw5LjIyNTY5Mzc1IDEyLjU1MzEwNDMsOS4xNzk1ODEyNSAxMi40MzkyMTQ4LDkuMTc5NTgxMjUgTDEyLjAxMDE5NjMsOS4xNzk1ODEyNSBDMTEuNzczMDk4MSw5LjE3OTU4MTI1IDExLjU4MDc0ODUsOS4zNzU1Mzc1NSAxMS41ODA3NDg1LDkuNjE3MDgxMjMgTDExLjU4MDc0ODUsMTEuMzExMjU2MiBMMTEuMDMyODU4OSwxMS4xMTcxMzc1IEMxMC44NTg0MTcyLDExLjA1NTE4NzUgMTAuNjY0NTY0NCwxMS4xMTQyMDYyIDEwLjU1MTc0ODUsMTEuMjYzMzUgQzEwLjQzODg0NjYsMTEuNDEyNDUgMTAuNDMyNDA0OSwxMS42MTgzODEyIDEwLjUzNTY0NDIsMTEuNzc0NyBMMTEuODY4MzQ5NywxMy43OTIxNDM4IEMxMS45NDgxODQxLDEzLjkxMjk4MTIgMTIuMDgxODI4MywxMy45ODU0MzEyIDEyLjIyNDY2MjYsMTMuOTg1NDMxMiBDMTIuMzY3NTgyOCwxMy45ODU0MzEyIDEyLjUwMTE4NDEsMTMuOTEyOTgxMiAxMi41ODA5NzU1LDEzLjc5MjE0MzggTDEzLjkxMzc2NjksMTEuNzc0NyBDMTQuMDE2OTYzMSwxMS42MTgzODEyIDE0LjAxMDQ3ODUsMTEuNDEyNDUgMTMuODk3NjYyNiwxMS4yNjMzNSBMMTMuODk3NjYyNiwxMS4yNjMzNSBMMTMuODk3NjYyNiwxMS4yNjMzNSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE3cHgiIGhlaWdodD0iMTRweCIgdmlld0JveD0iMCAwIDE3IDE0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+aW5kZW50PC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImluZGVudCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgIDxnIGlkPSJMYXllcl8xIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS1wYXRoIiB4PSI1LjcxNjQ4MzUyIiB5PSIzLjIxMDgyNjIxIiB3aWR0aD0iMTEuMjgzNTE2NSIgaGVpZ2h0PSIxLjE5NjU4MTIiPjwvcmVjdD4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLXBhdGgiIHg9IjAiIHk9IjAuMDE5OTQzMDE5OSIgd2lkdGg9IjE3IiBoZWlnaHQ9IjEuMTk2NTgxMiI+PC9yZWN0PgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgeD0iMCIgeT0iMTIuNzgzNDc1OCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjEuMTk2NTgxMiI+PC9yZWN0PgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgeD0iNS43MTY0ODM1MiIgeT0iOS41OTI1OTI1OSIgd2lkdGg9IjExLjI4MzUxNjUiIGhlaWdodD0iMS4xOTY1ODEyIj48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS1wYXRoIiB4PSI1LjcxNjQ4MzUyIiB5PSI2LjQwMTcwOTQiIHdpZHRoPSIxMS4yODM1MTY1IiBoZWlnaHQ9IjEuMTk2NTgxMiI+PC9yZWN0PgogICAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJTaGFwZSIgcG9pbnRzPSIwLjE4NjgxMzE4NyA5LjQ5MTQwMTcxIDIuNTIwNTk1NiA3IDAuMTg2ODEzMTg3IDQuNTA4NTk4MjkiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTRweCIgdmlld0JveD0iMCAwIDE2IDE0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+b3V0ZGVudDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJvdXRkZW50IiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IkxheWVyXzEiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLXBhdGgiIHg9IjUuMzk2MTY2MyIgeT0iMy4xOTM0MzU5IiB3aWR0aD0iMTAuNTczMzA0MiIgaGVpZ2h0PSIxLjE5NjU4MTIiPjwvcmVjdD4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLXBhdGgiIHg9IjAuMDM5NDkyMzQxNCIgeT0iMC4wMDI1NTI3MDY1NSIgd2lkdGg9IjE1LjkyOTk3ODEiIGhlaWdodD0iMS4xOTY1ODEyIj48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS1wYXRoIiB4PSIwLjAzOTQ5MjM0MTQiIHk9IjEyLjc2NjA4NTUiIHdpZHRoPSIxNS45Mjk5NzgxIiBoZWlnaHQ9IjEuMTk2NTgxMiI+PC9yZWN0PgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgeD0iNS4zOTYxNjYzIiB5PSI5LjU3NTIwMjI4IiB3aWR0aD0iMTAuNTczMzA0MiIgaGVpZ2h0PSIxLjE5NjU4MTIiPjwvcmVjdD4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLXBhdGgiIHg9IjUuMzk2MTY2MyIgeT0iNi4zODQzMTkwOSIgd2lkdGg9IjEwLjU3MzMwNDIiIGhlaWdodD0iMS4xOTY1ODEyIj48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlNoYXBlIiBwb2ludHM9IjIuMTg2ODg4NCA0LjQ5MTIwNzk4IDAgNi45ODI2MDk2OSAyLjE4Njg4ODQgOS40NzQwMTE0Ij48L3BvbHlnb24+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjEzcHgiIGhlaWdodD0iMTNweCIgdmlld0JveD0iMCAwIDEzIDEzIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+bGlzdC1vcmRlcmVkPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9Imxpc3Qtb3JkZXJlZCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgIDxnIGlkPSJQYWdlLTEiPgogICAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Imxpc3Qtb3JkZXJlZCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxnIGlkPSJDYXBhXzEiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNC4yMDE5MzQxNiwxLjQ2NTczODAxIEwxMi4zNTI0MDQzLDEuNDY1NzM4MDEgQzEyLjY4OTk5NjksMS40NjU3MzgwMSAxMi45NjM2ODk3LDEuMTQzNTY4MjYgMTIuOTYzNjg5NywwLjc0NjE4MDgxMiBDMTIuOTYzNjg5NywwLjM0ODc5MzM1OCAxMi42ODk5OTY5LDAuMDI2NjIzNjE2MyAxMi4zNTI0MDQzLDAuMDI2NjIzNjE2MyBMNC4yMDE5MzQxNiwwLjAyNjYyMzYxNjMgQzMuODY0MzQxNywwLjAyNjYyMzYxNjMgMy41OTA2NDg5LDAuMzQ4NzkzMzU4IDMuNTkwNjQ4OSwwLjc0NjE4MDgxMiBDMy41OTA2NDg5LDEuMTQzNTY4MjYgMy44NjQzNDE3LDEuNDY1NzM4MDEgNC4yMDE5MzQxNiwxLjQ2NTczODAxIEw0LjIwMTkzNDE2LDEuNDY1NzM4MDEgTDQuMjAxOTM0MTYsMS40NjU3MzgwMSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzUyNDA0Myw1Ljc4MzA4MTE4IEw0LjIwMTkzNDE2LDUuNzgzMDgxMTggQzMuODY0MzQxNyw1Ljc4MzA4MTE4IDMuNTkwNjQ4OSw2LjEwNTI1MDkyIDMuNTkwNjQ4OSw2LjUwMjYzODM3IEMzLjU5MDY0ODksNi45MDAwMjU4MyAzLjg2NDM0MTcsNy4yMjIxOTU1NyA0LjIwMTkzNDE2LDcuMjIyMTk1NTcgTDEyLjM1MjQwNDMsNy4yMjIxOTU1NyBDMTIuNjg5OTk2OSw3LjIyMjE5NTU3IDEyLjk2MzY4OTcsNi45MDAwMjU4MyAxMi45NjM2ODk3LDYuNTAyNjM4MzcgQzEyLjk2MzY4OTcsNi4xMDUyMDI5NSAxMi42OTAwMzc3LDUuNzgzMDgxMTggMTIuMzUyNDA0Myw1Ljc4MzA4MTE4IEwxMi4zNTI0MDQzLDUuNzgzMDgxMTggTDEyLjM1MjQwNDMsNS43ODMwODExOCBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzUyNDA0MywxMS41Mzk1Mzg3IEw0LjIwMTkzNDE2LDExLjUzOTUzODcgQzMuODY0MzQxNywxMS41Mzk1Mzg3IDMuNTkwNjQ4OSwxMS44NjE3MDg1IDMuNTkwNjQ4OSwxMi4yNTkwOTYgQzMuNTkwNjQ4OSwxMi42NTY0ODM0IDMuODY0MzQxNywxMi45Nzg2NTMxIDQuMjAxOTM0MTYsMTIuOTc4NjUzMSBMMTIuMzUyNDA0MywxMi45Nzg2NTMxIEMxMi42ODk5OTY5LDEyLjk3ODY1MzEgMTIuOTYzNjg5NywxMi42NTY0ODM0IDEyLjk2MzY4OTcsMTIuMjU5MDk2IEMxMi45NjM2ODk3LDExLjg2MTcwODUgMTIuNjkwMDM3NywxMS41Mzk1Mzg3IDEyLjM1MjQwNDMsMTEuNTM5NTM4NyBMMTIuMzUyNDA0MywxMS41Mzk1Mzg3IEwxMi4zNTI0MDQzLDExLjUzOTUzODcgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTAuNzY3MjAzNzYyLDEuMjQ4OTU5NDEgTDAuNzY3MjAzNzYyLDMuMDUwOTIyNTEgQzAuNzY3MjAzNzYyLDMuMjQ2MzU0MjUgMC45MDI1MDE1NjgsMy4zOTM3MTk1NiAxLjA4MTk3NDkyLDMuMzkzNzE5NTYgQzEuMjU4NDMyNiwzLjM5MzcxOTU2IDEuMzk2NjIzODMsMy4yNDMxNDAyMyAxLjM5NjYyMzgzLDMuMDUwOTIyNTEgTDEuMzk2NjIzODMsMC4zNTYyMjg3ODIgQzEuMzk2NjIzODMsMC4xNjYyNjU2ODIgMS4yNjQzMDA5NCwwLjAxNzQxMzI4NDEgMS4wOTUzODI0NCwwLjAxNzQxMzI4NDEgQzAuOTQ2Nzk5MzY5LDAuMDE3NDEzMjg0MSAwLjg3MjQ2NzA4NCwwLjEzNDc0OTA3NyAwLjg0ODA1NjQyNiwwLjE3MzMxNzM0MyBDMC44NDcwMzc2MTcsMC4xNzQ5NDgzMzkgMC44NDYwMTg4MDksMC4xNzY1NzkzMzYgMC44NDUsMC4xNzgzMDYyNzMgTDAuNTc5MDUwMTU2LDAuNjIxMTY5NzQyIEMwLjUyNzQxNjkyOCwwLjY4NzI3MzA2MyAwLjQ4MTQ4OTAyOCwwLjc5MyAwLjQ4MTQ4OTAyOCwwLjg5NDQwOTU5NiBDMC40ODE0NDgyNzYsMS4wODc3MzA2MyAwLjYwOTE2NjE0NCwxLjI0NTQwOTYgMC43NjcyMDM3NjIsMS4yNDg5NTk0MSBMMC43NjcyMDM3NjIsMS4yNDg5NTk0MSBMMC43NjcyMDM3NjIsMS4yNDg5NTk0MSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMC4zNTE2OTI3OSw4LjE5MDc2NzQ5IEwxLjU1MDA1NjQzLDguMTkwNzY3NDkgQzEuNzA2OTEyMjMsOC4xOTA3Njc0OSAxLjgzNDU0ODU5LDguMDI4MDk5NjMgMS44MzQ1NDg1OSw3LjgyODE1ODY3IEMxLjgzNDU0ODU5LDcuNjMwMzI4NDEgMS43MDY5NTI5Nyw3LjQ2OTM4NzQ1IDEuNTUwMDU2NDMsNy40NjkzODc0NSBMMC42Nzk5MTIyMjYsNy40NjkzODc0NSBMMC42Nzk5MTIyMjYsNy40NjM0ODcwOSBDMC42Nzk5MTIyMjYsNy4zNTU3OTMzNiAwLjg4OTcwNTMyOSw3LjE4MTUxNjYxIDEuMDU4Mjk3ODEsNy4wNDE0OTA3NyBDMS4zOTM2NDg5LDYuNzYyOTI2MiAxLjgxMDk5MzczLDYuNDE2MjkxNTEgMS44MTA5OTM3Myw1LjgxNTEyNTQ2IEMxLjgxMDk5MzczLDUuMjQ0NjEyNTUgMS40MzU0MjAwNiw0LjgxNDQ2MTI1IDAuOTM3MzQ0ODMxLDQuODE0NDYxMjUgQzAuNDYwNDIwMDYzLDQuODE0NDYxMjUgMC4xMDA4MjEzMTcsNS4yMDAzMzU3OSAwLjEwMDgyMTMxNyw1LjcxMjAzNjkgQzAuMTAwODIxMzE3LDYuMDA4OTc0MTcgMC4yNjUwMTI1MzksNi4xMTQzNjUzMSAwLjQwNTYwODE1LDYuMTE0MzY1MzEgQzAuNjA2ODQzMjYsNi4xMTQzNjUzMSAwLjcyNzEwMzQ0OSw1LjkzNzk3Nzg2IDAuNzI3MTAzNDQ5LDUuNzY3NTM4NzUgQzAuNzI3MTAzNDQ5LDUuNjYxNTcxOTYgMC43NTAyNTA3ODMsNS41Mzk5MTg4MiAwLjkzMDYyMDY5Myw1LjUzOTkxODgyIEMxLjE3NDI3OSw1LjUzOTkxODgyIDEuMTgxMjg4NCw1Ljc5NDA2NjQyIDEuMTgxMjg4NCw1LjgyMzA0MDU5IEMxLjE4MTI4ODQsNi4wNTE0NzYwMiAwLjkyOTQzODg3Miw2LjI2NTA0MDU5IDAuNjg1ODYyMDY5LDYuNDcxNTUzNTEgQzAuMzg0NzgzNjk5LDYuNzI2ODA0NDMgMC4wNDM1MjM1MTEsNy4wMTYxNjIzNiAwLjA0MzUyMzUxMSw3LjQ2MzU4MzAzIEwwLjA0MzUyMzUxMSw3Ljg0NzkyMjUxIEMwLjA0MzQ4Mjc1ODYsOC4wNTI5OTYzMSAwLjIwMjg2NTIwMyw4LjE5MDc2NzQ5IDAuMzUxNjkyNzksOC4xOTA3Njc0OSBMMC4zNTE2OTI3OSw4LjE5MDc2NzQ5IEwwLjM1MTY5Mjc5LDguMTkwNzY3NDkgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEuNzcwNTI2NjQsMTAuNTQzMDk2IEMxLjc3MDUyNjY0LDkuOTUxMDQ0MjcgMS40NzM1MjM1MSw5LjYxMTUwOTIxIDAuOTU1NzI0MTM5LDkuNjExNTA5MjEgQzAuMjc2Nzg5OTY5LDkuNjExNTA5MjEgMC4wOTczOTgxMTksMTAuMTgyMjYyIDAuMDk3Mzk4MTE5LDEwLjQ4NDA0NDMgQzAuMDk3Mzk4MTE5LDEwLjgzNTM4MDEgMC4zMTkyOTQ2NywxMC44NzMzMjQ3IDAuNDE0Njk1OTI1LDEwLjg3MzMyNDcgQzAuNjAwNDg1ODkzLDEwLjg3MzMyNDcgMC43MjUyNjk1OTIsMTAuNzI2MzkxMiAwLjcyNTI2OTU5MiwxMC41MDc2OTM3IEMwLjcyNTI2OTU5MiwxMC40MjM1NTM1IDAuNzUwNjk5MDYsMTAuMzI2OTg4OSAwLjk0ODg3Nzc0NCwxMC4zMjY5ODg5IEMxLjA5MTMwNzIxLDEwLjMyNjk4ODkgMS4xNDkyOTc4MSwxMC4zNTExNjYxIDEuMTQ5Mjk3ODEsMTAuNTk0MDg4NSBDMS4xNDkyOTc4MSwxMC44MzE0NDY1IDEuMTA2MDE4ODEsMTAuODU3MzAyNSAwLjkzNTU1MTcyMywxMC44NTczMDI1IEMwLjc3MTgwODc3NywxMC44NTczMDI1IDAuNjQ4MzY5OTA2LDExLjAwOTQxNyAwLjY0ODM2OTkwNiwxMS4yMTEwODQ5IEMwLjY0ODM2OTkwNiwxMS40MTA1OTQxIDAuNzczMzE2NjE1LDExLjU2MTA3NzUgMC45Mzg5NzQ5MiwxMS41NjEwNzc1IEMxLjE2NDEzMTY2LDExLjU2MTA3NzUgMS4yMDkzNjY3NywxMS42NjkyOTg5IDEuMjA5MzY2NzcsMTEuODQzOTU5NCBMMS4yMDkzNjY3NywxMS45MTg3NDU0IEMxLjIwOTM2Njc3LDEyLjIxMjYxMjUgMS4xMTIwMDk0MSwxMi4yNjgzMDYzIDAuOTMyMzMyMjkxLDEyLjI2ODMwNjMgQzAuNjg0NDM1NzM2LDEyLjI2ODMwNjMgMC42NjUxNTk4NzUsMTIuMTE4MDYyNyAwLjY2NTE1OTg3NSwxMi4wNzIwMTExIEMwLjY2NTE1OTg3NSwxMS44OTc4MzAzIDAuNTY3MDY4OTY1LDExLjcyMjA2NjQgMC4zNDc5MDI4MjIsMTEuNzIyMDY2NCBDMC4xNTU1NTE3MjQsMTEuNzIyMDY2NCAwLjA0MDcxMTU5ODgsMTEuODYzMTQ3NiAwLjA0MDcxMTU5ODgsMTIuMDk5NTQ2MSBDMC4wNDA3MTE1OTg4LDEyLjUzMDEyOTEgMC4zNTQzNDE2OTMsMTIuOTg3NzY3NSAwLjkzNTU1MTcyMywxMi45ODc3Njc1IEMxLjUwMDEzNDgsMTIuOTg3NzY3NSAxLjgzNzIzODI0LDEyLjU4ODEyNTUgMS44MzcyMzgyNCwxMS45MTg3NDU0IEwxLjgzNzIzODI0LDExLjg0Mzk1OTQgQzEuODM3MjM4MjQsMTEuNTY5NTIwMyAxLjc2MjY2MTQ0LDExLjM0MTk0ODMgMS42MjI3MTc4NywxMS4xNzgzMjEgQzEuNzE4NTY3NCwxMS4wMTUwNzc1IDEuNzcwNTI2NjQsMTAuNzk3MjQzNSAxLjc3MDUyNjY0LDEwLjU0MzA5NiBMMS43NzA1MjY2NCwxMC41NDMwOTYgTDEuNzcwNTI2NjQsMTAuNTQzMDk2IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTRweCIgdmlld0JveD0iMCAwIDE2IDE0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+bGlzdC11bm9yZGVyZWQ8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0ibGlzdC11bm9yZGVyZWQiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICA8ZyBpZD0iQ2FwYV8xIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEuNzIwODE2MzMsMy40MjcwODMzMyBDMi42NzEwMjA0MSwzLjQyNzA4MzMzIDMuNDQxNjMyNjUsMi42NTkwMjc3OCAzLjQ0MTYzMjY1LDEuNzE5MjEyOTYgQzMuNDQxNjMyNjUsMC43NzkzOTgxNDggMi42NzEwMjA0MSwwLjAwODEwMTg1MTg1IDEuNzIwODE2MzMsMC4wMDgxMDE4NTE4NSBDMC43NzA2MTIyNDUsMC4wMDgxMDE4NTE4NSAwLDAuNzc2MTU3NDA3IDAsMS43MTU5NzIyMiBDMCwyLjY1NTc4NzA0IDAuNzczODc3NTUxLDMuNDI3MDgzMzMgMS43MjA4MTYzMywzLjQyNzA4MzMzIEwxLjcyMDgxNjMzLDMuNDI3MDgzMzMgWiBNMS43MjA4MTYzMywwLjgwMjA4MzMzMyBDMi4yMzAyMDQwOCwwLjgwMjA4MzMzMyAyLjY0MTYzMjY1LDEuMjEzNjU3NDEgMi42NDE2MzI2NSwxLjcxNTk3MjIyIEMyLjY0MTYzMjY1LDIuMjE4Mjg3MDQgMi4yMjY5Mzg3OCwyLjYyOTg2MTExIDEuNzIwODE2MzMsMi42Mjk4NjExMSBDMS4yMTQ2OTM4OCwyLjYyOTg2MTExIDAuOCwyLjIxODI4NzA0IDAuOCwxLjcxNTk3MjIyIEMwLjgsMS4yMTM2NTc0MSAxLjIxNDY5Mzg4LDAuODAyMDgzMzMzIDEuNzIwODE2MzMsMC44MDIwODMzMzMgTDEuNzIwODE2MzMsMC44MDIwODMzMzMgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEuNzIwODE2MzMsOC43MDMwMDkyNiBDMi42NzEwMjA0MSw4LjcwMzAwOTI2IDMuNDQxNjMyNjUsNy45MzQ5NTM3IDMuNDQxNjMyNjUsNi45OTUxMzg4OSBDMy40NDE2MzI2NSw2LjA1NTMyNDA3IDIuNjcxMDIwNDEsNS4yODcyNjg1MiAxLjcyMDgxNjMzLDUuMjg3MjY4NTIgQzAuNzcwNjEyMjQ1LDUuMjg3MjY4NTIgMCw2LjA1MjA4MzMzIDAsNi45OTUxMzg4OSBDMCw3LjkzODE5NDQ0IDAuNzczODc3NTUxLDguNzAzMDA5MjYgMS43MjA4MTYzMyw4LjcwMzAwOTI2IEwxLjcyMDgxNjMzLDguNzAzMDA5MjYgWiBNMS43MjA4MTYzMyw2LjA4MTI1IEMyLjIzMDIwNDA4LDYuMDgxMjUgMi42NDE2MzI2NSw2LjQ5MjgyNDA3IDIuNjQxNjMyNjUsNi45OTUxMzg4OSBDMi42NDE2MzI2NSw3LjQ5NzQ1MzcgMi4yMjY5Mzg3OCw3LjkwOTAyNzc4IDEuNzIwODE2MzMsNy45MDkwMjc3OCBDMS4yMTQ2OTM4OCw3LjkwOTAyNzc4IDAuOCw3LjUwMDY5NDQ0IDAuOCw2Ljk5NTEzODg5IEMwLjgsNi40ODk1ODMzMyAxLjIxNDY5Mzg4LDYuMDgxMjUgMS43MjA4MTYzMyw2LjA4MTI1IEwxLjcyMDgxNjMzLDYuMDgxMjUgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEuNzIwODE2MzMsMTMuOTgyMTc1OSBDMi42NzEwMjA0MSwxMy45ODIxNzU5IDMuNDQxNjMyNjUsMTMuMjE0MTIwNCAzLjQ0MTYzMjY1LDEyLjI3NDMwNTYgQzMuNDQxNjMyNjUsMTEuMzMxMjUgMi42Njc3NTUxLDEwLjU2NjQzNTIgMS43MjA4MTYzMywxMC41NjY0MzUyIEMwLjc3Mzg3NzU1MSwxMC41NjY0MzUyIDAsMTEuMzM0NDkwNyAwLDEyLjI3NDMwNTYgQzAsMTMuMjE0MTIwNCAwLjc3Mzg3NzU1MSwxMy45ODIxNzU5IDEuNzIwODE2MzMsMTMuOTgyMTc1OSBMMS43MjA4MTYzMywxMy45ODIxNzU5IFogTTEuNzIwODE2MzMsMTEuMzU3MTc1OSBDMi4yMzAyMDQwOCwxMS4zNTcxNzU5IDIuNjQxNjMyNjUsMTEuNzY4NzUgMi42NDE2MzI2NSwxMi4yNzEwNjQ4IEMyLjY0MTYzMjY1LDEyLjc3NjYyMDQgMi4yMjY5Mzg3OCwxMy4xODQ5NTM3IDEuNzIwODE2MzMsMTMuMTg0OTUzNyBDMS4yMTQ2OTM4OCwxMy4xODQ5NTM3IDAuOCwxMi43NzMzNzk2IDAuOCwxMi4yNzEwNjQ4IEMwLjgsMTEuNzY4NzUgMS4yMTQ2OTM4OCwxMS4zNTcxNzU5IDEuNzIwODE2MzMsMTEuMzU3MTc1OSBMMS43MjA4MTYzMywxMS4zNTcxNzU5IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01Ljc0MzY3MzQ3LDIuMTE0NTgzMzMgTDE1LjU4ODU3MTQsMi4xMTQ1ODMzMyBDMTUuODEwNjEyMiwyLjExNDU4MzMzIDE1Ljk5MDIwNDEsMS45MzYzNDI1OSAxNS45OTAyMDQxLDEuNzE1OTcyMjIgQzE1Ljk5MDIwNDEsMS40OTU2MDE4NSAxNS44MTA2MTIyLDEuMzE3MzYxMTEgMTUuNTg4NTcxNCwxLjMxNzM2MTExIEw1Ljc0MzY3MzQ3LDEuMzE3MzYxMTEgQzUuNTIxNjMyNjUsMS4zMTczNjExMSA1LjM0MjA0MDgyLDEuNDk1NjAxODUgNS4zNDIwNDA4MiwxLjcxNTk3MjIyIEM1LjM0MjA0MDgyLDEuOTM2MzQyNTkgNS41MjE2MzI2NSwyLjExNDU4MzMzIDUuNzQzNjczNDcsMi4xMTQ1ODMzMyBMNS43NDM2NzM0NywyLjExNDU4MzMzIFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01Ljc0MzY3MzQ3LDcuMzkzNzUgTDE1LjU4ODU3MTQsNy4zOTM3NSBDMTUuODEwNjEyMiw3LjM5Mzc1IDE1Ljk5MDIwNDEsNy4yMTU1MDkyNiAxNS45OTAyMDQxLDYuOTk1MTM4ODkgQzE1Ljk5MDIwNDEsNi43NzQ3Njg1MiAxNS44MTA2MTIyLDYuNTk2NTI3NzggMTUuNTg4NTcxNCw2LjU5NjUyNzc4IEw1Ljc0MzY3MzQ3LDYuNTk2NTI3NzggQzUuNTIxNjMyNjUsNi41OTY1Mjc3OCA1LjM0MjA0MDgyLDYuNzc0NzY4NTIgNS4zNDIwNDA4Miw2Ljk5NTEzODg5IEM1LjM0MjA0MDgyLDcuMjE1NTA5MjYgNS41MjE2MzI2NSw3LjM5Mzc1IDUuNzQzNjczNDcsNy4zOTM3NSBMNS43NDM2NzM0Nyw3LjM5Mzc1IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01Ljc0MzY3MzQ3LDEyLjY2OTY3NTkgTDE1LjU4ODU3MTQsMTIuNjY5Njc1OSBDMTUuODEwNjEyMiwxMi42Njk2NzU5IDE1Ljk5MDIwNDEsMTIuNDkxNDM1MiAxNS45OTAyMDQxLDEyLjI3MTA2NDggQzE1Ljk5MDIwNDEsMTIuMDUwNjk0NCAxNS44MTA2MTIyLDExLjg3MjQ1MzcgMTUuNTg4NTcxNCwxMS44NzI0NTM3IEw1Ljc0MzY3MzQ3LDExLjg3MjQ1MzcgQzUuNTIxNjMyNjUsMTEuODcyNDUzNyA1LjM0MjA0MDgyLDEyLjA1MDY5NDQgNS4zNDIwNDA4MiwxMi4yNzEwNjQ4IEM1LjM0MjA0MDgyLDEyLjQ5MTQzNTIgNS41MjE2MzI2NSwxMi42Njk2NzU5IDUuNzQzNjczNDcsMTIuNjY5Njc1OSBMNS43NDM2NzM0NywxMi42Njk2NzU5IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+YWxpZ24tbGVmdDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJhbGlnbi1sZWZ0IiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IkNhcGFfMSI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik04LjQ5MzI2MDg3LDE0Ljg4NzE3MzkgTDAuMzI2MDg2OTU3LDE0Ljg4NzE3MzkgQzAuMTQ2MDg2OTU3LDE0Ljg4NzE3MzkgMCwxNC43NDEwODcgMCwxNC41NjEwODcgQzAsMTQuMzgxMDg3IDAuMTQ2MDg2OTU3LDE0LjIzNSAwLjMyNjA4Njk1NywxNC4yMzUgTDguNDkzMjYwODcsMTQuMjM1IEM4LjY3MzI2MDg3LDE0LjIzNSA4LjgxOTM0NzgzLDE0LjM4MTA4NyA4LjgxOTM0NzgzLDE0LjU2MTA4NyBDOC44MTkzNDc4MywxNC43NDEwODcgOC42NzM5MTMwNCwxNC44ODcxNzM5IDguNDkzMjYwODcsMTQuODg3MTczOSBMOC40OTMyNjA4NywxNC44ODcxNzM5IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC42MTc4MjYxLDEwLjE2MTUyMTcgTDAuMzI2MDg2OTU3LDEwLjE2MTUyMTcgQzAuMTQ2MDg2OTU3LDEwLjE2MTUyMTcgMCwxMC4wMTU0MzQ4IDAsOS44MzU0MzQ3OCBDMCw5LjY1NTQzNDc4IDAuMTQ2MDg2OTU3LDkuNTA5MzQ3ODMgMC4zMjYwODY5NTcsOS41MDkzNDc4MyBMMTQuNjE3ODI2MSw5LjUwOTM0NzgzIEMxNC43OTc4MjYxLDkuNTA5MzQ3ODMgMTQuOTQzOTEzLDkuNjU1NDM0NzggMTQuOTQzOTEzLDkuODM1NDM0NzggQzE0Ljk0MzkxMywxMC4wMTU0MzQ4IDE0Ljc5NzgyNjEsMTAuMTYxNTIxNyAxNC42MTc4MjYxLDEwLjE2MTUyMTcgTDE0LjYxNzgyNjEsMTAuMTYxNTIxNyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOC40OTMyNjA4Nyw1LjQzNTIxNzM5IEwwLjMyNjA4Njk1Nyw1LjQzNTIxNzM5IEMwLjE0NjA4Njk1Nyw1LjQzNTIxNzM5IDAsNS4yODkxMzA0MyAwLDUuMTA5MTMwNDMgQzAsNC45MjkxMzA0MyAwLjE0NjA4Njk1Nyw0Ljc4MzA0MzQ4IDAuMzI2MDg2OTU3LDQuNzgzMDQzNDggTDguNDkzMjYwODcsNC43ODMwNDM0OCBDOC42NzMyNjA4Nyw0Ljc4MzA0MzQ4IDguODE5MzQ3ODMsNC45MjkxMzA0MyA4LjgxOTM0NzgzLDUuMTA5MTMwNDMgQzguODE5MzQ3ODMsNS4yODkxMzA0MyA4LjY3MzkxMzA0LDUuNDM1MjE3MzkgOC40OTMyNjA4Nyw1LjQzNTIxNzM5IEw4LjQ5MzI2MDg3LDUuNDM1MjE3MzkgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjYxNzgyNjEsMC43MDg5MTMwNDMgTDAuMzI2MDg2OTU3LDAuNzA4OTEzMDQzIEMwLjE0NjA4Njk1NywwLjcwODkxMzA0MyAwLDAuNTYyODI2MDg3IDAsMC4zODI4MjYwODcgQzAsMC4yMDI4MjYwODcgMC4xNDYwODY5NTcsMC4wNTY3MzkxMzA0IDAuMzI2MDg2OTU3LDAuMDU2NzM5MTMwNCBMMTQuNjE3ODI2MSwwLjA1NjczOTEzMDQgQzE0Ljc5NzgyNjEsMC4wNTY3MzkxMzA0IDE0Ljk0MzkxMywwLjIwMjgyNjA4NyAxNC45NDM5MTMsMC4zODI4MjYwODcgQzE0Ljk0MzkxMywwLjU2MjgyNjA4NyAxNC43OTc4MjYxLDAuNzA4OTEzMDQzIDE0LjYxNzgyNjEsMC43MDg5MTMwNDMgTDE0LjYxNzgyNjEsMC43MDg5MTMwNDMgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+YWxpZ24tY2VudGVyPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImFsaWduLWNlbnRlciIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEuNTU1ODY5NiwxNC44ODcxNzM5IEwzLjM4ODA0MzQ4LDE0Ljg4NzE3MzkgQzMuMjA4MDQzNDgsMTQuODg3MTczOSAzLjA2MTk1NjUyLDE0Ljc0MTA4NyAzLjA2MTk1NjUyLDE0LjU2MTA4NyBDMy4wNjE5NTY1MiwxNC4zODEwODcgMy4yMDgwNDM0OCwxNC4yMzUgMy4zODgwNDM0OCwxNC4yMzUgTDExLjU1NTIxNzQsMTQuMjM1IEMxMS43MzUyMTc0LDE0LjIzNSAxMS44ODEzMDQzLDE0LjM4MTA4NyAxMS44ODEzMDQzLDE0LjU2MTA4NyBDMTEuODgxMzA0MywxNC43NDEwODcgMTEuNzM1ODY5NiwxNC44ODcxNzM5IDExLjU1NTg2OTYsMTQuODg3MTczOSBMMTEuNTU1ODY5NiwxNC44ODcxNzM5IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjYxNzgyNjEsMTAuMTYxNTIxNyBMMC4zMjYwODY5NTcsMTAuMTYxNTIxNyBDMC4xNDYwODY5NTcsMTAuMTYxNTIxNyAwLDEwLjAxNTQzNDggMCw5LjgzNTQzNDc4IEMwLDkuNjU1NDM0NzggMC4xNDYwODY5NTcsOS41MDkzNDc4MyAwLjMyNjA4Njk1Nyw5LjUwOTM0NzgzIEwxNC42MTc4MjYxLDkuNTA5MzQ3ODMgQzE0Ljc5NzgyNjEsOS41MDkzNDc4MyAxNC45NDM5MTMsOS42NTU0MzQ3OCAxNC45NDM5MTMsOS44MzU0MzQ3OCBDMTQuOTQzOTEzLDEwLjAxNTQzNDggMTQuNzk3ODI2MSwxMC4xNjE1MjE3IDE0LjYxNzgyNjEsMTAuMTYxNTIxNyBMMTQuNjE3ODI2MSwxMC4xNjE1MjE3IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTExLjU1NTg2OTYsNS40MzUyMTczOSBMMy4zODgwNDM0OCw1LjQzNTIxNzM5IEMzLjIwODA0MzQ4LDUuNDM1MjE3MzkgMy4wNjE5NTY1Miw1LjI4OTEzMDQzIDMuMDYxOTU2NTIsNS4xMDkxMzA0MyBDMy4wNjE5NTY1Miw0LjkyOTEzMDQzIDMuMjA4MDQzNDgsNC43ODMwNDM0OCAzLjM4ODA0MzQ4LDQuNzgzMDQzNDggTDExLjU1NTIxNzQsNC43ODMwNDM0OCBDMTEuNzM1MjE3NCw0Ljc4MzA0MzQ4IDExLjg4MTMwNDMsNC45MjkxMzA0MyAxMS44ODEzMDQzLDUuMTA5MTMwNDMgQzExLjg4MTMwNDMsNS4yODkxMzA0MyAxMS43MzU4Njk2LDUuNDM1MjE3MzkgMTEuNTU1ODY5Niw1LjQzNTIxNzM5IEwxMS41NTU4Njk2LDUuNDM1MjE3MzkgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQuNjE3ODI2MSwwLjcwODkxMzA0MyBMMC4zMjYwODY5NTcsMC43MDg5MTMwNDMgQzAuMTQ2MDg2OTU3LDAuNzA4OTEzMDQzIDAsMC41NjI4MjYwODcgMCwwLjM4MjgyNjA4NyBDMCwwLjIwMjgyNjA4NyAwLjE0NjA4Njk1NywwLjA1NjczOTEzMDQgMC4zMjYwODY5NTcsMC4wNTY3MzkxMzA0IEwxNC42MTc4MjYxLDAuMDU2NzM5MTMwNCBDMTQuNzk3ODI2MSwwLjA1NjczOTEzMDQgMTQuOTQzOTEzLDAuMjAyODI2MDg3IDE0Ljk0MzkxMywwLjM4MjgyNjA4NyBDMTQuOTQzOTEzLDAuNTYyODI2MDg3IDE0Ljc5NzgyNjEsMC43MDg5MTMwNDMgMTQuNjE3ODI2MSwwLjcwODkxMzA0MyBMMTQuNjE3ODI2MSwwLjcwODkxMzA0MyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+YWxpZ24tcmlnaHQ8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iYWxpZ24tcmlnaHQiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICA8ZyBpZD0iQ2FwYV8xIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjYxNzgyNjEsMTQuODg3MTczOSBMNi40NTA2NTIxNywxNC44ODcxNzM5IEM2LjI3MDY1MjE3LDE0Ljg4NzE3MzkgNi4xMjQ1NjUyMiwxNC43NDEwODcgNi4xMjQ1NjUyMiwxNC41NjEwODcgQzYuMTI0NTY1MjIsMTQuMzgxMDg3IDYuMjcwNjUyMTcsMTQuMjM1IDYuNDUwNjUyMTcsMTQuMjM1IEwxNC42MTc4MjYxLDE0LjIzNSBDMTQuNzk3ODI2MSwxNC4yMzUgMTQuOTQzOTEzLDE0LjM4MTA4NyAxNC45NDM5MTMsMTQuNTYxMDg3IEMxNC45NDM5MTMsMTQuNzQxMDg3IDE0Ljc5NzgyNjEsMTQuODg3MTczOSAxNC42MTc4MjYxLDE0Ljg4NzE3MzkgTDE0LjYxNzgyNjEsMTQuODg3MTczOSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQuNjE3ODI2MSwxMC4xNjE1MjE3IEwwLjMyNjA4Njk1NywxMC4xNjE1MjE3IEMwLjE0NjA4Njk1NywxMC4xNjE1MjE3IDAsMTAuMDE1NDM0OCAwLDkuODM1NDM0NzggQzAsOS42NTU0MzQ3OCAwLjE0NjA4Njk1Nyw5LjUwOTM0NzgzIDAuMzI2MDg2OTU3LDkuNTA5MzQ3ODMgTDE0LjYxNzgyNjEsOS41MDkzNDc4MyBDMTQuNzk3ODI2MSw5LjUwOTM0NzgzIDE0Ljk0MzkxMyw5LjY1NTQzNDc4IDE0Ljk0MzkxMyw5LjgzNTQzNDc4IEMxNC45NDM5MTMsMTAuMDE1NDM0OCAxNC43OTc4MjYxLDEwLjE2MTUyMTcgMTQuNjE3ODI2MSwxMC4xNjE1MjE3IEwxNC42MTc4MjYxLDEwLjE2MTUyMTcgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjYxNzgyNjEsNS40MzUyMTczOSBMNi40NTA2NTIxNyw1LjQzNTIxNzM5IEM2LjI3MDY1MjE3LDUuNDM1MjE3MzkgNi4xMjQ1NjUyMiw1LjI4OTEzMDQzIDYuMTI0NTY1MjIsNS4xMDkxMzA0MyBDNi4xMjQ1NjUyMiw0LjkyOTEzMDQzIDYuMjcwNjUyMTcsNC43ODMwNDM0OCA2LjQ1MDY1MjE3LDQuNzgzMDQzNDggTDE0LjYxNzgyNjEsNC43ODMwNDM0OCBDMTQuNzk3ODI2MSw0Ljc4MzA0MzQ4IDE0Ljk0MzkxMyw0LjkyOTEzMDQzIDE0Ljk0MzkxMyw1LjEwOTEzMDQzIEMxNC45NDM5MTMsNS4yODkxMzA0MyAxNC43OTc4MjYxLDUuNDM1MjE3MzkgMTQuNjE3ODI2MSw1LjQzNTIxNzM5IEwxNC42MTc4MjYxLDUuNDM1MjE3MzkgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjYxNzgyNjEsMC43MDg5MTMwNDMgTDAuMzI2MDg2OTU3LDAuNzA4OTEzMDQzIEMwLjE0NjA4Njk1NywwLjcwODkxMzA0MyAwLDAuNTYyODI2MDg3IDAsMC4zODI4MjYwODcgQzAsMC4yMDI4MjYwODcgMC4xNDYwODY5NTcsMC4wNTY3MzkxMzA0IDAuMzI2MDg2OTU3LDAuMDU2NzM5MTMwNCBMMTQuNjE3ODI2MSwwLjA1NjczOTEzMDQgQzE0Ljc5NzgyNjEsMC4wNTY3MzkxMzA0IDE0Ljk0MzkxMywwLjIwMjgyNjA4NyAxNC45NDM5MTMsMC4zODI4MjYwODcgQzE0Ljk0MzkxMywwLjU2MjgyNjA4NyAxNC43OTc4MjYxLDAuNzA4OTEzMDQzIDE0LjYxNzgyNjEsMC43MDg5MTMwNDMgTDE0LjYxNzgyNjEsMC43MDg5MTMwNDMgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+YWxpZ24tanVzdGlmeTwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJhbGlnbi1qdXN0aWZ5IiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IkNhcGFfMSI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC42MTkxMzA0LDE0Ljg4NzgyNjEgTDAuMzI2MDg2OTU3LDE0Ljg4NzgyNjEgQzAuMTQ2MDg2OTU3LDE0Ljg4NzgyNjEgMCwxNC43NDE3MzkxIDAsMTQuNTYxNzM5MSBDMCwxNC4zODE3MzkxIDAuMTQ2MDg2OTU3LDE0LjIzNTY1MjIgMC4zMjYwODY5NTcsMTQuMjM1NjUyMiBMMTQuNjE5MTMwNCwxNC4yMzU2NTIyIEMxNC43OTkxMzA0LDE0LjIzNTY1MjIgMTQuOTQ1MjE3NCwxNC4zODE3MzkxIDE0Ljk0NTIxNzQsMTQuNTYxNzM5MSBDMTQuOTQ1MjE3NCwxNC43NDE3MzkxIDE0Ljc5OTEzMDQsMTQuODg3ODI2MSAxNC42MTkxMzA0LDE0Ljg4NzgyNjEgTDE0LjYxOTEzMDQsMTQuODg3ODI2MSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQuNjE5MTMwNCwxMC4xNjIxNzM5IEwwLjMyNjA4Njk1NywxMC4xNjIxNzM5IEMwLjE0NjA4Njk1NywxMC4xNjIxNzM5IDAsMTAuMDE2MDg3IDAsOS44MzYwODY5NiBDMCw5LjY1NjA4Njk2IDAuMTQ2MDg2OTU3LDkuNTEgMC4zMjYwODY5NTcsOS41MSBMMTQuNjE5MTMwNCw5LjUxIEMxNC43OTkxMzA0LDkuNTEgMTQuOTQ1MjE3NCw5LjY1NjA4Njk2IDE0Ljk0NTIxNzQsOS44MzYwODY5NiBDMTQuOTQ1MjE3NCwxMC4wMTYwODcgMTQuNzk5MTMwNCwxMC4xNjIxNzM5IDE0LjYxOTEzMDQsMTAuMTYyMTczOSBMMTQuNjE5MTMwNCwxMC4xNjIxNzM5IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC42MTkxMzA0LDUuNDM1ODY5NTcgTDAuMzI2MDg2OTU3LDUuNDM1ODY5NTcgQzAuMTQ2MDg2OTU3LDUuNDM1ODY5NTcgMCw1LjI4OTc4MjYxIDAsNS4xMDk3ODI2MSBDMCw0LjkyOTc4MjYxIDAuMTQ2MDg2OTU3LDQuNzgzNjk1NjUgMC4zMjYwODY5NTcsNC43ODM2OTU2NSBMMTQuNjE5MTMwNCw0Ljc4MzY5NTY1IEMxNC43OTkxMzA0LDQuNzgzNjk1NjUgMTQuOTQ1MjE3NCw0LjkyOTc4MjYxIDE0Ljk0NTIxNzQsNS4xMDk3ODI2MSBDMTQuOTQ1MjE3NCw1LjI4OTc4MjYxIDE0Ljc5OTEzMDQsNS40MzU4Njk1NyAxNC42MTkxMzA0LDUuNDM1ODY5NTcgTDE0LjYxOTEzMDQsNS40MzU4Njk1NyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQuNjE5MTMwNCwwLjcwOTU2NTIxNyBMMC4zMjYwODY5NTcsMC43MDk1NjUyMTcgQzAuMTQ2MDg2OTU3LDAuNzA5NTY1MjE3IDAsMC41NjM0NzgyNjEgMCwwLjM4MzQ3ODI2MSBDMCwwLjIwMzQ3ODI2MSAwLjE0NjA4Njk1NywwLjA1NzM5MTMwNDMgMC4zMjYwODY5NTcsMC4wNTczOTEzMDQzIEwxNC42MTkxMzA0LDAuMDU3MzkxMzA0MyBDMTQuNzk5MTMwNCwwLjA1NzM5MTMwNDMgMTQuOTQ1MjE3NCwwLjIwMzQ3ODI2MSAxNC45NDUyMTc0LDAuMzgzNDc4MjYxIEMxNC45NDUyMTc0LDAuNTYzNDc4MjYxIDE0Ljc5OTEzMDQsMC43MDk1NjUyMTcgMTQuNjE5MTMwNCwwLjcwOTU2NTIxNyBMMTQuNjE5MTMwNCwwLjcwOTU2NTIxNyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Y29sb3I8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iY29sb3IiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICA8ZyBpZD0iQ2FwYV8xIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjQwNjM4NzEsMC41ODUyNTgwNjUgQzEzLjYyNjI5MDMsLTAuMTk0ODcwOTY4IDEyLjM2MTQ1MTYsLTAuMTk1MDk2Nzc0IDExLjU4MDgzODcsMC41ODUgTDExLjA0MTU4MDYsMS4xMjQyNTgwNiBDMTAuNzUxOTAzMiwwLjgzNDYxMjkwMyAxMC4yODI3MDk3LDAuODM0NjEyOTAzIDkuOTkzMDY0NTIsMS4xMjQyNTgwNiBDOS43MDMzNTQ4NCwxLjQxMzY3NzQyIDkuNzAzMzU0ODQsMS44ODMzODcxIDkuOTkzMDY0NTIsMi4xNzI4MDY0NSBMMTAuMTY3Nzc0MiwyLjM0NzYxMjkgTDQuMzQyMzU0ODQsOC4xNzM0NTE2MSBMNC4zNDE4Mzg3MSw4LjE3MzQ1MTYxIEwyLjMxOTc0MTk0LDEwLjE5NTc0MTkgQzIuMTU5MDMyMjYsMTAuMzU2NDUxNiAyLjA2NDI5MDMyLDEwLjU3MTQxOTQgMi4wNTQwOTY3NywxMC43OTg0NTE2IEwyLjA0OTI1ODA2LDEwLjkwNjMyMjYgTDIuMDQ5MjU4MDYsMTAuOTA3ODA2NSBMMS45Njc2Nzc0MiwxMi43MzY5Njc3IEMxLjk2NDMyMjU4LDEyLjgyMTkwMzIgMS45OTYxNjEyOSwxMi45MDQyMjU4IDIuMDU2MDMyMjYsMTIuOTY0MzIyNiBDMi4xMTI1MTYxMywxMy4wMjEwNjQ1IDIuMTg5NzQxOTQsMTMuMDUyNjQ1MiAyLjI2OTkwMzIzLDEzLjA1MjY0NTIgQzIuMjc0MjU4MDYsMTMuMDUyNjQ1MiAyLjI3ODU4MDY1LDEzLjA1MjY0NTIgMi4yODM0NTE2MSwxMy4wNTIzODcxIEwzLjI1MzI1ODA2LDEzLjAwOTQ1MTYgTDMuMjUzNzc0MTksMTMuMDA5NDUxNiBMMy44NDQ2Nzc0MiwxMi45ODMxNjEzIEw0LjExMywxMi45NzEzNTQ4IEM0LjQwOTg3MDk3LDEyLjk1ODA2NDUgNC42OTE4Mzg3MSwxMi44MzM5Njc3IDQuOTAyMzIyNTgsMTIuNjIzNzQxOSBMMTIuNjczMjI1OCw0Ljg1MzA2NDUyIEwxMi44MTg1ODA2LDQuOTk4Mzg3MSBDMTIuOTYzNDE5NCw1LjE0MzE2MTI5IDEzLjE1MzE2MTMsNS4yMTU1ODA2NSAxMy4zNDI4Mzg3LDUuMjE1NTgwNjUgQzEzLjUzMjU0ODQsNS4yMTU1ODA2NSAxMy43MjIzMjI2LDUuMTQzMTYxMjkgMTMuODY3MTI5LDQuOTk4Mzg3MSBDMTQuMTU2ODA2NSw0LjcwODkzNTQ4IDE0LjE1NjgwNjUsNC4yMzkyMjU4MSAxMy44NjcxMjksMy45NDk4Mzg3MSBMMTQuNDA2MzU0OCwzLjQxMDU0ODM5IEMxNS4xODY1MTYxLDIuNjMwNDUxNjEgMTUuMTg2NTE2MSwxLjM2NTYxMjkgMTQuNDA2Mzg3MSwwLjU4NTI1ODA2NSBMMTQuNDA2Mzg3MSwwLjU4NTI1ODA2NSBaIE04Ljc5NDgwNjQ1LDcuMzMzMjI1ODEgTDYuMDY1Nzc0MTksNy44NDgwNjQ1MiBMMTAuNTE3MzIyNiwzLjM5NjMyMjU4IEwxMS42MjQ4MDY1LDQuNTAzMjkwMzIgTDguNzk0ODA2NDUsNy4zMzMyMjU4MSBMOC43OTQ4MDY0NSw3LjMzMzIyNTgxIFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yLjA4MDY0NTE2LDEzLjY3MzI5MDMgQzAuOTMxNzA5Njc3LDEzLjY3MzI5MDMgMCwxMy45NjgyOTAzIDAsMTQuMzMyNDgzOSBDMCwxNC42OTY0ODM5IDAuOTMxNzA5Njc3LDE0Ljk5MTQ1MTYgMi4wODA2NDUxNiwxNC45OTE0NTE2IEMzLjIyOTU4MDY1LDE0Ljk5MTQ1MTYgNC4xNjA4Mzg3MSwxNC42OTY1MTYxIDQuMTYwODM4NzEsMTQuMzMyNDgzOSBDNC4xNjA4Mzg3MSwxMy45NjgyNTgxIDMuMjI5NTgwNjUsMTMuNjczMjkwMyAyLjA4MDY0NTE2LDEzLjY3MzI5MDMgTDIuMDgwNjQ1MTYsMTMuNjczMjkwMyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0ZWQgYnkgSWNvTW9vbi5pbyAtLT4KPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNSIgaGVpZ2h0PSIxNSIgdmlld0JveD0iMCAwIDE2IDE2Ij4KPHBhdGggZmlsbD0iIzAwMDAwMCIgZD0iTTguMSAxNGw2LjQtNy4yYzAuNi0wLjcgMC42LTEuOC0wLjEtMi41bC0yLjctMi43Yy0wLjMtMC40LTAuOC0wLjYtMS4zLTAuNmgtMS44Yy0wLjUgMC0xIDAuMi0xLjQgMC42bC02LjcgNy42Yy0wLjYgMC43LTAuNiAxLjkgMC4xIDIuNWwyLjcgMi43YzAuMyAwLjQgMC44IDAuNiAxLjMgMC42aDExLjR2LTFoLTcuOXpNNi44IDEzLjljMCAwIDAtMC4xIDAgMGwtMi43LTIuN2MtMC40LTAuNC0wLjQtMC45IDAtMS4zbDMuNC0zLjloLTFsLTMgMy4zYy0wLjYgMC43LTAuNiAxLjcgMC4xIDIuNGwyLjMgMi4zaC0xLjNjLTAuMiAwLTAuNC0wLjEtMC42LTAuMmwtMi44LTIuOGMtMC4zLTAuMy0wLjMtMC44IDAtMS4xbDMuNS0zLjloMS44bDMuNS00aDFsLTMuNSA0IDMuMSAzLjctMy41IDRjLTAuMSAwLjEtMC4yIDAuMS0wLjMgMC4yeiI+PC9wYXRoPgo8L3N2Zz4K"},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+bGluazwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJsaW5rIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IkNhcGFfMSI+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuOTY3LDAuOTUgQzEzLjM1NTUsMC4zMzg1IDEyLjUzOTc1LDAuMDAxNzUgMTEuNjY5NzUsMC4wMDE3NSBDMTAuOCwwLjAwMTc1IDkuOTg0LDAuMzM4NSA5LjM3MjUsMC45NSBMNy4xMDUsMy4yMTc1IEM2LjI4NjI1LDQuMDM2MjUgNiw1LjE4NjUgNi4yMzk3NSw2LjI0IEM2LjAwNDUsNi4xODcgNS43NjIyNSw2LjE1Njc1IDUuNTE0NzUsNi4xNTY3NSBDNC42NDUsNi4xNTY3NSAzLjgyOSw2LjQ5MzUgMy4yMTc3NSw3LjEwNSBMMC45NSw5LjM3Mjc1IEMtMC4zMTY1LDEwLjYzOTI1IC0wLjMxNjUsMTIuNzAwNzUgMC45NSwxMy45NjcyNSBDMS41NjE1LDE0LjU3ODc1IDIuMzc3MjUsMTQuOTE1NSAzLjI0NzI1LDE0LjkxNTUgQzQuMTE3MjUsMTQuOTE1NSA0LjkzMywxNC41Nzg3NSA1LjU0NDUsMTMuOTY3MjUgTDcuODEyLDExLjY5OTc1IEM4LjYzMDc1LDEwLjg4MSA4LjkxNyw5LjczMDc1IDguNjc3MjUsOC42NzcyNSBDOC45MTI1LDguNzMwMjUgOS4xNTQ3NSw4Ljc2MDUgOS40MDIyNSw4Ljc2MDUgQzEwLjI3MjI1LDguNzYwNSAxMS4wODgyNSw4LjQyMzc1IDExLjY5OTUsNy44MTIyNSBMMTMuOTY3MjUsNS41NDQ3NSBDMTUuMjM0LDQuMjc4IDE1LjIzNCwyLjIxNjc1IDEzLjk2NywwLjk1IEwxMy45NjcsMC45NSBaIE03LjEwNSwxMC45OTI1IEw0LjgzNzUsMTMuMjYgQzQuNDE1LDEzLjY4MjUgMy44NSwxMy45MTUyNSAzLjI0NzI1LDEzLjkxNTI1IEMyLjY0NDUsMTMuOTE1MjUgMi4wNzk3NSwxMy42ODI1IDEuNjU3LDEzLjI2IEMwLjc4MDI1LDEyLjM4MyAwLjc4MDI1LDEwLjk1NjUgMS42NTcsMTAuMDc5NSBMMy45MjQ3NSw3LjgxMiBDNC4zNDcyNSw3LjM4OTUgNC45MTIsNy4xNTY3NSA1LjUxNDc1LDcuMTU2NzUgQzUuOTQ1NzUsNy4xNTY3NSA2LjM1NjI1LDcuMjc3NSA2LjcxMDI1LDcuNDk5NzUgTDQuNzcyMjUsOS40Mzc3NSBDNC41NzcsOS42MzMgNC41NzcsOS45NDk1IDQuNzcyMjUsMTAuMTQ0NzUgQzQuODY5NzUsMTAuMjQyNSA0Ljk5Nzc1LDEwLjI5MTI1IDUuMTI1NzUsMTAuMjkxMjUgQzUuMjUzNzUsMTAuMjkxMjUgNS4zODE3NSwxMC4yNDI1IDUuNDc5MjUsMTAuMTQ0NzUgTDcuNDE3NSw4LjIwNjUgQzcuOTYzLDkuMDc1IDcuODYsMTAuMjM3MjUgNy4xMDUsMTAuOTkyNSBMNy4xMDUsMTAuOTkyNSBaIE0xMy4yNiw0LjgzNzUgTDEwLjk5MjI1LDcuMTA1IEMxMC41Njk3NSw3LjUyNzUgMTAuMDA1LDcuNzYwMjUgOS40MDIsNy43NjAyNSBDOC45NzEsNy43NjAyNSA4LjU2MDc1LDcuNjM5NSA4LjIwNjc1LDcuNDE3MjUgTDEwLjE0NDc1LDUuNDc5MjUgQzEwLjM0LDUuMjg0IDEwLjM0LDQuOTY3NSAxMC4xNDQ3NSw0Ljc3MjI1IEM5Ljk0OTc1LDQuNTc3IDkuNjMyNzUsNC41NzcgOS40Mzc3NSw0Ljc3MjI1IEw3LjQ5OTUsNi43MTA1IEM2Ljk1NCw1Ljg0MiA3LjA1Nyw0LjY4IDcuODEyLDMuOTI0NzUgTDEwLjA3OTUsMS42NTcyNSBDMTAuNTAyLDEuMjM0NzUgMTEuMDY3LDEuMDAyIDExLjY2OTc1LDEuMDAyIEMxMi4yNzI3NSwxLjAwMiAxMi44MzcyNSwxLjIzNDc1IDEzLjI2LDEuNjU3MjUgQzEzLjY4Mjc1LDIuMDc5NzUgMTMuOTE1MjUsMi42NDQ1IDEzLjkxNTI1LDMuMjQ3NSBDMTMuOTE1MjUsMy44NTAyNSAxMy42ODI1LDQuNDE1IDEzLjI2LDQuODM3NSBMMTMuMjYsNC44Mzc1IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+dW5saW5rPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9InVubGluayIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgIDxnIGlkPSJDYXBhXzEiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuOTU2MjcyNywxLjAzNjYzNjM2IEMxMi41NzQwOTA5LC0wLjM0NTU0NTQ1NSAxMC4zMjQ5MDkxLC0wLjM0NSA4Ljk0MjQ1NDU1LDEuMDM2NjM2MzYgTDYuNDM1NTQ1NDUsMy41NDM1NDU0NSBDNi4yMjI1NDU0NSwzLjc1NjU0NTQ1IDYuMjIyNTQ1NDUsNC4xMDE4MTgxOCA2LjQzNTU0NTQ1LDQuMzE0ODE4MTggQzYuNjQ4NTQ1NDUsNC41Mjc4MTgxOCA2Ljk5MzgxODE4LDQuNTI3ODE4MTggNy4yMDY4MTgxOCw0LjMxNDgxODE4IEw5LjcxMzcyNzI3LDEuODA3OTA5MDkgQzEwLjE3NDkwOTEsMS4zNDcgMTAuNzkxMjcyNywxLjA5MjgxODE4IDExLjQ0OTA5MDksMS4wOTI4MTgxOCBDMTIuMTA3MTgxOCwxLjA5MjgxODE4IDEyLjcyMzU0NTUsMS4zNDcgMTMuMTg0NzI3MywxLjgwODE4MTgyIEMxMy42NDU5MDkxLDIuMjY5MzYzNjQgMTMuOTAwMDkwOSwyLjg4NTcyNzI3IDEzLjkwMDA5MDksMy41NDM4MTgxOCBDMTMuOTAwMDkwOSw0LjIwMTYzNjM2IDEzLjY0NTkwOTEsNC44MTggMTMuMTg0NzI3Myw1LjI3OTE4MTgyIEw5LjkwNjgxODE4LDguNTU3OTA5MDkgQzguOTQ5NTQ1NDUsOS41MTQ2MzYzNiA3LjM5MjU0NTQ1LDkuNTE0NjM2MzYgNi40MzUyNzI3Myw4LjU1NzkwOTA5IEM2LjIyMjI3MjczLDguMzQ0OTA5MDkgNS44NzcsOC4zNDQ5MDkwOSA1LjY2NCw4LjU1NzkwOTA5IEM1LjQ1MSw4Ljc3MDkwOTA5IDUuNDUxLDkuMTE2NDU0NTUgNS42NjQsOS4zMjkxODE4MiBDNi4zNTUwOTA5MSwxMC4wMjAyNzI3IDcuMjYzLDEwLjM2NTgxODIgOC4xNzA5MDkwOSwxMC4zNjU4MTgyIEM5LjA3ODgxODE4LDEwLjM2NTgxODIgOS45ODY3MjcyNywxMC4wMjAyNzI3IDEwLjY3NzgxODIsOS4zMjkxODE4MiBMMTMuOTU2MjcyNyw2LjA1MDcyNzI3IEMxNC42MjM2MzY0LDUuMzgzNjM2MzYgMTQuOTkxMjcyNyw0LjQ5MzE4MTgyIDE0Ljk5MTI3MjcsMy41NDM4MTgxOCBDMTQuOTkxMjcyNywyLjU5NDE4MTgyIDE0LjYyMzYzNjQsMS43MDQgMTMuOTU2MjcyNywxLjAzNjYzNjM2IEwxMy45NTYyNzI3LDEuMDM2NjM2MzYgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTcuMzk5NjM2MzYsMTEuMDY0NTQ1NSBMNS4yNzgzNjM2NCwxMy4xODU4MTgyIEM0LjgxNzE4MTgyLDEzLjY0NyA0LjIwMDgxODE4LDEzLjkwMTE4MTggMy41NDI3MjcyNywxMy45MDExODE4IEMyLjg4NDkwOTA5LDEzLjkwMTE4MTggMi4yNjgyNzI3MywxMy42NDcgMS44MDcwOTA5MSwxMy4xODU4MTgyIEMwLjg1MDA5MDkwOSwxMi4yMjg4MTgyIDAuODUwMDkwOTA5LDEwLjY3MTU0NTUgMS44MDcwOTA5MSw5LjcxNDU0NTQ1IEw0Ljg5MjcyNzI3LDYuNjI4OTA5MDkgQzUuMzUzOTA5MDksNi4xNjggNS45NzAyNzI3Myw1LjkxMzgxODE4IDYuNjI4MzYzNjQsNS45MTM4MTgxOCBDNy4yODYxODE4Miw1LjkxMzgxODE4IDcuOTAyNTQ1NDUsNi4xNjggOC4zNjM3MjcyNyw2LjYyODkwOTA5IEM4LjU3NjcyNzI3LDYuODQxOTA5MDkgOC45MjIsNi44NDE5MDkwOSA5LjEzNSw2LjYyODkwOTA5IEM5LjM0OCw2LjQxNTkwOTA5IDkuMzQ4LDYuMDcwNjM2MzYgOS4xMzUsNS44NTc2MzYzNiBDNy43NTMwOTA5MSw0LjQ3NTcyNzI3IDUuNTAzOTA5MDksNC40NzU0NTQ1NSA0LjEyMTE4MTgyLDUuODU3NjM2MzYgTDEuMDM1NTQ1NDUsOC45NDM1NDU0NSBDMC4zNjg0NTQ1NDUsOS42MTA2MzYzNiAwLjAwMDgxODE4MTgxOCwxMC41MDEwOTA5IDAuMDAwODE4MTgxODE4LDExLjQ1MDQ1NDUgQzAuMDAwODE4MTgxODE4LDEyLjM5OTU0NTUgMC4zNjg0NTQ1NDUsMTMuMjkgMS4wMzU4MTgxOCwxMy45NTcwOTA5IEMxLjcwMjkwOTA5LDE0LjYyNDQ1NDUgMi41OTMzNjM2NCwxNC45OTIwOTA5IDMuNTQyNDU0NTUsMTQuOTkyMDkwOSBDNC40OTE4MTgxOCwxNC45OTIwOTA5IDUuMzgyMjcyNzMsMTQuNjI0NDU0NSA2LjA0OTM2MzY0LDEzLjk1NzA5MDkgTDguMTcwNjM2MzYsMTEuODM1ODE4MiBDOC4zODM2MzYzNiwxMS42MjI4MTgyIDguMzgzNjM2MzYsMTEuMjc3NTQ1NSA4LjE3MDYzNjM2LDExLjA2NDU0NTUgQzcuOTU3NjM2MzYsMTAuODUxNTQ1NSA3LjYxMjYzNjM2LDEwLjg1MTU0NTUgNy4zOTk2MzYzNiwxMS4wNjQ1NDU1IEw3LjM5OTYzNjM2LDExLjA2NDU0NTUgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTkuMjczNTQ1NDUsMTIuMDAxOTA5MSBDOC45NzI0NTQ1NSwxMi4wMDE5MDkxIDguNzI4MDkwOTEsMTIuMjQ2MjcyNyA4LjcyODA5MDkxLDEyLjU0NzM2MzYgTDguNzI4MDkwOTEsMTQuMTgzNzI3MyBDOC43MjgwOTA5MSwxNC40ODQ4MTgyIDguOTcyNDU0NTUsMTQuNzI5MTgxOCA5LjI3MzU0NTQ1LDE0LjcyOTE4MTggQzkuNTc0NjM2MzYsMTQuNzI5MTgxOCA5LjgxOSwxNC40ODQ4MTgyIDkuODE5LDE0LjE4MzcyNzMgTDkuODE5LDEyLjU0NzM2MzYgQzkuODE5LDEyLjI0NiA5LjU3NDkwOTA5LDEyLjAwMTkwOTEgOS4yNzM1NDU0NSwxMi4wMDE5MDkxIEw5LjI3MzU0NTQ1LDEyLjAwMTkwOTEgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExLjIyOTU0NTUsMTEuNjE2MjcyNyBDMTEuMDE2NTQ1NSwxMS40MDMyNzI3IDEwLjY3MTI3MjcsMTEuNDAzMjcyNyAxMC40NTgyNzI3LDExLjYxNjI3MjcgQzEwLjI0NTI3MjcsMTEuODI5MjcyNyAxMC4yNDUyNzI3LDEyLjE3NDU0NTUgMTAuNDU4MjcyNywxMi4zODc1NDU1IEwxMS42MTUxODE4LDEzLjU0NDQ1NDUgQzExLjcyMTgxODIsMTMuNjUxMDkwOSAxMS44NjExODE4LDEzLjcwNDI3MjcgMTIuMDAwODE4MiwxMy43MDQyNzI3IEMxMi4xNDA0NTQ1LDEzLjcwNDI3MjcgMTIuMjc5ODE4MiwxMy42NTEwOTA5IDEyLjM4NjQ1NDUsMTMuNTQ0NDU0NSBDMTIuNTk5NDU0NSwxMy4zMzE0NTQ1IDEyLjU5OTQ1NDUsMTIuOTg2MTgxOCAxMi4zODY0NTQ1LDEyLjc3MzE4MTggTDExLjIyOTU0NTUsMTEuNjE2MjcyNyBMMTEuMjI5NTQ1NSwxMS42MTYyNzI3IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMi41MzY3MjczLDkuODIwMDkwOTEgTDEwLjkwMDM2MzYsOS44MjAwOTA5MSBDMTAuNTk5MjcyNyw5LjgyMDA5MDkxIDEwLjM1NDkwOTEsMTAuMDY0NDU0NSAxMC4zNTQ5MDkxLDEwLjM2NTU0NTUgQzEwLjM1NDkwOTEsMTAuNjY2NjM2NCAxMC41OTkyNzI3LDEwLjkxMSAxMC45MDAzNjM2LDEwLjkxMSBMMTIuNTM2NzI3MywxMC45MTEgQzEyLjgzNzgxODIsMTAuOTExIDEzLjA4MjE4MTgsMTAuNjY2NjM2NCAxMy4wODIxODE4LDEwLjM2NTU0NTUgQzEzLjA4MjE4MTgsMTAuMDY0NDU0NSAxMi44MzgwOTA5LDkuODIwMDkwOTEgMTIuNTM2NzI3Myw5LjgyMDA5MDkxIEwxMi41MzY3MjczLDkuODIwMDkwOTEgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQuOTA5OTA5MDksMy41NDczNjM2NCBDNS4yMTEsMy41NDczNjM2NCA1LjQ1NTM2MzY0LDMuMzAzIDUuNDU1MzYzNjQsMy4wMDE5MDkwOSBMNS40NTUzNjM2NCwxLjM2NTU0NTQ1IEM1LjQ1NTM2MzY0LDEuMDY0NDU0NTUgNS4yMTEsMC44MjAwOTA5MDkgNC45MDk5MDkwOSwwLjgyMDA5MDkwOSBDNC42MDg4MTgxOCwwLjgyMDA5MDkwOSA0LjM2NDQ1NDU1LDEuMDY0NDU0NTUgNC4zNjQ0NTQ1NSwxLjM2NTU0NTQ1IEw0LjM2NDQ1NDU1LDMuMDAxOTA5MDkgQzQuMzY0NDU0NTUsMy4zMDMgNC42MDg4MTgxOCwzLjU0NzM2MzY0IDQuOTA5OTA5MDksMy41NDczNjM2NCBMNC45MDk5MDkwOSwzLjU0NzM2MzY0IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yLjg4NzkwOTA5LDMuOTMzIEMyLjk5NDU0NTQ1LDQuMDM5NjM2MzYgMy4xMzM5MDkwOSw0LjA5MjgxODE4IDMuMjczNTQ1NDUsNC4wOTI4MTgxOCBDMy40MTMxODE4Miw0LjA5MjgxODE4IDMuNTUyNTQ1NDUsNC4wMzk2MzYzNiAzLjY1OTE4MTgyLDMuOTMzIEMzLjg3MjE4MTgyLDMuNzIgMy44NzIxODE4MiwzLjM3NDcyNzI3IDMuNjU5MTgxODIsMy4xNjE3MjcyNyBMMi41MDIyNzI3MywyLjAwNDU0NTQ1IEMyLjI4OTI3MjczLDEuNzkxNTQ1NDUgMS45NDQsMS43OTE1NDU0NSAxLjczMSwyLjAwNDU0NTQ1IEMxLjUxOCwyLjIxNzU0NTQ1IDEuNTE4LDIuNTYyODE4MTggMS43MzEsMi43NzU4MTgxOCBMMi44ODc5MDkwOSwzLjkzMyBMMi44ODc5MDkwOSwzLjkzMyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMS42Mjc2MzYzNiw1LjcyOTE4MTgyIEwzLjI2NCw1LjcyOTE4MTgyIEMzLjU2NTA5MDkxLDUuNzI5MTgxODIgMy44MDk0NTQ1NSw1LjQ4NDgxODE4IDMuODA5NDU0NTUsNS4xODM3MjcyNyBDMy44MDk0NTQ1NSw0Ljg4MjYzNjM2IDMuNTY1MDkwOTEsNC42MzgyNzI3MyAzLjI2NCw0LjYzODI3MjczIEwxLjYyNzYzNjM2LDQuNjM4MjcyNzMgQzEuMzI2NTQ1NDUsNC42MzgyNzI3MyAxLjA4MjE4MTgyLDQuODgyNjM2MzYgMS4wODIxODE4Miw1LjE4MzcyNzI3IEMxLjA4MjE4MTgyLDUuNDg0ODE4MTggMS4zMjY1NDU0NSw1LjcyOTE4MTgyIDEuNjI3NjM2MzYsNS43MjkxODE4MiBMMS42Mjc2MzYzNiw1LjcyOTE4MTgyIFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iMTYuOTk5OTgyODMzODYyMzA1IiBoZWlnaHQ9IjE2Ljk5OTk4MDkyNjUxMzY3MiIgdmlld0JveD0iMTUuNzI4OSAyMi4wODI0IDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMTY1NTE1OTg5MDY1MTcwMywgMCwgMCwgMC4xNjU1MTU5ODkwNjUxNzAzLCAxNi41ODUwNjc3NDkwMjM0MzgsIDIyLjkzODQyNjk3MTQzNTU0NykiPgogICAgPHBhdGggZD0iTSA3OS4yODUgMTMuMDg0IEMgNjEuMDMxIC01LjE3MiAzMS4zMzIgLTUuMTcyIDEzLjA4MSAxMy4wOCBDIC01LjE3MyAzMS4zMzEgLTUuMTcxIDYxLjAzMSAxMy4wODMgNzkuMjg2IEMgMzEuMzMyIDk3LjUzNyA2MS4wMzEgOTcuNTM3IDc5LjI4MyA3OS4yODMgQyA5Ny41MzYgNjEuMDMxIDk3LjUzNSAzMS4zMzMgNzkuMjg1IDEzLjA4NCBaIE0gNzQuMTc3IDc0LjE3OCBDIDU4Ljc0MSA4OS42MTQgMzMuNjI1IDg5LjYxNiAxOC4xODcgNzQuMTggQyAyLjc0OCA1OC43NDIgMi43NSAzMy42MjIgMTguMTg3IDE4LjE4NiBDIDMzLjYyMyAyLjc1MSA1OC43NCAyLjc0OSA3NC4xNzkgMTguMTg4IEMgODkuNjE1IDMzLjYyMyA4OS42MTMgNTguNzQzIDc0LjE3NyA3NC4xNzggWiBNIDI4LjcyMSAzMy41MTMgQyAyOC43MjEgMzAuNDkyIDMxLjE3MSAyOC4wNDIgMzQuMTkyIDI4LjA0MiBDIDM3LjIxMyAyOC4wNDIgMzkuNjYzIDMwLjQ5MSAzOS42NjMgMzMuNTEzIEMgMzkuNjYzIDM2LjUzNiAzNy4yMTMgMzguOTg2IDM0LjE5MiAzOC45ODYgQyAzMS4xNzEgMzguOTg2IDI4LjcyMSAzNi41MzYgMjguNzIxIDMzLjUxMyBaIE0gNTMuNTMgMzMuNTEzIEMgNTMuNTMgMzAuNDkyIDU1Ljk4MiAyOC4wNDIgNTkuMDA0IDI4LjA0MiBDIDYyLjAyNCAyOC4wNDIgNjQuNDc0IDMwLjQ5MSA2NC40NzQgMzMuNTEzIEMgNjQuNDc0IDM2LjUzNiA2Mi4wMjUgMzguOTg2IDU5LjAwNCAzOC45ODYgQyA1NS45ODIgMzguOTg2IDUzLjUzIDM2LjUzNiA1My41MyAzMy41MTMgWiBNIDY2LjQ2NSA1NS45MjIgQyA2My4wNzUgNjMuNzY0IDU1LjEzNCA2OC44MyA0Ni4yMzYgNjguODMgQyAzNy4xNDcgNjguODMgMjkuMTU5IDYzLjczOCAyNS44ODUgNTUuODU3IEMgMjUuMzI0IDU0LjUwOCAyNS45NjQgNTIuOTU5IDI3LjMxNCA1Mi4zOTcgQyAyNy42NDYgNTIuMjYgMjcuOTkgNTIuMTk2IDI4LjMyOSA1Mi4xOTYgQyAyOS4zNjcgNTIuMTk2IDMwLjM1MiA1Mi44MDggMzAuNzc0IDUzLjgyNyBDIDMzLjIyNCA1OS43MjcgMzkuMjkzIDYzLjUzNyA0Ni4yMzYgNjMuNTM3IEMgNTMuMDIxIDYzLjUzNyA1OS4wNTQgNTkuNzI0IDYxLjYwNiA1My44MjEgQyA2Mi4xODcgNTIuNDggNjMuNzQ1IDUxLjg2MSA2NS4wODcgNTIuNDQyIEMgNjYuNDI3IDUzLjAyNCA2Ny4wNDYgNTQuNTgxIDY2LjQ2NSA1NS45MjIgWiIvPgogIDwvZz4KPC9zdmc+"},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iMTYuOTk5OTM3MDU3NDk1MTE3IiBoZWlnaHQ9IjE2Ljk5OTkzNzA1NzQ5NTExNyIgdmlld0JveD0iNS44MTI3NmUtNyAzLjA1NDIwZS04IDE2Ljk5OTkgMTYuOTk5OSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSI+CiAgICA8Zz4KICAgICAgPHBhdGggZD0iTTIwMi4wNDIsMTk5LjIzOGMtNi45MzgtMi4xMDMtMTQuMjY4LDEuODItMTYuMzcxLDguNzU5bC01NS4xMzgsMTgyLjA0NWMtMi4xMDIsNi45MzgsMS44MiwxNC4yNjgsOC43NTksMTYuMzcmIzEwOyYjOTsmIzk7JiM5O2MxLjI3LDAuMzg1LDIuNTQ5LDAuNTY4LDMuODExLDAuNTY4YzUuNjMzLDAsMTAuODQxLTMuNjU2LDEyLjU2LTkuMzI2bDU1LjEzOC0xODIuMDQ1JiMxMDsmIzk7JiM5OyYjOTtDMjEyLjkwMSwyMDguNjY4LDIwOC45ODEsMjAxLjMzOCwyMDIuMDQyLDE5OS4yMzh6Ii8+CiAgICA8L2c+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIj4KICAgIDxnPgogICAgICA8cGF0aCBkPSJNMjY4Ljk5NCwxOTkuMjM4Yy02LjkzLTIuMTAzLTE0LjI2OCwxLjgyLTE2LjM3LDguNzU5bC01NS4xMzgsMTgyLjA0NWMtMi4xMDIsNi45MzgsMS44MiwxNC4yNjgsOC43NTksMTYuMzcmIzEwOyYjOTsmIzk7JiM5O2MxLjI2OSwwLjM4NSwyLjU0OSwwLjU2OCwzLjgxMSwwLjU2OGM1LjYzMywwLDEwLjg0MS0zLjY1NiwxMi41Ni05LjMyNmw1NS4xMzgtMTgyLjA0NSYjMTA7JiM5OyYjOTsmIzk7QzI3OS44NTcsMjA4LjY2OCwyNzUuOTM1LDIwMS4zMzgsMjY4Ljk5NCwxOTkuMjM4eiIvPgogICAgPC9nPgogIDwvZz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSI+CiAgICA8Zz4KICAgICAgPHBhdGggZD0iTTQ5OC44NzIsMEgxMy4xMjhDNS44NzgsMCwwLDUuODc5LDAsMTMuMTI4djQ4NS43NDRDMCw1MDYuMTIxLDUuODc4LDUxMiwxMy4xMjgsNTEyaDQ4NS43NDQmIzEwOyYjOTsmIzk7JiM5O2M3LjI0OSwwLDEzLjEyOC01Ljg3OSwxMy4xMjgtMTMuMTI4VjEzLjEyOEM1MTIsNS44NzksNTA2LjEyMSwwLDQ5OC44NzIsMHogTTEwNS4wMjYsMjYuMjU2aDMwMS45NDl2NTIuNTEzSDEwNS4wMjZWMjYuMjU2eiYjMTA7JiM5OyYjOTsmIzk7IE0yNi4yNTYsMjYuMjU2aDUyLjUxM3Y1Mi41MTNIMjYuMjU2VjI2LjI1NnogTTQ4NS43NDQsNDg1Ljc0NEgyNi4yNTZWMTA1LjAyNmg0NTkuNDg3VjQ4NS43NDR6IE00ODUuNzQ0LDc4Ljc2OWgtNTIuNTEzVjI2LjI1NiYjMTA7JiM5OyYjOTsmIzk7aDUyLjUxM1Y3OC43Njl6Ii8+CiAgICA8L2c+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIj4KICAgIDxnPgogICAgICA8Y2lyY2xlIGN4PSI5My44NjciIGN5PSIyNDUuMDY0IiByPSIxMy4xMjgiLz4KICAgIDwvZz4KICA8L2c+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzMyMDI5OTgzNDAxMjk4NSwgMCwgMCwgMC4wMzMyMDI5OTgzNDAxMjk4NSwgLTIuODQyMTcwOTQzMDQwNDAxZS0xNCwgMCkiPgogICAgPGc+CiAgICAgIDxjaXJjbGUgY3g9IjkzLjg2NyIgY3k9IjM2MC41OTIiIHI9IjEzLjEyOCIvPgogICAgPC9nPgogIDwvZz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSI+CiAgICA8Zz4KICAgICAgPHBhdGggZD0iTTQyOS4yOTIsMzgwLjcxOEgzMDcuMmMtNy4yNDksMC0xMy4xMjgsNS44NzktMTMuMTI4LDEzLjEyOGMwLDcuMjQ5LDUuODc5LDEzLjEyOCwxMy4xMjgsMTMuMTI4aDEyMi4wOTImIzEwOyYjOTsmIzk7JiM5O2M3LjI0OSwwLDEzLjEyOC01Ljg3OSwxMy4xMjgtMTMuMTI4QzQ0Mi40MjEsMzg2LjU5Nyw0MzYuNTQyLDM4MC43MTgsNDI5LjI5MiwzODAuNzE4eiIvPgogICAgPC9nPgogIDwvZz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzMyMDI5OTgzNDAxMjk4NSwgMCwgMCwgMC4wMzMyMDI5OTgzNDAxMjk4NSwgLTIuODQyMTcwOTQzMDQwNDAxZS0xNCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzMyMDI5OTgzNDAxMjk4NSwgMCwgMCwgMC4wMzMyMDI5OTgzNDAxMjk4NSwgLTIuODQyMTcwOTQzMDQwNDAxZS0xNCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzMyMDI5OTgzNDAxMjk4NSwgMCwgMCwgMC4wMzMyMDI5OTgzNDAxMjk4NSwgLTIuODQyMTcwOTQzMDQwNDAxZS0xNCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzMyMDI5OTgzNDAxMjk4NSwgMCwgMCwgMC4wMzMyMDI5OTgzNDAxMjk4NSwgLTIuODQyMTcwOTQzMDQwNDAxZS0xNCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzMyMDI5OTgzNDAxMjk4NSwgMCwgMCwgMC4wMzMyMDI5OTgzNDAxMjk4NSwgLTIuODQyMTcwOTQzMDQwNDAxZS0xNCwgMCkiLz4KPC9zdmc+"},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTRweCIgdmlld0JveD0iMCAwIDE1IDE0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+aW1hZ2U8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iaW1hZ2UiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICA8ZyBpZD0iQ2FwYV8xIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0Ljc0MTM3OTMsMCBMMC4yNTg2MjA2OSwwIEMwLjExNTg2MjA2OSwwIDAsMC4xMzYwNDM0NzggMCwwLjMwNDM0NzgyNiBMMCwxMy42OTU2NTIyIEMwLDEzLjg2Mzk1NjUgMC4xMTU4NjIwNjksMTQgMC4yNTg2MjA2OSwxNCBMMTQuNzQxMzc5MywxNCBDMTQuODg0MTM3OSwxNCAxNSwxMy44NjM5NTY1IDE1LDEzLjY5NTY1MjIgTDE1LDAuMzA0MzQ3ODI2IEMxNSwwLjEzNjA0MzQ3OCAxNC44ODQxMzc5LDAgMTQuNzQxMzc5MywwIEwxNC43NDEzNzkzLDAgWiBNMTQuNDgyNzU4NiwxMy4zOTEzMDQzIEwwLjUxNzI0MTM3OSwxMy4zOTEzMDQzIEwwLjUxNzI0MTM3OSwwLjYwODY5NTY1MiBMMTQuNDgyNzU4NiwwLjYwODY5NTY1MiBMMTQuNDgyNzU4NiwxMy4zOTEzMDQzIEwxNC40ODI3NTg2LDEzLjM5MTMwNDMgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQuMTM3OTMxMDMsNi43Mzc2NTIxNyBDNC45MzIxNTUxNyw2LjczNzY1MjE3IDUuNTc4MTg5NjYsNS45NzczOTEzIDUuNTc4MTg5NjYsNS4wNDMwNDM0OCBDNS41NzgxODk2Niw0LjEwODA4Njk2IDQuOTMyMTU1MTcsMy4zNDc4MjYwOSA0LjEzNzkzMTAzLDMuMzQ3ODI2MDkgQzMuMzQzNzA2OSwzLjM0NzgyNjA5IDIuNjk3NjcyNDEsNC4xMDgwODY5NiAyLjY5NzY3MjQxLDUuMDQyNzM5MTMgQzIuNjk3NjcyNDEsNS45NzczOTEzIDMuMzQzNzA2OSw2LjczNzY1MjE3IDQuMTM3OTMxMDMsNi43Mzc2NTIxNyBMNC4xMzc5MzEwMyw2LjczNzY1MjE3IFogTTQuMTM3OTMxMDMsMy45NTY1MjE3NCBDNC42NDY4OTY1NSwzLjk1NjUyMTc0IDUuMDYwOTQ4MjgsNC40NDQwODY5NiA1LjA2MDk0ODI4LDUuMDQyNzM5MTMgQzUuMDYwOTQ4MjgsNS42NDEzOTEzIDQuNjQ2ODk2NTUsNi4xMjg5NTY1MiA0LjEzNzkzMTAzLDYuMTI4OTU2NTIgQzMuNjI4OTY1NTIsNi4xMjg5NTY1MiAzLjIxNDkxMzc5LDUuNjQxNjk1NjUgMy4yMTQ5MTM3OSw1LjA0MzA0MzQ4IEMzLjIxNDkxMzc5LDQuNDQ0MzkxMyAzLjYyODk2NTUyLDMuOTU2NTIxNzQgNC4xMzc5MzEwMywzLjk1NjUyMTc0IEw0LjEzNzkzMTAzLDMuOTU2NTIxNzQgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEuODEwMzQ0ODMsMTIuMTczOTEzIEMxLjg3MDg2MjA3LDEyLjE3MzkxMyAxLjkzMTg5NjU1LDEyLjE0ODk1NjUgMS45ODEwMzQ0OCwxMi4wOTgxMzA0IEw2LjE5OTkxMzc5LDcuNzI3MDg2OTYgTDguODY0MjI0MTQsMTAuODYyMTczOSBDOC45NjUzNDQ4MywxMC45ODExNzM5IDkuMTI4NzkzMSwxMC45ODExNzM5IDkuMjI5OTEzNzksMTAuODYyMTczOSBDOS4zMzEwMzQ0OCwxMC43NDMxNzM5IDkuMzMxMDM0NDgsMTAuNTUwODI2MSA5LjIyOTkxMzc5LDEwLjQzMTgyNjEgTDcuOTg2NzI0MTQsOC45Njg4MjYwOSBMMTAuMzYxMTIwNyw1LjkwODkxMzA0IEwxMy4yNzM0NDgzLDkuMDUwNjk1NjUgQzEzLjM3ODcwNjksOS4xNjQyMTczOSAxMy41NDI0MTM4LDkuMTU1Njk1NjUgMTMuNjM4ODc5Myw5LjAzMTgyNjA5IEMxMy43MzUzNDQ4LDguOTA3OTU2NTIgMTMuNzI4MzYyMSw4LjcxNTMwNDM1IDEzLjYyMjg0NDgsOC42MDE3ODI2MSBMMTAuNTE5Mzk2Niw1LjI1Mzk1NjUyIEMxMC40Njg3MDY5LDUuMTk5NDc4MjYgMTAuNDAxMjA2OSw1LjE3MjM5MTMgMTAuMzMzMTg5Nyw1LjE3NDIxNzM5IEMxMC4yNjQ2NTUyLDUuMTc3ODY5NTcgMTAuMiw1LjIxMzQ3ODI2IDEwLjE1MzcwNjksNS4yNzMxMzA0MyBMNy42MjA3NzU4Niw4LjUzNzg2OTU3IEw2LjM5NDEzNzkzLDcuMDk0MzQ3ODMgQzYuMjk3NDEzNzksNi45ODA4MjYwOSA2LjE0Mjc1ODYyLDYuOTc1MDQzNDggNi4wNDAzNDQ4Myw3LjA4MDk1NjUyIEwxLjYzOTM5NjU1LDExLjY0MSBDMS41MzIwNjg5NywxMS43NTIwODcgMS41MjE3MjQxNCwxMS45NDQ0MzQ4IDEuNjE2MTIwNjksMTIuMDcwNzM5MSBDMS42NjczMjc1OSwxMi4xMzkyMTc0IDEuNzM4NzA2OSwxMi4xNzM5MTMgMS44MTAzNDQ4MywxMi4xNzM5MTMgTDEuODEwMzQ0ODMsMTIuMTczOTEzIFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE0cHgiIGhlaWdodD0iMTdweCIgdmlld0JveD0iMCAwIDE0IDE3IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+dW5kbzwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJ1bmRvIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IkNhcGFfMSI+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNywxNC44NzUgQzkuNjcyMzE3MzEsMTQuODc1IDExLjg0NjE1MzgsMTIuNzMwMjc3MyAxMS44NDYxNTM4LDEwLjA5Mzc1IEMxMS44NDYxNTM4LDcuNDU3MjIyNjYgOS42NzIzMTczMSw1LjMxMjUgNyw1LjMxMjUgTDcsOC41IEwxLjYxNTM4NDYyLDQuMjUgTDcsMCBMNywzLjE4NzUgQzEwLjg1OTY5MjMsMy4xODc1IDE0LDYuMjg1NzgzMiAxNCwxMC4wOTM3NSBDMTQsMTMuOTAxNzUgMTAuODU5NjkyMywxNyA3LDE3IEMzLjE0MDM0MTM1LDE3IDAsMTMuOTAxNzUgMCwxMC4wOTM3NSBMMi4xNTM4NDYxNSwxMC4wOTM3NSBDMi4xNTM4NDYxNSwxMi43MzAyNzczIDQuMzI3NjgyNjksMTQuODc1IDcsMTQuODc1IEw3LDE0Ljg3NSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjEzcHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDEzIDE2IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+cmVkbzwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJyZWRvIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IkNhcGFfMSI+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNi41MDM1MjE1MiwxMy45NzcyNTEgQzQuMDI2ODczNDIsMTMuOTc3MjUxIDIuMDEyMTY5NjIsMTEuOTYyMTM5OSAyLjAxMjE2OTYyLDkuNDg0NTc2MTMgQzIuMDEyMTY5NjIsNy4wMDcxNDQwMyA0LjAyNjg3MzQyLDQuOTkxODY4MzEgNi41MDM1MjE1Miw0Ljk5MTg2ODMxIEw2LjUwMzUyMTUyLDcuOTg3MDI4ODEgTDExLjQ5Mzg0MywzLjk5MzU0NzMzIEw2LjUwMzUyMTUyLDAgTDYuNTAzNTIxNTIsMi45OTUxNjA0OSBDMi45MjY0ODEwMSwyLjk5NTE2MDQ5IDAuMDE2MTI2NTgyMyw1LjkwNjUwMjA2IDAuMDE2MTI2NTgyMyw5LjQ4NDYwOTA1IEMwLjAxNjEyNjU4MjMsMTMuMDYyOTEzNiAyLjkyNjQ4MTAxLDE1Ljk3NDA5MDUgNi41MDM1MjE1MiwxNS45NzQwOTA1IEMxMC4wODA1NjIsMTUuOTc0MDkwNSAxMi45OTA4MTc3LDEzLjA2MjkxMzYgMTIuOTkwODE3Nyw5LjQ4NDYwOTA1IEwxMC45OTQ5MDYzLDkuNDg0NjA5MDUgQzEwLjk5NDkzOTIsMTEuOTYyMTM5OSA4Ljk4MDE2OTYyLDEzLjk3NzI1MSA2LjUwMzUyMTUyLDEzLjk3NzI1MSBMNi41MDM1MjE1MiwxMy45NzcyNTEgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iMTYuOTk5ODQ1NTA0NzYwNzQyIiBoZWlnaHQ9IjE0Ljk5OTg1MjE4MDQ4MDk1NyIgdmlld0JveD0iMC4wMDAwMDIzMzA0MyAxLjY4NzY3ZS03IDE2Ljk5OTggMTQuOTk5OSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2ODAwMDU4NDg0MDc3NSwgMCwgMCwgMC4wMzQxNjkwMDMzNjc0MjQwMSwgMCwgMCkiPgogICAgPHBhdGggZD0iTTM0My4yNzMsMzQwLjgyNGgtODEuMTc5bC05Mi4zNzktMTA4LjM3N0w3OS40MjksMzQwLjgyNEgwbDEzMC44NjQtMTQ4LjE4N0w2LjI5NSw1Mi43OTJIODYuNDNsODYuNzk3LDEwMS4zODgmIzEwOyYjOTsmIzk7bDg3LjQ2MS0xMDEuMzg4aDc2LjYzOUwyMTEuMzUyLDE5Mi42MzdMMzQzLjI3MywzNDAuODI0eiBNMzkzLjE1NCw0MDEuMDZsNTIuODYtNDAuMDM0YzE4LjU0Mi0xMi43MzEsMzAuNzI0LTI0LjU1OSwzNi41NjMtMzUuNDY0JiMxMDsmIzk7JiM5O2M1Ljg0LTEwLjksOC43NDgtMjIuNjIxLDguNzQ4LTM1LjE3NmMwLTIwLjUwNC02Ljg1Ni0zNy4wNTUtMjAuNTU4LTQ5LjY1M2MtMTMuNzAxLTEyLjYwMi0zMS43MjMtMTguODk2LTU0LjA0OC0xOC44OTYmIzEwOyYjOTsmIzk7Yy0yMS41MjEsMC0zOC43NTEsNi4zNzItNTEuNjM2LDE5LjExMmMtMTIuOTIyLDEyLjc1LTE5LjM3LDMxLjk2LTE5LjM3LDU3LjY0OGg0MS41MjNjMC0xNS4zMjcsMi43MTMtMjUuOTI1LDguMTMzLTMxLjgwMSYjMTA7JiM5OyYjOTtjNS40MjYtNS44NzUsMTIuODYyLTguODE4LDIyLjMzMS04LjgxOGM5LjQ2MywwLDE2Ljk0LDIuOTksMjIuNDg0LDguOTYxYzUuNTA5LDUuOTcsOC4yNywxMy4zOTQsOC4yNywyMi4yNiYjMTA7JiM5OyYjOTtjMCw4Ljg1NC0yLjU1NCwxNi44NjktNy42OSwyNC4wMzljLTUuMTMsNy4xNy0xOS4zODEsMTkuMjYzLTQyLjc3NiwzNi4yODZjLTIwLjAyLDE0LjYzNS00Ny4wOTEsMjguNDMxLTU1LjIxOCw0MS4zNjMmIzEwOyYjOTsmIzk7bDAuNDA3LDQ4LjEwM2gxNDguNjAzdi0zNy45MzZoLTk4LjYyN1Y0MDEuMDZ6Ii8+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgo8L3N2Zz4="},function(e,t){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iMTYuOTk5OTMxMzM1NDQ5MjIiIGhlaWdodD0iMTUuMDAwMTk4MzY0MjU3ODEyIiB2aWV3Qm94PSItMC4wMDAwMDQxMjc5NiAyLjI2MjUzZS03IDE2Ljk5OTkgMTUuMDAwMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2MTAwMDc2NDM2OTk3LCAwLCAwLCAwLjAzMjYyNzAwMTQwNDc2MjI3LCAwLCAwKSI+CiAgICA8cGF0aCBkPSJNMjExLjM1NywzMTEuNTZsMTMxLjkyMiwxNDguMTg4aC04MS4xNzhsLTkyLjM4LTEwOC4zNzlMNzkuNDM1LDQ1OS43NDhIMEwxMzAuODYxLDMxMS41Nkw2LjMwMSwxNzEuNzE0aDgwLjEzNSYjMTA7JiM5OyYjOTtsODYuNzk0LDEwMS4zOTFsODcuNDctMTAxLjM5MWg3Ni42MzlMMjExLjM1NywzMTEuNTZ6IE0zOTEuNzM2LDIxMS4zNmw1NC4zNzMtNDAuMDMzYzE4LjU0Mi0xMi43NDEsMzAuNzI0LTI0LjU2LDM2LjU2My0zNS40NjgmIzEwOyYjOTsmIzk7YzUuODM0LTEwLjkwMiw4Ljc0OC0yMi42MTgsOC43NDgtMzUuMTcyYzAtMjAuNTA4LTYuODU2LTM3LjA2MS0yMC41NTItNDkuNjU2Yy0xMy43MDctMTIuNjAyLTMxLjcyOS0xOC44OTctNTQuMDU0LTE4Ljg5NyYjMTA7JiM5OyYjOTtjLTIxLjUyNywwLTM4Ljc0NSw2LjM3NS01MS42MzcsMTkuMTE1QzM1Mi4yNTgsNjMuOTk2LDM0NS44MSw4My4yMDYsMzQ1LjgxLDEwOC45aDQxLjUyM2MwLTE1LjMzLDIuNzE5LTI1LjkyOCw4LjE0NS0zMS44MDYmIzEwOyYjOTsmIzk7YzUuNDI2LTUuODc5LDEyLjg2MS04LjgxOSwyMi4zMzEtOC44MTljOS40NTcsMCwxNi45MjksMi45OTEsMjIuNDczLDguOTY0YzUuNTIxLDUuOTY3LDguMjc1LDEzLjM4OCw4LjI3NSwyMi4yNTcmIzEwOyYjOTsmIzk7YzAsOC44NTQtMi41NTQsMTYuODY2LTcuNjg1LDI0LjAzOXMtMTkuMzg3LDE5LjI3Mi00Mi43ODIsMzYuMjk4Yy0yMC4wMTQsMTQuNjM1LTQ3LjA5NywyOC40MjItNTUuMjE4LDQxLjM2NGwwLjQwNyw0OC4wOTMmIzEwOyYjOTsmIzk7aDE0OC42MDN2LTM3LjkzSDM5MS43MzZ6Ii8+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTYxMDAwNzY0MzY5OTcsIDAsIDAsIDAuMDMyNjI3MDAxNDA0NzYyMjcsIDAsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzQ1NjEwMDA3NjQzNjk5NywgMCwgMCwgMC4wMzI2MjcwMDE0MDQ3NjIyNywgMCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2MTAwMDc2NDM2OTk3LCAwLCAwLCAwLjAzMjYyNzAwMTQwNDc2MjI3LCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTYxMDAwNzY0MzY5OTcsIDAsIDAsIDAuMDMyNjI3MDAxNDA0NzYyMjcsIDAsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzQ1NjEwMDA3NjQzNjk5NywgMCwgMCwgMC4wMzI2MjcwMDE0MDQ3NjIyNywgMCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2MTAwMDc2NDM2OTk3LCAwLCAwLCAwLjAzMjYyNzAwMTQwNDc2MjI3LCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTYxMDAwNzY0MzY5OTcsIDAsIDAsIDAuMDMyNjI3MDAxNDA0NzYyMjcsIDAsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzQ1NjEwMDA3NjQzNjk5NywgMCwgMCwgMC4wMzI2MjcwMDE0MDQ3NjIyNywgMCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2MTAwMDc2NDM2OTk3LCAwLCAwLCAwLjAzMjYyNzAwMTQwNDc2MjI3LCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTYxMDAwNzY0MzY5OTcsIDAsIDAsIDAuMDMyNjI3MDAxNDA0NzYyMjcsIDAsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzQ1NjEwMDA3NjQzNjk5NywgMCwgMCwgMC4wMzI2MjcwMDE0MDQ3NjIyNywgMCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2MTAwMDc2NDM2OTk3LCAwLCAwLCAwLjAzMjYyNzAwMTQwNDc2MjI3LCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTYxMDAwNzY0MzY5OTcsIDAsIDAsIDAuMDMyNjI3MDAxNDA0NzYyMjcsIDAsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzQ1NjEwMDA3NjQzNjk5NywgMCwgMCwgMC4wMzI2MjcwMDE0MDQ3NjIyNywgMCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2MTAwMDc2NDM2OTk3LCAwLCAwLCAwLjAzMjYyNzAwMTQwNDc2MjI3LCAwLCAwKSIvPgo8L3N2Zz4="},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}var i=n(121),r=o(i),l=n(122),a=o(l),c=n(123),s=o(c),M=n(124),u=o(M),g=n(125),d=o(g),p=n(126),N=o(p),D=n(127),I=o(D),y=n(128),j=o(y),f=n(129),w=o(f),m=n(130),C=o(m),z=n(131),A=o(z),T=n(132),E=o(T),L=n(133),x=o(L),O=n(134),k=o(O);e.exports={en:r.default,fr:a.default,zh:s.default,ru:u.default,pt:d.default,ko:N.default,it:I.default,nl:j.default,de:w.default,da:C.default,zh_tw:A.default,pl:E.default,es:x.default,ja:k.default}},function(e,t,n){"use strict";e.exports={"generic.add":"Add","generic.cancel":"Cancel","components.controls.blocktype.h1":"H1","components.controls.blocktype.h2":"H2","components.controls.blocktype.h3":"H3","components.controls.blocktype.h4":"H4","components.controls.blocktype.h5":"H5","components.controls.blocktype.h6":"H6","components.controls.blocktype.blockquote":"Blockquote","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"Block Type","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Color Picker","components.controls.colorpicker.text":"Text","components.controls.colorpicker.background":"Highlight","components.controls.embedded.embedded":"Embedded","components.controls.embedded.embeddedlink":"Embedded Link","components.controls.embedded.enterlink":"Enter link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Font","components.controls.fontsize.fontsize":"Font Size","components.controls.history.history":"History","components.controls.history.undo":"Undo","components.controls.history.redo":"Redo","components.controls.image.image":"Image","components.controls.image.fileUpload":"File Upload","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Drop the file or click to upload","components.controls.inline.bold":"Bold","components.controls.inline.italic":"Italic","components.controls.inline.underline":"Underline","components.controls.inline.strikethrough":"Strikethrough","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Superscript","components.controls.inline.subscript":"Subscript","components.controls.link.linkTitle":"Link Title","components.controls.link.linkTarget":"Link Target","components.controls.link.linkTargetOption":"Open link in new window","components.controls.link.link":"Link","components.controls.link.unlink":"Unlink","components.controls.list.list":"List","components.controls.list.unordered":"Unordered","components.controls.list.ordered":"Ordered","components.controls.list.indent":"Indent","components.controls.list.outdent":"Outdent","components.controls.remove.remove":"Remove","components.controls.textalign.textalign":"Text Align","components.controls.textalign.left":"Left","components.controls.textalign.center":"Center","components.controls.textalign.right":"Right","components.controls.textalign.justify":"Justify"}},function(e,t,n){"use strict";e.exports={"generic.add":"Ok","generic.cancel":"Annuler","components.controls.blocktype.h1":"Titre 1","components.controls.blocktype.h2":"Titre 2","components.controls.blocktype.h3":"Titre 3","components.controls.blocktype.h4":"Titre 4","components.controls.blocktype.h5":"Titre 5","components.controls.blocktype.h6":"Titre 6","components.controls.blocktype.blockquote":"Citation","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"Type bloc","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Palette de couleur","components.controls.colorpicker.text":"Texte","components.controls.colorpicker.background":"Fond","components.controls.embedded.embedded":"Embedded","components.controls.embedded.embeddedlink":"Lien iFrame","components.controls.embedded.enterlink":"Entrer le lien","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Police","components.controls.fontsize.fontsize":"Taille de police","components.controls.history.history":"Historique","components.controls.history.undo":"Précédent","components.controls.history.redo":"Suivant","components.controls.image.image":"Image","components.controls.image.fileUpload":"Téléchargement","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Glisser une image ou cliquer pour télécharger","components.controls.inline.bold":"Gras","components.controls.inline.italic":"Italique","components.controls.inline.underline":"Souligner","components.controls.inline.strikethrough":"Barrer","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Exposant","components.controls.inline.subscript":"Indice","components.controls.link.linkTitle":"Titre du lien","components.controls.link.linkTarget":"Cible du lien","components.controls.link.linkTargetOption":"Ouvrir le lien dans une nouvelle fenêtre","components.controls.link.link":"Lier","components.controls.link.unlink":"Délier","components.controls.list.list":"Liste","components.controls.list.unordered":"Désordonnée","components.controls.list.ordered":"Ordonnée","components.controls.list.indent":"Augmenter le retrait","components.controls.list.outdent":"Diminuer le retrat","components.controls.remove.remove":"Supprimer","components.controls.textalign.textalign":"Alignement du texte","components.controls.textalign.left":"Gauche","components.controls.textalign.center":"Centre","components.controls.textalign.right":"Droite","components.controls.textalign.justify":"Justifier"}},function(e,t,n){"use strict";e.exports={"generic.add":"添加","generic.cancel":"取消","components.controls.blocktype.h1":"标题1","components.controls.blocktype.h2":"标题2","components.controls.blocktype.h3":"标题3","components.controls.blocktype.h4":"标题4","components.controls.blocktype.h5":"标题5","components.controls.blocktype.h6":"标题6","components.controls.blocktype.blockquote":"引用","components.controls.blocktype.code":"源码","components.controls.blocktype.blocktype":"样式","components.controls.blocktype.normal":"正文","components.controls.colorpicker.colorpicker":"选色器","components.controls.colorpicker.text":"文字","components.controls.colorpicker.background":"背景","components.controls.embedded.embedded":"内嵌","components.controls.embedded.embeddedlink":"内嵌网页","components.controls.embedded.enterlink":"输入网页地址","components.controls.emoji.emoji":"表情符号","components.controls.fontfamily.fontfamily":"字体","components.controls.fontsize.fontsize":"字号","components.controls.history.history":"历史","components.controls.history.undo":"撤销","components.controls.history.redo":"恢复","components.controls.image.image":"图片","components.controls.image.fileUpload":"来自文件","components.controls.image.byURL":"在线图片","components.controls.image.dropFileText":"点击或者拖拽文件上传","components.controls.inline.bold":"粗体","components.controls.inline.italic":"斜体","components.controls.inline.underline":"下划线","components.controls.inline.strikethrough":"删除线","components.controls.inline.monospace":"等宽字体","components.controls.inline.superscript":"上标","components.controls.inline.subscript":"下标","components.controls.link.linkTitle":"超链接","components.controls.link.linkTarget":"输入链接地址","components.controls.link.linkTargetOption":"在新窗口中打开链接","components.controls.link.link":"链接","components.controls.link.unlink":"删除链接","components.controls.list.list":"列表","components.controls.list.unordered":"项目符号","components.controls.list.ordered":"编号","components.controls.list.indent":"增加缩进量","components.controls.list.outdent":"减少缩进量","components.controls.remove.remove":"清除格式","components.controls.textalign.textalign":"文本对齐","components.controls.textalign.left":"文本左对齐","components.controls.textalign.center":"居中","components.controls.textalign.right":"文本右对齐","components.controls.textalign.justify":"两端对齐"}},function(e,t,n){"use strict";e.exports={"generic.add":"Добавить","generic.cancel":"Отменить","components.controls.blocktype.h1":"Заголовок 1","components.controls.blocktype.h2":"Заголовок 2","components.controls.blocktype.h3":"Заголовок 3","components.controls.blocktype.h4":"Заголовок 4","components.controls.blocktype.h5":"Заголовок 5","components.controls.blocktype.h6":"Заголовок 6","components.controls.blocktype.blockquote":"Цитата","components.controls.blocktype.code":"Код","components.controls.blocktype.blocktype":"Форматирование","components.controls.blocktype.normal":"Обычный","components.controls.colorpicker.colorpicker":"Выбор цвета","components.controls.colorpicker.text":"Текст","components.controls.colorpicker.background":"Фон","components.controls.embedded.embedded":"Встраивание","components.controls.embedded.embeddedlink":"Ссылка в iFrame","components.controls.embedded.enterlink":"Вставьте ссылку","components.controls.emoji.emoji":"Эмодзи","components.controls.fontfamily.fontfamily":"Шрифт","components.controls.fontsize.fontsize":"Размер шрифта","components.controls.history.history":"История","components.controls.history.undo":"Отменить","components.controls.history.redo":"Вернуть","components.controls.image.image":"Изображение","components.controls.image.fileUpload":"Файлы","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Переместите в эту область файлы или кликните для загрузки","components.controls.inline.bold":"Жирный","components.controls.inline.italic":"Курсив","components.controls.inline.underline":"Подчеркивание","components.controls.inline.strikethrough":"Зачеркивание","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Верхний индекс","components.controls.inline.subscript":"Нижний индекс","components.controls.link.linkTitle":"Текст","components.controls.link.linkTarget":"Адрес ссылки","components.controls.link.linkTargetOption":"Открывать в новом окне","components.controls.link.link":"Ссылка","components.controls.link.unlink":"Убрать ссылку","components.controls.list.list":"Список","components.controls.list.unordered":"Неупорядоченный","components.controls.list.ordered":"Упорядоченный","components.controls.list.indent":"Отступ","components.controls.list.outdent":"Выступ","components.controls.remove.remove":"Удалить","components.controls.textalign.textalign":"Выравнивание текста","components.controls.textalign.left":"Слева","components.controls.textalign.center":"По центру","components.controls.textalign.right":"Справа","components.controls.textalign.justify":"Выравнить"}},function(e,t,n){"use strict";e.exports={"generic.add":"Ok","generic.cancel":"Cancelar","components.controls.blocktype.h1":"Título 1","components.controls.blocktype.h2":"Título 2","components.controls.blocktype.h3":"Título 3","components.controls.blocktype.h4":"Título 4","components.controls.blocktype.h5":"Título 5","components.controls.blocktype.h6":"Título 6","components.controls.blocktype.blockquote":"Citação","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"Estilo","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Paleta de cores","components.controls.colorpicker.text":"Texto","components.controls.colorpicker.background":"Fundo","components.controls.embedded.embedded":"Embarcado","components.controls.embedded.embeddedlink":"Link embarcado","components.controls.embedded.enterlink":"Coloque o link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Fonte","components.controls.fontsize.fontsize":"Tamanho da Fonte","components.controls.history.history":"Histórico","components.controls.history.undo":"Desfazer","components.controls.history.redo":"Refazer","components.controls.image.image":"Imagem","components.controls.image.fileUpload":"Carregar arquivo","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Arraste uma imagem aqui ou clique para carregar","components.controls.inline.bold":"Negrito","components.controls.inline.italic":"Itálico","components.controls.inline.underline":"Sublinhado","components.controls.inline.strikethrough":"Strikethrough","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Sobrescrito","components.controls.inline.subscript":"Subscrito","components.controls.link.linkTitle":"Título do link","components.controls.link.linkTarget":"Alvo do link","components.controls.link.linkTargetOption":"Abrir link em outra janela","components.controls.link.link":"Adicionar Link","components.controls.link.unlink":"Remover link","components.controls.list.list":"Lista","components.controls.list.unordered":"Sem ordenção","components.controls.list.ordered":"Ordenada","components.controls.list.indent":"Aumentar recuo","components.controls.list.outdent":"Diminuir recuo","components.controls.remove.remove":"Remover","components.controls.textalign.textalign":"Alinhamento do texto","components.controls.textalign.left":"À Esquerda","components.controls.textalign.center":"Centralizado","components.controls.textalign.right":"À Direita","components.controls.textalign.justify":"Justificado"}},function(e,t,n){"use strict";e.exports={"generic.add":"입력","generic.cancel":"취소","components.controls.blocktype.h1":"제목1","components.controls.blocktype.h2":"제목2","components.controls.blocktype.h3":"제목3","components.controls.blocktype.h4":"제목4","components.controls.blocktype.h5":"제목5","components.controls.blocktype.h6":"제목6","components.controls.blocktype.blockquote":"인용","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"블록","components.controls.blocktype.normal":"표준","components.controls.colorpicker.colorpicker":"색상 선택","components.controls.colorpicker.text":"글꼴색","components.controls.colorpicker.background":"배경색","components.controls.embedded.embedded":"임베드","components.controls.embedded.embeddedlink":"임베드 링크","components.controls.embedded.enterlink":"주소를 입력하세요","components.controls.emoji.emoji":"이모지","components.controls.fontfamily.fontfamily":"글꼴","components.controls.fontsize.fontsize":"글꼴 크기","components.controls.history.history":"히스토리","components.controls.history.undo":"실행 취소","components.controls.history.redo":"다시 실행","components.controls.image.image":"이미지","components.controls.image.fileUpload":"파일 업로드","components.controls.image.byURL":"주소","components.controls.image.dropFileText":"클릭하거나 파일을 드롭하여 업로드하세요","components.controls.inline.bold":"굵게","components.controls.inline.italic":"기울임꼴","components.controls.inline.underline":"밑줄","components.controls.inline.strikethrough":"취소선","components.controls.inline.monospace":"고정 너비","components.controls.inline.superscript":"위 첨자","components.controls.inline.subscript":"아래 첨자","components.controls.link.linkTitle":"링크 제목","components.controls.link.linkTarget":"링크 타겟","components.controls.link.linkTargetOption":"새창으로 열기","components.controls.link.link":"링크","components.controls.link.unlink":"링크 제거","components.controls.list.list":"리스트","components.controls.list.unordered":"일반 리스트","components.controls.list.ordered":"순서 리스트","components.controls.list.indent":"들여쓰기","components.controls.list.outdent":"내어쓰기","components.controls.remove.remove":"삭제","components.controls.textalign.textalign":"텍스트 정렬","components.controls.textalign.left":"왼쪽","components.controls.textalign.center":"중앙","components.controls.textalign.right":"오른쪽","components.controls.textalign.justify":"양쪽"}},function(e,t,n){"use strict";e.exports={"generic.add":"Aggiungi","generic.cancel":"Annulla","components.controls.blocktype.h1":"H1","components.controls.blocktype.h2":"H2","components.controls.blocktype.h3":"H3","components.controls.blocktype.h4":"H4","components.controls.blocktype.h5":"H5","components.controls.blocktype.h6":"H6","components.controls.blocktype.blockquote":"Citazione","components.controls.blocktype.code":"Codice","components.controls.blocktype.blocktype":"Stili","components.controls.blocktype.normal":"Normale","components.controls.colorpicker.colorpicker":"Colore testo","components.controls.colorpicker.text":"Testo","components.controls.colorpicker.background":"Evidenziazione","components.controls.embedded.embedded":"Incorpora","components.controls.embedded.embeddedlink":"Incorpora link","components.controls.embedded.enterlink":"Inserisci link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Carattere","components.controls.fontsize.fontsize":"Dimensione carattere","components.controls.history.history":"Modifiche","components.controls.history.undo":"Annulla","components.controls.history.redo":"Ripristina","components.controls.image.image":"Immagine","components.controls.image.fileUpload":"Carica immagine","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Trascina il file o clicca per caricare","components.controls.inline.bold":"Grassetto","components.controls.inline.italic":"Corsivo","components.controls.inline.underline":"Sottolineato","components.controls.inline.strikethrough":"Barrato","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Apice","components.controls.inline.subscript":"Pedice","components.controls.link.linkTitle":"Testo","components.controls.link.linkTarget":"Link","components.controls.link.linkTargetOption":"Apri link in una nuova finestra","components.controls.link.link":"Inserisci link","components.controls.link.unlink":"Rimuovi link","components.controls.list.list":"Lista","components.controls.list.unordered":"Elenco puntato","components.controls.list.ordered":"Elenco numerato","components.controls.list.indent":"Indent","components.controls.list.outdent":"Outdent","components.controls.remove.remove":"Rimuovi formattazione","components.controls.textalign.textalign":"Allineamento del testo","components.controls.textalign.left":"Allinea a sinistra","components.controls.textalign.center":"Allinea al centro","components.controls.textalign.right":"Allinea a destra","components.controls.textalign.justify":"Giustifica"}},function(e,t,n){"use strict";e.exports={"generic.add":"Toevoegen","generic.cancel":"Annuleren","components.controls.blocktype.h1":"H1","components.controls.blocktype.h2":"H2","components.controls.blocktype.h3":"H3","components.controls.blocktype.h4":"H4","components.controls.blocktype.h5":"H5","components.controls.blocktype.h6":"H6","components.controls.blocktype.blockquote":"Blockquote","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"Blocktype","components.controls.blocktype.normal":"Normaal","components.controls.colorpicker.colorpicker":"Kleurkiezer","components.controls.colorpicker.text":"Tekst","components.controls.colorpicker.background":"Achtergrond","components.controls.embedded.embedded":"Ingevoegd","components.controls.embedded.embeddedlink":"Ingevoegde link","components.controls.embedded.enterlink":"Voeg link toe","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Lettertype","components.controls.fontsize.fontsize":"Lettergrootte","components.controls.history.history":"Geschiedenis","components.controls.history.undo":"Ongedaan maken","components.controls.history.redo":"Opnieuw","components.controls.image.image":"Afbeelding","components.controls.image.fileUpload":"Bestand uploaden","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Drop het bestand hier of klik om te uploaden","components.controls.inline.bold":"Dikgedrukt","components.controls.inline.italic":"Schuingedrukt","components.controls.inline.underline":"Onderstrepen","components.controls.inline.strikethrough":"Doorstrepen","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Superscript","components.controls.inline.subscript":"Subscript","components.controls.link.linkTitle":"Linktitel","components.controls.link.linkTarget":"Link bestemming","components.controls.link.linkTargetOption":"Open link in een nieuw venster","components.controls.link.link":"Link","components.controls.link.unlink":"Unlink","components.controls.list.list":"Lijst","components.controls.list.unordered":"Ongeordend","components.controls.list.ordered":"Geordend","components.controls.list.indent":"Inspringen","components.controls.list.outdent":"Inspringen verkleinen","components.controls.remove.remove":"Verwijderen","components.controls.textalign.textalign":"Tekst uitlijnen","components.controls.textalign.left":"Links","components.controls.textalign.center":"Gecentreerd","components.controls.textalign.right":"Rechts","components.controls.textalign.justify":"Uitgelijnd"}},function(e,t,n){"use strict";e.exports={"generic.add":"Hinzufügen","generic.cancel":"Abbrechen","components.controls.blocktype.h1":"Überschrift 1","components.controls.blocktype.h2":"Überschrift 2","components.controls.blocktype.h3":"Überschrift 3","components.controls.blocktype.h4":"Überschrift 4","components.controls.blocktype.h5":"Überschrift 5","components.controls.blocktype.h6":"Überschrift 6","components.controls.blocktype.blockquote":"Zitat","components.controls.blocktype.code":"Quellcode","components.controls.blocktype.blocktype":"Blocktyp","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Farbauswahl","components.controls.colorpicker.text":"Text","components.controls.colorpicker.background":"Hintergrund","components.controls.embedded.embedded":"Eingebettet","components.controls.embedded.embeddedlink":"Eingebetteter Link","components.controls.embedded.enterlink":"Link eingeben","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Schriftart","components.controls.fontsize.fontsize":"Schriftgröße","components.controls.history.history":"Historie","components.controls.history.undo":"Zurücknehmen","components.controls.history.redo":"Wiederholen","components.controls.image.image":"Bild","components.controls.image.fileUpload":"Datei-Upload","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Dateien ziehen und ablegen, oder klicken zum Hochladen","components.controls.inline.bold":"Fett","components.controls.inline.italic":"Kursiv","components.controls.inline.underline":"Unterstreichen","components.controls.inline.strikethrough":"Durchstreichen","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Hochgestellt","components.controls.inline.subscript":"Tiefgestellt","components.controls.link.linkTitle":"Link-Titel","components.controls.link.linkTarget":"Link-Ziel","components.controls.link.linkTargetOption":"Link in neuem Fenster öffnen","components.controls.link.link":"Link","components.controls.link.unlink":"Aufheben","components.controls.list.list":"Liste","components.controls.list.unordered":"Aufzählung","components.controls.list.ordered":"Nummerierte Liste","components.controls.list.indent":"Einzug vergrößern","components.controls.list.outdent":"Einzug reduzieren","components.controls.remove.remove":"Entfernen","components.controls.textalign.textalign":"Textausrichtung","components.controls.textalign.left":"Linksbündig","components.controls.textalign.center":"Zentrieren","components.controls.textalign.right":"Rechtsbündig","components.controls.textalign.justify":"Blocksatz"}},function(e,t,n){"use strict";e.exports={"generic.add":"Tilføj","generic.cancel":"Annuller","components.controls.blocktype.h1":"Overskrift 1","components.controls.blocktype.h2":"Overskrift 2","components.controls.blocktype.h3":"Overskrift 3","components.controls.blocktype.h4":"Overskrift 4","components.controls.blocktype.h5":"Overskrift 5","components.controls.blocktype.h6":"Overskrift 6","components.controls.blocktype.blockquote":"Blokcitat","components.controls.blocktype.code":"Kode","components.controls.blocktype.blocktype":"Blok Type","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Farver","components.controls.colorpicker.text":"Tekst","components.controls.colorpicker.background":"Baggrund","components.controls.embedded.embedded":"Indlejre","components.controls.embedded.embeddedlink":"Indlejre Link","components.controls.embedded.enterlink":"Indtast link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Fonttype","components.controls.fontsize.fontsize":"Fontstørrelser","components.controls.history.history":"Historie","components.controls.history.undo":"Fortryd","components.controls.history.redo":"Gendan","components.controls.image.image":"Billede","components.controls.image.fileUpload":"Filoverførsel","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Drop filen eller klik for at uploade","components.controls.inline.bold":"Fed","components.controls.inline.italic":"Kursiv","components.controls.inline.underline":"Understrege","components.controls.inline.strikethrough":"Gennemstreget","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Hævet","components.controls.inline.subscript":"Sænket","components.controls.link.linkTitle":"Link Titel","components.controls.link.linkTarget":"Link Mål","components.controls.link.linkTargetOption":"Åbn link i nyt vindue","components.controls.link.link":"Link","components.controls.link.unlink":"Fjern link","components.controls.list.list":"Liste","components.controls.list.unordered":"Uordnet","components.controls.list.ordered":"Ordnet","components.controls.list.indent":"Indrykning","components.controls.list.outdent":"Udrykning","components.controls.remove.remove":"Fjern","components.controls.textalign.textalign":"Tekstjustering","components.controls.textalign.left":"Venstre","components.controls.textalign.center":"Center","components.controls.textalign.right":"Højre","components.controls.textalign.justify":"Margener"}},function(e,t,n){"use strict";e.exports={"generic.add":"新增","generic.cancel":"取消","components.controls.blocktype.h1":"標題1","components.controls.blocktype.h2":"標題2","components.controls.blocktype.h3":"標題3","components.controls.blocktype.h4":"標題4","components.controls.blocktype.h5":"標題5","components.controls.blocktype.h6":"標題6","components.controls.blocktype.blockquote":"引用","components.controls.blocktype.code":"程式碼","components.controls.blocktype.blocktype":"樣式","components.controls.blocktype.normal":"正文","components.controls.colorpicker.colorpicker":"選色器","components.controls.colorpicker.text":"文字","components.controls.colorpicker.background":"背景","components.controls.embedded.embedded":"內嵌","components.controls.embedded.embeddedlink":"內嵌網頁","components.controls.embedded.enterlink":"輸入網頁地址","components.controls.emoji.emoji":"表情符號","components.controls.fontfamily.fontfamily":"字體","components.controls.fontsize.fontsize":"字體大小","components.controls.history.history":"歷史紀錄","components.controls.history.undo":"復原","components.controls.history.redo":"重做","components.controls.image.image":"圖片","components.controls.image.fileUpload":"檔案上傳","components.controls.image.byURL":"網址","components.controls.image.dropFileText":"點擊或拖曳檔案上傳","components.controls.inline.bold":"粗體","components.controls.inline.italic":"斜體","components.controls.inline.underline":"底線","components.controls.inline.strikethrough":"刪除線","components.controls.inline.monospace":"等寬字體","components.controls.inline.superscript":"上標","components.controls.inline.subscript":"下標","components.controls.link.linkTitle":"超連結","components.controls.link.linkTarget":"輸入連結位址","components.controls.link.linkTargetOption":"在新視窗打開連結","components.controls.link.link":"連結","components.controls.link.unlink":"刪除連結","components.controls.list.list":"列表","components.controls.list.unordered":"項目符號","components.controls.list.ordered":"編號","components.controls.list.indent":"增加縮排","components.controls.list.outdent":"減少縮排","components.controls.remove.remove":"清除格式","components.controls.textalign.textalign":"文字對齊","components.controls.textalign.left":"文字向左對齊","components.controls.textalign.center":"文字置中","components.controls.textalign.right":"文字向右對齊","components.controls.textalign.justify":"兩端對齊"}},function(e,t,n){"use strict";e.exports={"generic.add":"Dodaj","generic.cancel":"Anuluj","components.controls.blocktype.h1":"Nagłówek 1","components.controls.blocktype.h2":"Nagłówek 2","components.controls.blocktype.h3":"Nagłówek 3","components.controls.blocktype.h4":"Nagłówek 4","components.controls.blocktype.h5":"Nagłówek 5","components.controls.blocktype.h6":"Nagłówek 6","components.controls.blocktype.blockquote":"Cytat","components.controls.blocktype.code":"Kod","components.controls.blocktype.blocktype":"Format","components.controls.blocktype.normal":"Normalny","components.controls.colorpicker.colorpicker":"Kolor","components.controls.colorpicker.text":"Tekst","components.controls.colorpicker.background":"Tło","components.controls.embedded.embedded":"Osadź","components.controls.embedded.embeddedlink":"Osadź odnośnik","components.controls.embedded.enterlink":"Wprowadź odnośnik","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Krój czcionki","components.controls.fontsize.fontsize":"Rozmiar czcionki","components.controls.history.history":"Historia","components.controls.history.undo":"Cofnij","components.controls.history.redo":"Ponów","components.controls.image.image":"Obrazek","components.controls.image.fileUpload":"Prześlij plik","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Upuść plik lub kliknij, aby przesłać","components.controls.inline.bold":"Pogrubienie","components.controls.inline.italic":"Kursywa","components.controls.inline.underline":"Podkreślenie","components.controls.inline.strikethrough":"Przekreślenie","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Indeks górny","components.controls.inline.subscript":"Indeks dolny","components.controls.link.linkTitle":"Tytuł odnośnika","components.controls.link.linkTarget":"Adres odnośnika","components.controls.link.linkTargetOption":"Otwórz odnośnik w nowej karcie","components.controls.link.link":"Wstaw odnośnik","components.controls.link.unlink":"Usuń odnośnik","components.controls.list.list":"Lista","components.controls.list.unordered":"Lista nieuporządkowana","components.controls.list.ordered":"Lista uporządkowana","components.controls.list.indent":"Zwiększ wcięcie","components.controls.list.outdent":"Zmniejsz wcięcie","components.controls.remove.remove":"Usuń","components.controls.textalign.textalign":"Wyrównaj tekst","components.controls.textalign.left":"Do lewej","components.controls.textalign.center":"Do środka","components.controls.textalign.right":"Do prawej","components.controls.textalign.justify":"Wyjustuj"}},function(e,t,n){"use strict";e.exports={"generic.add":"Añadir","generic.cancel":"Cancelar","components.controls.blocktype.h1":"H1","components.controls.blocktype.h2":"H2","components.controls.blocktype.h3":"H3","components.controls.blocktype.h4":"H4","components.controls.blocktype.h5":"H5","components.controls.blocktype.h6":"H6","components.controls.blocktype.blockquote":"Blockquote","components.controls.blocktype.code":"Código","components.controls.blocktype.blocktype":"Tipo de bloque","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Seleccionar color","components.controls.colorpicker.text":"Texto","components.controls.colorpicker.background":"Subrayado","components.controls.embedded.embedded":"Adjuntar","components.controls.embedded.embeddedlink":"Adjuntar Link","components.controls.embedded.enterlink":"Introducir link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Fuente","components.controls.fontsize.fontsize":"Tamaño de fuente","components.controls.history.history":"Histórico","components.controls.history.undo":"Deshacer","components.controls.history.redo":"Rehacer","components.controls.image.image":"Imagen","components.controls.image.fileUpload":"Subir archivo","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Arrastra el archivo o haz click para subirlo","components.controls.inline.bold":"Negrita","components.controls.inline.italic":"Cursiva","components.controls.inline.underline":"Subrayado","components.controls.inline.strikethrough":"Tachado","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Sobreíndice","components.controls.inline.subscript":"Subíndice","components.controls.link.linkTitle":"Título del enlace","components.controls.link.linkTarget":"Objetivo del enlace","components.controls.link.linkTargetOption":"Abrir en nueva ventana","components.controls.link.link":"Enlazar","components.controls.link.unlink":"Desenlazar","components.controls.list.list":"Lista","components.controls.list.unordered":"Desordenada","components.controls.list.ordered":"Ordenada","components.controls.list.indent":"Indentada","components.controls.list.outdent":"Dentada","components.controls.remove.remove":"Eliminar","components.controls.textalign.textalign":"Alineación del texto","components.controls.textalign.left":"Izquierda","components.controls.textalign.center":"Centrado","components.controls.textalign.right":"Derecha","components.controls.textalign.justify":"Justificado"}},function(e,t,n){"use strict";e.exports={"generic.add":"追加","generic.cancel":"キャンセル","components.controls.blocktype.h1":"見出し1","components.controls.blocktype.h2":"見出し2","components.controls.blocktype.h3":"見出し3","components.controls.blocktype.h4":"見出し4","components.controls.blocktype.h5":"見出し5","components.controls.blocktype.h6":"見出し6","components.controls.blocktype.blockquote":"引用","components.controls.blocktype.code":"コード","components.controls.blocktype.blocktype":"スタイル","components.controls.blocktype.normal":"標準テキスト","components.controls.colorpicker.colorpicker":"テキストの色","components.controls.colorpicker.text":"テキスト","components.controls.colorpicker.background":"ハイライト","components.controls.embedded.embedded":"埋め込み","components.controls.embedded.embeddedlink":"埋め込みリンク","components.controls.embedded.enterlink":"リンクを入力してください","components.controls.emoji.emoji":"絵文字","components.controls.fontfamily.fontfamily":"フォント","components.controls.fontsize.fontsize":"フォントサイズ","components.controls.history.history":"履歴","components.controls.history.undo":"元に戻す","components.controls.history.redo":"やり直し","components.controls.image.image":"画像","components.controls.image.fileUpload":"ファイルをアップロード","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"ここに画像をドラッグするか、クリックしてください","components.controls.inline.bold":"太字","components.controls.inline.italic":"斜体","components.controls.inline.underline":"下線","components.controls.inline.strikethrough":"取り消し線","components.controls.inline.monospace":"等幅フォント","components.controls.inline.superscript":"上付き文字","components.controls.inline.subscript":"下付き文字","components.controls.link.linkTitle":"リンクタイトル","components.controls.link.linkTarget":"リンク対象","components.controls.link.linkTargetOption":"新しいウィンドウで開く","components.controls.link.link":"リンク","components.controls.link.unlink":"リンクを解除","components.controls.list.list":"リスト","components.controls.list.unordered":"箇条書き","components.controls.list.ordered":"番号付き","components.controls.list.indent":"インデント増","components.controls.list.outdent":"インデント減","components.controls.remove.remove":"書式をクリア","components.controls.textalign.textalign":"整列","components.controls.textalign.left":"左揃え","components.controls.textalign.center":"中央揃え","components.controls.textalign.right":"右揃え","components.controls.textalign.justify":"両端揃え"}},function(e,t){e.exports={"rdw-editor-main":"rdw-editor-main","rdw-editor-toolbar":"rdw-editor-toolbar","public-DraftStyleDefault-block":"public-DraftStyleDefault-block","rdw-editor-wrapper":"rdw-editor-wrapper"}},function(e,t){e.exports={"DraftEditor-editorContainer":"DraftEditor-editorContainer","DraftEditor-root":"DraftEditor-root","public-DraftEditor-content":"public-DraftEditor-content","public-DraftEditor-block":"public-DraftEditor-block","DraftEditor-alignLeft":"DraftEditor-alignLeft","public-DraftStyleDefault-block":"public-DraftStyleDefault-block","public-DraftEditorPlaceholder-root":"public-DraftEditorPlaceholder-root","DraftEditor-alignCenter":"DraftEditor-alignCenter","DraftEditor-alignRight":"DraftEditor-alignRight","public-DraftEditorPlaceholder-hasFocus":"public-DraftEditorPlaceholder-hasFocus","DraftEditorPlaceholder-hidden":"DraftEditorPlaceholder-hidden","public-DraftStyleDefault-ltr":"public-DraftStyleDefault-ltr","public-DraftStyleDefault-rtl":"public-DraftStyleDefault-rtl","public-DraftStyleDefault-listLTR":"public-DraftStyleDefault-listLTR","public-DraftStyleDefault-listRTL":"public-DraftStyleDefault-listRTL","public-DraftStyleDefault-ol":"public-DraftStyleDefault-ol","public-DraftStyleDefault-ul":"public-DraftStyleDefault-ul","public-DraftStyleDefault-depth0":"public-DraftStyleDefault-depth0","public-DraftStyleDefault-depth1":"public-DraftStyleDefault-depth1","public-DraftStyleDefault-depth2":"public-DraftStyleDefault-depth2","public-DraftStyleDefault-depth3":"public-DraftStyleDefault-depth3","public-DraftStyleDefault-depth4":"public-DraftStyleDefault-depth4","public-DraftStyleDefault-unorderedListItem":"public-DraftStyleDefault-unorderedListItem","public-DraftStyleDefault-orderedListItem":"public-DraftStyleDefault-orderedListItem","public-DraftStyleDefault-reset":"public-DraftStyleDefault-reset"}}])});

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function (global, factory) {
   true ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.Immutable = factory());
}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

  function createClass(ctor, superClass) {
    if (superClass) {
      ctor.prototype = Object.create(superClass.prototype);
    }
    ctor.prototype.constructor = ctor;
  }

  function Iterable(value) {
      return isIterable(value) ? value : Seq(value);
    }


  createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }


  createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }


  createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
    }



  function isIterable(maybeIterable) {
    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
  }

  function isKeyed(maybeKeyed) {
    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
  }

  function isIndexed(maybeIndexed) {
    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
  }

  function isAssociative(maybeAssociative) {
    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
  }

  function isOrdered(maybeOrdered) {
    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
  }

  Iterable.isIterable = isIterable;
  Iterable.isKeyed = isKeyed;
  Iterable.isIndexed = isIndexed;
  Iterable.isAssociative = isAssociative;
  Iterable.isOrdered = isOrdered;

  Iterable.Keyed = KeyedIterable;
  Iterable.Indexed = IndexedIterable;
  Iterable.Set = SetIterable;


  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  // Used for setting prototype methods that IE8 chokes on.
  var DELETE = 'delete';

  // Constants describing the size of trie nodes.
  var SHIFT = 5; // Resulted in best performance after ______?
  var SIZE = 1 << SHIFT;
  var MASK = SIZE - 1;

  // A consistent shared value representing "not set" which equals nothing other
  // than itself, and nothing that could be provided externally.
  var NOT_SET = {};

  // Boolean references, Rough equivalent of `bool &`.
  var CHANGE_LENGTH = { value: false };
  var DID_ALTER = { value: false };

  function MakeRef(ref) {
    ref.value = false;
    return ref;
  }

  function SetRef(ref) {
    ref && (ref.value = true);
  }

  // A function which returns a value representing an "owner" for transient writes
  // to tries. The return value will only ever equal itself, and will not equal
  // the return of any subsequent call of this function.
  function OwnerID() {}

  // http://jsperf.com/copy-array-inline
  function arrCopy(arr, offset) {
    offset = offset || 0;
    var len = Math.max(0, arr.length - offset);
    var newArr = new Array(len);
    for (var ii = 0; ii < len; ii++) {
      newArr[ii] = arr[ii + offset];
    }
    return newArr;
  }

  function ensureSize(iter) {
    if (iter.size === undefined) {
      iter.size = iter.__iterate(returnTrue);
    }
    return iter.size;
  }

  function wrapIndex(iter, index) {
    // This implements "is array index" which the ECMAString spec defines as:
    //
    //     A String property name P is an array index if and only if
    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    //     to 2^32−1.
    //
    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
    if (typeof index !== 'number') {
      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
      if ('' + uint32Index !== index || uint32Index === 4294967295) {
        return NaN;
      }
      index = uint32Index;
    }
    return index < 0 ? ensureSize(iter) + index : index;
  }

  function returnTrue() {
    return true;
  }

  function wholeSlice(begin, end, size) {
    return (begin === 0 || (size !== undefined && begin <= -size)) &&
      (end === undefined || (size !== undefined && end >= size));
  }

  function resolveBegin(begin, size) {
    return resolveIndex(begin, size, 0);
  }

  function resolveEnd(end, size) {
    return resolveIndex(end, size, size);
  }

  function resolveIndex(index, size, defaultIndex) {
    return index === undefined ?
      defaultIndex :
      index < 0 ?
        Math.max(0, size + index) :
        size === undefined ?
          index :
          Math.min(size, index);
  }

  /* global Symbol */

  var ITERATE_KEYS = 0;
  var ITERATE_VALUES = 1;
  var ITERATE_ENTRIES = 2;

  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';

  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


  function Iterator(next) {
      this.next = next;
    }

    Iterator.prototype.toString = function() {
      return '[Iterator]';
    };


  Iterator.KEYS = ITERATE_KEYS;
  Iterator.VALUES = ITERATE_VALUES;
  Iterator.ENTRIES = ITERATE_ENTRIES;

  Iterator.prototype.inspect =
  Iterator.prototype.toSource = function () { return this.toString(); }
  Iterator.prototype[ITERATOR_SYMBOL] = function () {
    return this;
  };


  function iteratorValue(type, k, v, iteratorResult) {
    var value = type === 0 ? k : type === 1 ? v : [k, v];
    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
      value: value, done: false
    });
    return iteratorResult;
  }

  function iteratorDone() {
    return { value: undefined, done: true };
  }

  function hasIterator(maybeIterable) {
    return !!getIteratorFn(maybeIterable);
  }

  function isIterator(maybeIterator) {
    return maybeIterator && typeof maybeIterator.next === 'function';
  }

  function getIterator(iterable) {
    var iteratorFn = getIteratorFn(iterable);
    return iteratorFn && iteratorFn.call(iterable);
  }

  function getIteratorFn(iterable) {
    var iteratorFn = iterable && (
      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
      iterable[FAUX_ITERATOR_SYMBOL]
    );
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  function isArrayLike(value) {
    return value && typeof value.length === 'number';
  }

  createClass(Seq, Iterable);
    function Seq(value) {
      return value === null || value === undefined ? emptySequence() :
        isIterable(value) ? value.toSeq() : seqFromValue(value);
    }

    Seq.of = function(/*...values*/) {
      return Seq(arguments);
    };

    Seq.prototype.toSeq = function() {
      return this;
    };

    Seq.prototype.toString = function() {
      return this.__toString('Seq {', '}');
    };

    Seq.prototype.cacheResult = function() {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };

    // abstract __iterateUncached(fn, reverse)

    Seq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, true);
    };

    // abstract __iteratorUncached(type, reverse)

    Seq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, true);
    };



  createClass(KeyedSeq, Seq);
    function KeyedSeq(value) {
      return value === null || value === undefined ?
        emptySequence().toKeyedSeq() :
        isIterable(value) ?
          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
          keyedSeqFromValue(value);
    }

    KeyedSeq.prototype.toKeyedSeq = function() {
      return this;
    };



  createClass(IndexedSeq, Seq);
    function IndexedSeq(value) {
      return value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
    }

    IndexedSeq.of = function(/*...values*/) {
      return IndexedSeq(arguments);
    };

    IndexedSeq.prototype.toIndexedSeq = function() {
      return this;
    };

    IndexedSeq.prototype.toString = function() {
      return this.__toString('Seq [', ']');
    };

    IndexedSeq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, false);
    };

    IndexedSeq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, false);
    };



  createClass(SetSeq, Seq);
    function SetSeq(value) {
      return (
        value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value
      ).toSetSeq();
    }

    SetSeq.of = function(/*...values*/) {
      return SetSeq(arguments);
    };

    SetSeq.prototype.toSetSeq = function() {
      return this;
    };



  Seq.isSeq = isSeq;
  Seq.Keyed = KeyedSeq;
  Seq.Set = SetSeq;
  Seq.Indexed = IndexedSeq;

  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

  Seq.prototype[IS_SEQ_SENTINEL] = true;



  createClass(ArraySeq, IndexedSeq);
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }

    ArraySeq.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };

    ArraySeq.prototype.__iterate = function(fn, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ArraySeq.prototype.__iterator = function(type, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new Iterator(function() 
        {return ii > maxIndex ?
          iteratorDone() :
          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
      );
    };



  createClass(ObjectSeq, KeyedSeq);
    function ObjectSeq(object) {
      var keys = Object.keys(object);
      this._object = object;
      this._keys = keys;
      this.size = keys.length;
    }

    ObjectSeq.prototype.get = function(key, notSetValue) {
      if (notSetValue !== undefined && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };

    ObjectSeq.prototype.has = function(key) {
      return this._object.hasOwnProperty(key);
    };

    ObjectSeq.prototype.__iterate = function(fn, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys[reverse ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ObjectSeq.prototype.__iterator = function(type, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var key = keys[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, key, object[key]);
      });
    };

  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(IterableSeq, IndexedSeq);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }

    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };

    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      if (!isIterator(iterator)) {
        return new Iterator(iteratorDone);
      }
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value);
      });
    };



  createClass(IteratorSeq, IndexedSeq);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }

    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };

    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new Iterator(function()  {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue(type, iterations, cache[iterations++]);
      });
    };




  // # pragma Helper functions

  function isSeq(maybeSeq) {
    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
  }

  var EMPTY_SEQ;

  function emptySequence() {
    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
  }

  function keyedSeqFromValue(value) {
    var seq =
      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
      typeof value === 'object' ? new ObjectSeq(value) :
      undefined;
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of [k, v] entries, '+
        'or keyed object: ' + value
      );
    }
    return seq;
  }

  function indexedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values: ' + value
      );
    }
    return seq;
  }

  function seqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value) ||
      (typeof value === 'object' && new ObjectSeq(value));
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values, or keyed object: ' + value
      );
    }
    return seq;
  }

  function maybeIndexedSeqFromValue(value) {
    return (
      isArrayLike(value) ? new ArraySeq(value) :
      isIterator(value) ? new IteratorSeq(value) :
      hasIterator(value) ? new IterableSeq(value) :
      undefined
    );
  }

  function seqIterate(seq, fn, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var entry = cache[reverse ? maxIndex - ii : ii];
        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
          return ii + 1;
        }
      }
      return ii;
    }
    return seq.__iterateUncached(fn, reverse);
  }

  function seqIterator(seq, type, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var entry = cache[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
      });
    }
    return seq.__iteratorUncached(type, reverse);
  }

  function fromJS(json, converter) {
    return converter ?
      fromJSWith(converter, json, '', {'': json}) :
      fromJSDefault(json);
  }

  function fromJSWith(converter, json, key, parentJSON) {
    if (Array.isArray(json)) {
      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    if (isPlainObj(json)) {
      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    return json;
  }

  function fromJSDefault(json) {
    if (Array.isArray(json)) {
      return IndexedSeq(json).map(fromJSDefault).toList();
    }
    if (isPlainObj(json)) {
      return KeyedSeq(json).map(fromJSDefault).toMap();
    }
    return json;
  }

  function isPlainObj(value) {
    return value && (value.constructor === Object || value.constructor === undefined);
  }

  /**
   * An extension of the "same-value" algorithm as [described for use by ES6 Map
   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
   *
   * NaN is considered the same as NaN, however -0 and 0 are considered the same
   * value, which is different from the algorithm described by
   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
   *
   * This is extended further to allow Objects to describe the values they
   * represent, by way of `valueOf` or `equals` (and `hashCode`).
   *
   * Note: because of this extension, the key equality of Immutable.Map and the
   * value equality of Immutable.Set will differ from ES6 Map and Set.
   *
   * ### Defining custom values
   *
   * The easiest way to describe the value an object represents is by implementing
   * `valueOf`. For example, `Date` represents a value by returning a unix
   * timestamp for `valueOf`:
   *
   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
   *     var date2 = new Date(1234567890000);
   *     date1.valueOf(); // 1234567890000
   *     assert( date1 !== date2 );
   *     assert( Immutable.is( date1, date2 ) );
   *
   * Note: overriding `valueOf` may have other implications if you use this object
   * where JavaScript expects a primitive, such as implicit string coercion.
   *
   * For more complex types, especially collections, implementing `valueOf` may
   * not be performant. An alternative is to implement `equals` and `hashCode`.
   *
   * `equals` takes another object, presumably of similar type, and returns true
   * if the it is equal. Equality is symmetrical, so the same result should be
   * returned if this and the argument are flipped.
   *
   *     assert( a.equals(b) === b.equals(a) );
   *
   * `hashCode` returns a 32bit integer number representing the object which will
   * be used to determine how to store the value object in a Map or Set. You must
   * provide both or neither methods, one must not exist without the other.
   *
   * Also, an important relationship between these methods must be upheld: if two
   * values are equal, they *must* return the same hashCode. If the values are not
   * equal, they might have the same hashCode; this is called a hash collision,
   * and while undesirable for performance reasons, it is acceptable.
   *
   *     if (a.equals(b)) {
   *       assert( a.hashCode() === b.hashCode() );
   *     }
   *
   * All Immutable collections implement `equals` and `hashCode`.
   *
   */
  function is(valueA, valueB) {
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
    if (typeof valueA.valueOf === 'function' &&
        typeof valueB.valueOf === 'function') {
      valueA = valueA.valueOf();
      valueB = valueB.valueOf();
      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
    }
    if (typeof valueA.equals === 'function' &&
        typeof valueB.equals === 'function' &&
        valueA.equals(valueB)) {
      return true;
    }
    return false;
  }

  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (
      !isIterable(b) ||
      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
      isKeyed(a) !== isKeyed(b) ||
      isIndexed(a) !== isIndexed(b) ||
      isOrdered(a) !== isOrdered(b)
    ) {
      return false;
    }

    if (a.size === 0 && b.size === 0) {
      return true;
    }

    var notAssociative = !isAssociative(a);

    if (isOrdered(a)) {
      var entries = a.entries();
      return b.every(function(v, k)  {
        var entry = entries.next().value;
        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
      }) && entries.next().done;
    }

    var flipped = false;

    if (a.size === undefined) {
      if (b.size === undefined) {
        if (typeof a.cacheResult === 'function') {
          a.cacheResult();
        }
      } else {
        flipped = true;
        var _ = a;
        a = b;
        b = _;
      }
    }

    var allEqual = true;
    var bSize = b.__iterate(function(v, k)  {
      if (notAssociative ? !a.has(v) :
          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
        allEqual = false;
        return false;
      }
    });

    return allEqual && a.size === bSize;
  }

  createClass(Repeat, IndexedSeq);

    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === undefined ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }

    Repeat.prototype.toString = function() {
      if (this.size === 0) {
        return 'Repeat []';
      }
      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };

    Repeat.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };

    Repeat.prototype.includes = function(searchValue) {
      return is(this._value, searchValue);
    };

    Repeat.prototype.slice = function(begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size) ? this :
        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
    };

    Repeat.prototype.reverse = function() {
      return this;
    };

    Repeat.prototype.indexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };

    Repeat.prototype.lastIndexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };

    Repeat.prototype.__iterate = function(fn, reverse) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
      var ii = 0;
      return new Iterator(function() 
        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
      );
    };

    Repeat.prototype.equals = function(other) {
      return other instanceof Repeat ?
        is(this._value, other._value) :
        deepEqual(other);
    };


  var EMPTY_REPEAT;

  function invariant(condition, error) {
    if (!condition) throw new Error(error);
  }

  createClass(Range, IndexedSeq);

    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start, end, step);
      }
      invariant(step !== 0, 'Cannot step a Range by 0');
      start = start || 0;
      if (end === undefined) {
        end = Infinity;
      }
      step = step === undefined ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }

    Range.prototype.toString = function() {
      if (this.size === 0) {
        return 'Range []';
      }
      return 'Range [ ' +
        this._start + '...' + this._end +
        (this._step !== 1 ? ' by ' + this._step : '') +
      ' ]';
    };

    Range.prototype.get = function(index, notSetValue) {
      return this.has(index) ?
        this._start + wrapIndex(this, index) * this._step :
        notSetValue;
    };

    Range.prototype.includes = function(searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 &&
        possibleIndex < this.size &&
        possibleIndex === Math.floor(possibleIndex);
    };

    Range.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
    };

    Range.prototype.indexOf = function(searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index
        }
      }
      return -1;
    };

    Range.prototype.lastIndexOf = function(searchValue) {
      return this.indexOf(searchValue);
    };

    Range.prototype.__iterate = function(fn, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse ? -step : step;
      }
      return ii;
    };

    Range.prototype.__iterator = function(type, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new Iterator(function()  {
        var v = value;
        value += reverse ? -step : step;
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
      });
    };

    Range.prototype.equals = function(other) {
      return other instanceof Range ?
        this._start === other._start &&
        this._end === other._end &&
        this._step === other._step :
        deepEqual(this, other);
    };


  var EMPTY_RANGE;

  createClass(Collection, Iterable);
    function Collection() {
      throw TypeError('Abstract');
    }


  createClass(KeyedCollection, Collection);function KeyedCollection() {}

  createClass(IndexedCollection, Collection);function IndexedCollection() {}

  createClass(SetCollection, Collection);function SetCollection() {}


  Collection.Keyed = KeyedCollection;
  Collection.Indexed = IndexedCollection;
  Collection.Set = SetCollection;

  var imul =
    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
    Math.imul :
    function imul(a, b) {
      a = a | 0; // int
      b = b | 0; // int
      var c = a & 0xffff;
      var d = b & 0xffff;
      // Shift by 0 fixes the sign on the high part.
      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
    };

  // v8 has an optimization for storing 31-bit signed numbers.
  // Values which have either 00 or 11 as the high order bits qualify.
  // This function drops the highest order bit in a signed number, maintaining
  // the sign bit.
  function smi(i32) {
    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
  }

  function hash(o) {
    if (o === false || o === null || o === undefined) {
      return 0;
    }
    if (typeof o.valueOf === 'function') {
      o = o.valueOf();
      if (o === false || o === null || o === undefined) {
        return 0;
      }
    }
    if (o === true) {
      return 1;
    }
    var type = typeof o;
    if (type === 'number') {
      if (o !== o || o === Infinity) {
        return 0;
      }
      var h = o | 0;
      if (h !== o) {
        h ^= o * 0xFFFFFFFF;
      }
      while (o > 0xFFFFFFFF) {
        o /= 0xFFFFFFFF;
        h ^= o;
      }
      return smi(h);
    }
    if (type === 'string') {
      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
    }
    if (typeof o.hashCode === 'function') {
      return o.hashCode();
    }
    if (type === 'object') {
      return hashJSObj(o);
    }
    if (typeof o.toString === 'function') {
      return hashString(o.toString());
    }
    throw new Error('Value type ' + type + ' cannot be hashed.');
  }

  function cachedHashString(string) {
    var hash = stringHashCache[string];
    if (hash === undefined) {
      hash = hashString(string);
      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
        STRING_HASH_CACHE_SIZE = 0;
        stringHashCache = {};
      }
      STRING_HASH_CACHE_SIZE++;
      stringHashCache[string] = hash;
    }
    return hash;
  }

  // http://jsperf.com/hashing-strings
  function hashString(string) {
    // This is the hash from JVM
    // The hash code for a string is computed as
    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
    // where s[i] is the ith character of the string and n is the length of
    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
    // (exclusive) by dropping high bits.
    var hash = 0;
    for (var ii = 0; ii < string.length; ii++) {
      hash = 31 * hash + string.charCodeAt(ii) | 0;
    }
    return smi(hash);
  }

  function hashJSObj(obj) {
    var hash;
    if (usingWeakMap) {
      hash = weakMap.get(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = obj[UID_HASH_KEY];
    if (hash !== undefined) {
      return hash;
    }

    if (!canDefineProperty) {
      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
      if (hash !== undefined) {
        return hash;
      }

      hash = getIENodeHash(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = ++objHashUID;
    if (objHashUID & 0x40000000) {
      objHashUID = 0;
    }

    if (usingWeakMap) {
      weakMap.set(obj, hash);
    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
      throw new Error('Non-extensible objects are not allowed as keys.');
    } else if (canDefineProperty) {
      Object.defineProperty(obj, UID_HASH_KEY, {
        'enumerable': false,
        'configurable': false,
        'writable': false,
        'value': hash
      });
    } else if (obj.propertyIsEnumerable !== undefined &&
               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
      // Since we can't define a non-enumerable property on the object
      // we'll hijack one of the less-used non-enumerable properties to
      // save our hash on it. Since this is a function it will not show up in
      // `JSON.stringify` which is what we want.
      obj.propertyIsEnumerable = function() {
        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
      };
      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
    } else if (obj.nodeType !== undefined) {
      // At this point we couldn't get the IE `uniqueID` to use as a hash
      // and we couldn't use a non-enumerable property to exploit the
      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
      // itself.
      obj[UID_HASH_KEY] = hash;
    } else {
      throw new Error('Unable to set a non-enumerable property on object.');
    }

    return hash;
  }

  // Get references to ES5 object methods.
  var isExtensible = Object.isExtensible;

  // True if Object.defineProperty works as expected. IE8 fails this test.
  var canDefineProperty = (function() {
    try {
      Object.defineProperty({}, '@', {});
      return true;
    } catch (e) {
      return false;
    }
  }());

  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
  // and avoid memory leaks from the IE cloneNode bug.
  function getIENodeHash(node) {
    if (node && node.nodeType > 0) {
      switch (node.nodeType) {
        case 1: // Element
          return node.uniqueID;
        case 9: // Document
          return node.documentElement && node.documentElement.uniqueID;
      }
    }
  }

  // If possible, use a WeakMap.
  var usingWeakMap = typeof WeakMap === 'function';
  var weakMap;
  if (usingWeakMap) {
    weakMap = new WeakMap();
  }

  var objHashUID = 0;

  var UID_HASH_KEY = '__immutablehash__';
  if (typeof Symbol === 'function') {
    UID_HASH_KEY = Symbol(UID_HASH_KEY);
  }

  var STRING_HASH_CACHE_MIN_STRLEN = 16;
  var STRING_HASH_CACHE_MAX_SIZE = 255;
  var STRING_HASH_CACHE_SIZE = 0;
  var stringHashCache = {};

  function assertNotInfinite(size) {
    invariant(
      size !== Infinity,
      'Cannot perform this action with an infinite size.'
    );
  }

  createClass(Map, KeyedCollection);

    // @pragma Construction

    function Map(value) {
      return value === null || value === undefined ? emptyMap() :
        isMap(value) && !isOrdered(value) ? value :
        emptyMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
      return emptyMap().withMutations(function(map ) {
        for (var i = 0; i < keyValues.length; i += 2) {
          if (i + 1 >= keyValues.length) {
            throw new Error('Missing value for key: ' + keyValues[i]);
          }
          map.set(keyValues[i], keyValues[i + 1]);
        }
      });
    };

    Map.prototype.toString = function() {
      return this.__toString('Map {', '}');
    };

    // @pragma Access

    Map.prototype.get = function(k, notSetValue) {
      return this._root ?
        this._root.get(0, undefined, k, notSetValue) :
        notSetValue;
    };

    // @pragma Modification

    Map.prototype.set = function(k, v) {
      return updateMap(this, k, v);
    };

    Map.prototype.setIn = function(keyPath, v) {
      return this.updateIn(keyPath, NOT_SET, function()  {return v});
    };

    Map.prototype.remove = function(k) {
      return updateMap(this, k, NOT_SET);
    };

    Map.prototype.deleteIn = function(keyPath) {
      return this.updateIn(keyPath, function()  {return NOT_SET});
    };

    Map.prototype.update = function(k, notSetValue, updater) {
      return arguments.length === 1 ?
        k(this) :
        this.updateIn([k], notSetValue, updater);
    };

    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = undefined;
      }
      var updatedValue = updateInDeepMap(
        this,
        forceIterator(keyPath),
        notSetValue,
        updater
      );
      return updatedValue === NOT_SET ? undefined : updatedValue;
    };

    Map.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };

    // @pragma Composition

    Map.prototype.merge = function(/*...iters*/) {
      return mergeIntoMapWith(this, undefined, arguments);
    };

    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };

    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.merge === 'function' ?
          m.merge.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoMapWith(this, deepMerger, arguments);
    };

    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
    };

    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.mergeDeep === 'function' ?
          m.mergeDeep.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.sort = function(comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator));
    };

    Map.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator, mapper));
    };

    // @pragma Mutability

    Map.prototype.withMutations = function(fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };

    Map.prototype.asMutable = function() {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    };

    Map.prototype.asImmutable = function() {
      return this.__ensureOwner();
    };

    Map.prototype.wasAltered = function() {
      return this.__altered;
    };

    Map.prototype.__iterator = function(type, reverse) {
      return new MapIterator(this, type, reverse);
    };

    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function(entry ) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse);
      return iterations;
    };

    Map.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };


  function isMap(maybeMap) {
    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
  }

  Map.isMap = isMap;

  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

  var MapPrototype = Map.prototype;
  MapPrototype[IS_MAP_SENTINEL] = true;
  MapPrototype[DELETE] = MapPrototype.remove;
  MapPrototype.removeIn = MapPrototype.deleteIn;


  // #pragma Trie Nodes



    function ArrayMapNode(ownerID, entries) {
      this.ownerID = ownerID;
      this.entries = entries;
    }

    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && entries.length === 1) {
        return; // undefined
      }

      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries, key, value);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new ArrayMapNode(ownerID, newEntries);
    };




    function BitmapIndexedNode(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }

    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue :
        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
    };

    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;

      if (!exists && value === NOT_SET) {
        return this;
      }

      var idx = popCount(bitmap & (bit - 1));
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : undefined;
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

      if (newNode === node) {
        return this;
      }

      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }

      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }

      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ?
        setIn(nodes, idx, newNode, isEditable) :
        spliceOut(nodes, idx, isEditable) :
        spliceIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }

      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };




    function HashArrayMapNode(ownerID, count, nodes) {
      this.ownerID = ownerID;
      this.count = count;
      this.nodes = nodes;
    }

    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };

    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];

      if (removed && !node) {
        return this;
      }

      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }

      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }

      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };




    function HashCollisionNode(ownerID, keyHash, entries) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries;
    }

    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }

      var removed = value === NOT_SET;

      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };




    function ValueNode(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }

    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };

    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }

      SetRef(didAlter);

      if (removed) {
        SetRef(didChangeSize);
        return; // undefined
      }

      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }

      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
    };



  // #pragma Iterators

  ArrayMapNode.prototype.iterate =
  HashCollisionNode.prototype.iterate = function (fn, reverse) {
    var entries = this.entries;
    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
        return false;
      }
    }
  }

  BitmapIndexedNode.prototype.iterate =
  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
    var nodes = this.nodes;
    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      var node = nodes[reverse ? maxIndex - ii : ii];
      if (node && node.iterate(fn, reverse) === false) {
        return false;
      }
    }
  }

  ValueNode.prototype.iterate = function (fn, reverse) {
    return fn(this.entry);
  }

  createClass(MapIterator, Iterator);

    function MapIterator(map, type, reverse) {
      this._type = type;
      this._reverse = reverse;
      this._stack = map._root && mapIteratorFrame(map._root);
    }

    MapIterator.prototype.next = function() {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone();
    };


  function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
  }

  function mapIteratorFrame(node, prev) {
    return {
      node: node,
      index: 0,
      __prev: prev
    };
  }

  function makeMap(size, root, ownerID, hash) {
    var map = Object.create(MapPrototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_MAP;
  function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }

  function updateMap(map, k, v) {
    var newRoot;
    var newSize;
    if (!map._root) {
      if (v === NOT_SET) {
        return map;
      }
      newSize = 1;
      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
    } else {
      var didChangeSize = MakeRef(CHANGE_LENGTH);
      var didAlter = MakeRef(DID_ALTER);
      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
      if (!didAlter.value) {
        return map;
      }
      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
    }
    if (map.__ownerID) {
      map.size = newSize;
      map._root = newRoot;
      map.__hash = undefined;
      map.__altered = true;
      return map;
    }
    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
  }

  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (!node) {
      if (value === NOT_SET) {
        return node;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return new ValueNode(ownerID, keyHash, [key, value]);
    }
    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
  }

  function isLeafNode(node) {
    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
  }

  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
    }

    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

    var newNode;
    var nodes = idx1 === idx2 ?
      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
  }

  function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
      ownerID = new OwnerID();
    }
    var node = new ValueNode(ownerID, hash(key), [key, value]);
    for (var ii = 0; ii < entries.length; ii++) {
      var entry = entries[ii];
      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
    }
    return node;
  }

  function packNodes(ownerID, nodes, count, excluding) {
    var bitmap = 0;
    var packedII = 0;
    var packedNodes = new Array(count);
    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
      var node = nodes[ii];
      if (node !== undefined && ii !== excluding) {
        bitmap |= bit;
        packedNodes[packedII++] = node;
      }
    }
    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
  }

  function expandNodes(ownerID, nodes, bitmap, including, node) {
    var count = 0;
    var expandedNodes = new Array(SIZE);
    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
    }
    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
  }

  function mergeIntoMapWith(map, merger, iterables) {
    var iters = [];
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = KeyedIterable(value);
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    return mergeIntoCollectionWith(map, merger, iters);
  }

  function deepMerger(existing, value, key) {
    return existing && existing.mergeDeep && isIterable(value) ?
      existing.mergeDeep(value) :
      is(existing, value) ? existing : value;
  }

  function deepMergerWith(merger) {
    return function(existing, value, key)  {
      if (existing && existing.mergeDeepWith && isIterable(value)) {
        return existing.mergeDeepWith(merger, value);
      }
      var nextValue = merger(existing, value, key);
      return is(existing, nextValue) ? existing : nextValue;
    };
  }

  function mergeIntoCollectionWith(collection, merger, iters) {
    iters = iters.filter(function(x ) {return x.size !== 0});
    if (iters.length === 0) {
      return collection;
    }
    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
      return collection.constructor(iters[0]);
    }
    return collection.withMutations(function(collection ) {
      var mergeIntoMap = merger ?
        function(value, key)  {
          collection.update(key, NOT_SET, function(existing )
            {return existing === NOT_SET ? value : merger(existing, value, key)}
          );
        } :
        function(value, key)  {
          collection.set(key, value);
        }
      for (var ii = 0; ii < iters.length; ii++) {
        iters[ii].forEach(mergeIntoMap);
      }
    });
  }

  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
    var isNotSet = existing === NOT_SET;
    var step = keyPathIter.next();
    if (step.done) {
      var existingValue = isNotSet ? notSetValue : existing;
      var newValue = updater(existingValue);
      return newValue === existingValue ? existing : newValue;
    }
    invariant(
      isNotSet || (existing && existing.set),
      'invalid keyPath'
    );
    var key = step.value;
    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
    var nextUpdated = updateInDeepMap(
      nextExisting,
      keyPathIter,
      notSetValue,
      updater
    );
    return nextUpdated === nextExisting ? existing :
      nextUpdated === NOT_SET ? existing.remove(key) :
      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
  }

  function popCount(x) {
    x = x - ((x >> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return x & 0x7f;
  }

  function setIn(array, idx, val, canEdit) {
    var newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
  }

  function spliceIn(array, idx, val, canEdit) {
    var newLen = array.length + 1;
    if (canEdit && idx + 1 === newLen) {
      array[idx] = val;
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        newArray[ii] = val;
        after = -1;
      } else {
        newArray[ii] = array[ii + after];
      }
    }
    return newArray;
  }

  function spliceOut(array, idx, canEdit) {
    var newLen = array.length - 1;
    if (canEdit && idx === newLen) {
      array.pop();
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        after = 1;
      }
      newArray[ii] = array[ii + after];
    }
    return newArray;
  }

  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

  createClass(List, IndexedCollection);

    // @pragma Construction

    function List(value) {
      var empty = emptyList();
      if (value === null || value === undefined) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function(list ) {
        list.setSize(size);
        iter.forEach(function(v, i)  {return list.set(i, v)});
      });
    }

    List.of = function(/*...values*/) {
      return this(arguments);
    };

    List.prototype.toString = function() {
      return this.__toString('List [', ']');
    };

    // @pragma Access

    List.prototype.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor(this, index);
        return node && node.array[index & MASK];
      }
      return notSetValue;
    };

    // @pragma Modification

    List.prototype.set = function(index, value) {
      return updateList(this, index, value);
    };

    List.prototype.remove = function(index) {
      return !this.has(index) ? this :
        index === 0 ? this.shift() :
        index === this.size - 1 ? this.pop() :
        this.splice(index, 1);
    };

    List.prototype.insert = function(index, value) {
      return this.splice(index, 0, value);
    };

    List.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };

    List.prototype.push = function(/*...values*/) {
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function(list ) {
        setListBounds(list, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(oldSize + ii, values[ii]);
        }
      });
    };

    List.prototype.pop = function() {
      return setListBounds(this, 0, -1);
    };

    List.prototype.unshift = function(/*...values*/) {
      var values = arguments;
      return this.withMutations(function(list ) {
        setListBounds(list, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(ii, values[ii]);
        }
      });
    };

    List.prototype.shift = function() {
      return setListBounds(this, 1);
    };

    // @pragma Composition

    List.prototype.merge = function(/*...iters*/) {
      return mergeIntoListWith(this, undefined, arguments);
    };

    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };

    List.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoListWith(this, deepMerger, arguments);
    };

    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMergerWith(merger), iters);
    };

    List.prototype.setSize = function(size) {
      return setListBounds(this, 0, size);
    };

    // @pragma Iteration

    List.prototype.slice = function(begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(
        this,
        resolveBegin(begin, size),
        resolveEnd(end, size)
      );
    };

    List.prototype.__iterator = function(type, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      return new Iterator(function()  {
        var value = values();
        return value === DONE ?
          iteratorDone() :
          iteratorValue(type, index++, value);
      });
    };

    List.prototype.__iterate = function(fn, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, index++, this) === false) {
          break;
        }
      }
      return index;
    };

    List.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };


  function isList(maybeList) {
    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
  }

  List.isList = isList;

  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

  var ListPrototype = List.prototype;
  ListPrototype[IS_LIST_SENTINEL] = true;
  ListPrototype[DELETE] = ListPrototype.remove;
  ListPrototype.setIn = MapPrototype.setIn;
  ListPrototype.deleteIn =
  ListPrototype.removeIn = MapPrototype.removeIn;
  ListPrototype.update = MapPrototype.update;
  ListPrototype.updateIn = MapPrototype.updateIn;
  ListPrototype.mergeIn = MapPrototype.mergeIn;
  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  ListPrototype.withMutations = MapPrototype.withMutations;
  ListPrototype.asMutable = MapPrototype.asMutable;
  ListPrototype.asImmutable = MapPrototype.asImmutable;
  ListPrototype.wasAltered = MapPrototype.wasAltered;



    function VNode(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }

    // TODO: seems like these methods are very similar

    VNode.prototype.removeBefore = function(ownerID, level, index) {
      if (index === level ? 1 << level : 0 || this.array.length === 0) {
        return this;
      }
      var originIndex = (index >>> level) & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = undefined;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };

    VNode.prototype.removeAfter = function(ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = ((index - 1) >>> level) & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }

      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }

      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };



  var DONE = {};

  function iterateList(list, reverse) {
    var left = list._origin;
    var right = list._capacity;
    var tailPos = getTailOffset(right);
    var tail = list._tail;

    return iterateNodeOrLeaf(list._root, list._level, 0);

    function iterateNodeOrLeaf(node, level, offset) {
      return level === 0 ?
        iterateLeaf(node, offset) :
        iterateNode(node, level, offset);
    }

    function iterateLeaf(node, offset) {
      var array = offset === tailPos ? tail && tail.array : node && node.array;
      var from = offset > left ? 0 : left - offset;
      var to = right - offset;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        if (from === to) {
          return DONE;
        }
        var idx = reverse ? --to : from++;
        return array && array[idx];
      };
    }

    function iterateNode(node, level, offset) {
      var values;
      var array = node && node.array;
      var from = offset > left ? 0 : (left - offset) >> level;
      var to = ((right - offset) >> level) + 1;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        do {
          if (values) {
            var value = values();
            if (value !== DONE) {
              return value;
            }
            values = null;
          }
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          values = iterateNodeOrLeaf(
            array && array[idx], level - SHIFT, offset + (idx << level)
          );
        } while (true);
      };
    }
  }

  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
    var list = Object.create(ListPrototype);
    list.size = capacity - origin;
    list._origin = origin;
    list._capacity = capacity;
    list._level = level;
    list._root = root;
    list._tail = tail;
    list.__ownerID = ownerID;
    list.__hash = hash;
    list.__altered = false;
    return list;
  }

  var EMPTY_LIST;
  function emptyList() {
    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
  }

  function updateList(list, index, value) {
    index = wrapIndex(list, index);

    if (index !== index) {
      return list;
    }

    if (index >= list.size || index < 0) {
      return list.withMutations(function(list ) {
        index < 0 ?
          setListBounds(list, index).set(0, value) :
          setListBounds(list, 0, index + 1).set(index, value)
      });
    }

    index += list._origin;

    var newTail = list._tail;
    var newRoot = list._root;
    var didAlter = MakeRef(DID_ALTER);
    if (index >= getTailOffset(list._capacity)) {
      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
    } else {
      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
    }

    if (!didAlter.value) {
      return list;
    }

    if (list.__ownerID) {
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
  }

  function updateVNode(node, ownerID, level, index, value, didAlter) {
    var idx = (index >>> level) & MASK;
    var nodeHas = node && idx < node.array.length;
    if (!nodeHas && value === undefined) {
      return node;
    }

    var newNode;

    if (level > 0) {
      var lowerNode = node && node.array[idx];
      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
      if (newLowerNode === lowerNode) {
        return node;
      }
      newNode = editableVNode(node, ownerID);
      newNode.array[idx] = newLowerNode;
      return newNode;
    }

    if (nodeHas && node.array[idx] === value) {
      return node;
    }

    SetRef(didAlter);

    newNode = editableVNode(node, ownerID);
    if (value === undefined && idx === newNode.array.length - 1) {
      newNode.array.pop();
    } else {
      newNode.array[idx] = value;
    }
    return newNode;
  }

  function editableVNode(node, ownerID) {
    if (ownerID && node && ownerID === node.ownerID) {
      return node;
    }
    return new VNode(node ? node.array.slice() : [], ownerID);
  }

  function listNodeFor(list, rawIndex) {
    if (rawIndex >= getTailOffset(list._capacity)) {
      return list._tail;
    }
    if (rawIndex < 1 << (list._level + SHIFT)) {
      var node = list._root;
      var level = list._level;
      while (node && level > 0) {
        node = node.array[(rawIndex >>> level) & MASK];
        level -= SHIFT;
      }
      return node;
    }
  }

  function setListBounds(list, begin, end) {
    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      end = end | 0;
    }
    var owner = list.__ownerID || new OwnerID();
    var oldOrigin = list._origin;
    var oldCapacity = list._capacity;
    var newOrigin = oldOrigin + begin;
    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
      return list;
    }

    // If it's going to end after it starts, it's empty.
    if (newOrigin >= newCapacity) {
      return list.clear();
    }

    var newLevel = list._level;
    var newRoot = list._root;

    // New origin might need creating a higher root.
    var offsetShift = 0;
    while (newOrigin + offsetShift < 0) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
      newLevel += SHIFT;
      offsetShift += 1 << newLevel;
    }
    if (offsetShift) {
      newOrigin += offsetShift;
      oldOrigin += offsetShift;
      newCapacity += offsetShift;
      oldCapacity += offsetShift;
    }

    var oldTailOffset = getTailOffset(oldCapacity);
    var newTailOffset = getTailOffset(newCapacity);

    // New size might need creating a higher root.
    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
      newLevel += SHIFT;
    }

    // Locate or create the new tail.
    var oldTail = list._tail;
    var newTail = newTailOffset < oldTailOffset ?
      listNodeFor(list, newCapacity - 1) :
      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

    // Merge Tail into tree.
    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
      newRoot = editableVNode(newRoot, owner);
      var node = newRoot;
      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
        var idx = (oldTailOffset >>> level) & MASK;
        node = node.array[idx] = editableVNode(node.array[idx], owner);
      }
      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
    }

    // If the size has been reduced, there's a chance the tail needs to be trimmed.
    if (newCapacity < oldCapacity) {
      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
    }

    // If the new origin is within the tail, then we do not need a root.
    if (newOrigin >= newTailOffset) {
      newOrigin -= newTailOffset;
      newCapacity -= newTailOffset;
      newLevel = SHIFT;
      newRoot = null;
      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

    // Otherwise, if the root has been trimmed, garbage collect.
    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
      offsetShift = 0;

      // Identify the new top root node of the subtree of the old root.
      while (newRoot) {
        var beginIndex = (newOrigin >>> newLevel) & MASK;
        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
          break;
        }
        if (beginIndex) {
          offsetShift += (1 << newLevel) * beginIndex;
        }
        newLevel -= SHIFT;
        newRoot = newRoot.array[beginIndex];
      }

      // Trim the new sides of the new root.
      if (newRoot && newOrigin > oldOrigin) {
        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
      }
      if (newRoot && newTailOffset < oldTailOffset) {
        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
      }
      if (offsetShift) {
        newOrigin -= offsetShift;
        newCapacity -= offsetShift;
      }
    }

    if (list.__ownerID) {
      list.size = newCapacity - newOrigin;
      list._origin = newOrigin;
      list._capacity = newCapacity;
      list._level = newLevel;
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
  }

  function mergeIntoListWith(list, merger, iterables) {
    var iters = [];
    var maxSize = 0;
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = IndexedIterable(value);
      if (iter.size > maxSize) {
        maxSize = iter.size;
      }
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    if (maxSize > list.size) {
      list = list.setSize(maxSize);
    }
    return mergeIntoCollectionWith(list, merger, iters);
  }

  function getTailOffset(size) {
    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
  }

  createClass(OrderedMap, Map);

    // @pragma Construction

    function OrderedMap(value) {
      return value === null || value === undefined ? emptyOrderedMap() :
        isOrderedMap(value) ? value :
        emptyOrderedMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    OrderedMap.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedMap.prototype.toString = function() {
      return this.__toString('OrderedMap {', '}');
    };

    // @pragma Access

    OrderedMap.prototype.get = function(k, notSetValue) {
      var index = this._map.get(k);
      return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };

    // @pragma Modification

    OrderedMap.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap();
    };

    OrderedMap.prototype.set = function(k, v) {
      return updateOrderedMap(this, k, v);
    };

    OrderedMap.prototype.remove = function(k) {
      return updateOrderedMap(this, k, NOT_SET);
    };

    OrderedMap.prototype.wasAltered = function() {
      return this._map.wasAltered() || this._list.wasAltered();
    };

    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._list.__iterate(
        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
        reverse
      );
    };

    OrderedMap.prototype.__iterator = function(type, reverse) {
      return this._list.fromEntrySeq().__iterator(type, reverse);
    };

    OrderedMap.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };


  function isOrderedMap(maybeOrderedMap) {
    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
  }

  OrderedMap.isOrderedMap = isOrderedMap;

  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



  function makeOrderedMap(map, list, ownerID, hash) {
    var omap = Object.create(OrderedMap.prototype);
    omap.size = map ? map.size : 0;
    omap._map = map;
    omap._list = list;
    omap.__ownerID = ownerID;
    omap.__hash = hash;
    return omap;
  }

  var EMPTY_ORDERED_MAP;
  function emptyOrderedMap() {
    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
  }

  function updateOrderedMap(omap, k, v) {
    var map = omap._map;
    var list = omap._list;
    var i = map.get(k);
    var has = i !== undefined;
    var newMap;
    var newList;
    if (v === NOT_SET) { // removed
      if (!has) {
        return omap;
      }
      if (list.size >= SIZE && list.size >= map.size * 2) {
        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
        if (omap.__ownerID) {
          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
        }
      } else {
        newMap = map.remove(k);
        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
      }
    } else {
      if (has) {
        if (v === list.get(i)[1]) {
          return omap;
        }
        newMap = map;
        newList = list.set(i, [k, v]);
      } else {
        newMap = map.set(k, list.size);
        newList = list.set(list.size, [k, v]);
      }
    }
    if (omap.__ownerID) {
      omap.size = newMap.size;
      omap._map = newMap;
      omap._list = newList;
      omap.__hash = undefined;
      return omap;
    }
    return makeOrderedMap(newMap, newList);
  }

  createClass(ToKeyedSequence, KeyedSeq);
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }

    ToKeyedSequence.prototype.get = function(key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };

    ToKeyedSequence.prototype.has = function(key) {
      return this._iter.has(key);
    };

    ToKeyedSequence.prototype.valueSeq = function() {
      return this._iter.valueSeq();
    };

    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
      }
      return reversedSequence;
    };

    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
      var mappedSequence = mapFactory(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
      }
      return mappedSequence;
    };

    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var ii;
      return this._iter.__iterate(
        this._useKeys ?
          function(v, k)  {return fn(v, k, this$0)} :
          ((ii = reverse ? resolveSize(this) : 0),
            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
        reverse
      );
    };

    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
      if (this._useKeys) {
        return this._iter.__iterator(type, reverse);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var ii = reverse ? resolveSize(this) : 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
      });
    };

  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(ToIndexedSequence, IndexedSeq);
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToIndexedSequence.prototype.includes = function(value) {
      return this._iter.includes(value);
    };

    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
    };

    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, iterations++, step.value, step)
      });
    };



  createClass(ToSetSequence, SetSeq);
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToSetSequence.prototype.has = function(key) {
      return this._iter.includes(key);
    };

    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
    };

    ToSetSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, step.value, step.value, step);
      });
    };



  createClass(FromEntriesSequence, KeyedSeq);
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }

    FromEntriesSequence.prototype.entrySeq = function() {
      return this._iter.toSeq();
    };

    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(entry ) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return fn(
            indexedIterable ? entry.get(1) : entry[1],
            indexedIterable ? entry.get(0) : entry[0],
            this$0
          );
        }
      }, reverse);
    };

    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          // Check if entry exists first so array access doesn't throw for holes
          // in the parent iteration.
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue(
              type,
              indexedIterable ? entry.get(0) : entry[0],
              indexedIterable ? entry.get(1) : entry[1],
              step
            );
          }
        }
      });
    };


  ToIndexedSequence.prototype.cacheResult =
  ToKeyedSequence.prototype.cacheResult =
  ToSetSequence.prototype.cacheResult =
  FromEntriesSequence.prototype.cacheResult =
    cacheResultThrough;


  function flipFactory(iterable) {
    var flipSequence = makeSequence(iterable);
    flipSequence._iter = iterable;
    flipSequence.size = iterable.size;
    flipSequence.flip = function()  {return iterable};
    flipSequence.reverse = function () {
      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
      reversedSequence.flip = function()  {return iterable.reverse()};
      return reversedSequence;
    };
    flipSequence.has = function(key ) {return iterable.includes(key)};
    flipSequence.includes = function(key ) {return iterable.has(key)};
    flipSequence.cacheResult = cacheResultThrough;
    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
    }
    flipSequence.__iteratorUncached = function(type, reverse) {
      if (type === ITERATE_ENTRIES) {
        var iterator = iterable.__iterator(type, reverse);
        return new Iterator(function()  {
          var step = iterator.next();
          if (!step.done) {
            var k = step.value[0];
            step.value[0] = step.value[1];
            step.value[1] = k;
          }
          return step;
        });
      }
      return iterable.__iterator(
        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
        reverse
      );
    }
    return flipSequence;
  }


  function mapFactory(iterable, mapper, context) {
    var mappedSequence = makeSequence(iterable);
    mappedSequence.size = iterable.size;
    mappedSequence.has = function(key ) {return iterable.has(key)};
    mappedSequence.get = function(key, notSetValue)  {
      var v = iterable.get(key, NOT_SET);
      return v === NOT_SET ?
        notSetValue :
        mapper.call(context, v, key, iterable);
    };
    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(
        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
        reverse
      );
    }
    mappedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        return iteratorValue(
          type,
          key,
          mapper.call(context, entry[1], key, iterable),
          step
        );
      });
    }
    return mappedSequence;
  }


  function reverseFactory(iterable, useKeys) {
    var reversedSequence = makeSequence(iterable);
    reversedSequence._iter = iterable;
    reversedSequence.size = iterable.size;
    reversedSequence.reverse = function()  {return iterable};
    if (iterable.flip) {
      reversedSequence.flip = function () {
        var flipSequence = flipFactory(iterable);
        flipSequence.reverse = function()  {return iterable.flip()};
        return flipSequence;
      };
    }
    reversedSequence.get = function(key, notSetValue) 
      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
    reversedSequence.has = function(key )
      {return iterable.has(useKeys ? key : -1 - key)};
    reversedSequence.includes = function(value ) {return iterable.includes(value)};
    reversedSequence.cacheResult = cacheResultThrough;
    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
    };
    reversedSequence.__iterator =
      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
    return reversedSequence;
  }


  function filterFactory(iterable, predicate, context, useKeys) {
    var filterSequence = makeSequence(iterable);
    if (useKeys) {
      filterSequence.has = function(key ) {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
      };
      filterSequence.get = function(key, notSetValue)  {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
          v : notSetValue;
      };
    }
    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      }, reverse);
      return iterations;
    };
    filterSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          var value = entry[1];
          if (predicate.call(context, value, key, iterable)) {
            return iteratorValue(type, useKeys ? key : iterations++, value, step);
          }
        }
      });
    }
    return filterSequence;
  }


  function countByFactory(iterable, grouper, context) {
    var groups = Map().asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        0,
        function(a ) {return a + 1}
      );
    });
    return groups.asImmutable();
  }


  function groupByFactory(iterable, grouper, context) {
    var isKeyedIter = isKeyed(iterable);
    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
      );
    });
    var coerce = iterableClass(iterable);
    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
  }


  function sliceFactory(iterable, begin, end, useKeys) {
    var originalSize = iterable.size;

    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      if (end === Infinity) {
        end = originalSize;
      } else {
        end = end | 0;
      }
    }

    if (wholeSlice(begin, end, originalSize)) {
      return iterable;
    }

    var resolvedBegin = resolveBegin(begin, originalSize);
    var resolvedEnd = resolveEnd(end, originalSize);

    // begin or end will be NaN if they were provided as negative numbers and
    // this iterable's size is unknown. In that case, cache first so there is
    // a known size and these do not resolve to NaN.
    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
    }

    // Note: resolvedEnd is undefined when the original sequence's length is
    // unknown and this slice did not supply an end and should contain all
    // elements after resolvedBegin.
    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
    var resolvedSize = resolvedEnd - resolvedBegin;
    var sliceSize;
    if (resolvedSize === resolvedSize) {
      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
    }

    var sliceSeq = makeSequence(iterable);

    // If iterable.size is undefined, the size of the realized sliceSeq is
    // unknown at this point unless the number of items to slice is 0
    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
      sliceSeq.get = function (index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 && index < sliceSize ?
          iterable.get(index + resolvedBegin, notSetValue) :
          notSetValue;
      }
    }

    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (sliceSize === 0) {
        return 0;
      }
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var skipped = 0;
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k)  {
        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
                 iterations !== sliceSize;
        }
      });
      return iterations;
    };

    sliceSeq.__iteratorUncached = function(type, reverse) {
      if (sliceSize !== 0 && reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      // Don't bother instantiating parent iterator if taking 0.
      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
      var skipped = 0;
      var iterations = 0;
      return new Iterator(function()  {
        while (skipped++ < resolvedBegin) {
          iterator.next();
        }
        if (++iterations > sliceSize) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (useKeys || type === ITERATE_VALUES) {
          return step;
        } else if (type === ITERATE_KEYS) {
          return iteratorValue(type, iterations - 1, undefined, step);
        } else {
          return iteratorValue(type, iterations - 1, step.value[1], step);
        }
      });
    }

    return sliceSeq;
  }


  function takeWhileFactory(iterable, predicate, context) {
    var takeSequence = makeSequence(iterable);
    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterations = 0;
      iterable.__iterate(function(v, k, c) 
        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
      );
      return iterations;
    };
    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterating = true;
      return new Iterator(function()  {
        if (!iterating) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var k = entry[0];
        var v = entry[1];
        if (!predicate.call(context, v, k, this$0)) {
          iterating = false;
          return iteratorDone();
        }
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return takeSequence;
  }


  function skipWhileFactory(iterable, predicate, context, useKeys) {
    var skipSequence = makeSequence(iterable);
    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      });
      return iterations;
    };
    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var skipping = true;
      var iterations = 0;
      return new Iterator(function()  {
        var step, k, v;
        do {
          step = iterator.next();
          if (step.done) {
            if (useKeys || type === ITERATE_VALUES) {
              return step;
            } else if (type === ITERATE_KEYS) {
              return iteratorValue(type, iterations++, undefined, step);
            } else {
              return iteratorValue(type, iterations++, step.value[1], step);
            }
          }
          var entry = step.value;
          k = entry[0];
          v = entry[1];
          skipping && (skipping = predicate.call(context, v, k, this$0));
        } while (skipping);
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return skipSequence;
  }


  function concatFactory(iterable, values) {
    var isKeyedIterable = isKeyed(iterable);
    var iters = [iterable].concat(values).map(function(v ) {
      if (!isIterable(v)) {
        v = isKeyedIterable ?
          keyedSeqFromValue(v) :
          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
      } else if (isKeyedIterable) {
        v = KeyedIterable(v);
      }
      return v;
    }).filter(function(v ) {return v.size !== 0});

    if (iters.length === 0) {
      return iterable;
    }

    if (iters.length === 1) {
      var singleton = iters[0];
      if (singleton === iterable ||
          isKeyedIterable && isKeyed(singleton) ||
          isIndexed(iterable) && isIndexed(singleton)) {
        return singleton;
      }
    }

    var concatSeq = new ArraySeq(iters);
    if (isKeyedIterable) {
      concatSeq = concatSeq.toKeyedSeq();
    } else if (!isIndexed(iterable)) {
      concatSeq = concatSeq.toSetSeq();
    }
    concatSeq = concatSeq.flatten(true);
    concatSeq.size = iters.reduce(
      function(sum, seq)  {
        if (sum !== undefined) {
          var size = seq.size;
          if (size !== undefined) {
            return sum + size;
          }
        }
      },
      0
    );
    return concatSeq;
  }


  function flattenFactory(iterable, depth, useKeys) {
    var flatSequence = makeSequence(iterable);
    flatSequence.__iterateUncached = function(fn, reverse) {
      var iterations = 0;
      var stopped = false;
      function flatDeep(iter, currentDepth) {var this$0 = this;
        iter.__iterate(function(v, k)  {
          if ((!depth || currentDepth < depth) && isIterable(v)) {
            flatDeep(v, currentDepth + 1);
          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
            stopped = true;
          }
          return !stopped;
        }, reverse);
      }
      flatDeep(iterable, 0);
      return iterations;
    }
    flatSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(type, reverse);
      var stack = [];
      var iterations = 0;
      return new Iterator(function()  {
        while (iterator) {
          var step = iterator.next();
          if (step.done !== false) {
            iterator = stack.pop();
            continue;
          }
          var v = step.value;
          if (type === ITERATE_ENTRIES) {
            v = v[1];
          }
          if ((!depth || stack.length < depth) && isIterable(v)) {
            stack.push(iterator);
            iterator = v.__iterator(type, reverse);
          } else {
            return useKeys ? step : iteratorValue(type, iterations++, v, step);
          }
        }
        return iteratorDone();
      });
    }
    return flatSequence;
  }


  function flatMapFactory(iterable, mapper, context) {
    var coerce = iterableClass(iterable);
    return iterable.toSeq().map(
      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
    ).flatten(true);
  }


  function interposeFactory(iterable, separator) {
    var interposedSequence = makeSequence(iterable);
    interposedSequence.size = iterable.size && iterable.size * 2 -1;
    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k) 
        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
        fn(v, iterations++, this$0) !== false},
        reverse
      );
      return iterations;
    };
    interposedSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      var step;
      return new Iterator(function()  {
        if (!step || iterations % 2) {
          step = iterator.next();
          if (step.done) {
            return step;
          }
        }
        return iterations % 2 ?
          iteratorValue(type, iterations++, separator) :
          iteratorValue(type, iterations++, step.value, step);
      });
    };
    return interposedSequence;
  }


  function sortFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    var isKeyedIterable = isKeyed(iterable);
    var index = 0;
    var entries = iterable.toSeq().map(
      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
    ).toArray();
    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
      isKeyedIterable ?
      function(v, i)  { entries[i].length = 2; } :
      function(v, i)  { entries[i] = v[1]; }
    );
    return isKeyedIterable ? KeyedSeq(entries) :
      isIndexed(iterable) ? IndexedSeq(entries) :
      SetSeq(entries);
  }


  function maxFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    if (mapper) {
      var entry = iterable.toSeq()
        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
      return entry && entry[0];
    } else {
      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
    }
  }

  function maxCompare(comparator, a, b) {
    var comp = comparator(b, a);
    // b is considered the new max if the comparator declares them equal, but
    // they are not equal and b is in fact a nullish value.
    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
  }


  function zipWithFactory(keyIter, zipper, iters) {
    var zipSequence = makeSequence(keyIter);
    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
    // Note: this a generic base implementation of __iterate in terms of
    // __iterator which may be more generically useful in the future.
    zipSequence.__iterate = function(fn, reverse) {
      /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */
      // indexed:
      var iterator = this.__iterator(ITERATE_VALUES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    zipSequence.__iteratorUncached = function(type, reverse) {
      var iterators = iters.map(function(i )
        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
      );
      var iterations = 0;
      var isDone = false;
      return new Iterator(function()  {
        var steps;
        if (!isDone) {
          steps = iterators.map(function(i ) {return i.next()});
          isDone = steps.some(function(s ) {return s.done});
        }
        if (isDone) {
          return iteratorDone();
        }
        return iteratorValue(
          type,
          iterations++,
          zipper.apply(null, steps.map(function(s ) {return s.value}))
        );
      });
    };
    return zipSequence
  }


  // #pragma Helper Functions

  function reify(iter, seq) {
    return isSeq(iter) ? seq : iter.constructor(seq);
  }

  function validateEntry(entry) {
    if (entry !== Object(entry)) {
      throw new TypeError('Expected [K, V] tuple: ' + entry);
    }
  }

  function resolveSize(iter) {
    assertNotInfinite(iter.size);
    return ensureSize(iter);
  }

  function iterableClass(iterable) {
    return isKeyed(iterable) ? KeyedIterable :
      isIndexed(iterable) ? IndexedIterable :
      SetIterable;
  }

  function makeSequence(iterable) {
    return Object.create(
      (
        isKeyed(iterable) ? KeyedSeq :
        isIndexed(iterable) ? IndexedSeq :
        SetSeq
      ).prototype
    );
  }

  function cacheResultThrough() {
    if (this._iter.cacheResult) {
      this._iter.cacheResult();
      this.size = this._iter.size;
      return this;
    } else {
      return Seq.prototype.cacheResult.call(this);
    }
  }

  function defaultComparator(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }

  function forceIterator(keyPath) {
    var iter = getIterator(keyPath);
    if (!iter) {
      // Array might not be iterable in this environment, so we need a fallback
      // to our wrapped type.
      if (!isArrayLike(keyPath)) {
        throw new TypeError('Expected iterable or array-like: ' + keyPath);
      }
      iter = getIterator(Iterable(keyPath));
    }
    return iter;
  }

  createClass(Record, KeyedCollection);

    function Record(defaultValues, name) {
      var hasInitialized;

      var RecordType = function Record(values) {
        if (values instanceof RecordType) {
          return values;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys);
          RecordTypePrototype.size = keys.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = Map(values);
      };

      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;

      return RecordType;
    }

    Record.prototype.toString = function() {
      return this.__toString(recordName(this) + ' {', '}');
    };

    // @pragma Access

    Record.prototype.has = function(k) {
      return this._defaultValues.hasOwnProperty(k);
    };

    Record.prototype.get = function(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k];
      return this._map ? this._map.get(k, defaultVal) : defaultVal;
    };

    // @pragma Modification

    Record.prototype.clear = function() {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
    };

    Record.prototype.set = function(k, v) {
      if (!this.has(k)) {
        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
      }
      if (this._map && !this._map.has(k)) {
        var defaultVal = this._defaultValues[k];
        if (v === defaultVal) {
          return this;
        }
      }
      var newMap = this._map && this._map.set(k, v);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.remove = function(k) {
      if (!this.has(k)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
    };

    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
    };

    Record.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };


  var RecordPrototype = Record.prototype;
  RecordPrototype[DELETE] = RecordPrototype.remove;
  RecordPrototype.deleteIn =
  RecordPrototype.removeIn = MapPrototype.removeIn;
  RecordPrototype.merge = MapPrototype.merge;
  RecordPrototype.mergeWith = MapPrototype.mergeWith;
  RecordPrototype.mergeIn = MapPrototype.mergeIn;
  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  RecordPrototype.setIn = MapPrototype.setIn;
  RecordPrototype.update = MapPrototype.update;
  RecordPrototype.updateIn = MapPrototype.updateIn;
  RecordPrototype.withMutations = MapPrototype.withMutations;
  RecordPrototype.asMutable = MapPrototype.asMutable;
  RecordPrototype.asImmutable = MapPrototype.asImmutable;


  function makeRecord(likeRecord, map, ownerID) {
    var record = Object.create(Object.getPrototypeOf(likeRecord));
    record._map = map;
    record.__ownerID = ownerID;
    return record;
  }

  function recordName(record) {
    return record._name || record.constructor.name || 'Record';
  }

  function setProps(prototype, names) {
    try {
      names.forEach(setProp.bind(undefined, prototype));
    } catch (error) {
      // Object.defineProperty failed. Probably IE8.
    }
  }

  function setProp(prototype, name) {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      }
    });
  }

  createClass(Set, SetCollection);

    // @pragma Construction

    function Set(value) {
      return value === null || value === undefined ? emptySet() :
        isSet(value) && !isOrdered(value) ? value :
        emptySet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    Set.of = function(/*...values*/) {
      return this(arguments);
    };

    Set.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    Set.prototype.toString = function() {
      return this.__toString('Set {', '}');
    };

    // @pragma Access

    Set.prototype.has = function(value) {
      return this._map.has(value);
    };

    // @pragma Modification

    Set.prototype.add = function(value) {
      return updateSet(this, this._map.set(value, true));
    };

    Set.prototype.remove = function(value) {
      return updateSet(this, this._map.remove(value));
    };

    Set.prototype.clear = function() {
      return updateSet(this, this._map.clear());
    };

    // @pragma Composition

    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function(x ) {return x.size !== 0});
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function(set ) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
        }
      });
    };

    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (!iters.every(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (iters.some(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.merge = function() {
      return this.union.apply(this, arguments);
    };

    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };

    Set.prototype.sort = function(comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator));
    };

    Set.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator, mapper));
    };

    Set.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
    };

    Set.prototype.__iterator = function(type, reverse) {
      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
    };

    Set.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };


  function isSet(maybeSet) {
    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
  }

  Set.isSet = isSet;

  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

  var SetPrototype = Set.prototype;
  SetPrototype[IS_SET_SENTINEL] = true;
  SetPrototype[DELETE] = SetPrototype.remove;
  SetPrototype.mergeDeep = SetPrototype.merge;
  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
  SetPrototype.withMutations = MapPrototype.withMutations;
  SetPrototype.asMutable = MapPrototype.asMutable;
  SetPrototype.asImmutable = MapPrototype.asImmutable;

  SetPrototype.__empty = emptySet;
  SetPrototype.__make = makeSet;

  function updateSet(set, newMap) {
    if (set.__ownerID) {
      set.size = newMap.size;
      set._map = newMap;
      return set;
    }
    return newMap === set._map ? set :
      newMap.size === 0 ? set.__empty() :
      set.__make(newMap);
  }

  function makeSet(map, ownerID) {
    var set = Object.create(SetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_SET;
  function emptySet() {
    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
  }

  createClass(OrderedSet, Set);

    // @pragma Construction

    function OrderedSet(value) {
      return value === null || value === undefined ? emptyOrderedSet() :
        isOrderedSet(value) ? value :
        emptyOrderedSet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    OrderedSet.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedSet.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    OrderedSet.prototype.toString = function() {
      return this.__toString('OrderedSet {', '}');
    };


  function isOrderedSet(maybeOrderedSet) {
    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
  }

  OrderedSet.isOrderedSet = isOrderedSet;

  var OrderedSetPrototype = OrderedSet.prototype;
  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

  OrderedSetPrototype.__empty = emptyOrderedSet;
  OrderedSetPrototype.__make = makeOrderedSet;

  function makeOrderedSet(map, ownerID) {
    var set = Object.create(OrderedSetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_ORDERED_SET;
  function emptyOrderedSet() {
    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
  }

  createClass(Stack, IndexedCollection);

    // @pragma Construction

    function Stack(value) {
      return value === null || value === undefined ? emptyStack() :
        isStack(value) ? value :
        emptyStack().unshiftAll(value);
    }

    Stack.of = function(/*...values*/) {
      return this(arguments);
    };

    Stack.prototype.toString = function() {
      return this.__toString('Stack [', ']');
    };

    // @pragma Access

    Stack.prototype.get = function(index, notSetValue) {
      var head = this._head;
      index = wrapIndex(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };

    Stack.prototype.peek = function() {
      return this._head && this._head.value;
    };

    // @pragma Modification

    Stack.prototype.push = function(/*...values*/) {
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pushAll = function(iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function(value ) {
        newSize++;
        head = {
          value: value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pop = function() {
      return this.slice(1);
    };

    Stack.prototype.unshift = function(/*...values*/) {
      return this.push.apply(this, arguments);
    };

    Stack.prototype.unshiftAll = function(iter) {
      return this.pushAll(iter);
    };

    Stack.prototype.shift = function() {
      return this.pop.apply(this, arguments);
    };

    Stack.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = undefined;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };

    Stack.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        // super.slice(begin, end);
        return IndexedCollection.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    // @pragma Mutability

    Stack.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };

    // @pragma Iteration

    Stack.prototype.__iterate = function(fn, reverse) {
      if (reverse) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };

    Stack.prototype.__iterator = function(type, reverse) {
      if (reverse) {
        return this.reverse().__iterator(type);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator(function()  {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type, iterations++, value);
        }
        return iteratorDone();
      });
    };


  function isStack(maybeStack) {
    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
  }

  Stack.isStack = isStack;

  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

  var StackPrototype = Stack.prototype;
  StackPrototype[IS_STACK_SENTINEL] = true;
  StackPrototype.withMutations = MapPrototype.withMutations;
  StackPrototype.asMutable = MapPrototype.asMutable;
  StackPrototype.asImmutable = MapPrototype.asImmutable;
  StackPrototype.wasAltered = MapPrototype.wasAltered;


  function makeStack(size, head, ownerID, hash) {
    var map = Object.create(StackPrototype);
    map.size = size;
    map._head = head;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_STACK;
  function emptyStack() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  }

  /**
   * Contributes additional methods to a constructor
   */
  function mixin(ctor, methods) {
    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
    Object.keys(methods).forEach(keyCopier);
    Object.getOwnPropertySymbols &&
      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
    return ctor;
  }

  Iterable.Iterator = Iterator;

  mixin(Iterable, {

    // ### Conversion to other types

    toArray: function() {
      assertNotInfinite(this.size);
      var array = new Array(this.size || 0);
      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
      return array;
    },

    toIndexedSeq: function() {
      return new ToIndexedSequence(this);
    },

    toJS: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
      ).__toJS();
    },

    toJSON: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
      ).__toJS();
    },

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, true);
    },

    toMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return Map(this.toKeyedSeq());
    },

    toObject: function() {
      assertNotInfinite(this.size);
      var object = {};
      this.__iterate(function(v, k)  { object[k] = v; });
      return object;
    },

    toOrderedMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedMap(this.toKeyedSeq());
    },

    toOrderedSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
    },

    toSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return Set(isKeyed(this) ? this.valueSeq() : this);
    },

    toSetSeq: function() {
      return new ToSetSequence(this);
    },

    toSeq: function() {
      return isIndexed(this) ? this.toIndexedSeq() :
        isKeyed(this) ? this.toKeyedSeq() :
        this.toSetSeq();
    },

    toStack: function() {
      // Use Late Binding here to solve the circular dependency.
      return Stack(isKeyed(this) ? this.valueSeq() : this);
    },

    toList: function() {
      // Use Late Binding here to solve the circular dependency.
      return List(isKeyed(this) ? this.valueSeq() : this);
    },


    // ### Common JavaScript methods and properties

    toString: function() {
      return '[Iterable]';
    },

    __toString: function(head, tail) {
      if (this.size === 0) {
        return head + tail;
      }
      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    concat: function() {var values = SLICE$0.call(arguments, 0);
      return reify(this, concatFactory(this, values));
    },

    includes: function(searchValue) {
      return this.some(function(value ) {return is(value, searchValue)});
    },

    entries: function() {
      return this.__iterator(ITERATE_ENTRIES);
    },

    every: function(predicate, context) {
      assertNotInfinite(this.size);
      var returnValue = true;
      this.__iterate(function(v, k, c)  {
        if (!predicate.call(context, v, k, c)) {
          returnValue = false;
          return false;
        }
      });
      return returnValue;
    },

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, true));
    },

    find: function(predicate, context, notSetValue) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[1] : notSetValue;
    },

    forEach: function(sideEffect, context) {
      assertNotInfinite(this.size);
      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
    },

    join: function(separator) {
      assertNotInfinite(this.size);
      separator = separator !== undefined ? '' + separator : ',';
      var joined = '';
      var isFirst = true;
      this.__iterate(function(v ) {
        isFirst ? (isFirst = false) : (joined += separator);
        joined += v !== null && v !== undefined ? v.toString() : '';
      });
      return joined;
    },

    keys: function() {
      return this.__iterator(ITERATE_KEYS);
    },

    map: function(mapper, context) {
      return reify(this, mapFactory(this, mapper, context));
    },

    reduce: function(reducer, initialReduction, context) {
      assertNotInfinite(this.size);
      var reduction;
      var useFirst;
      if (arguments.length < 2) {
        useFirst = true;
      } else {
        reduction = initialReduction;
      }
      this.__iterate(function(v, k, c)  {
        if (useFirst) {
          useFirst = false;
          reduction = v;
        } else {
          reduction = reducer.call(context, reduction, v, k, c);
        }
      });
      return reduction;
    },

    reduceRight: function(reducer, initialReduction, context) {
      var reversed = this.toKeyedSeq().reverse();
      return reversed.reduce.apply(reversed, arguments);
    },

    reverse: function() {
      return reify(this, reverseFactory(this, true));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, true));
    },

    some: function(predicate, context) {
      return !this.every(not(predicate), context);
    },

    sort: function(comparator) {
      return reify(this, sortFactory(this, comparator));
    },

    values: function() {
      return this.__iterator(ITERATE_VALUES);
    },


    // ### More sequential methods

    butLast: function() {
      return this.slice(0, -1);
    },

    isEmpty: function() {
      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
    },

    count: function(predicate, context) {
      return ensureSize(
        predicate ? this.toSeq().filter(predicate, context) : this
      );
    },

    countBy: function(grouper, context) {
      return countByFactory(this, grouper, context);
    },

    equals: function(other) {
      return deepEqual(this, other);
    },

    entrySeq: function() {
      var iterable = this;
      if (iterable._cache) {
        // We cache as an entries array, so we can just return the cache!
        return new ArraySeq(iterable._cache);
      }
      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
      return entriesSequence;
    },

    filterNot: function(predicate, context) {
      return this.filter(not(predicate), context);
    },

    findEntry: function(predicate, context, notSetValue) {
      var found = notSetValue;
      this.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          found = [k, v];
          return false;
        }
      });
      return found;
    },

    findKey: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry && entry[0];
    },

    findLast: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
    },

    findLastEntry: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
    },

    findLastKey: function(predicate, context) {
      return this.toKeyedSeq().reverse().findKey(predicate, context);
    },

    first: function() {
      return this.find(returnTrue);
    },

    flatMap: function(mapper, context) {
      return reify(this, flatMapFactory(this, mapper, context));
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, true));
    },

    fromEntrySeq: function() {
      return new FromEntriesSequence(this);
    },

    get: function(searchKey, notSetValue) {
      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
    },

    getIn: function(searchKeyPath, notSetValue) {
      var nested = this;
      // Note: in an ES6 environment, we would prefer:
      // for (var key of searchKeyPath) {
      var iter = forceIterator(searchKeyPath);
      var step;
      while (!(step = iter.next()).done) {
        var key = step.value;
        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
        if (nested === NOT_SET) {
          return notSetValue;
        }
      }
      return nested;
    },

    groupBy: function(grouper, context) {
      return groupByFactory(this, grouper, context);
    },

    has: function(searchKey) {
      return this.get(searchKey, NOT_SET) !== NOT_SET;
    },

    hasIn: function(searchKeyPath) {
      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
    },

    isSubset: function(iter) {
      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
      return this.every(function(value ) {return iter.includes(value)});
    },

    isSuperset: function(iter) {
      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
      return iter.isSubset(this);
    },

    keyOf: function(searchValue) {
      return this.findKey(function(value ) {return is(value, searchValue)});
    },

    keySeq: function() {
      return this.toSeq().map(keyMapper).toIndexedSeq();
    },

    last: function() {
      return this.toSeq().reverse().first();
    },

    lastKeyOf: function(searchValue) {
      return this.toKeyedSeq().reverse().keyOf(searchValue);
    },

    max: function(comparator) {
      return maxFactory(this, comparator);
    },

    maxBy: function(mapper, comparator) {
      return maxFactory(this, comparator, mapper);
    },

    min: function(comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
    },

    minBy: function(mapper, comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
    },

    rest: function() {
      return this.slice(1);
    },

    skip: function(amount) {
      return this.slice(Math.max(0, amount));
    },

    skipLast: function(amount) {
      return reify(this, this.toSeq().reverse().skip(amount).reverse());
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, true));
    },

    skipUntil: function(predicate, context) {
      return this.skipWhile(not(predicate), context);
    },

    sortBy: function(mapper, comparator) {
      return reify(this, sortFactory(this, comparator, mapper));
    },

    take: function(amount) {
      return this.slice(0, Math.max(0, amount));
    },

    takeLast: function(amount) {
      return reify(this, this.toSeq().reverse().take(amount).reverse());
    },

    takeWhile: function(predicate, context) {
      return reify(this, takeWhileFactory(this, predicate, context));
    },

    takeUntil: function(predicate, context) {
      return this.takeWhile(not(predicate), context);
    },

    valueSeq: function() {
      return this.toIndexedSeq();
    },


    // ### Hashable Object

    hashCode: function() {
      return this.__hash || (this.__hash = hashIterable(this));
    }


    // ### Internal

    // abstract __iterate(fn, reverse)

    // abstract __iterator(type, reverse)
  });

  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  var IterablePrototype = Iterable.prototype;
  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
  IterablePrototype.__toJS = IterablePrototype.toArray;
  IterablePrototype.__toStringMapper = quoteString;
  IterablePrototype.inspect =
  IterablePrototype.toSource = function() { return this.toString(); };
  IterablePrototype.chain = IterablePrototype.flatMap;
  IterablePrototype.contains = IterablePrototype.includes;

  mixin(KeyedIterable, {

    // ### More sequential methods

    flip: function() {
      return reify(this, flipFactory(this));
    },

    mapEntries: function(mapper, context) {var this$0 = this;
      var iterations = 0;
      return reify(this,
        this.toSeq().map(
          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
        ).fromEntrySeq()
      );
    },

    mapKeys: function(mapper, context) {var this$0 = this;
      return reify(this,
        this.toSeq().flip().map(
          function(k, v)  {return mapper.call(context, k, v, this$0)}
        ).flip()
      );
    }

  });

  var KeyedIterablePrototype = KeyedIterable.prototype;
  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



  mixin(IndexedIterable, {

    // ### Conversion to other types

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, false);
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, false));
    },

    findIndex: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    indexOf: function(searchValue) {
      var key = this.keyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    lastIndexOf: function(searchValue) {
      var key = this.lastKeyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    reverse: function() {
      return reify(this, reverseFactory(this, false));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, false));
    },

    splice: function(index, removeNum /*, ...values*/) {
      var numArgs = arguments.length;
      removeNum = Math.max(removeNum | 0, 0);
      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
        return this;
      }
      // If index is negative, it should resolve relative to the size of the
      // collection. However size may be expensive to compute if not cached, so
      // only call count() if the number is in fact negative.
      index = resolveBegin(index, index < 0 ? this.count() : this.size);
      var spliced = this.slice(0, index);
      return reify(
        this,
        numArgs === 1 ?
          spliced :
          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
      );
    },


    // ### More collection methods

    findLastIndex: function(predicate, context) {
      var entry = this.findLastEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    first: function() {
      return this.get(0);
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, false));
    },

    get: function(index, notSetValue) {
      index = wrapIndex(this, index);
      return (index < 0 || (this.size === Infinity ||
          (this.size !== undefined && index > this.size))) ?
        notSetValue :
        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
    },

    has: function(index) {
      index = wrapIndex(this, index);
      return index >= 0 && (this.size !== undefined ?
        this.size === Infinity || index < this.size :
        this.indexOf(index) !== -1
      );
    },

    interpose: function(separator) {
      return reify(this, interposeFactory(this, separator));
    },

    interleave: function(/*...iterables*/) {
      var iterables = [this].concat(arrCopy(arguments));
      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
      var interleaved = zipped.flatten(true);
      if (zipped.size) {
        interleaved.size = zipped.size * iterables.length;
      }
      return reify(this, interleaved);
    },

    keySeq: function() {
      return Range(0, this.size);
    },

    last: function() {
      return this.get(-1);
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, false));
    },

    zip: function(/*, ...iterables */) {
      var iterables = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, iterables));
    },

    zipWith: function(zipper/*, ...iterables */) {
      var iterables = arrCopy(arguments);
      iterables[0] = this;
      return reify(this, zipWithFactory(this, zipper, iterables));
    }

  });

  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



  mixin(SetIterable, {

    // ### ES6 Collection methods (ES6 Array and Map)

    get: function(value, notSetValue) {
      return this.has(value) ? value : notSetValue;
    },

    includes: function(value) {
      return this.has(value);
    },


    // ### More sequential methods

    keySeq: function() {
      return this.valueSeq();
    }

  });

  SetIterable.prototype.has = IterablePrototype.includes;
  SetIterable.prototype.contains = SetIterable.prototype.includes;


  // Mixin subclasses

  mixin(KeyedSeq, KeyedIterable.prototype);
  mixin(IndexedSeq, IndexedIterable.prototype);
  mixin(SetSeq, SetIterable.prototype);

  mixin(KeyedCollection, KeyedIterable.prototype);
  mixin(IndexedCollection, IndexedIterable.prototype);
  mixin(SetCollection, SetIterable.prototype);


  // #pragma Helper functions

  function keyMapper(v, k) {
    return k;
  }

  function entryMapper(v, k) {
    return [k, v];
  }

  function not(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    }
  }

  function neg(predicate) {
    return function() {
      return -predicate.apply(this, arguments);
    }
  }

  function quoteString(value) {
    return typeof value === 'string' ? JSON.stringify(value) : String(value);
  }

  function defaultZipper() {
    return arrCopy(arguments);
  }

  function defaultNegComparator(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
  }

  function hashIterable(iterable) {
    if (iterable.size === Infinity) {
      return 0;
    }
    var ordered = isOrdered(iterable);
    var keyed = isKeyed(iterable);
    var h = ordered ? 1 : 0;
    var size = iterable.__iterate(
      keyed ?
        ordered ?
          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
        ordered ?
          function(v ) { h = 31 * h + hash(v) | 0; } :
          function(v ) { h = h + hash(v) | 0; }
    );
    return murmurHashOfSize(size, h);
  }

  function murmurHashOfSize(size, h) {
    h = imul(h, 0xCC9E2D51);
    h = imul(h << 15 | h >>> -15, 0x1B873593);
    h = imul(h << 13 | h >>> -13, 5);
    h = (h + 0xE6546B64 | 0) ^ size;
    h = imul(h ^ h >>> 16, 0x85EBCA6B);
    h = imul(h ^ h >>> 13, 0xC2B2AE35);
    h = smi(h ^ h >>> 16);
    return h;
  }

  function hashMerge(a, b) {
    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
  }

  var Immutable = {

    Iterable: Iterable,

    Seq: Seq,
    Collection: Collection,
    Map: Map,
    OrderedMap: OrderedMap,
    List: List,
    Stack: Stack,
    Set: Set,
    OrderedSet: OrderedSet,

    Record: Record,
    Range: Range,
    Repeat: Repeat,

    is: is,
    fromJS: fromJS

  };

  return Immutable;

}));

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.draftjsToHtml=e():t.draftjsToHtml=e()}("undefined"!=typeof self?self:this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var u=n[r]={i:r,l:!1,exports:{}};return t[r].call(u.exports,u,u.exports,e),u.l=!0,u.exports}var n={};return e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=1)}([function(t,e,n){"use strict";function r(t){return t&&S[t]}function u(t){var e="";return(0,L.forEach)(t,function(t,n){n&&(e+=t+":"+n+";")}),e}function a(t,e){var n=[];if(e)for(var r=0,u=0,a=t,o=e.trigger||"#",i=e.separator||" ";a.length>0&&u>=0;)if(a[0]===o?(u=0,r=0,a=a.substr(o.length)):(u=a.indexOf(i+o))>=0&&(a=a.substr(u+(i+o).length),r+=u+i.length),u>=0){var s=a.indexOf(i)>=0?a.indexOf(i):a.length,f=a.substr(0,s);f&&f.length>0&&n.push({offset:r,length:f.length+o.length,type:"HASHTAG"}),r+=o.length}return n}function o(t,e){var n=[],r=0,u=t.entityRanges.map(function(t){return{offset:t.offset,length:t.length,key:t.key,type:"ENTITY"}});return u=u.concat(a(t.text,e)),u=u.sort(function(t,e){return t.offset-e.offset}),u.forEach(function(t){t.offset>r&&n.push({start:r,end:t.offset}),n.push({start:t.offset,end:t.offset+t.length,entityKey:t.key,type:t.type}),r=t.offset+t.length}),r<t.text.length&&n.push({start:r,end:t.text.length}),n}function i(t){return!!(t.entityRanges.length>0&&(0,L.isEmptyString)(t.text)||"atomic"===t.type)}function s(t){var e=t.text,n=t.inlineStyleRanges,r={BOLD:new Array(e.length),ITALIC:new Array(e.length),UNDERLINE:new Array(e.length),STRIKETHROUGH:new Array(e.length),CODE:new Array(e.length),SUPERSCRIPT:new Array(e.length),SUBSCRIPT:new Array(e.length),COLOR:new Array(e.length),BGCOLOR:new Array(e.length),FONTSIZE:new Array(e.length),FONTFAMILY:new Array(e.length),length:e.length};return n&&n.length>0&&n.forEach(function(t){for(var e=t.offset,n=e+t.length,u=e;u<n;u+=1)0===t.style.indexOf("color-")?r.COLOR[u]=t.style.substring(6):0===t.style.indexOf("bgcolor-")?r.BGCOLOR[u]=t.style.substring(8):0===t.style.indexOf("fontsize-")?r.FONTSIZE[u]=t.style.substring(9):0===t.style.indexOf("fontfamily-")?r.FONTFAMILY[u]=t.style.substring(11):r[t.style]&&(r[t.style][u]=!0)}),r}function f(t,e){var n={};return t.COLOR[e]&&(n.COLOR=t.COLOR[e]),t.BGCOLOR[e]&&(n.BGCOLOR=t.BGCOLOR[e]),t.FONTSIZE[e]&&(n.FONTSIZE=t.FONTSIZE[e]),t.FONTFAMILY[e]&&(n.FONTFAMILY=t.FONTFAMILY[e]),t.UNDERLINE[e]&&(n.UNDERLINE=!0),t.ITALIC[e]&&(n.ITALIC=!0),t.BOLD[e]&&(n.BOLD=!0),t.STRIKETHROUGH[e]&&(n.STRIKETHROUGH=!0),t.CODE[e]&&(n.CODE=!0),t.SUBSCRIPT[e]&&(n.SUBSCRIPT=!0),t.SUPERSCRIPT[e]&&(n.SUPERSCRIPT=!0),n}function l(t,e,n){var r=!0;return n>0&&n<t.length?e.forEach(function(e){r=r&&t[e][n]===t[e][n-1]}):r=!1,r}function h(t,e){return"BOLD"===t?"<strong>"+e+"</strong>":"ITALIC"===t?"<em>"+e+"</em>":"UNDERLINE"===t?"<ins>"+e+"</ins>":"STRIKETHROUGH"===t?"<del>"+e+"</del>":"CODE"===t?"<code>"+e+"</code>":"SUPERSCRIPT"===t?"<sup>"+e+"</sup>":"SUBSCRIPT"===t?"<sub>"+e+"</sub>":e}function c(t){if(t&&t.length>0){return t.map(function(t){switch(t){case"\n":return"<br>";case"&":return"&amp;";case"<":return"&lt;";case">":return"&gt;";default:return t}}).join("")}return""}function p(t,e){if(t&&(t.COLOR||t.BGCOLOR||t.FONTSIZE||t.FONTFAMILY)){var n='style="';return t.COLOR&&(n+="color: "+t.COLOR+";"),t.BGCOLOR&&(n+="background-color: "+t.BGCOLOR+";"),t.FONTSIZE&&(n+="font-size: "+t.FONTSIZE+(/^\d+$/.test(t.FONTSIZE)?"px":"")+";"),t.FONTFAMILY&&(n+="font-family: "+t.FONTFAMILY+";"),"<span "+(n+='"')+">"+e+"</span>"}return e}function g(t,e,n,r){var u=t[e];if("function"==typeof r){var a=r(u,n);if(a)return a}if("MENTION"===u.type)return'<a href="'+u.data.url+'" class="wysiwyg-mention" data-mention data-value="'+u.data.value+'">'+n+"</a>";if("LINK"===u.type){var o=u.data.targetOption||"_self";return'<a href="'+u.data.url+'" target="'+o+'">'+n+"</a>"}return"IMAGE"===u.type?'<img src="'+u.data.src+'" alt="'+u.data.alt+'" style="float:'+(u.data.alignment||"none")+";height: "+u.data.height+";width: "+u.data.width+'"/>':"EMBEDDED_LINK"===u.type?'<iframe width="'+u.data.width+'" height="'+u.data.height+'" src="'+u.data.src+'" frameBorder="0"></iframe>':n}function d(t,e,n,r){var u=[],a=t.text;if(a.length>0)for(var o=s(t),i=void 0,h=n;h<r;h+=1)h!==n&&l(o,e,h)?(i.text.push(a[h]),i.end=h+1):(i={styles:f(o,h),text:[a[h]],start:h,end:h+1},u.push(i));return u}function y(t){if(t){for(var e=t,n=0;n<e.length&&" "===t[n];n+=1)e=e.replace(" ","&nbsp;");return e}return t}function O(t){if(t){for(var e=t,n=e.length-1;n>=0&&" "===e[n];n-=1)e=e.substring(0,n)+"&nbsp;"+e.substring(n+1);return e}return t}function T(t){var e=t.styles,n=t.text,r=c(n);return(0,L.forEach)(e,function(t,e){r=h(t,r,e)}),r}function I(t,e){var n=d(t,["BOLD","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT"],e.start,e.end),r="";return n.forEach(function(t){r+=T(t)}),r=p(e.styles,r)}function v(t,e,n,r){var u=[];d(t,["COLOR","BGCOLOR","FONTSIZE","FONTFAMILY"],n.start,n.end).forEach(function(e){u.push(I(t,e))});var a=u.join("");return"ENTITY"===n.type?void 0!==n.entityKey&&null!==n.entityKey&&(a=g(e,n.entityKey,a,r)):"HASHTAG"===n.type&&(a='<a href="'+a+'" class="wysiwyg-hashtag">'+a+"</a>"),a}function E(t,e,n,r){var u=[],a=o(t,n);return a.forEach(function(n,o){var i=v(t,e,n,r);0===o&&(i=y(i)),o===a.length-1&&(i=O(i)),u.push(i)}),u.join("")}function R(t,e,n,a,o){var s=[];if(i(t))s.push(g(e,t.entityRanges[0].key,void 0,o));else{var f=r(t.type);if(f){s.push("<"+f);var l=u(t.data);l&&s.push(' style="'+l+'"'),a&&s.push(' dir = "auto"'),s.push(">"),s.push(E(t,e,n,o)),s.push("</"+f+">")}}return s.push("\n"),s.join("")}Object.defineProperty(e,"__esModule",{value:!0}),e.getBlockTag=r,e.getBlockStyle=u,e.getStylesAtOffset=f,e.sameStyleAsPrevious=l,e.addInlineStyleMarkup=h,e.addStylePropertyMarkup=p,e.trimLeadingZeros=y,e.trimTrailingZeros=O,e.getBlockInnerMarkup=E,e.getBlockMarkup=R;var L=n(2),S={unstyled:"p","header-one":"h1","header-two":"h2","header-three":"h3","header-four":"h4","header-five":"h5","header-six":"h6","unordered-list-item":"ul","ordered-list-item":"ol",blockquote:"blockquote",code:"pre"}},function(t,e,n){"use strict";function r(t,e,n,r){var o=[];if(t){var i=t.blocks,s=t.entityMap;if(i&&i.length>0){var f=[];if(i.forEach(function(t){if((0,a.isList)(t.type))f.push(t);else{if(f.length>0){var i=(0,a.getListMarkup)(f,s,e,r);o.push(i),f=[]}var l=(0,u.getBlockMarkup)(t,s,e,n,r);o.push(l)}}),f.length>0){var l=(0,a.getListMarkup)(f,s,e,n,r);o.push(l),f=[]}}}return o.join("")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=r;var u=n(0),a=n(3)},function(t,e,n){"use strict";function r(t,e){if(t)for(var n in t)({}).hasOwnProperty.call(t,n)&&e(n,t[n])}function u(t){return void 0===t||null===t||0===t.length||0===t.trim().length}Object.defineProperty(e,"__esModule",{value:!0}),e.forEach=r,e.isEmptyString=u},function(t,e,n){"use strict";function r(t){return"unordered-list-item"===t||"ordered-list-item"===t}function u(t,e,n,r,o){var i=[],s=[],f=void 0;return t.forEach(function(t){var l=!1;if(f?f.type!==t.type?(i.push("</"+(0,a.getBlockTag)(f.type)+">\n"),i.push("<"+(0,a.getBlockTag)(t.type)+">\n")):f.depth===t.depth?s&&s.length>0&&(i.push(u(s,e,n,r,o)),s=[]):(l=!0,s.push(t)):i.push("<"+(0,a.getBlockTag)(t.type)+">\n"),!l){i.push("<li");var h=(0,a.getBlockStyle)(t.data);h&&i.push(' style="'+h+'"'),r&&i.push(' dir = "auto"'),i.push(">"),i.push((0,a.getBlockInnerMarkup)(t,e,n,o)),i.push("</li>\n"),f=t}}),s&&s.length>0&&i.push(u(s,e,n,r,o)),i.push("</"+(0,a.getBlockTag)(f.type)+">\n"),i.join("")}Object.defineProperty(e,"__esModule",{value:!0}),e.isList=r,e.getListMarkup=u;var a=n(0)}])});

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(478);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(314)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../css-loader/index.js!./react-draft-wysiwyg.css", function() {
			var newContent = require("!!../../css-loader/index.js!./react-draft-wysiwyg.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(313)(false);
// imports


// module
exports.push([module.i, ".rdw-option-wrapper {\n  border: 1px solid #F1F1F1;\n  padding: 5px;\n  min-width: 25px;\n  height: 20px;\n  border-radius: 2px;\n  margin: 0 4px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n  background: white;\n  text-transform: capitalize;\n}\n.rdw-option-wrapper:hover {\n  box-shadow: 1px 1px 0px #BFBDBD;\n}\n.rdw-option-wrapper:active {\n  box-shadow: 1px 1px 0px #BFBDBD inset;\n}\n.rdw-option-active {\n  box-shadow: 1px 1px 0px #BFBDBD inset;\n}\n.rdw-option-disabled {\n  opacity: 0.3;\n  cursor: default;\n}\n.rdw-dropdown-wrapper {\n  height: 30px;\n  background: white;\n  cursor: pointer;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  margin: 0 3px;\n  text-transform: capitalize;\n  background: white;\n}\n.rdw-dropdown-wrapper:focus {\n  outline: none;\n}\n.rdw-dropdown-wrapper:hover {\n  box-shadow: 1px 1px 0px #BFBDBD;\n  background-color: #FFFFFF;\n}\n.rdw-dropdown-wrapper:active {\n  box-shadow: 1px 1px 0px #BFBDBD inset;\n}\n.rdw-dropdown-carettoopen {\n  height: 0px;\n  width: 0px;\n  position: absolute;\n  top: 35%;\n  right: 10%;\n  border-top: 6px solid black;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n}\n.rdw-dropdown-carettoclose {\n  height: 0px;\n  width: 0px;\n  position: absolute;\n  top: 35%;\n  right: 10%;\n  border-bottom: 6px solid black;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n}\n.rdw-dropdown-selectedtext {\n  display: flex;\n  position: relative;\n  height: 100%;\n  align-items: center;\n  padding: 0 5px;\n}\n.rdw-dropdown-optionwrapper {\n  z-index: 100;\n  position: relative;\n  border: 1px solid #F1F1F1;\n  width: 98%;\n  background: white;\n  border-radius: 2px;\n  margin: 0;\n  padding: 0;\n  max-height: 250px;\n  overflow-y: scroll;\n}\n.rdw-dropdown-optionwrapper:hover {\n  box-shadow: 1px 1px 0px #BFBDBD;\n  background-color: #FFFFFF;\n}\n.rdw-dropdownoption-default {\n  min-height: 25px;\n  display: flex;\n  align-items: center;\n  padding: 0 5px;\n}\n.rdw-dropdownoption-highlighted {\n  background: #F1F1F1;\n}\n.rdw-dropdownoption-active {\n  background: #f5f5f5;\n}\n.rdw-dropdownoption-disabled {\n  opacity: 0.3;\n  cursor: default;\n}\n.rdw-inline-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n}\n.rdw-inline-dropdown {\n  width: 50px;\n}\n.rdw-inline-dropdownoption {\n  height: 40px;\n  display: flex;\n  justify-content: center;\n}\n.rdw-block-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n}\n.rdw-block-dropdown {\n  width: 110px;\n}\n.rdw-fontsize-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n}\n.rdw-fontsize-dropdown {\n  min-width: 40px;\n}\n.rdw-fontsize-option {\n  display: flex;\n  justify-content: center;\n}\n.rdw-fontfamily-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n}\n.rdw-fontfamily-dropdown {\n  width: 115px;\n}\n.rdw-fontfamily-placeholder {\n  white-space: nowrap;\n  max-width: 90px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.rdw-fontfamily-optionwrapper {\n  width: 140px;\n}\n.rdw-list-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n}\n.rdw-list-dropdown {\n  width: 50px;\n  z-index: 90;\n}\n.rdw-list-dropdownOption {\n  height: 40px;\n  display: flex;\n  justify-content: center;\n}\n.rdw-text-align-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n}\n.rdw-text-align-dropdown {\n  width: 50px;\n  z-index: 90;\n}\n.rdw-text-align-dropdownOption {\n  height: 40px;\n  display: flex;\n  justify-content: center;\n}\n.rdw-right-aligned-block {\n  text-align: right;\n}\n.rdw-left-aligned-block {\n  text-align: left !important;\n}\n.rdw-center-aligned-block {\n  text-align: center !important;\n}\n.rdw-justify-aligned-block {\n  text-align: justify !important;\n}\n.rdw-right-aligned-block > div {\n  display: inline-block;\n}\n.rdw-left-aligned-block > div {\n  display: inline-block;\n}\n.rdw-center-aligned-block > div {\n  display: inline-block;\n}\n.rdw-justify-aligned-block > div {\n  display: inline-block;\n}\n.rdw-colorpicker-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  position: relative;\n}\n.rdw-colorpicker-modal {\n  position: absolute;\n  top: 35px;\n  left: 5px;\n  display: flex;\n  flex-direction: column;\n  width: 175px;\n  height: 175px;\n  border: 1px solid #F1F1F1;\n  padding: 15px;\n  border-radius: 2px;\n  z-index: 100;\n  background: white;\n  box-shadow: 3px 3px 5px #BFBDBD;\n}\n.rdw-colorpicker-modal-header {\n  display: flex;\n  padding-bottom: 5px;\n}\n.rdw-colorpicker-modal-style-label {\n  font-size: 15px;\n  width: 50%;\n  text-align: center;\n  cursor: pointer;\n  padding: 0 10px 5px;\n}\n.rdw-colorpicker-modal-style-label-active {\n  border-bottom: 2px solid #0a66b7;\n}\n.rdw-colorpicker-modal-options {\n  margin: 5px auto;\n  display: flex;\n  width: 100%;\n  height: 100%;\n  flex-wrap: wrap;\n  overflow: scroll;\n}\n.rdw-colorpicker-cube {\n  width: 22px;\n  height: 22px;\n  border: 1px solid #F1F1F1;\n}\n.rdw-colorpicker-option {\n  margin: 3px;\n  padding: 0;\n  min-height: 20px;\n  border: none;\n  width: 22px;\n  height: 22px;\n  min-width: 22px;\n  box-shadow: 1px 2px 1px #BFBDBD inset;\n}\n.rdw-colorpicker-option:hover {\n  box-shadow: 1px 2px 1px #BFBDBD;\n}\n.rdw-colorpicker-option:active {\n  box-shadow: -1px -2px 1px #BFBDBD;\n}\n.rdw-colorpicker-option-active {\n  box-shadow: 0px 0px 2px 2px #BFBDBD;\n}\n.rdw-link-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  position: relative;\n}\n.rdw-link-dropdown {\n  width: 50px;\n}\n.rdw-link-dropdownOption {\n  height: 40px;\n  display: flex;\n  justify-content: center;\n}\n.rdw-link-dropdownPlaceholder {\n  margin-left: 8px;\n}\n.rdw-link-modal {\n  position: absolute;\n  top: 35px;\n  left: 5px;\n  display: flex;\n  flex-direction: column;\n  width: 235px;\n  height: 205px;\n  border: 1px solid #F1F1F1;\n  padding: 15px;\n  border-radius: 2px;\n  z-index: 100;\n  background: white;\n  box-shadow: 3px 3px 5px #BFBDBD;\n}\n.rdw-link-modal-label {\n  font-size: 15px;\n}\n.rdw-link-modal-input {\n  margin-top: 5px;\n  border-radius: 2px;\n  border: 1px solid #F1F1F1;\n  height: 25px;\n  margin-bottom: 15px;\n  padding: 0 5px;\n}\n.rdw-link-modal-input:focus {\n  outline: none;\n}\n.rdw-link-modal-buttonsection {\n  margin: 0 auto;\n}\n.rdw-link-modal-target-option {\n  margin-bottom: 20px;\n}\n.rdw-link-modal-target-option > span {\n  margin-left: 5px;\n}\n.rdw-link-modal-btn {\n  margin-left: 10px;\n  width: 75px;\n  height: 30px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  cursor: pointer;\n  background: white;\n  text-transform: capitalize;\n}\n.rdw-link-modal-btn:hover {\n  box-shadow: 1px 1px 0px #BFBDBD;\n}\n.rdw-link-modal-btn:active {\n  box-shadow: 1px 1px 0px #BFBDBD inset;\n}\n.rdw-link-modal-btn:focus {\n  outline: none !important;\n}\n.rdw-link-modal-btn:disabled {\n  background: #ece9e9;\n}\n.rdw-link-dropdownoption {\n  height: 40px;\n  display: flex;\n  justify-content: center;\n}\n.rdw-history-dropdown {\n  width: 50px;\n}\n.rdw-embedded-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  position: relative;\n}\n.rdw-embedded-modal {\n  position: absolute;\n  top: 35px;\n  left: 5px;\n  display: flex;\n  flex-direction: column;\n  width: 235px;\n  height: 180px;\n  border: 1px solid #F1F1F1;\n  padding: 15px;\n  border-radius: 2px;\n  z-index: 100;\n  background: white;\n  justify-content: space-between;\n  box-shadow: 3px 3px 5px #BFBDBD;\n}\n.rdw-embedded-modal-header {\n  font-size: 15px;\n  display: flex;\n}\n.rdw-embedded-modal-header-option {\n  width: 50%;\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n}\n.rdw-embedded-modal-header-label {\n  width: 95px;\n  border: 1px solid #f1f1f1;\n  margin-top: 5px;\n  background: #6EB8D4;\n  border-bottom: 2px solid #0a66b7;\n}\n.rdw-embedded-modal-link-section {\n  display: flex;\n  flex-direction: column;\n}\n.rdw-embedded-modal-link-input {\n  width: 88%;\n  height: 35px;\n  margin: 10px 0;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  font-size: 15px;\n  padding: 0 5px;\n}\n.rdw-embedded-modal-link-input-wrapper {\n  display: flex;\n  align-items: center;\n}\n.rdw-embedded-modal-link-input:focus {\n  outline: none;\n}\n.rdw-embedded-modal-btn-section {\n  display: flex;\n  justify-content: center;\n}\n.rdw-embedded-modal-btn {\n  margin: 0 3px;\n  width: 75px;\n  height: 30px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  cursor: pointer;\n  background: white;\n  text-transform: capitalize;\n}\n.rdw-embedded-modal-btn:hover {\n  box-shadow: 1px 1px 0px #BFBDBD;\n}\n.rdw-embedded-modal-btn:active {\n  box-shadow: 1px 1px 0px #BFBDBD inset;\n}\n.rdw-embedded-modal-btn:focus {\n  outline: none !important;\n}\n.rdw-embedded-modal-btn:disabled {\n  background: #ece9e9;\n}\n.rdw-embedded-modal-size {\n  align-items: center;\n  display: flex;\n  margin: 8px 0;\n  justify-content: space-between;\n}\n.rdw-embedded-modal-size-input {\n  width: 80%;\n  height: 20px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  font-size: 12px;\n}\n.rdw-embedded-modal-size-input:focus {\n  outline: none;\n}\n.rdw-emoji-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  position: relative;\n}\n.rdw-emoji-modal {\n  overflow: auto;\n  position: absolute;\n  top: 35px;\n  left: 5px;\n  display: flex;\n  flex-wrap: wrap;\n  width: 235px;\n  height: 180px;\n  border: 1px solid #F1F1F1;\n  padding: 15px;\n  border-radius: 2px;\n  z-index: 100;\n  background: white;\n  box-shadow: 3px 3px 5px #BFBDBD;\n}\n.rdw-emoji-icon {\n  margin: 2.5px;\n  height: 24px;\n  width: 24px;\n  cursor: pointer;\n  font-size: 22px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.rdw-spinner {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  width: 100%;\n}\n.rdw-spinner > div {\n  width: 12px;\n  height: 12px;\n  background-color: #333;\n\n  border-radius: 100%;\n  display: inline-block;\n  -webkit-animation: sk-bouncedelay 1.4s infinite ease-in-out both;\n  animation: sk-bouncedelay 1.4s infinite ease-in-out both;\n}\n.rdw-spinner .rdw-bounce1 {\n  -webkit-animation-delay: -0.32s;\n  animation-delay: -0.32s;\n}\n.rdw-spinner .rdw-bounce2 {\n  -webkit-animation-delay: -0.16s;\n  animation-delay: -0.16s;\n}\n@-webkit-keyframes sk-bouncedelay {\n  0%, 80%, 100% { -webkit-transform: scale(0) }\n  40% { -webkit-transform: scale(1.0) }\n}\n@keyframes sk-bouncedelay {\n  0%, 80%, 100% {\n    -webkit-transform: scale(0);\n    transform: scale(0);\n  } 40% {\n    -webkit-transform: scale(1.0);\n    transform: scale(1.0);\n  }\n}\n.rdw-image-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  position: relative;\n}\n.rdw-image-modal {\n  position: absolute;\n  top: 35px;\n  left: 5px;\n  display: flex;\n  flex-direction: column;\n  width: 235px;\n  border: 1px solid #F1F1F1;\n  padding: 15px;\n  border-radius: 2px;\n  z-index: 100;\n  background: white;\n  box-shadow: 3px 3px 5px #BFBDBD;\n}\n.rdw-image-modal-header {\n  font-size: 15px;\n  margin: 10px 0;\n  display: flex;\n}\n.rdw-image-modal-header-option {\n  width: 50%;\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n}\n.rdw-image-modal-header-label {\n  width: 80px;\n  background: #f1f1f1;\n  border: 1px solid #f1f1f1;\n  margin-top: 5px;\n}\n.rdw-image-modal-header-label-highlighted {\n  background: #6EB8D4;\n  border-bottom: 2px solid #0a66b7;\n}\n.rdw-image-modal-upload-option {\n  width: 100%;\n  color: gray;\n  cursor: pointer;\n  display: flex;\n  border: none;\n  font-size: 15px;\n  align-items: center;\n  justify-content: center;\n  background-color: #f1f1f1;\n  outline: 2px dashed gray;\n  outline-offset: -10px;\n  margin: 10px 0;\n  padding: 9px 0;\n}\n.rdw-image-modal-upload-option-highlighted {\n  outline: 2px dashed #0a66b7;\n}\n.rdw-image-modal-upload-option-label {\n  cursor: pointer;\n  height: 100%;\n  width: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  padding: 15px;\n}\n.rdw-image-modal-upload-option-label span{\n  padding: 0 20px;\n}\n.rdw-image-modal-upload-option-image-preview {\n  max-width: 100%;\n  max-height: 200px;\n}\n.rdw-image-modal-upload-option-input {\n\twidth: 0.1px;\n\theight: 0.1px;\n\topacity: 0;\n\toverflow: hidden;\n\tposition: absolute;\n\tz-index: -1;\n}\n.rdw-image-modal-url-section {\n  display: flex;\n  align-items: center;\n}\n.rdw-image-modal-url-input {\n  width: 90%;\n  height: 35px;\n  margin: 15px 0 12px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  font-size: 15px;\n  padding: 0 5px;\n}\n.rdw-image-modal-btn-section {\n  margin: 10px auto 0;\n}\n.rdw-image-modal-url-input:focus {\n  outline: none;\n}\n.rdw-image-modal-btn {\n  margin: 0 5px;\n  width: 75px;\n  height: 30px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  cursor: pointer;\n  background: white;\n  text-transform: capitalize;\n}\n.rdw-image-modal-btn:hover {\n  box-shadow: 1px 1px 0px #BFBDBD;\n}\n.rdw-image-modal-btn:active {\n  box-shadow: 1px 1px 0px #BFBDBD inset;\n}\n.rdw-image-modal-btn:focus {\n  outline: none !important;\n}\n.rdw-image-modal-btn:disabled {\n  background: #ece9e9;\n}\n.rdw-image-modal-spinner {\n  position: absolute;\n  top: -3px;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  opacity: 0.5;\n}\n.rdw-image-modal-alt-input {\n  width: 70%;\n  height: 20px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  font-size: 12px;\n  margin-left: 5px;\n}\n.rdw-image-modal-alt-input:focus {\n  outline: none;\n}\n.rdw-image-modal-alt-lbl {\n  font-size: 12px;\n}\n.rdw-image-modal-size {\n  align-items: center;\n  display: flex;\n  margin: 8px 0;\n  justify-content: space-between;\n}\n.rdw-image-modal-size-input {\n  width: 40%;\n  height: 20px;\n  border: 1px solid #F1F1F1;\n  border-radius: 2px;\n  font-size: 12px;\n}\n.rdw-image-modal-size-input:focus {\n  outline: none;\n}\n.rdw-image-mandatory-sign {\n  color: red;\n  margin-left: 3px;\n  margin-right: 3px;\n}\n.rdw-remove-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n  position: relative;\n}\n.rdw-history-wrapper {\n  display: flex;\n  align-items: center;\n  margin-bottom: 6px;\n}\n.rdw-history-dropdownoption {\n  height: 40px;\n  display: flex;\n  justify-content: center;\n}\n.rdw-history-dropdown {\n  width: 50px;\n}\n.rdw-link-decorator-wrapper {\n  position: relative;\n}\n.rdw-link-decorator-icon {\n  position: absolute;\n  left: 40%;\n  top: 0;\n  cursor: pointer;\n  background-color: white;\n}\n.rdw-mention-link {\n  text-decoration: none;\n  color: #1236ff;\n  background-color: #f0fbff;\n  padding: 1px 2px;\n  border-radius: 2px;\n}\n.rdw-suggestion-wrapper {\n  position: relative;\n}\n.rdw-suggestion-dropdown {\n  position: absolute;\n  display: flex;\n  flex-direction: column;\n  border: 1px solid #F1F1F1;\n  min-width: 100px;\n  max-height: 150px;\n  overflow: auto;\n  background: white;\n  z-index: 100;\n}\n.rdw-suggestion-option {\n  padding: 7px 5px;\n  border-bottom: 1px solid #f1f1f1;\n}\n.rdw-suggestion-option-active {\n  background-color: #F1F1F1;\n}\n.rdw-hashtag-link {\n  text-decoration: none;\n  color: #1236ff;\n  background-color: #f0fbff;\n  padding: 1px 2px;\n  border-radius: 2px;\n}\n.rdw-image-alignment-options-popup {\n  position: absolute;;\n  background: white;\n  display: flex;\n  padding: 5px 2px;\n  border-radius: 2px;\n  border: 1px solid #F1F1F1;\n  width: 105px;\n  cursor: pointer;\n  z-index: 100;\n}\n.rdw-alignment-option-left {\n  justify-content: flex-start;\n}\n.rdw-image-alignment-option {\n  height: 15px;\n  width: 15px;\n  min-width: 15px;\n}\n.rdw-image-alignment {\n  position: relative;\n}\n.rdw-image-imagewrapper {\n  position: relative;\n}\n.rdw-image-center {\n  display: flex;\n  justify-content: center;\n}\n.rdw-image-left {\n  display: flex;\n}\n.rdw-image-right {\n  display: flex;\n  justify-content: flex-end;\n}\n.rdw-image-alignment-options-popup-right {\n  right: 0;\n}\n.rdw-editor-main {\n  height: 100%;\n  overflow: auto;\n  box-sizing: border-box;\n}\n.rdw-editor-toolbar {\n  padding: 6px 5px 0;\n  border-radius: 2px;\n  border: 1px solid #F1F1F1;\n  display: flex;\n  justify-content: flex-start;\n  background: white;\n  flex-wrap: wrap;\n  font-size: 15px;\n  margin-bottom: 5px;\n  user-select: none;\n}\n.public-DraftStyleDefault-block {\n  margin: 1em 0;\n}\n.rdw-editor-wrapper:focus {\n  outline: none;\n}\n.rdw-editor-wrapper {\n  box-sizing: content-box;\n}\n.rdw-editor-main blockquote {\n  border-left: 5px solid #f1f1f1;\n  padding-left: 5px;\n}\n.rdw-editor-main pre {\n  background: #f1f1f1;\n  border-radius: 3px;\n  padding: 1px 10px;\n}/**\n * Draft v0.9.1\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n.DraftEditor-editorContainer,.DraftEditor-root,.public-DraftEditor-content{height:inherit;text-align:initial}.public-DraftEditor-content[contenteditable=true]{-webkit-user-modify:read-write-plaintext-only}.DraftEditor-root{position:relative}.DraftEditor-editorContainer{background-color:rgba(255,255,255,0);border-left:.1px solid transparent;position:relative;z-index:1}.public-DraftEditor-block{position:relative}.DraftEditor-alignLeft .public-DraftStyleDefault-block{text-align:left}.DraftEditor-alignLeft .public-DraftEditorPlaceholder-root{left:0;text-align:left}.DraftEditor-alignCenter .public-DraftStyleDefault-block{text-align:center}.DraftEditor-alignCenter .public-DraftEditorPlaceholder-root{margin:0 auto;text-align:center;width:100%}.DraftEditor-alignRight .public-DraftStyleDefault-block{text-align:right}.DraftEditor-alignRight .public-DraftEditorPlaceholder-root{right:0;text-align:right}.public-DraftEditorPlaceholder-root{color:#9197a3;position:absolute;z-index:0}.public-DraftEditorPlaceholder-hasFocus{color:#bdc1c9}.DraftEditorPlaceholder-hidden{display:none}.public-DraftStyleDefault-block{position:relative;white-space:pre-wrap}.public-DraftStyleDefault-ltr{direction:ltr;text-align:left}.public-DraftStyleDefault-rtl{direction:rtl;text-align:right}.public-DraftStyleDefault-listLTR{direction:ltr}.public-DraftStyleDefault-listRTL{direction:rtl}.public-DraftStyleDefault-ol,.public-DraftStyleDefault-ul{margin:16px 0;padding:0}.public-DraftStyleDefault-depth0.public-DraftStyleDefault-listLTR{margin-left:1.5em}.public-DraftStyleDefault-depth0.public-DraftStyleDefault-listRTL{margin-right:1.5em}.public-DraftStyleDefault-depth1.public-DraftStyleDefault-listLTR{margin-left:3em}.public-DraftStyleDefault-depth1.public-DraftStyleDefault-listRTL{margin-right:3em}.public-DraftStyleDefault-depth2.public-DraftStyleDefault-listLTR{margin-left:4.5em}.public-DraftStyleDefault-depth2.public-DraftStyleDefault-listRTL{margin-right:4.5em}.public-DraftStyleDefault-depth3.public-DraftStyleDefault-listLTR{margin-left:6em}.public-DraftStyleDefault-depth3.public-DraftStyleDefault-listRTL{margin-right:6em}.public-DraftStyleDefault-depth4.public-DraftStyleDefault-listLTR{margin-left:7.5em}.public-DraftStyleDefault-depth4.public-DraftStyleDefault-listRTL{margin-right:7.5em}.public-DraftStyleDefault-unorderedListItem{list-style-type:square;position:relative}.public-DraftStyleDefault-unorderedListItem.public-DraftStyleDefault-depth0{list-style-type:disc}.public-DraftStyleDefault-unorderedListItem.public-DraftStyleDefault-depth1{list-style-type:circle}.public-DraftStyleDefault-orderedListItem{list-style-type:none;position:relative}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-listLTR:before{left:-36px;position:absolute;text-align:right;width:30px}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-listRTL:before{position:absolute;right:-36px;text-align:left;width:30px}.public-DraftStyleDefault-orderedListItem:before{content:counter(ol0) \". \";counter-increment:ol0}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth1:before{content:counter(ol1) \". \";counter-increment:ol1}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth2:before{content:counter(ol2) \". \";counter-increment:ol2}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth3:before{content:counter(ol3) \". \";counter-increment:ol3}.public-DraftStyleDefault-orderedListItem.public-DraftStyleDefault-depth4:before{content:counter(ol4) \". \";counter-increment:ol4}.public-DraftStyleDefault-depth0.public-DraftStyleDefault-reset{counter-reset:ol0}.public-DraftStyleDefault-depth1.public-DraftStyleDefault-reset{counter-reset:ol1}.public-DraftStyleDefault-depth2.public-DraftStyleDefault-reset{counter-reset:ol2}.public-DraftStyleDefault-depth3.public-DraftStyleDefault-reset{counter-reset:ol3}.public-DraftStyleDefault-depth4.public-DraftStyleDefault-reset{counter-reset:ol4}", ""]);

// exports


/***/ }),
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */,
/* 488 */,
/* 489 */,
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lodash = __webpack_require__(34);

var _lodash2 = _interopRequireDefault(_lodash);

var _service = __webpack_require__(338);

var _reeValidate = __webpack_require__(344);

var _reeValidate2 = _interopRequireDefault(_reeValidate);

var _Form = __webpack_require__(502);

var _Form2 = _interopRequireDefault(_Form);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // import libs


// import components


var Page = function (_Component) {
  _inherits(Page, _Component);

  function Page(props) {
    _classCallCheck(this, Page);

    var _this = _possibleConstructorReturn(this, (Page.__proto__ || Object.getPrototypeOf(Page)).call(this, props));

    _this.validator = new _reeValidate2.default({
      title: 'required|min:3',
      content: 'required|min:10',
      description: 'required|min:10'
    });

    var article = _this.props.article.toJson();

    _this.state = {
      article: article,
      errors: _this.validator.errors
    };

    _this.handleSubmit = _this.handleSubmit.bind(_this);
    _this.handleChange = _this.handleChange.bind(_this);
    return _this;
  }

  _createClass(Page, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.loadArticle();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var article = nextProps.article.toJson();

      if (!_lodash2.default.isEqual(this.state.article, article)) {
        this.setState({ article: article });
      }
    }
  }, {
    key: 'loadArticle',
    value: function loadArticle() {
      var _props = this.props,
          match = _props.match,
          article = _props.article,
          dispatch = _props.dispatch;


      if (!article.id) {
        dispatch((0, _service.articleEditRequest)(match.params.id));
      }
    }
  }, {
    key: 'handleChange',
    value: function handleChange(name, value) {
      var _this2 = this;

      var errors = this.validator.errors;


      this.setState({ article: _extends({}, this.state.article, _defineProperty({}, name, value)) });

      errors.remove(name);

      this.validator.validate(name, value).then(function () {
        _this2.setState({ errors: errors });
      });
    }
  }, {
    key: 'handleSubmit',
    value: function handleSubmit(e) {
      var _this3 = this;

      e.preventDefault();
      var article = this.state.article;
      var errors = this.validator.errors;


      this.validator.validateAll(article).then(function (success) {
        if (success) {
          _this3.submit(article);
        } else {
          _this3.setState({ errors: errors });
        }
      });
    }
  }, {
    key: 'submit',
    value: function submit(article) {
      var _this4 = this;

      this.props.dispatch((0, _service.articleUpdateRequest)(article)).catch(function (_ref) {
        var error = _ref.error,
            statusCode = _ref.statusCode;
        var errors = _this4.validator.errors;


        if (statusCode === 422) {
          _lodash2.default.forOwn(error, function (message, field) {
            errors.add(field, message);
          });
        }

        _this4.setState({ errors: errors });
      });
    }
  }, {
    key: 'renderForm',
    value: function renderForm() {
      var article = this.props.article;


      if (article.id) {
        return _react2.default.createElement(_Form2.default, _extends({}, this.state, {
          onChange: this.handleChange,
          onSubmit: this.handleSubmit }));
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'main',
        { className: 'col-sm-9 ml-sm-auto col-md-10 pt-3', role: 'main' },
        _react2.default.createElement(
          'h1',
          null,
          'Edit'
        ),
        this.renderForm()
      );
    }
  }]);

  return Page;
}(_react.Component);

Page.displayName = 'EditArticle';
Page.propTypes = {
  match: _propTypes2.default.object.isRequired,
  article: _propTypes2.default.object,
  dispatch: _propTypes2.default.func.isRequired
};
exports.default = Page;

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _wysiwygEditor = __webpack_require__(388);

var _wysiwygEditor2 = _interopRequireDefault(_wysiwygEditor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var displayName = 'ArticleFrom';
var propTypes = {
  article: _propTypes2.default.object.isRequired,
  errors: _propTypes2.default.object.isRequired,
  onChange: _propTypes2.default.func.isRequired,
  onSubmit: _propTypes2.default.func.isRequired
};

var Form = function Form(_ref) {
  var article = _ref.article,
      errors = _ref.errors,
      onChange = _ref.onChange,
      _onSubmit = _ref.onSubmit;


  function handleChange(name, value) {
    if (value !== article[name]) {
      onChange(name, value);
    }
  }

  return _react2.default.createElement(
    'form',
    { onSubmit: function onSubmit(e) {
        return _onSubmit(e);
      } },
    _react2.default.createElement(
      'div',
      { className: 'form-group row' },
      _react2.default.createElement(
        'label',
        { htmlFor: 'title', className: 'col-sm-2 col-form-label' },
        'Title'
      ),
      _react2.default.createElement(
        'div',
        { className: 'col-sm-10' },
        _react2.default.createElement('input', { type: 'text',
          id: 'title',
          name: 'title',
          className: 'form-control ' + (errors.has('title') && 'is-invalid'),
          placeholder: 'Title',
          value: article.title || '',
          onChange: function onChange(e) {
            return handleChange(e.target.name, e.target.value);
          } }),
        errors.has('title') && _react2.default.createElement(
          'div',
          { className: 'invalid-feedback' },
          errors.first('title')
        )
      )
    ),
    _react2.default.createElement(
      'div',
      { className: 'form-group row' },
      _react2.default.createElement(
        'label',
        { htmlFor: 'description', className: 'col-sm-2 col-form-label' },
        'Description'
      ),
      _react2.default.createElement(
        'div',
        { className: 'col-sm-10' },
        _react2.default.createElement('textarea', { id: 'description',
          name: 'description',
          className: 'form-control ' + (errors.has('description') && 'is-invalid'),
          rows: '3',
          placeholder: 'Description',
          value: article.description,
          onChange: function onChange(e) {
            return handleChange(e.target.name, e.target.value);
          } }),
        errors.has('description') && _react2.default.createElement(
          'div',
          { className: 'invalid-feedback' },
          errors.first('description')
        )
      )
    ),
    _react2.default.createElement(
      'div',
      { className: 'form-group row' },
      _react2.default.createElement(
        'label',
        { htmlFor: 'content', className: 'col-sm-2 col-form-label' },
        'Content'
      ),
      _react2.default.createElement(
        'div',
        { className: 'col-sm-10' },
        _react2.default.createElement(_wysiwygEditor2.default, { id: 'content', value: article.content, onChange: function onChange(e) {
            return handleChange('content', e);
          } }),
        errors.has('content') && _react2.default.createElement(
          'div',
          { className: 'invalid-feedback' },
          errors.first('content')
        )
      )
    ),
    _react2.default.createElement(
      'div',
      { className: 'form-group row' },
      _react2.default.createElement(
        'div',
        { className: 'col-sm-10 ml-auto' },
        _react2.default.createElement(
          'button',
          { disabled: errors.any(), type: 'submit', className: 'btn btn-primary' },
          'Update'
        )
      )
    )
  );
};

Form.displayName = displayName;
Form.propTypes = propTypes;

exports.default = Form;

/***/ })
]));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL21vZHVsZXMvYXJ0aWNsZS9wYWdlcy9lZGl0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9ub2RlX21vZHVsZXMvaW1tdXRhYmxlL2Rpc3QvaW1tdXRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRWRpdG9yU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdE1vZGlmaWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvQ2hhcmFjdGVyTWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9Db250ZW50QmxvY2tOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9udWxsdGhyb3dzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9Vc2VyQWdlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZW5lcmF0ZVJhbmRvbUtleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0RmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvQ29udGVudEJsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9Vbmljb2RlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9TZWxlY3Rpb25TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY3guanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9tb2R1bGVzL2FydGljbGUvQXJ0aWNsZS5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL21vZHVsZXMvYXJ0aWNsZS9zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvbW9kdWxlcy9hcnRpY2xlL3N0b3JlL2FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9CbG9ja01hcEJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9maW5kUmFuZ2VzSW1tdXRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvaXNFdmVudEhhbmRsZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9yZW1vdmVUZXh0V2l0aFN0cmF0ZWd5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWUtdmFsaWRhdGUvZGlzdC9yZWUtdmFsaWRhdGUuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZ2V0Q29udGVudFN0YXRlRnJhZ21lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdEVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0T2Zmc2V0S2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvQ29udGVudFN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvc2FuaXRpemVEcmFmdFRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL1VuaWNvZGVCaWRpRGlyZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRGVmYXVsdERyYWZ0QmxvY2tSZW5kZXJNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXRFbnRpdHlLZXlGb3JTZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL1N0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRTY3JvbGxQb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2ZpbmRBbmNlc3Rvck9mZnNldEtleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0tleUJpbmRpbmdVdGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvbW92ZVNlbGVjdGlvbkJhY2t3YXJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRHJhZnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9yYW5kb21pemVCbG9ja01hcEtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9yZW1vdmVFbnRpdGllc0F0RWRnZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9pbnNlcnRJbnRvTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2dldE5leHREZWxpbWl0ZXJCbG9ja0tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0Jsb2NrVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0RW50aXR5SW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL1VuaWNvZGVCaWRpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRGVmYXVsdERyYWZ0SW5saW5lU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9pc1NlbGVjdGlvbkF0TGVhZlN0YXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRHJhZnRFZGl0b3JCbG9jay5yZWFjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvU2Nyb2xsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9EYXRhVHJhbnNmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXRTZWxlY3Rpb25PZmZzZXRLZXlGb3JOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZ2V0VGV4dENvbnRlbnRGcm9tRmlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXRVcGRhdGVkU2VsZWN0aW9uU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXRGcmFnbWVudEZyb21TZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXRSYW5nZUNsaWVudFJlY3RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZ2V0RHJhZnRFZGl0b3JTZWxlY3Rpb25XaXRoTm9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdFJlbW92YWJsZVdvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9tb3ZlU2VsZWN0aW9uRm9yd2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2NvbnZlcnRGcm9tSFRNTFRvQ29udGVudEJsb2Nrcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2dldFNhZmVCb2R5RnJvbUhUTUwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9SaWNoVGV4dEVkaXRvclV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXREZWZhdWx0S2V5QmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0U3RyaW5nS2V5LmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tbW9uL3d5c2l3eWctZWRpdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvQXRvbWljQmxvY2tVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0RmVhdHVyZUZsYWdzLWNvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9Db250ZW50U3RhdGVJbmxpbmVTdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2FwcGx5RW50aXR5VG9Db250ZW50U3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9hcHBseUVudGl0eVRvQ29udGVudEJsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZ2V0Q2hhcmFjdGVyUmVtb3ZhbFJhbmdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRHJhZnRFbnRpdHlTZWdtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2dldFJhbmdlc0ZvckRyYWZ0RW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvaW5zZXJ0RnJhZ21lbnRJbnRvQ29udGVudFN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvaW5zZXJ0VGV4dEludG9Db250ZW50U3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9tb2RpZnlCbG9ja0ZvckNvbnRlbnRTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL3JlbW92ZVJhbmdlRnJvbUNvbnRlbnRTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL3NwbGl0QmxvY2tJbkNvbnRlbnRTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0VkaXRvckJpZGlTZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9Vbmljb2RlQmlkaVNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9tb3ZlQmxvY2tJbkNvbnRlbnRTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0NvbXBvc2l0ZURyYWZ0RGVjb3JhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRHJhZnRFZGl0b3IucmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdEVkaXRvckNvbXBvc2l0aW9uSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0RWRpdG9yQ29udGVudHMucmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdEVkaXRvckNvbnRlbnRzLWNvcmUucmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdEVkaXRvckxlYWYucmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdEVkaXRvclRleHROb2RlLnJlYWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9Vc2VyQWdlbnREYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91YS1wYXJzZXItanMvc3JjL3VhLXBhcnNlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL1ZlcnNpb25SYW5nZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvbWFwT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL3NldERyYWZ0RWRpdG9yU2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRHJhZnRKc0RlYnVnTG9nZ2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0U3R5bGVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0RWxlbWVudFBvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRFbGVtZW50UmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0RG9jdW1lbnRTY3JvbGxFbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0Vmlld3BvcnREaW1lbnNpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9qb2luQ2xhc3Nlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0RWRpdG9yRHJhZ0hhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL1Bob3Rvc01pbWVUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0RWRpdG9yRWRpdEhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9lZGl0T25CZWZvcmVJbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZWRpdE9uQmx1ci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2VkaXRPbkNvbXBvc2l0aW9uU3RhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9lZGl0T25Db3B5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZWRpdE9uQ3V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZWRpdE9uRHJhZ092ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9lZGl0T25EcmFnU3RhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9lZGl0T25Gb2N1cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2VkaXRPbklucHV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZWRpdE9uS2V5RG93bi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL1NlY29uZGFyeUNsaXBib2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2tleUNvbW1hbmRCYWNrc3BhY2VUb1N0YXJ0T2ZMaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZXhwYW5kUmFuZ2VUb1N0YXJ0T2ZMaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIva2V5Q29tbWFuZEJhY2tzcGFjZVdvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL1Rva2VuaXplVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2tleUNvbW1hbmREZWxldGVXb3JkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIva2V5Q29tbWFuZEluc2VydE5ld2xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9rZXlDb21tYW5kTW92ZVNlbGVjdGlvblRvRW5kT2ZCbG9jay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2tleUNvbW1hbmRNb3ZlU2VsZWN0aW9uVG9TdGFydE9mQmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9rZXlDb21tYW5kUGxhaW5CYWNrc3BhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9rZXlDb21tYW5kUGxhaW5EZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9rZXlDb21tYW5kVHJhbnNwb3NlQ2hhcmFjdGVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2tleUNvbW1hbmRVbmRvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZWRpdE9uUGFzdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdFBhc3RlUHJvY2Vzc29yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9VUkkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9hZGp1c3RCbG9ja0RlcHRoRm9yQ29udGVudFN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvc3BsaXRUZXh0SW50b1RleHRCbG9ja3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9lZGl0T25TZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXREcmFmdEVkaXRvclNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0RWRpdG9yUGxhY2Vob2xkZXIucmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9jb252ZXJ0RnJvbURyYWZ0U3RhdGVUb1Jhdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2VuY29kZUVudGl0eVJhbmdlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2VuY29kZUlubGluZVN0eWxlUmFuZ2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvY29udmVydEZyb21SYXdUb0RyYWZ0U3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdFRyZWVBZGFwdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvY3JlYXRlQ2hhcmFjdGVyTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2RlY29kZUVudGl0eVJhbmdlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2RlY29kZUlubGluZVN0eWxlUmFuZ2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZ2V0VmlzaWJsZVNlbGVjdGlvblJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXRSYW5nZUJvdW5kaW5nQ2xpZW50UmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZnQtd3lzaXd5Zy9kaXN0L3JlYWN0LWRyYWZ0LXd5c2l3eWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltbXV0YWJsZS9kaXN0L2ltbXV0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZnRqcy10by1odG1sL2xpYi9kcmFmdGpzLXRvLWh0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWZ0LXd5c2l3eWcvZGlzdC9yZWFjdC1kcmFmdC13eXNpd3lnLmNzcz81MDAyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFmdC13eXNpd3lnL2Rpc3QvcmVhY3QtZHJhZnQtd3lzaXd5Zy5jc3MiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9tb2R1bGVzL2FydGljbGUvcGFnZXMvZWRpdC9QYWdlLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvbW9kdWxlcy9hcnRpY2xlL3BhZ2VzL2VkaXQvY29tcG9uZW50cy9Gb3JtLmpzIl0sIm5hbWVzIjpbIm1hcFN0YXRlVG9Qcm9wcyIsInN0YXRlIiwicm91dGVyIiwicGFyYW1zIiwibWF0Y2giLCJhcnRpY2xlIiwiYXJ0aWNsZXMiLCJkYXRhIiwiZmluZCIsImlkIiwiTnVtYmVyIiwiQXJ0aWNsZSIsIlBhZ2UiLCJwcm9wcyIsImluaXRpYWxpemUiLCJzbHVnIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImNvbnRlbnQiLCJwdWJsaXNoZWQiLCJwdWJsaXNoZWRBdCIsInVzZXIiLCJVc2VyIiwiTW9kZWwiLCJhcnRpY2xlQWRkUmVxdWVzdCIsImFydGljbGVVcGRhdGVSZXF1ZXN0IiwiYXJ0aWNsZVJlbW92ZVJlcXVlc3QiLCJhcnRpY2xlTGlzdFJlcXVlc3QiLCJhcnRpY2xlRWRpdFJlcXVlc3QiLCJhcnRpY2xlRmV0Y2hSZXF1ZXN0IiwiYXJ0aWNsZUFjdGlvbnMiLCJ0cmFuc2Zvcm1SZXF1ZXN0IiwicGFybXMiLCJUcmFuc2Zvcm1lciIsInNlbmQiLCJ0cmFuc2Zvcm1SZXNwb25zZSIsImZldGNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJIdHRwIiwicG9zdCIsInRoZW4iLCJkaXNwYXRjaCIsImFkZCIsInJlcyIsImNhdGNoIiwiZXJyIiwic3RhdHVzQ29kZSIsInJlc3BvbnNlIiwic3RhdHVzIiwiZXJyb3IiLCJyZXNldEVycm9ycyIsImVycm9ycyIsInJlcGxhY2UiLCJzZWFyY2hTdHIiLCJyZXBsYWNlU3RyIiwicmVzZXRWYWxpZGF0aW9uRmllbGRzIiwibWVzc2FnZSIsInBhdGNoIiwiZGVsZXRlIiwicmVtb3ZlIiwiY29uc29sZSIsInBhZ2VOdW1iZXIiLCJ1cmwiLCJnZXQiLCJsaXN0IiwidXBkYXRlIiwicGF5bG9hZCIsInR5cGUiLCJBUlRJQ0xFX0FERCIsIkFSVElDTEVfVVBEQVRFIiwiQVJUSUNMRV9SRU1PVkUiLCJBUlRJQ0xFX0xJU1QiLCJXWVNJV1lHIiwiZWRpdG9yU3RhdGUiLCJjb252ZXJ0SHRtbFRvRWRpdG9yU3RhdGUiLCJ2YWx1ZSIsIm9uRWRpdG9yU3RhdGVDaGFuZ2UiLCJiaW5kIiwiYmxvY2tzRnJvbUhUTUwiLCJDb250ZW50U3RhdGUiLCJjcmVhdGVGcm9tQmxvY2tBcnJheSIsImNvbnRlbnRCbG9ja3MiLCJlbnRpdHlNYXAiLCJFZGl0b3JTdGF0ZSIsImNyZWF0ZVdpdGhDb250ZW50Iiwic2V0U3RhdGUiLCJvbkNoYW5nZSIsImdldEN1cnJlbnRDb250ZW50IiwiQ29tcG9uZW50IiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwic3RyaW5nIiwiaXNSZXF1aXJlZCIsImZ1bmMiLCJ2YWxpZGF0b3IiLCJSZWVWYWxpZGF0ZSIsInRvSnNvbiIsImhhbmRsZVN1Ym1pdCIsImhhbmRsZUNoYW5nZSIsImxvYWRBcnRpY2xlIiwibmV4dFByb3BzIiwiXyIsImlzRXF1YWwiLCJuYW1lIiwidmFsaWRhdGUiLCJlIiwicHJldmVudERlZmF1bHQiLCJ2YWxpZGF0ZUFsbCIsInN1Y2Nlc3MiLCJzdWJtaXQiLCJmb3JPd24iLCJmaWVsZCIsInJlbmRlckZvcm0iLCJkaXNwbGF5TmFtZSIsIm9iamVjdCIsIm9uU3VibWl0IiwiRm9ybSIsImhhcyIsInRhcmdldCIsImZpcnN0IiwiYW55Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOzs7O0FBR0E7Ozs7OztBQUVBLElBQU1BLGtCQUFrQixTQUFsQkEsZUFBa0IsQ0FBQ0MsS0FBRCxFQUFRQyxNQUFSLEVBQW1CO0FBQUEsTUFDakNDLE1BRGlDLEdBQ3RCRCxPQUFPRSxLQURlLENBQ2pDRCxNQURpQzs7QUFFekMsTUFBTUUsVUFBVUosTUFBTUssUUFBTixDQUFlQyxJQUFmLENBQW9CQyxJQUFwQixDQUF5QjtBQUFBLFdBQVdILFFBQVFJLEVBQVIsS0FBZUMsT0FBT1AsT0FBT00sRUFBZCxDQUExQjtBQUFBLEdBQXpCLENBQWhCO0FBQ0EsU0FBTztBQUNMSixhQUFTQSxVQUFVLElBQUlNLGlCQUFKLENBQVlOLE9BQVosQ0FBVixHQUFpQyxJQUFJTSxpQkFBSixDQUFZLEVBQVo7QUFEckMsR0FBUDtBQUdELENBTkQ7O0FBSEE7a0JBV2UseUJBQVFYLGVBQVIsRUFBeUJZLGNBQXpCLEM7Ozs7OztBQ2RmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQixjQUFjOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QixtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2Qyx3QkFBd0I7QUFDckU7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsS0FBSztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRkFBbUYseUNBQXlDO0FBQzVIO0FBQ0E7QUFDQSxpRkFBaUYseUNBQXlDO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7QUFDN0QsU0FBUztBQUNUOztBQUVBO0FBQ0E7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O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FB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QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNELHFFQUFxRSxxQkFBcUI7QUFDMUY7O0FBRUEsd0RBQXdEO0FBQ3hELHFFQUFxRSxxQkFBcUI7QUFDMUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsS0FBSztBQUN4Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDO0FBQ3RDLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDLDJEQUEyRCxzQkFBc0I7QUFDakY7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx5QkFBeUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDRCQUE0QjtBQUN4RTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEO0FBQ3JELGtEQUFrRCx3QkFBd0I7QUFDMUU7O0FBRUE7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjtBQUN2RCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxLQUFLO0FBQy9DOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQW9DO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGNBQWMsRUFBRTtBQUNqRTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZSxFQUFFO0FBQ3ZEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlDQUF5Qyw4QkFBOEI7QUFDdkUsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxpRkFBaUYsWUFBWTtBQUM3RixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwwQ0FBMEMsMEJBQTBCO0FBQ3BFLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0JBQXdCO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHOzs7O0FBSUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDRDQUE0Qyw4QkFBOEI7QUFDMUUsS0FBSzs7QUFFTDtBQUNBLGdEQUFnRCw4QkFBOEI7QUFDOUUsS0FBSzs7QUFFTCwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOzs7O0FBSTdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUJBQXFCO0FBQzFELEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBOEMsRUFBRTtBQUMzRSwyQkFBMkIseUNBQXlDLEVBQUU7QUFDdEU7QUFDQSx3QkFBd0IsMEJBQTBCLEVBQUU7QUFDcEQsd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEc7Ozs7Ozs7QUNyM0pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkMsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlOztBQUV4UCxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsMkNBQTJDO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSw2Qjs7Ozs7OztBQ2hqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELDRCQUE0QixFQUFFO0FBQ2hGO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLDBCQUEwQixFQUFFO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQiw4QkFBOEI7QUFDL0M7O0FBRUE7QUFDQSxHQUFHOztBQUVILG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixvREFBb0Q7QUFDbEYsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0Msb0JBQW9CLEVBQUU7QUFDOUQ7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyx3QkFBd0IsRUFBRSx3QkFBd0Isb0JBQW9CLEVBQUU7QUFDN0cscURBQXFELHlCQUF5QixFQUFFO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUNBQXlDLHlCQUF5QixFQUFFO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTs7QUFFcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFOztBQUU3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMEJBQTBCLEVBQUU7QUFDdEU7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFVBQVUscUJBQXFCOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDhCQUE4QixFQUFFO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxtQ0FBbUMsd0JBQXdCLEVBQUUsRUFBRSxFQUFFO0FBQy9HOztBQUVBLDRDQUE0Qyw4QkFBOEIsRUFBRTtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixVQUFVLHFCQUFxQjs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0EsbUJBQW1CLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsVUFBVSxxQkFBcUI7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qix3RUFBd0U7QUFDaEc7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIsS0FBSztBQUNMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsdUJBQXVCLFdBQVcscUJBQXFCLFdBQVcscUJBQXFCOztBQUV2RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFLGtCQUFrQjtBQUNsQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUEsNEJBQTRCLGNBQWMscUJBQXFCLFVBQVUscUJBQXFCLFNBQVMscUJBQXFCO0FBQzVILHlCQUF5QixjQUFjLHFCQUFxQixVQUFVLHFCQUFxQixTQUFTLHFCQUFxQjs7QUFFekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw4QkFBOEIsRUFBRTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLLG1CQUFtQixNQUFNLG1CQUFtQixFQUFFO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7O0FBRWY7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQ0FBMEMsNkJBQTZCLEVBQUU7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZixHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILGVBQWUsZUFBZTtBQUM5QixHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMOztBQUVBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsSUFBSSxFQUFFOztBQUVOLHdEQUF3RCxvQ0FBb0MsVUFBVSxFQUFFLEVBQUUsRUFBRTtBQUM1Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEIsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxJQUFJLEVBQUU7O0FBRU4sd0RBQXdELG9DQUFvQyxVQUFVLEVBQUUsRUFBRSxFQUFFO0FBQzVHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQSwyQkFBMkIsR0FBRyx5Q0FBeUM7QUFDdkU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBOztBQUVBLDBCQUEwQixpQ0FBaUMsY0FBYztBQUN6RSx3QkFBd0IsMEJBQTBCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBLDhDQUE4QyxrQkFBa0IsRUFBRTtBQUNsRTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0QsNkJBQTZCLEVBQUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsb0NBQW9DLEVBQUU7QUFDcEYsT0FBTyxPQUFPO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7O0FBRUE7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtDQUErQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMEJBQTBCO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0NBQXdDO0FBQ3JGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLHNCQUFzQixVQUFVLEVBQUUsRUFBRTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxtRUFBbUU7QUFDN0U7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksRUFBRTtBQUNkO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCLGNBQWMsRUFBRTtBQUNoQixjQUFjLEVBQUU7QUFDaEI7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQSxjQUFjLEVBQUU7QUFDaEIsY0FBYyxFQUFFO0FBQ2hCLGNBQWMsRUFBRTtBQUNoQjs7QUFFQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0IsRUFBRSxPQUFPLEVBQUU7QUFDM0IsZ0JBQWdCLEVBQUU7QUFDbEIsaUJBQWlCLEVBQUUsT0FBTyxFQUFFOztBQUU1QixZQUFZLEVBQUU7QUFDZCxjQUFjLEVBQUUsT0FBTyxFQUFFO0FBQ3pCLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixFQUFFO0FBQzVCLDRCQUE0QixFQUFFLE9BQU8sRUFBRTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxRQUFRLG9EQUFvRDtBQUN2RSxXQUFXLE1BQU07QUFDakIsYUFBYSxLQUFLO0FBQ2xCLFlBQVksVUFBVTtBQUN0QixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUSxvREFBb0Q7QUFDdkUsV0FBVyxNQUFNLGlFQUFpRTtBQUNsRixhQUFhLEtBQUs7QUFDbEIsWUFBWSxV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QUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx5RUFBeUUsa0JBQWtCO0FBQzNGLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsOERBQThELGVBQWU7QUFDN0UsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsOERBQThELGNBQWM7QUFDNUUsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0UsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxvRUFBb0Usa0JBQWtCO0FBQ3RGLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx1RUFBdUUsZ0JBQWdCO0FBQ3ZGLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFD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QTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsdUNBQXVDO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsUUFBUSxvREFBb0Q7QUFDdkUsV0FBVyxNQUFNLGlFQUFpRTtBQUNsRixXQUFXLE9BQU8sa0VBQWtFO0FBQ3BGLFdBQVcsY0FBYztBQUN6QixhQUFhLEtBQUs7QUFDbEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksV0FBVztBQUN2QixZQUFZLFdBQVc7QUFDdkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHFEQUFxRCxFQUFFO0FBQzdHLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkI7Ozs7Ozs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQzs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosaURBQWlELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUU5TywwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsdUM7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkI7Ozs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVDOzs7Ozs7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVDOzs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDOzs7Ozs7O0FDbkNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEM7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCOzs7Ozs7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLGlEQUFpRCxhQUFhLHVGQUF1RixFQUFFLHVGQUF1Rjs7QUFFOU8sMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFNWU7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCxxQzs7Ozs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsOEI7Ozs7Ozs7QUMxTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Qzs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDOzs7Ozs7OztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsMEM7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEM7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQzs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0Q7Ozs7Ozs7QUMzb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVk7QUFDWixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSx5Qzs7Ozs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSwyQzs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQzs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSwwQzs7Ozs7OztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUM7Ozs7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIseUJBQXlCO0FBQzFDLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSx5Qzs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0Q7Ozs7Ozs7QUMxUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLDRDOzs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSw0Qzs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Qzs7Ozs7OztBQ2pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLDBDOzs7Ozs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DOzs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsb0M7Ozs7Ozs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLHlDOzs7Ozs7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2Sjs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7O0FBRUEseUM7Ozs7Ozs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFeFAsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosaURBQWlELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUU5TywwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsMkNBQTJDO0FBQ2pFO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLHVCQUF1QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDZCOzs7Ozs7O0FDdmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnQ0FBZ0M7QUFDbkM7QUFDQSwrQkFBK0IsZ0NBQWdDOztBQUUvRDtBQUNBO0FBQ0EsR0FBRyxnQ0FBZ0M7QUFDbkM7QUFDQSwrQkFBK0IsZ0NBQWdDOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sd0RBQXdEO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQscUM7Ozs7Ozs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCOzs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQSw2QkFBNkI7QUFDN0Isa0RBQWtEOztBQUVsRDtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLGdCQUFnQjtBQUM5Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxFQUFFO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9ELElBQUk7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FB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O0FBRUEsMkI7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsbUM7Ozs7Ozs7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQzs7Ozs7OztBQ2RBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7O0FDekxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEI7Ozs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMEJBQTBCO0FBQ3RGO0FBQ0E7QUFDQTs7QUFFQSx3Qzs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEI7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCOzs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQzs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLDZCOzs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdURBQXVEO0FBQzVGLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSw2Qjs7Ozs7Ozs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0I7Ozs7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0M7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtEOzs7Ozs7OztBQzNDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLDBDOzs7Ozs7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUM7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsa0NBQWtDOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0M7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUM7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQSxxRDs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBLHVEOzs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEM7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUM7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLCtDOzs7Ozs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtREFBbUQ7QUFDOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxnQ0FBZ0M7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGdDOzs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDZCOzs7Ozs7O0FDcEtBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUZBQW1GLHlDQUF5QztBQUM1SDtBQUNBO0FBQ0EsaUZBQWlGLHlDQUF5QztBQUMxSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsMkNBQTJDOztBQUUzQyw2Q0FBNkM7O0FBRTdDLHlDQUF5Qzs7O0FBR3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsbUNBQW1DLEtBQUs7QUFDeEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQsU0FBUztBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsZUFBZTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQ7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtB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QTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RCw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxlQUFlO0FBQ3BFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsS0FBSztBQUN4RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQW9DO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGNBQWMsRUFBRTtBQUNqRTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZSxFQUFFO0FBQ3ZEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlDQUF5Qyw4QkFBOEI7QUFDdkUsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlGQUFpRixZQUFZO0FBQzdGLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDBDQUEwQywwQkFBMEI7QUFDcEUsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw0Q0FBNEMsOEJBQThCO0FBQzFFLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3QkFBd0I7QUFDbkU7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOzs7O0FBSTdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFCQUFxQjtBQUMxRCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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a0YsYUFBYSxTQUFiLEVBQXdCTyxDQUF4QixDQUFMO0FBQUEsV0FBekQsR0FERjtBQUVHdEQsZUFBT2tFLEdBQVAsQ0FBVyxTQUFYLEtBQXlCO0FBQUE7QUFBQSxZQUFLLFdBQVUsa0JBQWY7QUFBbUNsRSxpQkFBT29FLEtBQVAsQ0FBYSxTQUFiO0FBQW5DO0FBRjVCO0FBRkYsS0EzQks7QUFrQ0w7QUFBQTtBQUFBLFFBQUssV0FBVSxnQkFBZjtBQUNFO0FBQUE7QUFBQSxVQUFLLFdBQVUsbUJBQWY7QUFDRTtBQUFBO0FBQUEsWUFBUSxVQUFVcEUsT0FBT3FFLEdBQVAsRUFBbEIsRUFBZ0MsTUFBSyxRQUFyQyxFQUE4QyxXQUFVLGlCQUF4RDtBQUFBO0FBQUE7QUFERjtBQURGO0FBbENLLEdBQVA7QUF3Q0QsQ0FoREQ7O0FBa0RBSixLQUFLSCxXQUFMLEdBQW1CQSxXQUFuQjtBQUNBRyxLQUFLM0IsU0FBTCxHQUFpQkEsU0FBakI7O2tCQUVlMkIsSSIsImZpbGUiOiJqcy9jaHVua3MvMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCdcbmltcG9ydCBBcnRpY2xlIGZyb20gJy4uLy4uL0FydGljbGUnXG5cbi8vIGltcG9ydCBjb21wb25lbnRzXG5pbXBvcnQgUGFnZSBmcm9tICcuL1BhZ2UnXG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IChzdGF0ZSwgcm91dGVyKSA9PiB7XG4gIGNvbnN0IHsgcGFyYW1zIH0gPSByb3V0ZXIubWF0Y2hcbiAgY29uc3QgYXJ0aWNsZSA9IHN0YXRlLmFydGljbGVzLmRhdGEuZmluZChhcnRpY2xlID0+IGFydGljbGUuaWQgPT09IE51bWJlcihwYXJhbXMuaWQpKVxuICByZXR1cm4ge1xuICAgIGFydGljbGU6IGFydGljbGUgPyBuZXcgQXJ0aWNsZShhcnRpY2xlKSA6IG5ldyBBcnRpY2xlKHt9KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzKShQYWdlKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9tb2R1bGVzL2FydGljbGUvcGFnZXMvZWRpdC9pbmRleC5qcyIsIi8qKlxuICogIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgZ2xvYmFsLkltbXV0YWJsZSA9IGZhY3RvcnkoKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7dmFyIFNMSUNFJDAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3MoY3Rvciwgc3VwZXJDbGFzcykge1xuICAgIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgIH1cbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBJdGVyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSXRlcmFibGUodmFsdWUpID8gdmFsdWUgOiBTZXEodmFsdWUpO1xuICAgIH1cblxuXG4gIGNyZWF0ZUNsYXNzKEtleWVkSXRlcmFibGUsIEl0ZXJhYmxlKTtcbiAgICBmdW5jdGlvbiBLZXllZEl0ZXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZSA6IEtleWVkU2VxKHZhbHVlKTtcbiAgICB9XG5cblxuICBjcmVhdGVDbGFzcyhJbmRleGVkSXRlcmFibGUsIEl0ZXJhYmxlKTtcbiAgICBmdW5jdGlvbiBJbmRleGVkSXRlcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0luZGV4ZWQodmFsdWUpID8gdmFsdWUgOiBJbmRleGVkU2VxKHZhbHVlKTtcbiAgICB9XG5cblxuICBjcmVhdGVDbGFzcyhTZXRJdGVyYWJsZSwgSXRlcmFibGUpO1xuICAgIGZ1bmN0aW9uIFNldEl0ZXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJdGVyYWJsZSh2YWx1ZSkgJiYgIWlzQXNzb2NpYXRpdmUodmFsdWUpID8gdmFsdWUgOiBTZXRTZXEodmFsdWUpO1xuICAgIH1cblxuXG5cbiAgZnVuY3Rpb24gaXNJdGVyYWJsZShtYXliZUl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuICEhKG1heWJlSXRlcmFibGUgJiYgbWF5YmVJdGVyYWJsZVtJU19JVEVSQUJMRV9TRU5USU5FTF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNLZXllZChtYXliZUtleWVkKSB7XG4gICAgcmV0dXJuICEhKG1heWJlS2V5ZWQgJiYgbWF5YmVLZXllZFtJU19LRVlFRF9TRU5USU5FTF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJbmRleGVkKG1heWJlSW5kZXhlZCkge1xuICAgIHJldHVybiAhIShtYXliZUluZGV4ZWQgJiYgbWF5YmVJbmRleGVkW0lTX0lOREVYRURfU0VOVElORUxdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXNzb2NpYXRpdmUobWF5YmVBc3NvY2lhdGl2ZSkge1xuICAgIHJldHVybiBpc0tleWVkKG1heWJlQXNzb2NpYXRpdmUpIHx8IGlzSW5kZXhlZChtYXliZUFzc29jaWF0aXZlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT3JkZXJlZChtYXliZU9yZGVyZWQpIHtcbiAgICByZXR1cm4gISEobWF5YmVPcmRlcmVkICYmIG1heWJlT3JkZXJlZFtJU19PUkRFUkVEX1NFTlRJTkVMXSk7XG4gIH1cblxuICBJdGVyYWJsZS5pc0l0ZXJhYmxlID0gaXNJdGVyYWJsZTtcbiAgSXRlcmFibGUuaXNLZXllZCA9IGlzS2V5ZWQ7XG4gIEl0ZXJhYmxlLmlzSW5kZXhlZCA9IGlzSW5kZXhlZDtcbiAgSXRlcmFibGUuaXNBc3NvY2lhdGl2ZSA9IGlzQXNzb2NpYXRpdmU7XG4gIEl0ZXJhYmxlLmlzT3JkZXJlZCA9IGlzT3JkZXJlZDtcblxuICBJdGVyYWJsZS5LZXllZCA9IEtleWVkSXRlcmFibGU7XG4gIEl0ZXJhYmxlLkluZGV4ZWQgPSBJbmRleGVkSXRlcmFibGU7XG4gIEl0ZXJhYmxlLlNldCA9IFNldEl0ZXJhYmxlO1xuXG5cbiAgdmFyIElTX0lURVJBQkxFX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfSVRFUkFCTEVfX0BAJztcbiAgdmFyIElTX0tFWUVEX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfS0VZRURfX0BAJztcbiAgdmFyIElTX0lOREVYRURfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9JTkRFWEVEX19AQCc7XG4gIHZhciBJU19PUkRFUkVEX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfT1JERVJFRF9fQEAnO1xuXG4gIC8vIFVzZWQgZm9yIHNldHRpbmcgcHJvdG90eXBlIG1ldGhvZHMgdGhhdCBJRTggY2hva2VzIG9uLlxuICB2YXIgREVMRVRFID0gJ2RlbGV0ZSc7XG5cbiAgLy8gQ29uc3RhbnRzIGRlc2NyaWJpbmcgdGhlIHNpemUgb2YgdHJpZSBub2Rlcy5cbiAgdmFyIFNISUZUID0gNTsgLy8gUmVzdWx0ZWQgaW4gYmVzdCBwZXJmb3JtYW5jZSBhZnRlciBfX19fX18/XG4gIHZhciBTSVpFID0gMSA8PCBTSElGVDtcbiAgdmFyIE1BU0sgPSBTSVpFIC0gMTtcblxuICAvLyBBIGNvbnNpc3RlbnQgc2hhcmVkIHZhbHVlIHJlcHJlc2VudGluZyBcIm5vdCBzZXRcIiB3aGljaCBlcXVhbHMgbm90aGluZyBvdGhlclxuICAvLyB0aGFuIGl0c2VsZiwgYW5kIG5vdGhpbmcgdGhhdCBjb3VsZCBiZSBwcm92aWRlZCBleHRlcm5hbGx5LlxuICB2YXIgTk9UX1NFVCA9IHt9O1xuXG4gIC8vIEJvb2xlYW4gcmVmZXJlbmNlcywgUm91Z2ggZXF1aXZhbGVudCBvZiBgYm9vbCAmYC5cbiAgdmFyIENIQU5HRV9MRU5HVEggPSB7IHZhbHVlOiBmYWxzZSB9O1xuICB2YXIgRElEX0FMVEVSID0geyB2YWx1ZTogZmFsc2UgfTtcblxuICBmdW5jdGlvbiBNYWtlUmVmKHJlZikge1xuICAgIHJlZi52YWx1ZSA9IGZhbHNlO1xuICAgIHJldHVybiByZWY7XG4gIH1cblxuICBmdW5jdGlvbiBTZXRSZWYocmVmKSB7XG4gICAgcmVmICYmIChyZWYudmFsdWUgPSB0cnVlKTtcbiAgfVxuXG4gIC8vIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIHZhbHVlIHJlcHJlc2VudGluZyBhbiBcIm93bmVyXCIgZm9yIHRyYW5zaWVudCB3cml0ZXNcbiAgLy8gdG8gdHJpZXMuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBvbmx5IGV2ZXIgZXF1YWwgaXRzZWxmLCBhbmQgd2lsbCBub3QgZXF1YWxcbiAgLy8gdGhlIHJldHVybiBvZiBhbnkgc3Vic2VxdWVudCBjYWxsIG9mIHRoaXMgZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIE93bmVySUQoKSB7fVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2NvcHktYXJyYXktaW5saW5lXG4gIGZ1bmN0aW9uIGFyckNvcHkoYXJyLCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgYXJyLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgdmFyIG5ld0FyciA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICAgIG5ld0FycltpaV0gPSBhcnJbaWkgKyBvZmZzZXRdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlU2l6ZShpdGVyKSB7XG4gICAgaWYgKGl0ZXIuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVyLnNpemUgPSBpdGVyLl9faXRlcmF0ZShyZXR1cm5UcnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXIuc2l6ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBJbmRleChpdGVyLCBpbmRleCkge1xuICAgIC8vIFRoaXMgaW1wbGVtZW50cyBcImlzIGFycmF5IGluZGV4XCIgd2hpY2ggdGhlIEVDTUFTdHJpbmcgc3BlYyBkZWZpbmVzIGFzOlxuICAgIC8vXG4gICAgLy8gICAgIEEgU3RyaW5nIHByb3BlcnR5IG5hbWUgUCBpcyBhbiBhcnJheSBpbmRleCBpZiBhbmQgb25seSBpZlxuICAgIC8vICAgICBUb1N0cmluZyhUb1VpbnQzMihQKSkgaXMgZXF1YWwgdG8gUCBhbmQgVG9VaW50MzIoUCkgaXMgbm90IGVxdWFsXG4gICAgLy8gICAgIHRvIDJeMzLiiJIxLlxuICAgIC8vXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWFycmF5LWV4b3RpYy1vYmplY3RzXG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB1aW50MzJJbmRleCA9IGluZGV4ID4+PiAwOyAvLyBOID4+PiAwIGlzIHNob3J0aGFuZCBmb3IgVG9VaW50MzJcbiAgICAgIGlmICgnJyArIHVpbnQzMkluZGV4ICE9PSBpbmRleCB8fCB1aW50MzJJbmRleCA9PT0gNDI5NDk2NzI5NSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuICAgICAgaW5kZXggPSB1aW50MzJJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IGVuc3VyZVNpemUoaXRlcikgKyBpbmRleCA6IGluZGV4O1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkge1xuICAgIHJldHVybiAoYmVnaW4gPT09IDAgfHwgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBiZWdpbiA8PSAtc2l6ZSkpICYmXG4gICAgICAoZW5kID09PSB1bmRlZmluZWQgfHwgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBlbmQgPj0gc2l6ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKSB7XG4gICAgcmV0dXJuIHJlc29sdmVJbmRleChiZWdpbiwgc2l6ZSwgMCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlRW5kKGVuZCwgc2l6ZSkge1xuICAgIHJldHVybiByZXNvbHZlSW5kZXgoZW5kLCBzaXplLCBzaXplKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVJbmRleChpbmRleCwgc2l6ZSwgZGVmYXVsdEluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgP1xuICAgICAgZGVmYXVsdEluZGV4IDpcbiAgICAgIGluZGV4IDwgMCA/XG4gICAgICAgIE1hdGgubWF4KDAsIHNpemUgKyBpbmRleCkgOlxuICAgICAgICBzaXplID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgIGluZGV4IDpcbiAgICAgICAgICBNYXRoLm1pbihzaXplLCBpbmRleCk7XG4gIH1cblxuICAvKiBnbG9iYWwgU3ltYm9sICovXG5cbiAgdmFyIElURVJBVEVfS0VZUyA9IDA7XG4gIHZhciBJVEVSQVRFX1ZBTFVFUyA9IDE7XG4gIHZhciBJVEVSQVRFX0VOVFJJRVMgPSAyO1xuXG4gIHZhciBSRUFMX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IFJFQUxfSVRFUkFUT1JfU1lNQk9MIHx8IEZBVVhfSVRFUkFUT1JfU1lNQk9MO1xuXG5cbiAgZnVuY3Rpb24gSXRlcmF0b3IobmV4dCkge1xuICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICB9XG5cbiAgICBJdGVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnW0l0ZXJhdG9yXSc7XG4gICAgfTtcblxuXG4gIEl0ZXJhdG9yLktFWVMgPSBJVEVSQVRFX0tFWVM7XG4gIEl0ZXJhdG9yLlZBTFVFUyA9IElURVJBVEVfVkFMVUVTO1xuICBJdGVyYXRvci5FTlRSSUVTID0gSVRFUkFURV9FTlRSSUVTO1xuXG4gIEl0ZXJhdG9yLnByb3RvdHlwZS5pbnNwZWN0ID1cbiAgSXRlcmF0b3IucHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50b1N0cmluZygpOyB9XG4gIEl0ZXJhdG9yLnByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgZnVuY3Rpb24gaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBpdGVyYXRvclJlc3VsdCkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGUgPT09IDAgPyBrIDogdHlwZSA9PT0gMSA/IHYgOiBbaywgdl07XG4gICAgaXRlcmF0b3JSZXN1bHQgPyAoaXRlcmF0b3JSZXN1bHQudmFsdWUgPSB2YWx1ZSkgOiAoaXRlcmF0b3JSZXN1bHQgPSB7XG4gICAgICB2YWx1ZTogdmFsdWUsIGRvbmU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yUmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0b3JEb25lKCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0l0ZXJhdG9yKG1heWJlSXRlcmFibGUpIHtcbiAgICByZXR1cm4gISFnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJdGVyYXRvcihtYXliZUl0ZXJhdG9yKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3IgJiYgdHlwZW9mIG1heWJlSXRlcmF0b3IubmV4dCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGl0ZXJhYmxlKTtcbiAgICByZXR1cm4gaXRlcmF0b3JGbiAmJiBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihpdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gaXRlcmFibGUgJiYgKFxuICAgICAgKFJFQUxfSVRFUkFUT1JfU1lNQk9MICYmIGl0ZXJhYmxlW1JFQUxfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgIGl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXVxuICAgICk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJztcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFNlcSwgSXRlcmFibGUpO1xuICAgIGZ1bmN0aW9uIFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eVNlcXVlbmNlKCkgOlxuICAgICAgICBpc0l0ZXJhYmxlKHZhbHVlKSA/IHZhbHVlLnRvU2VxKCkgOiBzZXFGcm9tVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIFNlcS5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiBTZXEoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU2VxLnByb3RvdHlwZS50b1NlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFNlcS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NlcSB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgU2VxLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9jYWNoZSAmJiB0aGlzLl9faXRlcmF0ZVVuY2FjaGVkKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gdGhpcy5lbnRyeVNlcSgpLnRvQXJyYXkoKTtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5fY2FjaGUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIGFic3RyYWN0IF9faXRlcmF0ZVVuY2FjaGVkKGZuLCByZXZlcnNlKVxuXG4gICAgU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHNlcUl0ZXJhdGUodGhpcywgZm4sIHJldmVyc2UsIHRydWUpO1xuICAgIH07XG5cbiAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdG9yVW5jYWNoZWQodHlwZSwgcmV2ZXJzZSlcblxuICAgIFNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBzZXFJdGVyYXRvcih0aGlzLCB0eXBlLCByZXZlcnNlLCB0cnVlKTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhLZXllZFNlcSwgU2VxKTtcbiAgICBmdW5jdGlvbiBLZXllZFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgP1xuICAgICAgICBlbXB0eVNlcXVlbmNlKCkudG9LZXllZFNlcSgpIDpcbiAgICAgICAgaXNJdGVyYWJsZSh2YWx1ZSkgP1xuICAgICAgICAgIChpc0tleWVkKHZhbHVlKSA/IHZhbHVlLnRvU2VxKCkgOiB2YWx1ZS5mcm9tRW50cnlTZXEoKSkgOlxuICAgICAgICAgIGtleWVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBLZXllZFNlcS5wcm90b3R5cGUudG9LZXllZFNlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuXG5cbiAgY3JlYXRlQ2xhc3MoSW5kZXhlZFNlcSwgU2VxKTtcbiAgICBmdW5jdGlvbiBJbmRleGVkU2VxKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5U2VxdWVuY2UoKSA6XG4gICAgICAgICFpc0l0ZXJhYmxlKHZhbHVlKSA/IGluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIDpcbiAgICAgICAgaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZS5lbnRyeVNlcSgpIDogdmFsdWUudG9JbmRleGVkU2VxKCk7XG4gICAgfVxuXG4gICAgSW5kZXhlZFNlcS5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiBJbmRleGVkU2VxKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvSW5kZXhlZFNlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXEgWycsICddJyk7XG4gICAgfTtcblxuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gc2VxSXRlcmF0ZSh0aGlzLCBmbiwgcmV2ZXJzZSwgZmFsc2UpO1xuICAgIH07XG5cbiAgICBJbmRleGVkU2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHNlcUl0ZXJhdG9yKHRoaXMsIHR5cGUsIHJldmVyc2UsIGZhbHNlKTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhTZXRTZXEsIFNlcSk7XG4gICAgZnVuY3Rpb24gU2V0U2VxKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlTZXF1ZW5jZSgpIDpcbiAgICAgICAgIWlzSXRlcmFibGUodmFsdWUpID8gaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkgOlxuICAgICAgICBpc0tleWVkKHZhbHVlKSA/IHZhbHVlLmVudHJ5U2VxKCkgOiB2YWx1ZVxuICAgICAgKS50b1NldFNlcSgpO1xuICAgIH1cblxuICAgIFNldFNlcS5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiBTZXRTZXEoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU2V0U2VxLnByb3RvdHlwZS50b1NldFNlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuXG5cbiAgU2VxLmlzU2VxID0gaXNTZXE7XG4gIFNlcS5LZXllZCA9IEtleWVkU2VxO1xuICBTZXEuU2V0ID0gU2V0U2VxO1xuICBTZXEuSW5kZXhlZCA9IEluZGV4ZWRTZXE7XG5cbiAgdmFyIElTX1NFUV9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX1NFUV9fQEAnO1xuXG4gIFNlcS5wcm90b3R5cGVbSVNfU0VRX1NFTlRJTkVMXSA9IHRydWU7XG5cblxuXG4gIGNyZWF0ZUNsYXNzKEFycmF5U2VxLCBJbmRleGVkU2VxKTtcbiAgICBmdW5jdGlvbiBBcnJheVNlcShhcnJheSkge1xuICAgICAgdGhpcy5fYXJyYXkgPSBhcnJheTtcbiAgICAgIHRoaXMuc2l6ZSA9IGFycmF5Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBBcnJheVNlcS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpID8gdGhpcy5fYXJyYXlbd3JhcEluZGV4KHRoaXMsIGluZGV4KV0gOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgQXJyYXlTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcbiAgICAgIHZhciBtYXhJbmRleCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICAgIGlmIChmbihhcnJheVtyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXSwgaWksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBpaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpaTtcbiAgICB9O1xuXG4gICAgQXJyYXlTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcbiAgICAgIHZhciBtYXhJbmRleCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpIFxuICAgICAgICB7cmV0dXJuIGlpID4gbWF4SW5kZXggP1xuICAgICAgICAgIGl0ZXJhdG9yRG9uZSgpIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGlpLCBhcnJheVtyZXZlcnNlID8gbWF4SW5kZXggLSBpaSsrIDogaWkrK10pfVxuICAgICAgKTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhPYmplY3RTZXEsIEtleWVkU2VxKTtcbiAgICBmdW5jdGlvbiBPYmplY3RTZXEob2JqZWN0KSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICB0aGlzLl9vYmplY3QgPSBvYmplY3Q7XG4gICAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICAgIHRoaXMuc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgIH1cblxuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaWYgKG5vdFNldFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFtrZXldO1xuICAgIH07XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgIH07XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5fb2JqZWN0O1xuICAgICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICAgICAgdmFyIG1heEluZGV4ID0ga2V5cy5sZW5ndGggLSAxO1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcbiAgICAgICAgaWYgKGZuKG9iamVjdFtrZXldLCBrZXksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBpaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpaTtcbiAgICB9O1xuXG4gICAgT2JqZWN0U2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMuX29iamVjdDtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcbiAgICAgIHZhciBtYXhJbmRleCA9IGtleXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBpaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV07XG4gICAgICAgIHJldHVybiBpaSsrID4gbWF4SW5kZXggP1xuICAgICAgICAgIGl0ZXJhdG9yRG9uZSgpIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGtleSwgb2JqZWN0W2tleV0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICBPYmplY3RTZXEucHJvdG90eXBlW0lTX09SREVSRURfU0VOVElORUxdID0gdHJ1ZTtcblxuXG4gIGNyZWF0ZUNsYXNzKEl0ZXJhYmxlU2VxLCBJbmRleGVkU2VxKTtcbiAgICBmdW5jdGlvbiBJdGVyYWJsZVNlcShpdGVyYWJsZSkge1xuICAgICAgdGhpcy5faXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICAgIHRoaXMuc2l6ZSA9IGl0ZXJhYmxlLmxlbmd0aCB8fCBpdGVyYWJsZS5zaXplO1xuICAgIH1cblxuICAgIEl0ZXJhYmxlU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLl9pdGVyYWJsZTtcbiAgICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGlmIChpc0l0ZXJhdG9yKGl0ZXJhdG9yKSkge1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChmbihzdGVwLnZhbHVlLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgSXRlcmFibGVTZXEucHJvdG90eXBlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMuX2l0ZXJhYmxlO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpO1xuICAgICAgaWYgKCFpc0l0ZXJhdG9yKGl0ZXJhdG9yKSkge1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGl0ZXJhdG9yRG9uZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmUgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuXG5cbiAgY3JlYXRlQ2xhc3MoSXRlcmF0b3JTZXEsIEluZGV4ZWRTZXEpO1xuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yU2VxKGl0ZXJhdG9yKSB7XG4gICAgICB0aGlzLl9pdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgICAgdGhpcy5faXRlcmF0b3JDYWNoZSA9IFtdO1xuICAgIH1cblxuICAgIEl0ZXJhdG9yU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyYXRvcjtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuX2l0ZXJhdG9yQ2FjaGU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB3aGlsZSAoaXRlcmF0aW9ucyA8IGNhY2hlLmxlbmd0aCkge1xuICAgICAgICBpZiAoZm4oY2FjaGVbaXRlcmF0aW9uc10sIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzdGVwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICB2YXIgdmFsID0gc3RlcC52YWx1ZTtcbiAgICAgICAgY2FjaGVbaXRlcmF0aW9uc10gPSB2YWw7XG4gICAgICAgIGlmIChmbih2YWwsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG5cbiAgICBJdGVyYXRvclNlcS5wcm90b3R5cGUuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlcmF0b3I7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLl9pdGVyYXRvckNhY2hlO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIGlmIChpdGVyYXRpb25zID49IGNhY2hlLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWNoZVtpdGVyYXRpb25zXSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucywgY2FjaGVbaXRlcmF0aW9ucysrXSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG5cblxuXG4gIC8vICMgcHJhZ21hIEhlbHBlciBmdW5jdGlvbnNcblxuICBmdW5jdGlvbiBpc1NlcShtYXliZVNlcSkge1xuICAgIHJldHVybiAhIShtYXliZVNlcSAmJiBtYXliZVNlcVtJU19TRVFfU0VOVElORUxdKTtcbiAgfVxuXG4gIHZhciBFTVBUWV9TRVE7XG5cbiAgZnVuY3Rpb24gZW1wdHlTZXF1ZW5jZSgpIHtcbiAgICByZXR1cm4gRU1QVFlfU0VRIHx8IChFTVBUWV9TRVEgPSBuZXcgQXJyYXlTZXEoW10pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleWVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHNlcSA9XG4gICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IG5ldyBBcnJheVNlcSh2YWx1ZSkuZnJvbUVudHJ5U2VxKCkgOlxuICAgICAgaXNJdGVyYXRvcih2YWx1ZSkgPyBuZXcgSXRlcmF0b3JTZXEodmFsdWUpLmZyb21FbnRyeVNlcSgpIDpcbiAgICAgIGhhc0l0ZXJhdG9yKHZhbHVlKSA/IG5ldyBJdGVyYWJsZVNlcSh2YWx1ZSkuZnJvbUVudHJ5U2VxKCkgOlxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IG5ldyBPYmplY3RTZXEodmFsdWUpIDpcbiAgICAgIHVuZGVmaW5lZDtcbiAgICBpZiAoIXNlcSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIEFycmF5IG9yIGl0ZXJhYmxlIG9iamVjdCBvZiBbaywgdl0gZW50cmllcywgJytcbiAgICAgICAgJ29yIGtleWVkIG9iamVjdDogJyArIHZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc2VxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBzZXEgPSBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpO1xuICAgIGlmICghc2VxKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgaXRlcmFibGUgb2JqZWN0IG9mIHZhbHVlczogJyArIHZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc2VxO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHNlcSA9IG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkgfHxcbiAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIG5ldyBPYmplY3RTZXEodmFsdWUpKTtcbiAgICBpZiAoIXNlcSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIEFycmF5IG9yIGl0ZXJhYmxlIG9iamVjdCBvZiB2YWx1ZXMsIG9yIGtleWVkIG9iamVjdDogJyArIHZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc2VxO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSA/IG5ldyBBcnJheVNlcSh2YWx1ZSkgOlxuICAgICAgaXNJdGVyYXRvcih2YWx1ZSkgPyBuZXcgSXRlcmF0b3JTZXEodmFsdWUpIDpcbiAgICAgIGhhc0l0ZXJhdG9yKHZhbHVlKSA/IG5ldyBJdGVyYWJsZVNlcSh2YWx1ZSkgOlxuICAgICAgdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcUl0ZXJhdGUoc2VxLCBmbiwgcmV2ZXJzZSwgdXNlS2V5cykge1xuICAgIHZhciBjYWNoZSA9IHNlcS5fY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICB2YXIgbWF4SW5kZXggPSBjYWNoZS5sZW5ndGggLSAxO1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcbiAgICAgICAgaWYgKGZuKGVudHJ5WzFdLCB1c2VLZXlzID8gZW50cnlbMF0gOiBpaSwgc2VxKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gaWkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaWk7XG4gICAgfVxuICAgIHJldHVybiBzZXEuX19pdGVyYXRlVW5jYWNoZWQoZm4sIHJldmVyc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VxSXRlcmF0b3Ioc2VxLCB0eXBlLCByZXZlcnNlLCB1c2VLZXlzKSB7XG4gICAgdmFyIGNhY2hlID0gc2VxLl9jYWNoZTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHZhciBtYXhJbmRleCA9IGNhY2hlLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBlbnRyeSA9IGNhY2hlW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldO1xuICAgICAgICByZXR1cm4gaWkrKyA+IG1heEluZGV4ID9cbiAgICAgICAgICBpdGVyYXRvckRvbmUoKSA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCB1c2VLZXlzID8gZW50cnlbMF0gOiBpaSAtIDEsIGVudHJ5WzFdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VxLl9faXRlcmF0b3JVbmNhY2hlZCh0eXBlLCByZXZlcnNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21KUyhqc29uLCBjb252ZXJ0ZXIpIHtcbiAgICByZXR1cm4gY29udmVydGVyID9cbiAgICAgIGZyb21KU1dpdGgoY29udmVydGVyLCBqc29uLCAnJywgeycnOiBqc29ufSkgOlxuICAgICAgZnJvbUpTRGVmYXVsdChqc29uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21KU1dpdGgoY29udmVydGVyLCBqc29uLCBrZXksIHBhcmVudEpTT04pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRlci5jYWxsKHBhcmVudEpTT04sIGtleSwgSW5kZXhlZFNlcShqc29uKS5tYXAoZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gZnJvbUpTV2l0aChjb252ZXJ0ZXIsIHYsIGssIGpzb24pfSkpO1xuICAgIH1cbiAgICBpZiAoaXNQbGFpbk9iaihqc29uKSkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRlci5jYWxsKHBhcmVudEpTT04sIGtleSwgS2V5ZWRTZXEoanNvbikubWFwKGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIGZyb21KU1dpdGgoY29udmVydGVyLCB2LCBrLCBqc29uKX0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tSlNEZWZhdWx0KGpzb24pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgcmV0dXJuIEluZGV4ZWRTZXEoanNvbikubWFwKGZyb21KU0RlZmF1bHQpLnRvTGlzdCgpO1xuICAgIH1cbiAgICBpZiAoaXNQbGFpbk9iaihqc29uKSkge1xuICAgICAgcmV0dXJuIEtleWVkU2VxKGpzb24pLm1hcChmcm9tSlNEZWZhdWx0KS50b01hcCgpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGxhaW5PYmoodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCk7XG4gIH1cblxuICAvKipcbiAgICogQW4gZXh0ZW5zaW9uIG9mIHRoZSBcInNhbWUtdmFsdWVcIiBhbGdvcml0aG0gYXMgW2Rlc2NyaWJlZCBmb3IgdXNlIGJ5IEVTNiBNYXBcbiAgICogYW5kIFNldF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwI0tleV9lcXVhbGl0eSlcbiAgICpcbiAgICogTmFOIGlzIGNvbnNpZGVyZWQgdGhlIHNhbWUgYXMgTmFOLCBob3dldmVyIC0wIGFuZCAwIGFyZSBjb25zaWRlcmVkIHRoZSBzYW1lXG4gICAqIHZhbHVlLCB3aGljaCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBieVxuICAgKiBbYE9iamVjdC5pc2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pcykuXG4gICAqXG4gICAqIFRoaXMgaXMgZXh0ZW5kZWQgZnVydGhlciB0byBhbGxvdyBPYmplY3RzIHRvIGRlc2NyaWJlIHRoZSB2YWx1ZXMgdGhleVxuICAgKiByZXByZXNlbnQsIGJ5IHdheSBvZiBgdmFsdWVPZmAgb3IgYGVxdWFsc2AgKGFuZCBgaGFzaENvZGVgKS5cbiAgICpcbiAgICogTm90ZTogYmVjYXVzZSBvZiB0aGlzIGV4dGVuc2lvbiwgdGhlIGtleSBlcXVhbGl0eSBvZiBJbW11dGFibGUuTWFwIGFuZCB0aGVcbiAgICogdmFsdWUgZXF1YWxpdHkgb2YgSW1tdXRhYmxlLlNldCB3aWxsIGRpZmZlciBmcm9tIEVTNiBNYXAgYW5kIFNldC5cbiAgICpcbiAgICogIyMjIERlZmluaW5nIGN1c3RvbSB2YWx1ZXNcbiAgICpcbiAgICogVGhlIGVhc2llc3Qgd2F5IHRvIGRlc2NyaWJlIHRoZSB2YWx1ZSBhbiBvYmplY3QgcmVwcmVzZW50cyBpcyBieSBpbXBsZW1lbnRpbmdcbiAgICogYHZhbHVlT2ZgLiBGb3IgZXhhbXBsZSwgYERhdGVgIHJlcHJlc2VudHMgYSB2YWx1ZSBieSByZXR1cm5pbmcgYSB1bml4XG4gICAqIHRpbWVzdGFtcCBmb3IgYHZhbHVlT2ZgOlxuICAgKlxuICAgKiAgICAgdmFyIGRhdGUxID0gbmV3IERhdGUoMTIzNDU2Nzg5MDAwMCk7IC8vIEZyaSBGZWIgMTMgMjAwOSAuLi5cbiAgICogICAgIHZhciBkYXRlMiA9IG5ldyBEYXRlKDEyMzQ1Njc4OTAwMDApO1xuICAgKiAgICAgZGF0ZTEudmFsdWVPZigpOyAvLyAxMjM0NTY3ODkwMDAwXG4gICAqICAgICBhc3NlcnQoIGRhdGUxICE9PSBkYXRlMiApO1xuICAgKiAgICAgYXNzZXJ0KCBJbW11dGFibGUuaXMoIGRhdGUxLCBkYXRlMiApICk7XG4gICAqXG4gICAqIE5vdGU6IG92ZXJyaWRpbmcgYHZhbHVlT2ZgIG1heSBoYXZlIG90aGVyIGltcGxpY2F0aW9ucyBpZiB5b3UgdXNlIHRoaXMgb2JqZWN0XG4gICAqIHdoZXJlIEphdmFTY3JpcHQgZXhwZWN0cyBhIHByaW1pdGl2ZSwgc3VjaCBhcyBpbXBsaWNpdCBzdHJpbmcgY29lcmNpb24uXG4gICAqXG4gICAqIEZvciBtb3JlIGNvbXBsZXggdHlwZXMsIGVzcGVjaWFsbHkgY29sbGVjdGlvbnMsIGltcGxlbWVudGluZyBgdmFsdWVPZmAgbWF5XG4gICAqIG5vdCBiZSBwZXJmb3JtYW50LiBBbiBhbHRlcm5hdGl2ZSBpcyB0byBpbXBsZW1lbnQgYGVxdWFsc2AgYW5kIGBoYXNoQ29kZWAuXG4gICAqXG4gICAqIGBlcXVhbHNgIHRha2VzIGFub3RoZXIgb2JqZWN0LCBwcmVzdW1hYmx5IG9mIHNpbWlsYXIgdHlwZSwgYW5kIHJldHVybnMgdHJ1ZVxuICAgKiBpZiB0aGUgaXQgaXMgZXF1YWwuIEVxdWFsaXR5IGlzIHN5bW1ldHJpY2FsLCBzbyB0aGUgc2FtZSByZXN1bHQgc2hvdWxkIGJlXG4gICAqIHJldHVybmVkIGlmIHRoaXMgYW5kIHRoZSBhcmd1bWVudCBhcmUgZmxpcHBlZC5cbiAgICpcbiAgICogICAgIGFzc2VydCggYS5lcXVhbHMoYikgPT09IGIuZXF1YWxzKGEpICk7XG4gICAqXG4gICAqIGBoYXNoQ29kZWAgcmV0dXJucyBhIDMyYml0IGludGVnZXIgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgb2JqZWN0IHdoaWNoIHdpbGxcbiAgICogYmUgdXNlZCB0byBkZXRlcm1pbmUgaG93IHRvIHN0b3JlIHRoZSB2YWx1ZSBvYmplY3QgaW4gYSBNYXAgb3IgU2V0LiBZb3UgbXVzdFxuICAgKiBwcm92aWRlIGJvdGggb3IgbmVpdGhlciBtZXRob2RzLCBvbmUgbXVzdCBub3QgZXhpc3Qgd2l0aG91dCB0aGUgb3RoZXIuXG4gICAqXG4gICAqIEFsc28sIGFuIGltcG9ydGFudCByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGVzZSBtZXRob2RzIG11c3QgYmUgdXBoZWxkOiBpZiB0d29cbiAgICogdmFsdWVzIGFyZSBlcXVhbCwgdGhleSAqbXVzdCogcmV0dXJuIHRoZSBzYW1lIGhhc2hDb2RlLiBJZiB0aGUgdmFsdWVzIGFyZSBub3RcbiAgICogZXF1YWwsIHRoZXkgbWlnaHQgaGF2ZSB0aGUgc2FtZSBoYXNoQ29kZTsgdGhpcyBpcyBjYWxsZWQgYSBoYXNoIGNvbGxpc2lvbixcbiAgICogYW5kIHdoaWxlIHVuZGVzaXJhYmxlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBpdCBpcyBhY2NlcHRhYmxlLlxuICAgKlxuICAgKiAgICAgaWYgKGEuZXF1YWxzKGIpKSB7XG4gICAqICAgICAgIGFzc2VydCggYS5oYXNoQ29kZSgpID09PSBiLmhhc2hDb2RlKCkgKTtcbiAgICogICAgIH1cbiAgICpcbiAgICogQWxsIEltbXV0YWJsZSBjb2xsZWN0aW9ucyBpbXBsZW1lbnQgYGVxdWFsc2AgYW5kIGBoYXNoQ29kZWAuXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBpcyh2YWx1ZUEsIHZhbHVlQikge1xuICAgIGlmICh2YWx1ZUEgPT09IHZhbHVlQiB8fCAodmFsdWVBICE9PSB2YWx1ZUEgJiYgdmFsdWVCICE9PSB2YWx1ZUIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZUEgfHwgIXZhbHVlQikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlQS52YWx1ZU9mID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZUIudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWVBID0gdmFsdWVBLnZhbHVlT2YoKTtcbiAgICAgIHZhbHVlQiA9IHZhbHVlQi52YWx1ZU9mKCk7XG4gICAgICBpZiAodmFsdWVBID09PSB2YWx1ZUIgfHwgKHZhbHVlQSAhPT0gdmFsdWVBICYmIHZhbHVlQiAhPT0gdmFsdWVCKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWVBIHx8ICF2YWx1ZUIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlQS5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlQi5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdmFsdWVBLmVxdWFscyh2YWx1ZUIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIWlzSXRlcmFibGUoYikgfHxcbiAgICAgIGEuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGIuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGEuc2l6ZSAhPT0gYi5zaXplIHx8XG4gICAgICBhLl9faGFzaCAhPT0gdW5kZWZpbmVkICYmIGIuX19oYXNoICE9PSB1bmRlZmluZWQgJiYgYS5fX2hhc2ggIT09IGIuX19oYXNoIHx8XG4gICAgICBpc0tleWVkKGEpICE9PSBpc0tleWVkKGIpIHx8XG4gICAgICBpc0luZGV4ZWQoYSkgIT09IGlzSW5kZXhlZChiKSB8fFxuICAgICAgaXNPcmRlcmVkKGEpICE9PSBpc09yZGVyZWQoYilcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYS5zaXplID09PSAwICYmIGIuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG5vdEFzc29jaWF0aXZlID0gIWlzQXNzb2NpYXRpdmUoYSk7XG5cbiAgICBpZiAoaXNPcmRlcmVkKGEpKSB7XG4gICAgICB2YXIgZW50cmllcyA9IGEuZW50cmllcygpO1xuICAgICAgcmV0dXJuIGIuZXZlcnkoZnVuY3Rpb24odiwgaykgIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllcy5uZXh0KCkudmFsdWU7XG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBpcyhlbnRyeVsxXSwgdikgJiYgKG5vdEFzc29jaWF0aXZlIHx8IGlzKGVudHJ5WzBdLCBrKSk7XG4gICAgICB9KSAmJiBlbnRyaWVzLm5leHQoKS5kb25lO1xuICAgIH1cblxuICAgIHZhciBmbGlwcGVkID0gZmFsc2U7XG5cbiAgICBpZiAoYS5zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChiLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGEuY2FjaGVSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBhLmNhY2hlUmVzdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsaXBwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgXyA9IGE7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gXztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWxsRXF1YWwgPSB0cnVlO1xuICAgIHZhciBiU2l6ZSA9IGIuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7XG4gICAgICBpZiAobm90QXNzb2NpYXRpdmUgPyAhYS5oYXModikgOlxuICAgICAgICAgIGZsaXBwZWQgPyAhaXModiwgYS5nZXQoaywgTk9UX1NFVCkpIDogIWlzKGEuZ2V0KGssIE5PVF9TRVQpLCB2KSkge1xuICAgICAgICBhbGxFcXVhbCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYWxsRXF1YWwgJiYgYS5zaXplID09PSBiU2l6ZTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFJlcGVhdCwgSW5kZXhlZFNlcSk7XG5cbiAgICBmdW5jdGlvbiBSZXBlYXQodmFsdWUsIHRpbWVzKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVwZWF0KSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlcGVhdCh2YWx1ZSwgdGltZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc2l6ZSA9IHRpbWVzID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IE1hdGgubWF4KDAsIHRpbWVzKTtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgaWYgKEVNUFRZX1JFUEVBVCkge1xuICAgICAgICAgIHJldHVybiBFTVBUWV9SRVBFQVQ7XG4gICAgICAgIH1cbiAgICAgICAgRU1QVFlfUkVQRUFUID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnUmVwZWF0IFtdJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnUmVwZWF0IFsgJyArIHRoaXMuX3ZhbHVlICsgJyAnICsgdGhpcy5zaXplICsgJyB0aW1lcyBdJztcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgPyB0aGlzLl92YWx1ZSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiBpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICByZXR1cm4gd2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSA/IHRoaXMgOlxuICAgICAgICBuZXcgUmVwZWF0KHRoaXMuX3ZhbHVlLCByZXNvbHZlRW5kKGVuZCwgc2l6ZSkgLSByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpKTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIGlmIChpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIGlmIChpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB0aGlzLnNpemU7IGlpKyspIHtcbiAgICAgICAgaWYgKGZuKHRoaXMuX3ZhbHVlLCBpaSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGlpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlpO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpIFxuICAgICAgICB7cmV0dXJuIGlpIDwgdGhpcyQwLnNpemUgPyBpdGVyYXRvclZhbHVlKHR5cGUsIGlpKyssIHRoaXMkMC5fdmFsdWUpIDogaXRlcmF0b3JEb25lKCl9XG4gICAgICApO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBSZXBlYXQgP1xuICAgICAgICBpcyh0aGlzLl92YWx1ZSwgb3RoZXIuX3ZhbHVlKSA6XG4gICAgICAgIGRlZXBFcXVhbChvdGhlcik7XG4gICAgfTtcblxuXG4gIHZhciBFTVBUWV9SRVBFQVQ7XG5cbiAgZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZXJyb3IpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFJhbmdlLCBJbmRleGVkU2VxKTtcblxuICAgIGZ1bmN0aW9uIFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kLCBzdGVwKTtcbiAgICAgIH1cbiAgICAgIGludmFyaWFudChzdGVwICE9PSAwLCAnQ2Fubm90IHN0ZXAgYSBSYW5nZSBieSAwJyk7XG4gICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gMSA6IE1hdGguYWJzKHN0ZXApO1xuICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHN0ZXAgPSAtc3RlcDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICAgIHRoaXMuc2l6ZSA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoZW5kIC0gc3RhcnQpIC8gc3RlcCAtIDEpICsgMSk7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIGlmIChFTVBUWV9SQU5HRSkge1xuICAgICAgICAgIHJldHVybiBFTVBUWV9SQU5HRTtcbiAgICAgICAgfVxuICAgICAgICBFTVBUWV9SQU5HRSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnUmFuZ2UgW10nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdSYW5nZSBbICcgK1xuICAgICAgICB0aGlzLl9zdGFydCArICcuLi4nICsgdGhpcy5fZW5kICtcbiAgICAgICAgKHRoaXMuX3N0ZXAgPiAxID8gJyBieSAnICsgdGhpcy5fc3RlcCA6ICcnKSArXG4gICAgICAnIF0nO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpID9cbiAgICAgICAgdGhpcy5fc3RhcnQgKyB3cmFwSW5kZXgodGhpcywgaW5kZXgpICogdGhpcy5fc3RlcCA6XG4gICAgICAgIG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIHBvc3NpYmxlSW5kZXggPSAoc2VhcmNoVmFsdWUgLSB0aGlzLl9zdGFydCkgLyB0aGlzLl9zdGVwO1xuICAgICAgcmV0dXJuIHBvc3NpYmxlSW5kZXggPj0gMCAmJlxuICAgICAgICBwb3NzaWJsZUluZGV4IDwgdGhpcy5zaXplICYmXG4gICAgICAgIHBvc3NpYmxlSW5kZXggPT09IE1hdGguZmxvb3IocG9zc2libGVJbmRleCk7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHRoaXMuc2l6ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBiZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgdGhpcy5zaXplKTtcbiAgICAgIGVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLnNpemUpO1xuICAgICAgaWYgKGVuZCA8PSBiZWdpbikge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKDAsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLmdldChiZWdpbiwgdGhpcy5fZW5kKSwgdGhpcy5nZXQoZW5kLCB0aGlzLl9lbmQpLCB0aGlzLl9zdGVwKTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIG9mZnNldFZhbHVlID0gc2VhcmNoVmFsdWUgLSB0aGlzLl9zdGFydDtcbiAgICAgIGlmIChvZmZzZXRWYWx1ZSAlIHRoaXMuX3N0ZXAgPT09IDApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gb2Zmc2V0VmFsdWUgLyB0aGlzLl9zdGVwO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleE9mKHNlYXJjaFZhbHVlKTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgbWF4SW5kZXggPSB0aGlzLnNpemUgLSAxO1xuICAgICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuICAgICAgdmFyIHZhbHVlID0gcmV2ZXJzZSA/IHRoaXMuX3N0YXJ0ICsgbWF4SW5kZXggKiBzdGVwIDogdGhpcy5fc3RhcnQ7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICAgIGlmIChmbih2YWx1ZSwgaWksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBpaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgKz0gcmV2ZXJzZSA/IC1zdGVwIDogc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpaTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgbWF4SW5kZXggPSB0aGlzLnNpemUgLSAxO1xuICAgICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuICAgICAgdmFyIHZhbHVlID0gcmV2ZXJzZSA/IHRoaXMuX3N0YXJ0ICsgbWF4SW5kZXggKiBzdGVwIDogdGhpcy5fc3RhcnQ7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciB2ID0gdmFsdWU7XG4gICAgICAgIHZhbHVlICs9IHJldmVyc2UgPyAtc3RlcCA6IHN0ZXA7XG4gICAgICAgIHJldHVybiBpaSA+IG1heEluZGV4ID8gaXRlcmF0b3JEb25lKCkgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGlpKyssIHYpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUmFuZ2UgP1xuICAgICAgICB0aGlzLl9zdGFydCA9PT0gb3RoZXIuX3N0YXJ0ICYmXG4gICAgICAgIHRoaXMuX2VuZCA9PT0gb3RoZXIuX2VuZCAmJlxuICAgICAgICB0aGlzLl9zdGVwID09PSBvdGhlci5fc3RlcCA6XG4gICAgICAgIGRlZXBFcXVhbCh0aGlzLCBvdGhlcik7XG4gICAgfTtcblxuXG4gIHZhciBFTVBUWV9SQU5HRTtcblxuICBjcmVhdGVDbGFzcyhDb2xsZWN0aW9uLCBJdGVyYWJsZSk7XG4gICAgZnVuY3Rpb24gQ29sbGVjdGlvbigpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignQWJzdHJhY3QnKTtcbiAgICB9XG5cblxuICBjcmVhdGVDbGFzcyhLZXllZENvbGxlY3Rpb24sIENvbGxlY3Rpb24pO2Z1bmN0aW9uIEtleWVkQ29sbGVjdGlvbigpIHt9XG5cbiAgY3JlYXRlQ2xhc3MoSW5kZXhlZENvbGxlY3Rpb24sIENvbGxlY3Rpb24pO2Z1bmN0aW9uIEluZGV4ZWRDb2xsZWN0aW9uKCkge31cblxuICBjcmVhdGVDbGFzcyhTZXRDb2xsZWN0aW9uLCBDb2xsZWN0aW9uKTtmdW5jdGlvbiBTZXRDb2xsZWN0aW9uKCkge31cblxuXG4gIENvbGxlY3Rpb24uS2V5ZWQgPSBLZXllZENvbGxlY3Rpb247XG4gIENvbGxlY3Rpb24uSW5kZXhlZCA9IEluZGV4ZWRDb2xsZWN0aW9uO1xuICBDb2xsZWN0aW9uLlNldCA9IFNldENvbGxlY3Rpb247XG5cbiAgdmFyIGltdWwgPVxuICAgIHR5cGVvZiBNYXRoLmltdWwgPT09ICdmdW5jdGlvbicgJiYgTWF0aC5pbXVsKDB4ZmZmZmZmZmYsIDIpID09PSAtMiA/XG4gICAgTWF0aC5pbXVsIDpcbiAgICBmdW5jdGlvbiBpbXVsKGEsIGIpIHtcbiAgICAgIGEgPSBhIHwgMDsgLy8gaW50XG4gICAgICBiID0gYiB8IDA7IC8vIGludFxuICAgICAgdmFyIGMgPSBhICYgMHhmZmZmO1xuICAgICAgdmFyIGQgPSBiICYgMHhmZmZmO1xuICAgICAgLy8gU2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0LlxuICAgICAgcmV0dXJuIChjICogZCkgKyAoKCgoYSA+Pj4gMTYpICogZCArIGMgKiAoYiA+Pj4gMTYpKSA8PCAxNikgPj4+IDApIHwgMDsgLy8gaW50XG4gICAgfTtcblxuICAvLyB2OCBoYXMgYW4gb3B0aW1pemF0aW9uIGZvciBzdG9yaW5nIDMxLWJpdCBzaWduZWQgbnVtYmVycy5cbiAgLy8gVmFsdWVzIHdoaWNoIGhhdmUgZWl0aGVyIDAwIG9yIDExIGFzIHRoZSBoaWdoIG9yZGVyIGJpdHMgcXVhbGlmeS5cbiAgLy8gVGhpcyBmdW5jdGlvbiBkcm9wcyB0aGUgaGlnaGVzdCBvcmRlciBiaXQgaW4gYSBzaWduZWQgbnVtYmVyLCBtYWludGFpbmluZ1xuICAvLyB0aGUgc2lnbiBiaXQuXG4gIGZ1bmN0aW9uIHNtaShpMzIpIHtcbiAgICByZXR1cm4gKChpMzIgPj4+IDEpICYgMHg0MDAwMDAwMCkgfCAoaTMyICYgMHhCRkZGRkZGRik7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNoKG8pIHtcbiAgICBpZiAobyA9PT0gZmFsc2UgfHwgbyA9PT0gbnVsbCB8fCBvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG8udmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbyA9IG8udmFsdWVPZigpO1xuICAgICAgaWYgKG8gPT09IGZhbHNlIHx8IG8gPT09IG51bGwgfHwgbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobyA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHZhciB0eXBlID0gdHlwZW9mIG87XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgaCA9IG8gfCAwO1xuICAgICAgaWYgKGggIT09IG8pIHtcbiAgICAgICAgaCBePSBvICogMHhGRkZGRkZGRjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvID4gMHhGRkZGRkZGRikge1xuICAgICAgICBvIC89IDB4RkZGRkZGRkY7XG4gICAgICAgIGggXj0gbztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbWkoaCk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG8ubGVuZ3RoID4gU1RSSU5HX0hBU0hfQ0FDSEVfTUlOX1NUUkxFTiA/IGNhY2hlZEhhc2hTdHJpbmcobykgOiBoYXNoU3RyaW5nKG8pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG8uaGFzaENvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvLmhhc2hDb2RlKCk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGhhc2hKU09iaihvKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvLnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaGFzaFN0cmluZyhvLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHR5cGUgJyArIHR5cGUgKyAnIGNhbm5vdCBiZSBoYXNoZWQuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjYWNoZWRIYXNoU3RyaW5nKHN0cmluZykge1xuICAgIHZhciBoYXNoID0gc3RyaW5nSGFzaENhY2hlW3N0cmluZ107XG4gICAgaWYgKGhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGFzaCA9IGhhc2hTdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID09PSBTVFJJTkdfSEFTSF9DQUNIRV9NQVhfU0laRSkge1xuICAgICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcbiAgICAgICAgc3RyaW5nSGFzaENhY2hlID0ge307XG4gICAgICB9XG4gICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFKys7XG4gICAgICBzdHJpbmdIYXNoQ2FjaGVbc3RyaW5nXSA9IGhhc2g7XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xuICB9XG5cbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vaGFzaGluZy1zdHJpbmdzXG4gIGZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyaW5nKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgaGFzaCBmcm9tIEpWTVxuICAgIC8vIFRoZSBoYXNoIGNvZGUgZm9yIGEgc3RyaW5nIGlzIGNvbXB1dGVkIGFzXG4gICAgLy8gc1swXSAqIDMxIF4gKG4gLSAxKSArIHNbMV0gKiAzMSBeIChuIC0gMikgKyAuLi4gKyBzW24gLSAxXSxcbiAgICAvLyB3aGVyZSBzW2ldIGlzIHRoZSBpdGggY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgYW5kIG4gaXMgdGhlIGxlbmd0aCBvZlxuICAgIC8vIHRoZSBzdHJpbmcuIFdlIFwibW9kXCIgdGhlIHJlc3VsdCB0byBtYWtlIGl0IGJldHdlZW4gMCAoaW5jbHVzaXZlKSBhbmQgMl4zMVxuICAgIC8vIChleGNsdXNpdmUpIGJ5IGRyb3BwaW5nIGhpZ2ggYml0cy5cbiAgICB2YXIgaGFzaCA9IDA7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHN0cmluZy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIGhhc2ggPSAzMSAqIGhhc2ggKyBzdHJpbmcuY2hhckNvZGVBdChpaSkgfCAwO1xuICAgIH1cbiAgICByZXR1cm4gc21pKGhhc2gpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzaEpTT2JqKG9iaikge1xuICAgIHZhciBoYXNoO1xuICAgIGlmICh1c2luZ1dlYWtNYXApIHtcbiAgICAgIGhhc2ggPSB3ZWFrTWFwLmdldChvYmopO1xuICAgICAgaWYgKGhhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoID0gb2JqW1VJRF9IQVNIX0tFWV07XG4gICAgaWYgKGhhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgaWYgKCFjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgaGFzaCA9IG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSAmJiBvYmoucHJvcGVydHlJc0VudW1lcmFibGVbVUlEX0hBU0hfS0VZXTtcbiAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICB9XG5cbiAgICAgIGhhc2ggPSBnZXRJRU5vZGVIYXNoKG9iaik7XG4gICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc2ggPSArK29iakhhc2hVSUQ7XG4gICAgaWYgKG9iakhhc2hVSUQgJiAweDQwMDAwMDAwKSB7XG4gICAgICBvYmpIYXNoVUlEID0gMDtcbiAgICB9XG5cbiAgICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgICB3ZWFrTWFwLnNldChvYmosIGhhc2gpO1xuICAgIH0gZWxzZSBpZiAoaXNFeHRlbnNpYmxlICE9PSB1bmRlZmluZWQgJiYgaXNFeHRlbnNpYmxlKG9iaikgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1leHRlbnNpYmxlIG9iamVjdHMgYXJlIG5vdCBhbGxvd2VkIGFzIGtleXMuJyk7XG4gICAgfSBlbHNlIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgVUlEX0hBU0hfS0VZLCB7XG4gICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgICAgICdjb25maWd1cmFibGUnOiBmYWxzZSxcbiAgICAgICAgJ3dyaXRhYmxlJzogZmFsc2UsXG4gICAgICAgICd2YWx1ZSc6IGhhc2hcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAob2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9PT0gb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSkge1xuICAgICAgLy8gU2luY2Ugd2UgY2FuJ3QgZGVmaW5lIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gdGhlIG9iamVjdFxuICAgICAgLy8gd2UnbGwgaGlqYWNrIG9uZSBvZiB0aGUgbGVzcy11c2VkIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgdG9cbiAgICAgIC8vIHNhdmUgb3VyIGhhc2ggb24gaXQuIFNpbmNlIHRoaXMgaXMgYSBmdW5jdGlvbiBpdCB3aWxsIG5vdCBzaG93IHVwIGluXG4gICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgIHdoaWNoIGlzIHdoYXQgd2Ugd2FudC5cbiAgICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGVbVUlEX0hBU0hfS0VZXSA9IGhhc2g7XG4gICAgfSBlbHNlIGlmIChvYmoubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBjb3VsZG4ndCBnZXQgdGhlIElFIGB1bmlxdWVJRGAgdG8gdXNlIGFzIGEgaGFzaFxuICAgICAgLy8gYW5kIHdlIGNvdWxkbid0IHVzZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IHRvIGV4cGxvaXQgdGhlXG4gICAgICAvLyBkb250RW51bSBidWcgc28gd2Ugc2ltcGx5IGFkZCB0aGUgYFVJRF9IQVNIX0tFWWAgb24gdGhlIG5vZGVcbiAgICAgIC8vIGl0c2VsZi5cbiAgICAgIG9ialtVSURfSEFTSF9LRVldID0gaGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2V0IGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gb2JqZWN0LicpO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNoO1xuICB9XG5cbiAgLy8gR2V0IHJlZmVyZW5jZXMgdG8gRVM1IG9iamVjdCBtZXRob2RzLlxuICB2YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuICAvLyBUcnVlIGlmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB3b3JrcyBhcyBleHBlY3RlZC4gSUU4IGZhaWxzIHRoaXMgdGVzdC5cbiAgdmFyIGNhbkRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdAJywge30pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSgpKTtcblxuICAvLyBJRSBoYXMgYSBgdW5pcXVlSURgIHByb3BlcnR5IG9uIERPTSBub2Rlcy4gV2UgY2FuIGNvbnN0cnVjdCB0aGUgaGFzaCBmcm9tIGl0XG4gIC8vIGFuZCBhdm9pZCBtZW1vcnkgbGVha3MgZnJvbSB0aGUgSUUgY2xvbmVOb2RlIGJ1Zy5cbiAgZnVuY3Rpb24gZ2V0SUVOb2RlSGFzaChub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA+IDApIHtcbiAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgICBjYXNlIDE6IC8vIEVsZW1lbnRcbiAgICAgICAgICByZXR1cm4gbm9kZS51bmlxdWVJRDtcbiAgICAgICAgY2FzZSA5OiAvLyBEb2N1bWVudFxuICAgICAgICAgIHJldHVybiBub2RlLmRvY3VtZW50RWxlbWVudCAmJiBub2RlLmRvY3VtZW50RWxlbWVudC51bmlxdWVJRDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiBwb3NzaWJsZSwgdXNlIGEgV2Vha01hcC5cbiAgdmFyIHVzaW5nV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nO1xuICB2YXIgd2Vha01hcDtcbiAgaWYgKHVzaW5nV2Vha01hcCkge1xuICAgIHdlYWtNYXAgPSBuZXcgV2Vha01hcCgpO1xuICB9XG5cbiAgdmFyIG9iakhhc2hVSUQgPSAwO1xuXG4gIHZhciBVSURfSEFTSF9LRVkgPSAnX19pbW11dGFibGVoYXNoX18nO1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFVJRF9IQVNIX0tFWSA9IFN5bWJvbChVSURfSEFTSF9LRVkpO1xuICB9XG5cbiAgdmFyIFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU4gPSAxNjtcbiAgdmFyIFNUUklOR19IQVNIX0NBQ0hFX01BWF9TSVpFID0gMjU1O1xuICB2YXIgU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9IDA7XG4gIHZhciBzdHJpbmdIYXNoQ2FjaGUgPSB7fTtcblxuICBmdW5jdGlvbiBhc3NlcnROb3RJbmZpbml0ZShzaXplKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgc2l6ZSAhPT0gSW5maW5pdHksXG4gICAgICAnQ2Fubm90IHBlcmZvcm0gdGhpcyBhY3Rpb24gd2l0aCBhbiBpbmZpbml0ZSBzaXplLidcbiAgICApO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoTWFwLCBLZXllZENvbGxlY3Rpb24pO1xuXG4gICAgLy8gQHByYWdtYSBDb25zdHJ1Y3Rpb25cblxuICAgIGZ1bmN0aW9uIE1hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eU1hcCgpIDpcbiAgICAgICAgaXNNYXAodmFsdWUpICYmICFpc09yZGVyZWQodmFsdWUpID8gdmFsdWUgOlxuICAgICAgICBlbXB0eU1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obWFwICkge1xuICAgICAgICAgIHZhciBpdGVyID0gS2V5ZWRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gbWFwLnNldChrLCB2KX0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdNYXAgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGssIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdCA/XG4gICAgICAgIHRoaXMuX3Jvb3QuZ2V0KDAsIHVuZGVmaW5lZCwgaywgbm90U2V0VmFsdWUpIDpcbiAgICAgICAgbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgIHJldHVybiB1cGRhdGVNYXAodGhpcywgaywgdik7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuc2V0SW4gPSBmdW5jdGlvbihrZXlQYXRoLCB2KSB7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVJbihrZXlQYXRoLCBOT1RfU0VULCBmdW5jdGlvbigpICB7cmV0dXJuIHZ9KTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihrKSB7XG4gICAgICByZXR1cm4gdXBkYXRlTWFwKHRoaXMsIGssIE5PVF9TRVQpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLmRlbGV0ZUluID0gZnVuY3Rpb24oa2V5UGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW4oa2V5UGF0aCwgZnVuY3Rpb24oKSAge3JldHVybiBOT1RfU0VUfSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oaywgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cbiAgICAgICAgayh0aGlzKSA6XG4gICAgICAgIHRoaXMudXBkYXRlSW4oW2tdLCBub3RTZXRWYWx1ZSwgdXBkYXRlcik7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUudXBkYXRlSW4gPSBmdW5jdGlvbihrZXlQYXRoLCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICAgICAgaWYgKCF1cGRhdGVyKSB7XG4gICAgICAgIHVwZGF0ZXIgPSBub3RTZXRWYWx1ZTtcbiAgICAgICAgbm90U2V0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlZFZhbHVlID0gdXBkYXRlSW5EZWVwTWFwKFxuICAgICAgICB0aGlzLFxuICAgICAgICBmb3JjZUl0ZXJhdG9yKGtleVBhdGgpLFxuICAgICAgICBub3RTZXRWYWx1ZSxcbiAgICAgICAgdXBkYXRlclxuICAgICAgKTtcbiAgICAgIHJldHVybiB1cGRhdGVkVmFsdWUgPT09IE5PVF9TRVQgPyB1bmRlZmluZWQgOiB1cGRhdGVkVmFsdWU7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5TWFwKCk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQ29tcG9zaXRpb25cblxuICAgIE1hcC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbigvKi4uLml0ZXJzKi8pIHtcbiAgICAgIHJldHVybiBtZXJnZUludG9NYXBXaXRoKHRoaXMsIHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5tZXJnZVdpdGggPSBmdW5jdGlvbihtZXJnZXIpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiBtZXJnZUludG9NYXBXaXRoKHRoaXMsIG1lcmdlciwgaXRlcnMpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLm1lcmdlSW4gPSBmdW5jdGlvbihrZXlQYXRoKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVJbihcbiAgICAgICAga2V5UGF0aCxcbiAgICAgICAgZW1wdHlNYXAoKSxcbiAgICAgICAgZnVuY3Rpb24obSApIHtyZXR1cm4gdHlwZW9mIG0ubWVyZ2UgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgIG0ubWVyZ2UuYXBwbHkobSwgaXRlcnMpIDpcbiAgICAgICAgICBpdGVyc1tpdGVycy5sZW5ndGggLSAxXX1cbiAgICAgICk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUubWVyZ2VEZWVwID0gZnVuY3Rpb24oLyouLi5pdGVycyovKSB7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCBkZWVwTWVyZ2VyLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBmdW5jdGlvbihtZXJnZXIpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiBtZXJnZUludG9NYXBXaXRoKHRoaXMsIGRlZXBNZXJnZXJXaXRoKG1lcmdlciksIGl0ZXJzKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5tZXJnZURlZXBJbiA9IGZ1bmN0aW9uKGtleVBhdGgpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUluKFxuICAgICAgICBrZXlQYXRoLFxuICAgICAgICBlbXB0eU1hcCgpLFxuICAgICAgICBmdW5jdGlvbihtICkge3JldHVybiB0eXBlb2YgbS5tZXJnZURlZXAgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgIG0ubWVyZ2VEZWVwLmFwcGx5KG0sIGl0ZXJzKSA6XG4gICAgICAgICAgaXRlcnNbaXRlcnMubGVuZ3RoIC0gMV19XG4gICAgICApO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gICAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICAgIHJldHVybiBPcmRlcmVkTWFwKHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbihtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIExhdGUgYmluZGluZ1xuICAgICAgcmV0dXJuIE9yZGVyZWRNYXAoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTXV0YWJpbGl0eVxuXG4gICAgTWFwLnByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgIHZhciBtdXRhYmxlID0gdGhpcy5hc011dGFibGUoKTtcbiAgICAgIGZuKG11dGFibGUpO1xuICAgICAgcmV0dXJuIG11dGFibGUud2FzQWx0ZXJlZCgpID8gbXV0YWJsZS5fX2Vuc3VyZU93bmVyKHRoaXMuX19vd25lcklEKSA6IHRoaXM7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuYXNNdXRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX293bmVySUQgPyB0aGlzIDogdGhpcy5fX2Vuc3VyZU93bmVyKG5ldyBPd25lcklEKCkpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLmFzSW1tdXRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2Vuc3VyZU93bmVyKCk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19hbHRlcmVkO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMsIHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB0aGlzLl9yb290ICYmIHRoaXMuX3Jvb3QuaXRlcmF0ZShmdW5jdGlvbihlbnRyeSApIHtcbiAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICByZXR1cm4gZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzJDApO1xuICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24ob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZU1hcCh0aGlzLnNpemUsIHRoaXMuX3Jvb3QsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNNYXAobWF5YmVNYXApIHtcbiAgICByZXR1cm4gISEobWF5YmVNYXAgJiYgbWF5YmVNYXBbSVNfTUFQX1NFTlRJTkVMXSk7XG4gIH1cblxuICBNYXAuaXNNYXAgPSBpc01hcDtcblxuICB2YXIgSVNfTUFQX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfTUFQX19AQCc7XG5cbiAgdmFyIE1hcFByb3RvdHlwZSA9IE1hcC5wcm90b3R5cGU7XG4gIE1hcFByb3RvdHlwZVtJU19NQVBfU0VOVElORUxdID0gdHJ1ZTtcbiAgTWFwUHJvdG90eXBlW0RFTEVURV0gPSBNYXBQcm90b3R5cGUucmVtb3ZlO1xuICBNYXBQcm90b3R5cGUucmVtb3ZlSW4gPSBNYXBQcm90b3R5cGUuZGVsZXRlSW47XG5cblxuICAvLyAjcHJhZ21hIFRyaWUgTm9kZXNcblxuXG5cbiAgICBmdW5jdGlvbiBBcnJheU1hcE5vZGUob3duZXJJRCwgZW50cmllcykge1xuICAgICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgfVxuXG4gICAgQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgICBmb3IgKHZhciBpaSA9IDAsIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKykge1xuICAgICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcbiAgICAgICAgICByZXR1cm4gZW50cmllc1tpaV1bMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgQXJyYXlNYXBOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICAgIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG5cbiAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICBmb3IgKHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lkeF1bMF0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBleGlzdHMgPSBpZHggPCBsZW47XG5cbiAgICAgIGlmIChleGlzdHMgPyBlbnRyaWVzW2lkeF1bMV0gPT09IHZhbHVlIDogcmVtb3ZlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAgIChyZW1vdmVkIHx8ICFleGlzdHMpICYmIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcblxuICAgICAgaWYgKHJlbW92ZWQgJiYgZW50cmllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgaWYgKCFleGlzdHMgJiYgIXJlbW92ZWQgJiYgZW50cmllcy5sZW5ndGggPj0gTUFYX0FSUkFZX01BUF9TSVpFKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVOb2Rlcyhvd25lcklELCBlbnRyaWVzLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICAgIHZhciBuZXdFbnRyaWVzID0gaXNFZGl0YWJsZSA/IGVudHJpZXMgOiBhcnJDb3B5KGVudHJpZXMpO1xuXG4gICAgICBpZiAoZXhpc3RzKSB7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgaWR4ID09PSBsZW4gLSAxID8gbmV3RW50cmllcy5wb3AoKSA6IChuZXdFbnRyaWVzW2lkeF0gPSBuZXdFbnRyaWVzLnBvcCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdFbnRyaWVzW2lkeF0gPSBba2V5LCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0VudHJpZXMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBuZXdFbnRyaWVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBBcnJheU1hcE5vZGUob3duZXJJRCwgbmV3RW50cmllcyk7XG4gICAgfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIGJpdG1hcCwgbm9kZXMpIHtcbiAgICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLmJpdG1hcCA9IGJpdG1hcDtcbiAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICB9XG5cbiAgICBCaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICAgIH1cbiAgICAgIHZhciBiaXQgPSAoMSA8PCAoKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0spKTtcbiAgICAgIHZhciBiaXRtYXAgPSB0aGlzLmJpdG1hcDtcbiAgICAgIHJldHVybiAoYml0bWFwICYgYml0KSA9PT0gMCA/IG5vdFNldFZhbHVlIDpcbiAgICAgICAgdGhpcy5ub2Rlc1twb3BDb3VudChiaXRtYXAgJiAoYml0IC0gMSkpXS5nZXQoc2hpZnQgKyBTSElGVCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSk7XG4gICAgfTtcblxuICAgIEJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXlIYXNoRnJhZyA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICAgICAgdmFyIGJpdCA9IDEgPDwga2V5SGFzaEZyYWc7XG4gICAgICB2YXIgYml0bWFwID0gdGhpcy5iaXRtYXA7XG4gICAgICB2YXIgZXhpc3RzID0gKGJpdG1hcCAmIGJpdCkgIT09IDA7XG5cbiAgICAgIGlmICghZXhpc3RzICYmIHZhbHVlID09PSBOT1RfU0VUKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWR4ID0gcG9wQ291bnQoYml0bWFwICYgKGJpdCAtIDEpKTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgICB2YXIgbm9kZSA9IGV4aXN0cyA/IG5vZGVzW2lkeF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbmV3Tm9kZSA9IHVwZGF0ZU5vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQgKyBTSElGVCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpO1xuXG4gICAgICBpZiAobmV3Tm9kZSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKCFleGlzdHMgJiYgbmV3Tm9kZSAmJiBub2Rlcy5sZW5ndGggPj0gTUFYX0JJVE1BUF9JTkRFWEVEX1NJWkUpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZE5vZGVzKG93bmVySUQsIG5vZGVzLCBiaXRtYXAsIGtleUhhc2hGcmFnLCBuZXdOb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4aXN0cyAmJiAhbmV3Tm9kZSAmJiBub2Rlcy5sZW5ndGggPT09IDIgJiYgaXNMZWFmTm9kZShub2Rlc1tpZHggXiAxXSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzW2lkeCBeIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhpc3RzICYmIG5ld05vZGUgJiYgbm9kZXMubGVuZ3RoID09PSAxICYmIGlzTGVhZk5vZGUobmV3Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gICAgICB2YXIgbmV3Qml0bWFwID0gZXhpc3RzID8gbmV3Tm9kZSA/IGJpdG1hcCA6IGJpdG1hcCBeIGJpdCA6IGJpdG1hcCB8IGJpdDtcbiAgICAgIHZhciBuZXdOb2RlcyA9IGV4aXN0cyA/IG5ld05vZGUgP1xuICAgICAgICBzZXRJbihub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKSA6XG4gICAgICAgIHNwbGljZU91dChub2RlcywgaWR4LCBpc0VkaXRhYmxlKSA6XG4gICAgICAgIHNwbGljZUluKG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpO1xuXG4gICAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgICB0aGlzLmJpdG1hcCA9IG5ld0JpdG1hcDtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5ld05vZGVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBuZXdCaXRtYXAsIG5ld05vZGVzKTtcbiAgICB9O1xuXG5cblxuXG4gICAgZnVuY3Rpb24gSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBjb3VudCwgbm9kZXMpIHtcbiAgICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgfVxuXG4gICAgSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICAgIH1cbiAgICAgIHZhciBpZHggPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1tpZHhdO1xuICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLmdldChzaGlmdCArIFNISUZULCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBIYXNoQXJyYXlNYXBOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICAgIH1cbiAgICAgIHZhciBpZHggPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgICAgIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpZHhdO1xuXG4gICAgICBpZiAocmVtb3ZlZCAmJiAhbm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld05vZGUgPSB1cGRhdGVOb2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKTtcbiAgICAgIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3Q291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIG5ld0NvdW50Kys7XG4gICAgICB9IGVsc2UgaWYgKCFuZXdOb2RlKSB7XG4gICAgICAgIG5ld0NvdW50LS07XG4gICAgICAgIGlmIChuZXdDb3VudCA8IE1JTl9IQVNIX0FSUkFZX01BUF9TSVpFKSB7XG4gICAgICAgICAgcmV0dXJuIHBhY2tOb2Rlcyhvd25lcklELCBub2RlcywgbmV3Q291bnQsIGlkeCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICAgIHZhciBuZXdOb2RlcyA9IHNldEluKG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpO1xuXG4gICAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgICB0aGlzLmNvdW50ID0gbmV3Q291bnQ7XG4gICAgICAgIHRoaXMubm9kZXMgPSBuZXdOb2RlcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBuZXdDb3VudCwgbmV3Tm9kZXMpO1xuICAgIH07XG5cblxuXG5cbiAgICBmdW5jdGlvbiBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyaWVzKSB7XG4gICAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5rZXlIYXNoID0ga2V5SGFzaDtcbiAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgfVxuXG4gICAgSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICAgIGZvciAodmFyIGlpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWldWzBdKSkge1xuICAgICAgICAgIHJldHVybiBlbnRyaWVzW2lpXVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBIYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG5cbiAgICAgIGlmIChrZXlIYXNoICE9PSB0aGlzLmtleUhhc2gpIHtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgICAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgICAgIHJldHVybiBtZXJnZUludG9Ob2RlKHRoaXMsIG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICAgIHZhciBpZHggPSAwO1xuICAgICAgZm9yICh2YXIgbGVuID0gZW50cmllcy5sZW5ndGg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpZHhdWzBdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhpc3RzID0gaWR4IDwgbGVuO1xuXG4gICAgICBpZiAoZXhpc3RzID8gZW50cmllc1tpZHhdWzFdID09PSB2YWx1ZSA6IHJlbW92ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgICAocmVtb3ZlZCB8fCAhZXhpc3RzKSAmJiBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG5cbiAgICAgIGlmIChyZW1vdmVkICYmIGxlbiA9PT0gMikge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIGVudHJpZXNbaWR4IF4gMV0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICAgICAgdmFyIG5ld0VudHJpZXMgPSBpc0VkaXRhYmxlID8gZW50cmllcyA6IGFyckNvcHkoZW50cmllcyk7XG5cbiAgICAgIGlmIChleGlzdHMpIHtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICBpZHggPT09IGxlbiAtIDEgPyBuZXdFbnRyaWVzLnBvcCgpIDogKG5ld0VudHJpZXNbaWR4XSA9IG5ld0VudHJpZXMucG9wKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0VudHJpZXNbaWR4XSA9IFtrZXksIHZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IG5ld0VudHJpZXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgbmV3RW50cmllcyk7XG4gICAgfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyeSkge1xuICAgICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG4gICAgICB0aGlzLmVudHJ5ID0gZW50cnk7XG4gICAgfVxuXG4gICAgVmFsdWVOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGlzKGtleSwgdGhpcy5lbnRyeVswXSkgPyB0aGlzLmVudHJ5WzFdIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIFZhbHVlTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuICAgICAgdmFyIGtleU1hdGNoID0gaXMoa2V5LCB0aGlzLmVudHJ5WzBdKTtcbiAgICAgIGlmIChrZXlNYXRjaCA/IHZhbHVlID09PSB0aGlzLmVudHJ5WzFdIDogcmVtb3ZlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcblxuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgICAgICByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAoa2V5TWF0Y2gpIHtcbiAgICAgICAgaWYgKG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEKSB7XG4gICAgICAgICAgdGhpcy5lbnRyeVsxXSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgICAgcmV0dXJuIG1lcmdlSW50b05vZGUodGhpcywgb3duZXJJRCwgc2hpZnQsIGhhc2goa2V5KSwgW2tleSwgdmFsdWVdKTtcbiAgICB9O1xuXG5cblxuICAvLyAjcHJhZ21hIEl0ZXJhdG9yc1xuXG4gIEFycmF5TWFwTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9XG4gIEhhc2hDb2xsaXNpb25Ob2RlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBtYXhJbmRleCA9IGVudHJpZXMubGVuZ3RoIC0gMTsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcbiAgICAgIGlmIChmbihlbnRyaWVzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIEJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS5pdGVyYXRlID1cbiAgSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBtYXhJbmRleCA9IG5vZGVzLmxlbmd0aCAtIDE7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldO1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5pdGVyYXRlKGZuLCByZXZlcnNlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFZhbHVlTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHJldHVybiBmbih0aGlzLmVudHJ5KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE1hcEl0ZXJhdG9yLCBJdGVyYXRvcik7XG5cbiAgICBmdW5jdGlvbiBNYXBJdGVyYXRvcihtYXAsIHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5fcmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgICB0aGlzLl9zdGFjayA9IG1hcC5fcm9vdCAmJiBtYXBJdGVyYXRvckZyYW1lKG1hcC5fcm9vdCk7XG4gICAgfVxuXG4gICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZTtcbiAgICAgIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrO1xuICAgICAgd2hpbGUgKHN0YWNrKSB7XG4gICAgICAgIHZhciBub2RlID0gc3RhY2subm9kZTtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhY2suaW5kZXgrKztcbiAgICAgICAgdmFyIG1heEluZGV4O1xuICAgICAgICBpZiAobm9kZS5lbnRyeSkge1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgbm9kZS5lbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuZW50cmllcykge1xuICAgICAgICAgIG1heEluZGV4ID0gbm9kZS5lbnRyaWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKGluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBub2RlLmVudHJpZXNbdGhpcy5fcmV2ZXJzZSA/IG1heEluZGV4IC0gaW5kZXggOiBpbmRleF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXhJbmRleCA9IG5vZGUubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoaW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzdWJOb2RlID0gbm9kZS5ub2Rlc1t0aGlzLl9yZXZlcnNlID8gbWF4SW5kZXggLSBpbmRleCA6IGluZGV4XTtcbiAgICAgICAgICAgIGlmIChzdWJOb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChzdWJOb2RlLmVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgc3ViTm9kZS5lbnRyeSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhY2sgPSB0aGlzLl9zdGFjayA9IG1hcEl0ZXJhdG9yRnJhbWUoc3ViTm9kZSwgc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrID0gdGhpcy5fc3RhY2sgPSB0aGlzLl9zdGFjay5fX3ByZXY7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgfTtcblxuXG4gIGZ1bmN0aW9uIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgZW50cnkpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwSXRlcmF0b3JGcmFtZShub2RlLCBwcmV2KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IG5vZGUsXG4gICAgICBpbmRleDogMCxcbiAgICAgIF9fcHJldjogcHJldlxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlTWFwKHNpemUsIHJvb3QsIG93bmVySUQsIGhhc2gpIHtcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShNYXBQcm90b3R5cGUpO1xuICAgIG1hcC5zaXplID0gc2l6ZTtcbiAgICBtYXAuX3Jvb3QgPSByb290O1xuICAgIG1hcC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIG1hcC5fX2hhc2ggPSBoYXNoO1xuICAgIG1hcC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgdmFyIEVNUFRZX01BUDtcbiAgZnVuY3Rpb24gZW1wdHlNYXAoKSB7XG4gICAgcmV0dXJuIEVNUFRZX01BUCB8fCAoRU1QVFlfTUFQID0gbWFrZU1hcCgwKSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNYXAobWFwLCBrLCB2KSB7XG4gICAgdmFyIG5ld1Jvb3Q7XG4gICAgdmFyIG5ld1NpemU7XG4gICAgaWYgKCFtYXAuX3Jvb3QpIHtcbiAgICAgIGlmICh2ID09PSBOT1RfU0VUKSB7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9XG4gICAgICBuZXdTaXplID0gMTtcbiAgICAgIG5ld1Jvb3QgPSBuZXcgQXJyYXlNYXBOb2RlKG1hcC5fX293bmVySUQsIFtbaywgdl1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpZENoYW5nZVNpemUgPSBNYWtlUmVmKENIQU5HRV9MRU5HVEgpO1xuICAgICAgdmFyIGRpZEFsdGVyID0gTWFrZVJlZihESURfQUxURVIpO1xuICAgICAgbmV3Um9vdCA9IHVwZGF0ZU5vZGUobWFwLl9yb290LCBtYXAuX19vd25lcklELCAwLCB1bmRlZmluZWQsIGssIHYsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKTtcbiAgICAgIGlmICghZGlkQWx0ZXIudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH1cbiAgICAgIG5ld1NpemUgPSBtYXAuc2l6ZSArIChkaWRDaGFuZ2VTaXplLnZhbHVlID8gdiA9PT0gTk9UX1NFVCA/IC0xIDogMSA6IDApO1xuICAgIH1cbiAgICBpZiAobWFwLl9fb3duZXJJRCkge1xuICAgICAgbWFwLnNpemUgPSBuZXdTaXplO1xuICAgICAgbWFwLl9yb290ID0gbmV3Um9vdDtcbiAgICAgIG1hcC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICBtYXAuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHJldHVybiBuZXdSb290ID8gbWFrZU1hcChuZXdTaXplLCBuZXdSb290KSA6IGVtcHR5TWFwKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVOb2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgaWYgKHZhbHVlID09PSBOT1RfU0VUKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnVwZGF0ZShvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMZWFmTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuY29uc3RydWN0b3IgPT09IFZhbHVlTm9kZSB8fCBub2RlLmNvbnN0cnVjdG9yID09PSBIYXNoQ29sbGlzaW9uTm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSW50b05vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGVudHJ5KSB7XG4gICAgaWYgKG5vZGUua2V5SGFzaCA9PT0ga2V5SGFzaCkge1xuICAgICAgcmV0dXJuIG5ldyBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCBrZXlIYXNoLCBbbm9kZS5lbnRyeSwgZW50cnldKTtcbiAgICB9XG5cbiAgICB2YXIgaWR4MSA9IChzaGlmdCA9PT0gMCA/IG5vZGUua2V5SGFzaCA6IG5vZGUua2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgICB2YXIgaWR4MiA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuXG4gICAgdmFyIG5ld05vZGU7XG4gICAgdmFyIG5vZGVzID0gaWR4MSA9PT0gaWR4MiA/XG4gICAgICBbbWVyZ2VJbnRvTm9kZShub2RlLCBvd25lcklELCBzaGlmdCArIFNISUZULCBrZXlIYXNoLCBlbnRyeSldIDpcbiAgICAgICgobmV3Tm9kZSA9IG5ldyBWYWx1ZU5vZGUob3duZXJJRCwga2V5SGFzaCwgZW50cnkpKSwgaWR4MSA8IGlkeDIgPyBbbm9kZSwgbmV3Tm9kZV0gOiBbbmV3Tm9kZSwgbm9kZV0pO1xuXG4gICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCAoMSA8PCBpZHgxKSB8ICgxIDw8IGlkeDIpLCBub2Rlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2Rlcyhvd25lcklELCBlbnRyaWVzLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBvd25lcklEID0gbmV3IE93bmVySUQoKTtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGhhc2goa2V5KSwgW2tleSwgdmFsdWVdKTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgZW50cmllcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaWldO1xuICAgICAgbm9kZSA9IG5vZGUudXBkYXRlKG93bmVySUQsIDAsIHVuZGVmaW5lZCwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBwYWNrTm9kZXMob3duZXJJRCwgbm9kZXMsIGNvdW50LCBleGNsdWRpbmcpIHtcbiAgICB2YXIgYml0bWFwID0gMDtcbiAgICB2YXIgcGFja2VkSUkgPSAwO1xuICAgIHZhciBwYWNrZWROb2RlcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBiaXQgPSAxLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrLCBiaXQgPDw9IDEpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaWldO1xuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiBpaSAhPT0gZXhjbHVkaW5nKSB7XG4gICAgICAgIGJpdG1hcCB8PSBiaXQ7XG4gICAgICAgIHBhY2tlZE5vZGVzW3BhY2tlZElJKytdID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIHBhY2tlZE5vZGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGFuZE5vZGVzKG93bmVySUQsIG5vZGVzLCBiaXRtYXAsIGluY2x1ZGluZywgbm9kZSkge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGV4cGFuZGVkTm9kZXMgPSBuZXcgQXJyYXkoU0laRSk7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBiaXRtYXAgIT09IDA7IGlpKyssIGJpdG1hcCA+Pj49IDEpIHtcbiAgICAgIGV4cGFuZGVkTm9kZXNbaWldID0gYml0bWFwICYgMSA/IG5vZGVzW2NvdW50KytdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBleHBhbmRlZE5vZGVzW2luY2x1ZGluZ10gPSBub2RlO1xuICAgIHJldHVybiBuZXcgSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBjb3VudCArIDEsIGV4cGFuZGVkTm9kZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VJbnRvTWFwV2l0aChtYXAsIG1lcmdlciwgaXRlcmFibGVzKSB7XG4gICAgdmFyIGl0ZXJzID0gW107XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGl0ZXJhYmxlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZXJhYmxlc1tpaV07XG4gICAgICB2YXIgaXRlciA9IEtleWVkSXRlcmFibGUodmFsdWUpO1xuICAgICAgaWYgKCFpc0l0ZXJhYmxlKHZhbHVlKSkge1xuICAgICAgICBpdGVyID0gaXRlci5tYXAoZnVuY3Rpb24odiApIHtyZXR1cm4gZnJvbUpTKHYpfSk7XG4gICAgICB9XG4gICAgICBpdGVycy5wdXNoKGl0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VJbnRvQ29sbGVjdGlvbldpdGgobWFwLCBtZXJnZXIsIGl0ZXJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZXBNZXJnZXIoZXhpc3RpbmcsIHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gZXhpc3RpbmcgJiYgZXhpc3RpbmcubWVyZ2VEZWVwICYmIGlzSXRlcmFibGUodmFsdWUpID9cbiAgICAgIGV4aXN0aW5nLm1lcmdlRGVlcCh2YWx1ZSkgOlxuICAgICAgaXMoZXhpc3RpbmcsIHZhbHVlKSA/IGV4aXN0aW5nIDogdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWVwTWVyZ2VyV2l0aChtZXJnZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXhpc3RpbmcsIHZhbHVlLCBrZXkpICB7XG4gICAgICBpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcubWVyZ2VEZWVwV2l0aCAmJiBpc0l0ZXJhYmxlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmcubWVyZ2VEZWVwV2l0aChtZXJnZXIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0VmFsdWUgPSBtZXJnZXIoZXhpc3RpbmcsIHZhbHVlLCBrZXkpO1xuICAgICAgcmV0dXJuIGlzKGV4aXN0aW5nLCBuZXh0VmFsdWUpID8gZXhpc3RpbmcgOiBuZXh0VmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSW50b0NvbGxlY3Rpb25XaXRoKGNvbGxlY3Rpb24sIG1lcmdlciwgaXRlcnMpIHtcbiAgICBpdGVycyA9IGl0ZXJzLmZpbHRlcihmdW5jdGlvbih4ICkge3JldHVybiB4LnNpemUgIT09IDB9KTtcbiAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3Rpb24uc2l6ZSA9PT0gMCAmJiAhY29sbGVjdGlvbi5fX293bmVySUQgJiYgaXRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5jb25zdHJ1Y3RvcihpdGVyc1swXSk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oY29sbGVjdGlvbiApIHtcbiAgICAgIHZhciBtZXJnZUludG9NYXAgPSBtZXJnZXIgP1xuICAgICAgICBmdW5jdGlvbih2YWx1ZSwga2V5KSAge1xuICAgICAgICAgIGNvbGxlY3Rpb24udXBkYXRlKGtleSwgTk9UX1NFVCwgZnVuY3Rpb24oZXhpc3RpbmcgKVxuICAgICAgICAgICAge3JldHVybiBleGlzdGluZyA9PT0gTk9UX1NFVCA/IHZhbHVlIDogbWVyZ2VyKGV4aXN0aW5nLCB2YWx1ZSwga2V5KX1cbiAgICAgICAgICApO1xuICAgICAgICB9IDpcbiAgICAgICAgZnVuY3Rpb24odmFsdWUsIGtleSkgIHtcbiAgICAgICAgICBjb2xsZWN0aW9uLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGl0ZXJzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBpdGVyc1tpaV0uZm9yRWFjaChtZXJnZUludG9NYXApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSW5EZWVwTWFwKGV4aXN0aW5nLCBrZXlQYXRoSXRlciwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgICB2YXIgaXNOb3RTZXQgPSBleGlzdGluZyA9PT0gTk9UX1NFVDtcbiAgICB2YXIgc3RlcCA9IGtleVBhdGhJdGVyLm5leHQoKTtcbiAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IGlzTm90U2V0ID8gbm90U2V0VmFsdWUgOiBleGlzdGluZztcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHVwZGF0ZXIoZXhpc3RpbmdWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3VmFsdWUgPT09IGV4aXN0aW5nVmFsdWUgPyBleGlzdGluZyA6IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBpc05vdFNldCB8fCAoZXhpc3RpbmcgJiYgZXhpc3Rpbmcuc2V0KSxcbiAgICAgICdpbnZhbGlkIGtleVBhdGgnXG4gICAgKTtcbiAgICB2YXIga2V5ID0gc3RlcC52YWx1ZTtcbiAgICB2YXIgbmV4dEV4aXN0aW5nID0gaXNOb3RTZXQgPyBOT1RfU0VUIDogZXhpc3RpbmcuZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgdmFyIG5leHRVcGRhdGVkID0gdXBkYXRlSW5EZWVwTWFwKFxuICAgICAgbmV4dEV4aXN0aW5nLFxuICAgICAga2V5UGF0aEl0ZXIsXG4gICAgICBub3RTZXRWYWx1ZSxcbiAgICAgIHVwZGF0ZXJcbiAgICApO1xuICAgIHJldHVybiBuZXh0VXBkYXRlZCA9PT0gbmV4dEV4aXN0aW5nID8gZXhpc3RpbmcgOlxuICAgICAgbmV4dFVwZGF0ZWQgPT09IE5PVF9TRVQgPyBleGlzdGluZy5yZW1vdmUoa2V5KSA6XG4gICAgICAoaXNOb3RTZXQgPyBlbXB0eU1hcCgpIDogZXhpc3RpbmcpLnNldChrZXksIG5leHRVcGRhdGVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcENvdW50KHgpIHtcbiAgICB4ID0geCAtICgoeCA+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICAgIHggPSAoeCAmIDB4MzMzMzMzMzMpICsgKCh4ID4+IDIpICYgMHgzMzMzMzMzMyk7XG4gICAgeCA9ICh4ICsgKHggPj4gNCkpICYgMHgwZjBmMGYwZjtcbiAgICB4ID0geCArICh4ID4+IDgpO1xuICAgIHggPSB4ICsgKHggPj4gMTYpO1xuICAgIHJldHVybiB4ICYgMHg3ZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEluKGFycmF5LCBpZHgsIHZhbCwgY2FuRWRpdCkge1xuICAgIHZhciBuZXdBcnJheSA9IGNhbkVkaXQgPyBhcnJheSA6IGFyckNvcHkoYXJyYXkpO1xuICAgIG5ld0FycmF5W2lkeF0gPSB2YWw7XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaWNlSW4oYXJyYXksIGlkeCwgdmFsLCBjYW5FZGl0KSB7XG4gICAgdmFyIG5ld0xlbiA9IGFycmF5Lmxlbmd0aCArIDE7XG4gICAgaWYgKGNhbkVkaXQgJiYgaWR4ICsgMSA9PT0gbmV3TGVuKSB7XG4gICAgICBhcnJheVtpZHhdID0gdmFsO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgICB2YXIgYWZ0ZXIgPSAwO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBuZXdMZW47IGlpKyspIHtcbiAgICAgIGlmIChpaSA9PT0gaWR4KSB7XG4gICAgICAgIG5ld0FycmF5W2lpXSA9IHZhbDtcbiAgICAgICAgYWZ0ZXIgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0FycmF5W2lpXSA9IGFycmF5W2lpICsgYWZ0ZXJdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cblxuICBmdW5jdGlvbiBzcGxpY2VPdXQoYXJyYXksIGlkeCwgY2FuRWRpdCkge1xuICAgIHZhciBuZXdMZW4gPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIGlmIChjYW5FZGl0ICYmIGlkeCA9PT0gbmV3TGVuKSB7XG4gICAgICBhcnJheS5wb3AoKTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgdmFyIG5ld0FycmF5ID0gbmV3IEFycmF5KG5ld0xlbik7XG4gICAgdmFyIGFmdGVyID0gMDtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmV3TGVuOyBpaSsrKSB7XG4gICAgICBpZiAoaWkgPT09IGlkeCkge1xuICAgICAgICBhZnRlciA9IDE7XG4gICAgICB9XG4gICAgICBuZXdBcnJheVtpaV0gPSBhcnJheVtpaSArIGFmdGVyXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgdmFyIE1BWF9BUlJBWV9NQVBfU0laRSA9IFNJWkUgLyA0O1xuICB2YXIgTUFYX0JJVE1BUF9JTkRFWEVEX1NJWkUgPSBTSVpFIC8gMjtcbiAgdmFyIE1JTl9IQVNIX0FSUkFZX01BUF9TSVpFID0gU0laRSAvIDQ7XG5cbiAgY3JlYXRlQ2xhc3MoTGlzdCwgSW5kZXhlZENvbGxlY3Rpb24pO1xuXG4gICAgLy8gQHByYWdtYSBDb25zdHJ1Y3Rpb25cblxuICAgIGZ1bmN0aW9uIExpc3QodmFsdWUpIHtcbiAgICAgIHZhciBlbXB0eSA9IGVtcHR5TGlzdCgpO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgfVxuICAgICAgaWYgKGlzTGlzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXIgPSBJbmRleGVkSXRlcmFibGUodmFsdWUpO1xuICAgICAgdmFyIHNpemUgPSBpdGVyLnNpemU7XG4gICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICB9XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZShzaXplKTtcbiAgICAgIGlmIChzaXplID4gMCAmJiBzaXplIDwgU0laRSkge1xuICAgICAgICByZXR1cm4gbWFrZUxpc3QoMCwgc2l6ZSwgU0hJRlQsIG51bGwsIG5ldyBWTm9kZShpdGVyLnRvQXJyYXkoKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5LndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obGlzdCApIHtcbiAgICAgICAgbGlzdC5zZXRTaXplKHNpemUpO1xuICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24odiwgaSkgIHtyZXR1cm4gbGlzdC5zZXQoaSwgdil9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIExpc3Qub2YgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnTGlzdCBbJywgJ10nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIExpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLnNpemUpIHtcbiAgICAgICAgaW5kZXggKz0gdGhpcy5fb3JpZ2luO1xuICAgICAgICB2YXIgbm9kZSA9IGxpc3ROb2RlRm9yKHRoaXMsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5hcnJheVtpbmRleCAmIE1BU0tdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgTGlzdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdXBkYXRlTGlzdCh0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhcyhpbmRleCkgPyB0aGlzIDpcbiAgICAgICAgaW5kZXggPT09IDAgPyB0aGlzLnNoaWZ0KCkgOlxuICAgICAgICBpbmRleCA9PT0gdGhpcy5zaXplIC0gMSA/IHRoaXMucG9wKCkgOlxuICAgICAgICB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX29yaWdpbiA9IHRoaXMuX2NhcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBTSElGVDtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX3RhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUxpc3QoKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgb2xkU2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obGlzdCApIHtcbiAgICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCAwLCBvbGRTaXplICsgdmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB2YWx1ZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgbGlzdC5zZXQob2xkU2l6ZSArIGlpLCB2YWx1ZXNbaWldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNldExpc3RCb3VuZHModGhpcywgMCwgLTEpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgdmFyIHZhbHVlcyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obGlzdCApIHtcbiAgICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCAtdmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB2YWx1ZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgbGlzdC5zZXQoaWksIHZhbHVlc1tpaV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDEpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIENvbXBvc2l0aW9uXG5cbiAgICBMaXN0LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKC8qLi4uaXRlcnMqLykge1xuICAgICAgcmV0dXJuIG1lcmdlSW50b0xpc3RXaXRoKHRoaXMsIHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUubWVyZ2VXaXRoID0gZnVuY3Rpb24obWVyZ2VyKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTGlzdFdpdGgodGhpcywgbWVyZ2VyLCBpdGVycyk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLm1lcmdlRGVlcCA9IGZ1bmN0aW9uKC8qLi4uaXRlcnMqLykge1xuICAgICAgcmV0dXJuIG1lcmdlSW50b0xpc3RXaXRoKHRoaXMsIGRlZXBNZXJnZXIsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBmdW5jdGlvbihtZXJnZXIpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiBtZXJnZUludG9MaXN0V2l0aCh0aGlzLCBkZWVwTWVyZ2VyV2l0aChtZXJnZXIpLCBpdGVycyk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAwLCBzaXplKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBJdGVyYXRpb25cblxuICAgIExpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKFxuICAgICAgICB0aGlzLFxuICAgICAgICByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpLFxuICAgICAgICByZXNvbHZlRW5kKGVuZCwgc2l6ZSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHZhbHVlcyA9IGl0ZXJhdGVMaXN0KHRoaXMsIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlcygpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IERPTkUgP1xuICAgICAgICAgIGl0ZXJhdG9yRG9uZSgpIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGluZGV4KyssIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciB2YWx1ZXMgPSBpdGVyYXRlTGlzdCh0aGlzLCByZXZlcnNlKTtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHdoaWxlICgodmFsdWUgPSB2YWx1ZXMoKSkgIT09IERPTkUpIHtcbiAgICAgICAgaWYgKGZuKHZhbHVlLCBpbmRleCsrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24ob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZUxpc3QodGhpcy5fb3JpZ2luLCB0aGlzLl9jYXBhY2l0eSwgdGhpcy5fbGV2ZWwsIHRoaXMuX3Jvb3QsIHRoaXMuX3RhaWwsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNMaXN0KG1heWJlTGlzdCkge1xuICAgIHJldHVybiAhIShtYXliZUxpc3QgJiYgbWF5YmVMaXN0W0lTX0xJU1RfU0VOVElORUxdKTtcbiAgfVxuXG4gIExpc3QuaXNMaXN0ID0gaXNMaXN0O1xuXG4gIHZhciBJU19MSVNUX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfTElTVF9fQEAnO1xuXG4gIHZhciBMaXN0UHJvdG90eXBlID0gTGlzdC5wcm90b3R5cGU7XG4gIExpc3RQcm90b3R5cGVbSVNfTElTVF9TRU5USU5FTF0gPSB0cnVlO1xuICBMaXN0UHJvdG90eXBlW0RFTEVURV0gPSBMaXN0UHJvdG90eXBlLnJlbW92ZTtcbiAgTGlzdFByb3RvdHlwZS5zZXRJbiA9IE1hcFByb3RvdHlwZS5zZXRJbjtcbiAgTGlzdFByb3RvdHlwZS5kZWxldGVJbiA9XG4gIExpc3RQcm90b3R5cGUucmVtb3ZlSW4gPSBNYXBQcm90b3R5cGUucmVtb3ZlSW47XG4gIExpc3RQcm90b3R5cGUudXBkYXRlID0gTWFwUHJvdG90eXBlLnVwZGF0ZTtcbiAgTGlzdFByb3RvdHlwZS51cGRhdGVJbiA9IE1hcFByb3RvdHlwZS51cGRhdGVJbjtcbiAgTGlzdFByb3RvdHlwZS5tZXJnZUluID0gTWFwUHJvdG90eXBlLm1lcmdlSW47XG4gIExpc3RQcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBNYXBQcm90b3R5cGUubWVyZ2VEZWVwSW47XG4gIExpc3RQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IE1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zO1xuICBMaXN0UHJvdG90eXBlLmFzTXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc011dGFibGU7XG4gIExpc3RQcm90b3R5cGUuYXNJbW11dGFibGUgPSBNYXBQcm90b3R5cGUuYXNJbW11dGFibGU7XG4gIExpc3RQcm90b3R5cGUud2FzQWx0ZXJlZCA9IE1hcFByb3RvdHlwZS53YXNBbHRlcmVkO1xuXG5cblxuICAgIGZ1bmN0aW9uIFZOb2RlKGFycmF5LCBvd25lcklEKSB7XG4gICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHNlZW1zIGxpa2UgdGhlc2UgbWV0aG9kcyBhcmUgdmVyeSBzaW1pbGFyXG5cbiAgICBWTm9kZS5wcm90b3R5cGUucmVtb3ZlQmVmb3JlID0gZnVuY3Rpb24ob3duZXJJRCwgbGV2ZWwsIGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IGxldmVsID8gMSA8PCBsZXZlbCA6IDAgfHwgdGhpcy5hcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgb3JpZ2luSW5kZXggPSAoaW5kZXggPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgICBpZiAob3JpZ2luSW5kZXggPj0gdGhpcy5hcnJheS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWTm9kZShbXSwgb3duZXJJRCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVtb3ZpbmdGaXJzdCA9IG9yaWdpbkluZGV4ID09PSAwO1xuICAgICAgdmFyIG5ld0NoaWxkO1xuICAgICAgaWYgKGxldmVsID4gMCkge1xuICAgICAgICB2YXIgb2xkQ2hpbGQgPSB0aGlzLmFycmF5W29yaWdpbkluZGV4XTtcbiAgICAgICAgbmV3Q2hpbGQgPSBvbGRDaGlsZCAmJiBvbGRDaGlsZC5yZW1vdmVCZWZvcmUob3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgpO1xuICAgICAgICBpZiAobmV3Q2hpbGQgPT09IG9sZENoaWxkICYmIHJlbW92aW5nRmlyc3QpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlbW92aW5nRmlyc3QgJiYgIW5ld0NoaWxkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdGFibGVWTm9kZSh0aGlzLCBvd25lcklEKTtcbiAgICAgIGlmICghcmVtb3ZpbmdGaXJzdCkge1xuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgb3JpZ2luSW5kZXg7IGlpKyspIHtcbiAgICAgICAgICBlZGl0YWJsZS5hcnJheVtpaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgICBlZGl0YWJsZS5hcnJheVtvcmlnaW5JbmRleF0gPSBuZXdDaGlsZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlZGl0YWJsZTtcbiAgICB9O1xuXG4gICAgVk5vZGUucHJvdG90eXBlLnJlbW92ZUFmdGVyID0gZnVuY3Rpb24ob3duZXJJRCwgbGV2ZWwsIGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IChsZXZlbCA/IDEgPDwgbGV2ZWwgOiAwKSB8fCB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBzaXplSW5kZXggPSAoKGluZGV4IC0gMSkgPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgICBpZiAoc2l6ZUluZGV4ID49IHRoaXMuYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3Q2hpbGQ7XG4gICAgICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgICAgIHZhciBvbGRDaGlsZCA9IHRoaXMuYXJyYXlbc2l6ZUluZGV4XTtcbiAgICAgICAgbmV3Q2hpbGQgPSBvbGRDaGlsZCAmJiBvbGRDaGlsZC5yZW1vdmVBZnRlcihvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCk7XG4gICAgICAgIGlmIChuZXdDaGlsZCA9PT0gb2xkQ2hpbGQgJiYgc2l6ZUluZGV4ID09PSB0aGlzLmFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZWRpdGFibGUgPSBlZGl0YWJsZVZOb2RlKHRoaXMsIG93bmVySUQpO1xuICAgICAgZWRpdGFibGUuYXJyYXkuc3BsaWNlKHNpemVJbmRleCArIDEpO1xuICAgICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICAgIGVkaXRhYmxlLmFycmF5W3NpemVJbmRleF0gPSBuZXdDaGlsZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlZGl0YWJsZTtcbiAgICB9O1xuXG5cblxuICB2YXIgRE9ORSA9IHt9O1xuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVMaXN0KGxpc3QsIHJldmVyc2UpIHtcbiAgICB2YXIgbGVmdCA9IGxpc3QuX29yaWdpbjtcbiAgICB2YXIgcmlnaHQgPSBsaXN0Ll9jYXBhY2l0eTtcbiAgICB2YXIgdGFpbFBvcyA9IGdldFRhaWxPZmZzZXQocmlnaHQpO1xuICAgIHZhciB0YWlsID0gbGlzdC5fdGFpbDtcblxuICAgIHJldHVybiBpdGVyYXRlTm9kZU9yTGVhZihsaXN0Ll9yb290LCBsaXN0Ll9sZXZlbCwgMCk7XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRlTm9kZU9yTGVhZihub2RlLCBsZXZlbCwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbGV2ZWwgPT09IDAgP1xuICAgICAgICBpdGVyYXRlTGVhZihub2RlLCBvZmZzZXQpIDpcbiAgICAgICAgaXRlcmF0ZU5vZGUobm9kZSwgbGV2ZWwsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZUxlYWYobm9kZSwgb2Zmc2V0KSB7XG4gICAgICB2YXIgYXJyYXkgPSBvZmZzZXQgPT09IHRhaWxQb3MgPyB0YWlsICYmIHRhaWwuYXJyYXkgOiBub2RlICYmIG5vZGUuYXJyYXk7XG4gICAgICB2YXIgZnJvbSA9IG9mZnNldCA+IGxlZnQgPyAwIDogbGVmdCAtIG9mZnNldDtcbiAgICAgIHZhciB0byA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgICAgaWYgKHRvID4gU0laRSkge1xuICAgICAgICB0byA9IFNJWkU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSAge1xuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICByZXR1cm4gRE9ORTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWR4ID0gcmV2ZXJzZSA/IC0tdG8gOiBmcm9tKys7XG4gICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheVtpZHhdO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRlTm9kZShub2RlLCBsZXZlbCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgdmFsdWVzO1xuICAgICAgdmFyIGFycmF5ID0gbm9kZSAmJiBub2RlLmFycmF5O1xuICAgICAgdmFyIGZyb20gPSBvZmZzZXQgPiBsZWZ0ID8gMCA6IChsZWZ0IC0gb2Zmc2V0KSA+PiBsZXZlbDtcbiAgICAgIHZhciB0byA9ICgocmlnaHQgLSBvZmZzZXQpID4+IGxldmVsKSArIDE7XG4gICAgICBpZiAodG8gPiBTSVpFKSB7XG4gICAgICAgIHRvID0gU0laRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpICB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gRE9ORSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgIHJldHVybiBET05FO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaWR4ID0gcmV2ZXJzZSA/IC0tdG8gOiBmcm9tKys7XG4gICAgICAgICAgdmFsdWVzID0gaXRlcmF0ZU5vZGVPckxlYWYoXG4gICAgICAgICAgICBhcnJheSAmJiBhcnJheVtpZHhdLCBsZXZlbCAtIFNISUZULCBvZmZzZXQgKyAoaWR4IDw8IGxldmVsKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlTGlzdChvcmlnaW4sIGNhcGFjaXR5LCBsZXZlbCwgcm9vdCwgdGFpbCwgb3duZXJJRCwgaGFzaCkge1xuICAgIHZhciBsaXN0ID0gT2JqZWN0LmNyZWF0ZShMaXN0UHJvdG90eXBlKTtcbiAgICBsaXN0LnNpemUgPSBjYXBhY2l0eSAtIG9yaWdpbjtcbiAgICBsaXN0Ll9vcmlnaW4gPSBvcmlnaW47XG4gICAgbGlzdC5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICBsaXN0Ll9sZXZlbCA9IGxldmVsO1xuICAgIGxpc3QuX3Jvb3QgPSByb290O1xuICAgIGxpc3QuX3RhaWwgPSB0YWlsO1xuICAgIGxpc3QuX19vd25lcklEID0gb3duZXJJRDtcbiAgICBsaXN0Ll9faGFzaCA9IGhhc2g7XG4gICAgbGlzdC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIHZhciBFTVBUWV9MSVNUO1xuICBmdW5jdGlvbiBlbXB0eUxpc3QoKSB7XG4gICAgcmV0dXJuIEVNUFRZX0xJU1QgfHwgKEVNUFRZX0xJU1QgPSBtYWtlTGlzdCgwLCAwLCBTSElGVCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGlzdChsaXN0LCBpbmRleCwgdmFsdWUpIHtcbiAgICBpbmRleCA9IHdyYXBJbmRleChsaXN0LCBpbmRleCk7XG5cbiAgICBpZiAoaW5kZXggIT09IGluZGV4KSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPj0gbGlzdC5zaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGxpc3Qud2l0aE11dGF0aW9ucyhmdW5jdGlvbihsaXN0ICkge1xuICAgICAgICBpbmRleCA8IDAgP1xuICAgICAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgaW5kZXgpLnNldCgwLCB2YWx1ZSkgOlxuICAgICAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgMCwgaW5kZXggKyAxKS5zZXQoaW5kZXgsIHZhbHVlKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW5kZXggKz0gbGlzdC5fb3JpZ2luO1xuXG4gICAgdmFyIG5ld1RhaWwgPSBsaXN0Ll90YWlsO1xuICAgIHZhciBuZXdSb290ID0gbGlzdC5fcm9vdDtcbiAgICB2YXIgZGlkQWx0ZXIgPSBNYWtlUmVmKERJRF9BTFRFUik7XG4gICAgaWYgKGluZGV4ID49IGdldFRhaWxPZmZzZXQobGlzdC5fY2FwYWNpdHkpKSB7XG4gICAgICBuZXdUYWlsID0gdXBkYXRlVk5vZGUobmV3VGFpbCwgbGlzdC5fX293bmVySUQsIDAsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdSb290ID0gdXBkYXRlVk5vZGUobmV3Um9vdCwgbGlzdC5fX293bmVySUQsIGxpc3QuX2xldmVsLCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKTtcbiAgICB9XG5cbiAgICBpZiAoIWRpZEFsdGVyLnZhbHVlKSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBpZiAobGlzdC5fX293bmVySUQpIHtcbiAgICAgIGxpc3QuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgbGlzdC5fdGFpbCA9IG5ld1RhaWw7XG4gICAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIGxpc3QuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICByZXR1cm4gbWFrZUxpc3QobGlzdC5fb3JpZ2luLCBsaXN0Ll9jYXBhY2l0eSwgbGlzdC5fbGV2ZWwsIG5ld1Jvb3QsIG5ld1RhaWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVk5vZGUobm9kZSwgb3duZXJJRCwgbGV2ZWwsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpIHtcbiAgICB2YXIgaWR4ID0gKGluZGV4ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgIHZhciBub2RlSGFzID0gbm9kZSAmJiBpZHggPCBub2RlLmFycmF5Lmxlbmd0aDtcbiAgICBpZiAoIW5vZGVIYXMgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgdmFyIG5ld05vZGU7XG5cbiAgICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgICB2YXIgbG93ZXJOb2RlID0gbm9kZSAmJiBub2RlLmFycmF5W2lkeF07XG4gICAgICB2YXIgbmV3TG93ZXJOb2RlID0gdXBkYXRlVk5vZGUobG93ZXJOb2RlLCBvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKTtcbiAgICAgIGlmIChuZXdMb3dlck5vZGUgPT09IGxvd2VyTm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5ld05vZGUgPSBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpO1xuICAgICAgbmV3Tm9kZS5hcnJheVtpZHhdID0gbmV3TG93ZXJOb2RlO1xuICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGVIYXMgJiYgbm9kZS5hcnJheVtpZHhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgU2V0UmVmKGRpZEFsdGVyKTtcblxuICAgIG5ld05vZGUgPSBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGlkeCA9PT0gbmV3Tm9kZS5hcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICBuZXdOb2RlLmFycmF5LnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOb2RlLmFycmF5W2lkeF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCAmJiBub2RlICYmIG93bmVySUQgPT09IG5vZGUub3duZXJJRCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZSA/IG5vZGUuYXJyYXkuc2xpY2UoKSA6IFtdLCBvd25lcklEKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3ROb2RlRm9yKGxpc3QsIHJhd0luZGV4KSB7XG4gICAgaWYgKHJhd0luZGV4ID49IGdldFRhaWxPZmZzZXQobGlzdC5fY2FwYWNpdHkpKSB7XG4gICAgICByZXR1cm4gbGlzdC5fdGFpbDtcbiAgICB9XG4gICAgaWYgKHJhd0luZGV4IDwgMSA8PCAobGlzdC5fbGV2ZWwgKyBTSElGVCkpIHtcbiAgICAgIHZhciBub2RlID0gbGlzdC5fcm9vdDtcbiAgICAgIHZhciBsZXZlbCA9IGxpc3QuX2xldmVsO1xuICAgICAgd2hpbGUgKG5vZGUgJiYgbGV2ZWwgPiAwKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmFycmF5WyhyYXdJbmRleCA+Pj4gbGV2ZWwpICYgTUFTS107XG4gICAgICAgIGxldmVsIC09IFNISUZUO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGlzdEJvdW5kcyhsaXN0LCBiZWdpbiwgZW5kKSB7XG4gICAgLy8gU2FuaXRpemUgYmVnaW4gJiBlbmQgdXNpbmcgdGhpcyBzaG9ydGhhbmQgZm9yIFRvSW50MzIoYXJndW1lbnQpXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50MzJcbiAgICBpZiAoYmVnaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmVnaW4gPSBiZWdpbiB8IDA7XG4gICAgfVxuICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kID0gZW5kIHwgMDtcbiAgICB9XG4gICAgdmFyIG93bmVyID0gbGlzdC5fX293bmVySUQgfHwgbmV3IE93bmVySUQoKTtcbiAgICB2YXIgb2xkT3JpZ2luID0gbGlzdC5fb3JpZ2luO1xuICAgIHZhciBvbGRDYXBhY2l0eSA9IGxpc3QuX2NhcGFjaXR5O1xuICAgIHZhciBuZXdPcmlnaW4gPSBvbGRPcmlnaW4gKyBiZWdpbjtcbiAgICB2YXIgbmV3Q2FwYWNpdHkgPSBlbmQgPT09IHVuZGVmaW5lZCA/IG9sZENhcGFjaXR5IDogZW5kIDwgMCA/IG9sZENhcGFjaXR5ICsgZW5kIDogb2xkT3JpZ2luICsgZW5kO1xuICAgIGlmIChuZXdPcmlnaW4gPT09IG9sZE9yaWdpbiAmJiBuZXdDYXBhY2l0eSA9PT0gb2xkQ2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIC8vIElmIGl0J3MgZ29pbmcgdG8gZW5kIGFmdGVyIGl0IHN0YXJ0cywgaXQncyBlbXB0eS5cbiAgICBpZiAobmV3T3JpZ2luID49IG5ld0NhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gbGlzdC5jbGVhcigpO1xuICAgIH1cblxuICAgIHZhciBuZXdMZXZlbCA9IGxpc3QuX2xldmVsO1xuICAgIHZhciBuZXdSb290ID0gbGlzdC5fcm9vdDtcblxuICAgIC8vIE5ldyBvcmlnaW4gbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICAgIHZhciBvZmZzZXRTaGlmdCA9IDA7XG4gICAgd2hpbGUgKG5ld09yaWdpbiArIG9mZnNldFNoaWZ0IDwgMCkge1xuICAgICAgbmV3Um9vdCA9IG5ldyBWTm9kZShuZXdSb290ICYmIG5ld1Jvb3QuYXJyYXkubGVuZ3RoID8gW3VuZGVmaW5lZCwgbmV3Um9vdF0gOiBbXSwgb3duZXIpO1xuICAgICAgbmV3TGV2ZWwgKz0gU0hJRlQ7XG4gICAgICBvZmZzZXRTaGlmdCArPSAxIDw8IG5ld0xldmVsO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0U2hpZnQpIHtcbiAgICAgIG5ld09yaWdpbiArPSBvZmZzZXRTaGlmdDtcbiAgICAgIG9sZE9yaWdpbiArPSBvZmZzZXRTaGlmdDtcbiAgICAgIG5ld0NhcGFjaXR5ICs9IG9mZnNldFNoaWZ0O1xuICAgICAgb2xkQ2FwYWNpdHkgKz0gb2Zmc2V0U2hpZnQ7XG4gICAgfVxuXG4gICAgdmFyIG9sZFRhaWxPZmZzZXQgPSBnZXRUYWlsT2Zmc2V0KG9sZENhcGFjaXR5KTtcbiAgICB2YXIgbmV3VGFpbE9mZnNldCA9IGdldFRhaWxPZmZzZXQobmV3Q2FwYWNpdHkpO1xuXG4gICAgLy8gTmV3IHNpemUgbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICAgIHdoaWxlIChuZXdUYWlsT2Zmc2V0ID49IDEgPDwgKG5ld0xldmVsICsgU0hJRlQpKSB7XG4gICAgICBuZXdSb290ID0gbmV3IFZOb2RlKG5ld1Jvb3QgJiYgbmV3Um9vdC5hcnJheS5sZW5ndGggPyBbbmV3Um9vdF0gOiBbXSwgb3duZXIpO1xuICAgICAgbmV3TGV2ZWwgKz0gU0hJRlQ7XG4gICAgfVxuXG4gICAgLy8gTG9jYXRlIG9yIGNyZWF0ZSB0aGUgbmV3IHRhaWwuXG4gICAgdmFyIG9sZFRhaWwgPSBsaXN0Ll90YWlsO1xuICAgIHZhciBuZXdUYWlsID0gbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXQgP1xuICAgICAgbGlzdE5vZGVGb3IobGlzdCwgbmV3Q2FwYWNpdHkgLSAxKSA6XG4gICAgICBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldCA/IG5ldyBWTm9kZShbXSwgb3duZXIpIDogb2xkVGFpbDtcblxuICAgIC8vIE1lcmdlIFRhaWwgaW50byB0cmVlLlxuICAgIGlmIChvbGRUYWlsICYmIG5ld1RhaWxPZmZzZXQgPiBvbGRUYWlsT2Zmc2V0ICYmIG5ld09yaWdpbiA8IG9sZENhcGFjaXR5ICYmIG9sZFRhaWwuYXJyYXkubGVuZ3RoKSB7XG4gICAgICBuZXdSb290ID0gZWRpdGFibGVWTm9kZShuZXdSb290LCBvd25lcik7XG4gICAgICB2YXIgbm9kZSA9IG5ld1Jvb3Q7XG4gICAgICBmb3IgKHZhciBsZXZlbCA9IG5ld0xldmVsOyBsZXZlbCA+IFNISUZUOyBsZXZlbCAtPSBTSElGVCkge1xuICAgICAgICB2YXIgaWR4ID0gKG9sZFRhaWxPZmZzZXQgPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgICAgIG5vZGUgPSBub2RlLmFycmF5W2lkeF0gPSBlZGl0YWJsZVZOb2RlKG5vZGUuYXJyYXlbaWR4XSwgb3duZXIpO1xuICAgICAgfVxuICAgICAgbm9kZS5hcnJheVsob2xkVGFpbE9mZnNldCA+Pj4gU0hJRlQpICYgTUFTS10gPSBvbGRUYWlsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzaXplIGhhcyBiZWVuIHJlZHVjZWQsIHRoZXJlJ3MgYSBjaGFuY2UgdGhlIHRhaWwgbmVlZHMgdG8gYmUgdHJpbW1lZC5cbiAgICBpZiAobmV3Q2FwYWNpdHkgPCBvbGRDYXBhY2l0eSkge1xuICAgICAgbmV3VGFpbCA9IG5ld1RhaWwgJiYgbmV3VGFpbC5yZW1vdmVBZnRlcihvd25lciwgMCwgbmV3Q2FwYWNpdHkpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBuZXcgb3JpZ2luIGlzIHdpdGhpbiB0aGUgdGFpbCwgdGhlbiB3ZSBkbyBub3QgbmVlZCBhIHJvb3QuXG4gICAgaWYgKG5ld09yaWdpbiA+PSBuZXdUYWlsT2Zmc2V0KSB7XG4gICAgICBuZXdPcmlnaW4gLT0gbmV3VGFpbE9mZnNldDtcbiAgICAgIG5ld0NhcGFjaXR5IC09IG5ld1RhaWxPZmZzZXQ7XG4gICAgICBuZXdMZXZlbCA9IFNISUZUO1xuICAgICAgbmV3Um9vdCA9IG51bGw7XG4gICAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUJlZm9yZShvd25lciwgMCwgbmV3T3JpZ2luKTtcblxuICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIHJvb3QgaGFzIGJlZW4gdHJpbW1lZCwgZ2FyYmFnZSBjb2xsZWN0LlxuICAgIH0gZWxzZSBpZiAobmV3T3JpZ2luID4gb2xkT3JpZ2luIHx8IG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0KSB7XG4gICAgICBvZmZzZXRTaGlmdCA9IDA7XG5cbiAgICAgIC8vIElkZW50aWZ5IHRoZSBuZXcgdG9wIHJvb3Qgbm9kZSBvZiB0aGUgc3VidHJlZSBvZiB0aGUgb2xkIHJvb3QuXG4gICAgICB3aGlsZSAobmV3Um9vdCkge1xuICAgICAgICB2YXIgYmVnaW5JbmRleCA9IChuZXdPcmlnaW4gPj4+IG5ld0xldmVsKSAmIE1BU0s7XG4gICAgICAgIGlmIChiZWdpbkluZGV4ICE9PSAobmV3VGFpbE9mZnNldCA+Pj4gbmV3TGV2ZWwpICYgTUFTSykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWdpbkluZGV4KSB7XG4gICAgICAgICAgb2Zmc2V0U2hpZnQgKz0gKDEgPDwgbmV3TGV2ZWwpICogYmVnaW5JbmRleDtcbiAgICAgICAgfVxuICAgICAgICBuZXdMZXZlbCAtPSBTSElGVDtcbiAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QuYXJyYXlbYmVnaW5JbmRleF07XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaW0gdGhlIG5ldyBzaWRlcyBvZiB0aGUgbmV3IHJvb3QuXG4gICAgICBpZiAobmV3Um9vdCAmJiBuZXdPcmlnaW4gPiBvbGRPcmlnaW4pIHtcbiAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQmVmb3JlKG93bmVyLCBuZXdMZXZlbCwgbmV3T3JpZ2luIC0gb2Zmc2V0U2hpZnQpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1Jvb3QgJiYgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXQpIHtcbiAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQWZ0ZXIob3duZXIsIG5ld0xldmVsLCBuZXdUYWlsT2Zmc2V0IC0gb2Zmc2V0U2hpZnQpO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldFNoaWZ0KSB7XG4gICAgICAgIG5ld09yaWdpbiAtPSBvZmZzZXRTaGlmdDtcbiAgICAgICAgbmV3Q2FwYWNpdHkgLT0gb2Zmc2V0U2hpZnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxpc3QuX19vd25lcklEKSB7XG4gICAgICBsaXN0LnNpemUgPSBuZXdDYXBhY2l0eSAtIG5ld09yaWdpbjtcbiAgICAgIGxpc3QuX29yaWdpbiA9IG5ld09yaWdpbjtcbiAgICAgIGxpc3QuX2NhcGFjaXR5ID0gbmV3Q2FwYWNpdHk7XG4gICAgICBsaXN0Ll9sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgbGlzdC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgICBsaXN0Ll90YWlsID0gbmV3VGFpbDtcbiAgICAgIGxpc3QuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgbGlzdC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIHJldHVybiBtYWtlTGlzdChuZXdPcmlnaW4sIG5ld0NhcGFjaXR5LCBuZXdMZXZlbCwgbmV3Um9vdCwgbmV3VGFpbCk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUludG9MaXN0V2l0aChsaXN0LCBtZXJnZXIsIGl0ZXJhYmxlcykge1xuICAgIHZhciBpdGVycyA9IFtdO1xuICAgIHZhciBtYXhTaXplID0gMDtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaXRlcmFibGVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgdmFyIHZhbHVlID0gaXRlcmFibGVzW2lpXTtcbiAgICAgIHZhciBpdGVyID0gSW5kZXhlZEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgIGlmIChpdGVyLnNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgIG1heFNpemUgPSBpdGVyLnNpemU7XG4gICAgICB9XG4gICAgICBpZiAoIWlzSXRlcmFibGUodmFsdWUpKSB7XG4gICAgICAgIGl0ZXIgPSBpdGVyLm1hcChmdW5jdGlvbih2ICkge3JldHVybiBmcm9tSlModil9KTtcbiAgICAgIH1cbiAgICAgIGl0ZXJzLnB1c2goaXRlcik7XG4gICAgfVxuICAgIGlmIChtYXhTaXplID4gbGlzdC5zaXplKSB7XG4gICAgICBsaXN0ID0gbGlzdC5zZXRTaXplKG1heFNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VJbnRvQ29sbGVjdGlvbldpdGgobGlzdCwgbWVyZ2VyLCBpdGVycyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUYWlsT2Zmc2V0KHNpemUpIHtcbiAgICByZXR1cm4gc2l6ZSA8IFNJWkUgPyAwIDogKCgoc2l6ZSAtIDEpID4+PiBTSElGVCkgPDwgU0hJRlQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoT3JkZXJlZE1hcCwgTWFwKTtcblxuICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cbiAgICBmdW5jdGlvbiBPcmRlcmVkTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5T3JkZXJlZE1hcCgpIDpcbiAgICAgICAgaXNPcmRlcmVkTWFwKHZhbHVlKSA/IHZhbHVlIDpcbiAgICAgICAgZW1wdHlPcmRlcmVkTWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbihtYXAgKSB7XG4gICAgICAgICAgdmFyIGl0ZXIgPSBLZXllZEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbih2LCBrKSAge3JldHVybiBtYXAuc2V0KGssIHYpfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIE9yZGVyZWRNYXAub2YgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnT3JkZXJlZE1hcCB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGssIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9tYXAuZ2V0KGspO1xuICAgICAgcmV0dXJuIGluZGV4ICE9PSB1bmRlZmluZWQgPyB0aGlzLl9saXN0LmdldChpbmRleClbMV0gOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9saXN0LmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5T3JkZXJlZE1hcCgpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrLCB2KSB7XG4gICAgICByZXR1cm4gdXBkYXRlT3JkZXJlZE1hcCh0aGlzLCBrLCB2KTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaykge1xuICAgICAgcmV0dXJuIHVwZGF0ZU9yZGVyZWRNYXAodGhpcywgaywgTk9UX1NFVCk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpIHx8IHRoaXMuX2xpc3Qud2FzQWx0ZXJlZCgpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX2xpc3QuX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbihlbnRyeSApIHtyZXR1cm4gZW50cnkgJiYgZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzJDApfSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9saXN0LmZyb21FbnRyeVNlcSgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbihvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgICB2YXIgbmV3TGlzdCA9IHRoaXMuX2xpc3QuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgICAgdGhpcy5fbGlzdCA9IG5ld0xpc3Q7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VPcmRlcmVkTWFwKG5ld01hcCwgbmV3TGlzdCwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuICAgIH07XG5cblxuICBmdW5jdGlvbiBpc09yZGVyZWRNYXAobWF5YmVPcmRlcmVkTWFwKSB7XG4gICAgcmV0dXJuIGlzTWFwKG1heWJlT3JkZXJlZE1hcCkgJiYgaXNPcmRlcmVkKG1heWJlT3JkZXJlZE1hcCk7XG4gIH1cblxuICBPcmRlcmVkTWFwLmlzT3JkZXJlZE1hcCA9IGlzT3JkZXJlZE1hcDtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZVtJU19PUkRFUkVEX1NFTlRJTkVMXSA9IHRydWU7XG4gIE9yZGVyZWRNYXAucHJvdG90eXBlW0RFTEVURV0gPSBPcmRlcmVkTWFwLnByb3RvdHlwZS5yZW1vdmU7XG5cblxuXG4gIGZ1bmN0aW9uIG1ha2VPcmRlcmVkTWFwKG1hcCwgbGlzdCwgb3duZXJJRCwgaGFzaCkge1xuICAgIHZhciBvbWFwID0gT2JqZWN0LmNyZWF0ZShPcmRlcmVkTWFwLnByb3RvdHlwZSk7XG4gICAgb21hcC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICAgIG9tYXAuX21hcCA9IG1hcDtcbiAgICBvbWFwLl9saXN0ID0gbGlzdDtcbiAgICBvbWFwLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgb21hcC5fX2hhc2ggPSBoYXNoO1xuICAgIHJldHVybiBvbWFwO1xuICB9XG5cbiAgdmFyIEVNUFRZX09SREVSRURfTUFQO1xuICBmdW5jdGlvbiBlbXB0eU9yZGVyZWRNYXAoKSB7XG4gICAgcmV0dXJuIEVNUFRZX09SREVSRURfTUFQIHx8IChFTVBUWV9PUkRFUkVEX01BUCA9IG1ha2VPcmRlcmVkTWFwKGVtcHR5TWFwKCksIGVtcHR5TGlzdCgpKSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVPcmRlcmVkTWFwKG9tYXAsIGssIHYpIHtcbiAgICB2YXIgbWFwID0gb21hcC5fbWFwO1xuICAgIHZhciBsaXN0ID0gb21hcC5fbGlzdDtcbiAgICB2YXIgaSA9IG1hcC5nZXQoayk7XG4gICAgdmFyIGhhcyA9IGkgIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgbmV3TWFwO1xuICAgIHZhciBuZXdMaXN0O1xuICAgIGlmICh2ID09PSBOT1RfU0VUKSB7IC8vIHJlbW92ZWRcbiAgICAgIGlmICghaGFzKSB7XG4gICAgICAgIHJldHVybiBvbWFwO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3Quc2l6ZSA+PSBTSVpFICYmIGxpc3Quc2l6ZSA+PSBtYXAuc2l6ZSAqIDIpIHtcbiAgICAgICAgbmV3TGlzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uKGVudHJ5LCBpZHgpICB7cmV0dXJuIGVudHJ5ICE9PSB1bmRlZmluZWQgJiYgaSAhPT0gaWR4fSk7XG4gICAgICAgIG5ld01hcCA9IG5ld0xpc3QudG9LZXllZFNlcSgpLm1hcChmdW5jdGlvbihlbnRyeSApIHtyZXR1cm4gZW50cnlbMF19KS5mbGlwKCkudG9NYXAoKTtcbiAgICAgICAgaWYgKG9tYXAuX19vd25lcklEKSB7XG4gICAgICAgICAgbmV3TWFwLl9fb3duZXJJRCA9IG5ld0xpc3QuX19vd25lcklEID0gb21hcC5fX293bmVySUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld01hcCA9IG1hcC5yZW1vdmUoayk7XG4gICAgICAgIG5ld0xpc3QgPSBpID09PSBsaXN0LnNpemUgLSAxID8gbGlzdC5wb3AoKSA6IGxpc3Quc2V0KGksIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMpIHtcbiAgICAgICAgaWYgKHYgPT09IGxpc3QuZ2V0KGkpWzFdKSB7XG4gICAgICAgICAgcmV0dXJuIG9tYXA7XG4gICAgICAgIH1cbiAgICAgICAgbmV3TWFwID0gbWFwO1xuICAgICAgICBuZXdMaXN0ID0gbGlzdC5zZXQoaSwgW2ssIHZdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld01hcCA9IG1hcC5zZXQoaywgbGlzdC5zaXplKTtcbiAgICAgICAgbmV3TGlzdCA9IGxpc3Quc2V0KGxpc3Quc2l6ZSwgW2ssIHZdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9tYXAuX19vd25lcklEKSB7XG4gICAgICBvbWFwLnNpemUgPSBuZXdNYXAuc2l6ZTtcbiAgICAgIG9tYXAuX21hcCA9IG5ld01hcDtcbiAgICAgIG9tYXAuX2xpc3QgPSBuZXdMaXN0O1xuICAgICAgb21hcC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb21hcDtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VPcmRlcmVkTWFwKG5ld01hcCwgbmV3TGlzdCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUb0tleWVkU2VxdWVuY2UsIEtleWVkU2VxKTtcbiAgICBmdW5jdGlvbiBUb0tleWVkU2VxdWVuY2UoaW5kZXhlZCwgdXNlS2V5cykge1xuICAgICAgdGhpcy5faXRlciA9IGluZGV4ZWQ7XG4gICAgICB0aGlzLl91c2VLZXlzID0gdXNlS2V5cztcbiAgICAgIHRoaXMuc2l6ZSA9IGluZGV4ZWQuc2l6ZTtcbiAgICB9XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLmdldChrZXksIG5vdFNldFZhbHVlKTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLmhhcyhrZXkpO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLnZhbHVlU2VxID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci52YWx1ZVNlcSgpO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciByZXZlcnNlZFNlcXVlbmNlID0gcmV2ZXJzZUZhY3RvcnkodGhpcywgdHJ1ZSk7XG4gICAgICBpZiAoIXRoaXMuX3VzZUtleXMpIHtcbiAgICAgICAgcmV2ZXJzZWRTZXF1ZW5jZS52YWx1ZVNlcSA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gdGhpcyQwLl9pdGVyLnRvU2VxKCkucmV2ZXJzZSgpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKG1hcHBlciwgY29udGV4dCkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIG1hcHBlZFNlcXVlbmNlID0gbWFwRmFjdG9yeSh0aGlzLCBtYXBwZXIsIGNvbnRleHQpO1xuICAgICAgaWYgKCF0aGlzLl91c2VLZXlzKSB7XG4gICAgICAgIG1hcHBlZFNlcXVlbmNlLnZhbHVlU2VxID0gZnVuY3Rpb24oKSAge3JldHVybiB0aGlzJDAuX2l0ZXIudG9TZXEoKS5tYXAobWFwcGVyLCBjb250ZXh0KX07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwcGVkU2VxdWVuY2U7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciBpaTtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShcbiAgICAgICAgdGhpcy5fdXNlS2V5cyA/XG4gICAgICAgICAgZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gZm4odiwgaywgdGhpcyQwKX0gOlxuICAgICAgICAgICgoaWkgPSByZXZlcnNlID8gcmVzb2x2ZVNpemUodGhpcykgOiAwKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHYgKSB7cmV0dXJuIGZuKHYsIHJldmVyc2UgPyAtLWlpIDogaWkrKywgdGhpcyQwKX0pLFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAodGhpcy5fdXNlS2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpaSA9IHJldmVyc2UgPyByZXNvbHZlU2l6ZSh0aGlzKSA6IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmUgPyBzdGVwIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIHJldmVyc2UgPyAtLWlpIDogaWkrKywgc3RlcC52YWx1ZSwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGVbSVNfT1JERVJFRF9TRU5USU5FTF0gPSB0cnVlO1xuXG5cbiAgY3JlYXRlQ2xhc3MoVG9JbmRleGVkU2VxdWVuY2UsIEluZGV4ZWRTZXEpO1xuICAgIGZ1bmN0aW9uIFRvSW5kZXhlZFNlcXVlbmNlKGl0ZXIpIHtcbiAgICAgIHRoaXMuX2l0ZXIgPSBpdGVyO1xuICAgICAgdGhpcy5zaXplID0gaXRlci5zaXplO1xuICAgIH1cblxuICAgIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5pbmNsdWRlcyh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIGZuKHYsIGl0ZXJhdGlvbnMrKywgdGhpcyQwKX0sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmUgPyBzdGVwIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZSwgc3RlcClcbiAgICAgIH0pO1xuICAgIH07XG5cblxuXG4gIGNyZWF0ZUNsYXNzKFRvU2V0U2VxdWVuY2UsIFNldFNlcSk7XG4gICAgZnVuY3Rpb24gVG9TZXRTZXF1ZW5jZShpdGVyKSB7XG4gICAgICB0aGlzLl9pdGVyID0gaXRlcjtcbiAgICAgIHRoaXMuc2l6ZSA9IGl0ZXIuc2l6ZTtcbiAgICB9XG5cbiAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLmluY2x1ZGVzKGtleSk7XG4gICAgfTtcblxuICAgIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24odiApIHtyZXR1cm4gZm4odiwgdiwgdGhpcyQwKX0sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHN0ZXAuZG9uZSA/IHN0ZXAgOlxuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwgc3RlcC52YWx1ZSwgc3RlcC52YWx1ZSwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhGcm9tRW50cmllc1NlcXVlbmNlLCBLZXllZFNlcSk7XG4gICAgZnVuY3Rpb24gRnJvbUVudHJpZXNTZXF1ZW5jZShlbnRyaWVzKSB7XG4gICAgICB0aGlzLl9pdGVyID0gZW50cmllcztcbiAgICAgIHRoaXMuc2l6ZSA9IGVudHJpZXMuc2l6ZTtcbiAgICB9XG5cbiAgICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5lbnRyeVNlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIudG9TZXEoKTtcbiAgICB9O1xuXG4gICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbihlbnRyeSApIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgZXhpc3RzIGZpcnN0IHNvIGFycmF5IGFjY2VzcyBkb2Vzbid0IHRocm93IGZvciBob2xlc1xuICAgICAgICAvLyBpbiB0aGUgcGFyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFsaWRhdGVFbnRyeShlbnRyeSk7XG4gICAgICAgICAgdmFyIGluZGV4ZWRJdGVyYWJsZSA9IGlzSXRlcmFibGUoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBmbihcbiAgICAgICAgICAgIGluZGV4ZWRJdGVyYWJsZSA/IGVudHJ5LmdldCgxKSA6IGVudHJ5WzFdLFxuICAgICAgICAgICAgaW5kZXhlZEl0ZXJhYmxlID8gZW50cnkuZ2V0KDApIDogZW50cnlbMF0sXG4gICAgICAgICAgICB0aGlzJDBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAvLyBDaGVjayBpZiBlbnRyeSBleGlzdHMgZmlyc3Qgc28gYXJyYXkgYWNjZXNzIGRvZXNuJ3QgdGhyb3cgZm9yIGhvbGVzXG4gICAgICAgICAgLy8gaW4gdGhlIHBhcmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIHZhciBpbmRleGVkSXRlcmFibGUgPSBpc0l0ZXJhYmxlKGVudHJ5KTtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBpbmRleGVkSXRlcmFibGUgPyBlbnRyeS5nZXQoMCkgOiBlbnRyeVswXSxcbiAgICAgICAgICAgICAgaW5kZXhlZEl0ZXJhYmxlID8gZW50cnkuZ2V0KDEpIDogZW50cnlbMV0sXG4gICAgICAgICAgICAgIHN0ZXBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG5cbiAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPVxuICAgIGNhY2hlUmVzdWx0VGhyb3VnaDtcblxuXG4gIGZ1bmN0aW9uIGZsaXBGYWN0b3J5KGl0ZXJhYmxlKSB7XG4gICAgdmFyIGZsaXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgZmxpcFNlcXVlbmNlLl9pdGVyID0gaXRlcmFibGU7XG4gICAgZmxpcFNlcXVlbmNlLnNpemUgPSBpdGVyYWJsZS5zaXplO1xuICAgIGZsaXBTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24oKSAge3JldHVybiBpdGVyYWJsZX07XG4gICAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IGl0ZXJhYmxlLnJldmVyc2UuYXBwbHkodGhpcyk7IC8vIHN1cGVyLnJldmVyc2UoKVxuICAgICAgcmV2ZXJzZWRTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24oKSAge3JldHVybiBpdGVyYWJsZS5yZXZlcnNlKCl9O1xuICAgICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG4gICAgfTtcbiAgICBmbGlwU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24oa2V5ICkge3JldHVybiBpdGVyYWJsZS5pbmNsdWRlcyhrZXkpfTtcbiAgICBmbGlwU2VxdWVuY2UuaW5jbHVkZXMgPSBmdW5jdGlvbihrZXkgKSB7cmV0dXJuIGl0ZXJhYmxlLmhhcyhrZXkpfTtcbiAgICBmbGlwU2VxdWVuY2UuY2FjaGVSZXN1bHQgPSBjYWNoZVJlc3VsdFRocm91Z2g7XG4gICAgZmxpcFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIGZuKGssIHYsIHRoaXMkMCkgIT09IGZhbHNlfSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIGZsaXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhYmxlLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmICghc3RlcC5kb25lKSB7XG4gICAgICAgICAgICB2YXIgayA9IHN0ZXAudmFsdWVbMF07XG4gICAgICAgICAgICBzdGVwLnZhbHVlWzBdID0gc3RlcC52YWx1ZVsxXTtcbiAgICAgICAgICAgIHN0ZXAudmFsdWVbMV0gPSBrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmFibGUuX19pdGVyYXRvcihcbiAgICAgICAgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMgPyBJVEVSQVRFX0tFWVMgOiBJVEVSQVRFX1ZBTFVFUyxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsaXBTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gbWFwRmFjdG9yeShpdGVyYWJsZSwgbWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIG1hcHBlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5zaXplID0gaXRlcmFibGUuc2l6ZTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbihrZXkgKSB7cmV0dXJuIGl0ZXJhYmxlLmhhcyhrZXkpfTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbihrZXksIG5vdFNldFZhbHVlKSAge1xuICAgICAgdmFyIHYgPSBpdGVyYWJsZS5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgIHJldHVybiB2ID09PSBOT1RfU0VUID9cbiAgICAgICAgbm90U2V0VmFsdWUgOlxuICAgICAgICBtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrZXksIGl0ZXJhYmxlKTtcbiAgICB9O1xuICAgIG1hcHBlZFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gaXRlcmFibGUuX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbih2LCBrLCBjKSAge3JldHVybiBmbihtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBjKSwgaywgdGhpcyQwKSAhPT0gZmFsc2V9LFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgIH1cbiAgICBtYXBwZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGUuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgdmFyIGtleSA9IGVudHJ5WzBdO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBtYXBwZXIuY2FsbChjb250ZXh0LCBlbnRyeVsxXSwga2V5LCBpdGVyYWJsZSksXG4gICAgICAgICAgc3RlcFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtYXBwZWRTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gcmV2ZXJzZUZhY3RvcnkoaXRlcmFibGUsIHVzZUtleXMpIHtcbiAgICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5faXRlciA9IGl0ZXJhYmxlO1xuICAgIHJldmVyc2VkU2VxdWVuY2Uuc2l6ZSA9IGl0ZXJhYmxlLnNpemU7XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5yZXZlcnNlID0gZnVuY3Rpb24oKSAge3JldHVybiBpdGVyYWJsZX07XG4gICAgaWYgKGl0ZXJhYmxlLmZsaXApIHtcbiAgICAgIHJldmVyc2VkU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZsaXBTZXF1ZW5jZSA9IGZsaXBGYWN0b3J5KGl0ZXJhYmxlKTtcbiAgICAgICAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbigpICB7cmV0dXJuIGl0ZXJhYmxlLmZsaXAoKX07XG4gICAgICAgIHJldHVybiBmbGlwU2VxdWVuY2U7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXZlcnNlZFNlcXVlbmNlLmdldCA9IGZ1bmN0aW9uKGtleSwgbm90U2V0VmFsdWUpIFxuICAgICAge3JldHVybiBpdGVyYWJsZS5nZXQodXNlS2V5cyA/IGtleSA6IC0xIC0ga2V5LCBub3RTZXRWYWx1ZSl9O1xuICAgIHJldmVyc2VkU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24oa2V5IClcbiAgICAgIHtyZXR1cm4gaXRlcmFibGUuaGFzKHVzZUtleXMgPyBrZXkgOiAtMSAtIGtleSl9O1xuICAgIHJldmVyc2VkU2VxdWVuY2UuaW5jbHVkZXMgPSBmdW5jdGlvbih2YWx1ZSApIHtyZXR1cm4gaXRlcmFibGUuaW5jbHVkZXModmFsdWUpfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuICAgIHJldmVyc2VkU2VxdWVuY2UuX19pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIGZuKHYsIGssIHRoaXMkMCl9LCAhcmV2ZXJzZSk7XG4gICAgfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLl9faXRlcmF0b3IgPVxuICAgICAgZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkgIHtyZXR1cm4gaXRlcmFibGUuX19pdGVyYXRvcih0eXBlLCAhcmV2ZXJzZSl9O1xuICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICB9XG5cblxuICBmdW5jdGlvbiBmaWx0ZXJGYWN0b3J5KGl0ZXJhYmxlLCBwcmVkaWNhdGUsIGNvbnRleHQsIHVzZUtleXMpIHtcbiAgICB2YXIgZmlsdGVyU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuICAgIGlmICh1c2VLZXlzKSB7XG4gICAgICBmaWx0ZXJTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbihrZXkgKSB7XG4gICAgICAgIHZhciB2ID0gaXRlcmFibGUuZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgICAgIHJldHVybiB2ICE9PSBOT1RfU0VUICYmICEhcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwga2V5LCBpdGVyYWJsZSk7XG4gICAgICB9O1xuICAgICAgZmlsdGVyU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24oa2V5LCBub3RTZXRWYWx1ZSkgIHtcbiAgICAgICAgdmFyIHYgPSBpdGVyYWJsZS5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgICAgcmV0dXJuIHYgIT09IE5PVF9TRVQgJiYgcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwga2V5LCBpdGVyYWJsZSkgP1xuICAgICAgICAgIHYgOiBub3RTZXRWYWx1ZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZpbHRlclNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaywgYykgIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDApO1xuICAgICAgICB9XG4gICAgICB9LCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgZmlsdGVyU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhYmxlLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBrZXkgPSBlbnRyeVswXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBlbnRyeVsxXTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGtleSwgaXRlcmFibGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCB1c2VLZXlzID8ga2V5IDogaXRlcmF0aW9ucysrLCB2YWx1ZSwgc3RlcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlclNlcXVlbmNlO1xuICB9XG5cblxuICBmdW5jdGlvbiBjb3VudEJ5RmFjdG9yeShpdGVyYWJsZSwgZ3JvdXBlciwgY29udGV4dCkge1xuICAgIHZhciBncm91cHMgPSBNYXAoKS5hc011dGFibGUoKTtcbiAgICBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHtcbiAgICAgIGdyb3Vwcy51cGRhdGUoXG4gICAgICAgIGdyb3VwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBpdGVyYWJsZSksXG4gICAgICAgIDAsXG4gICAgICAgIGZ1bmN0aW9uKGEgKSB7cmV0dXJuIGEgKyAxfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZ3JvdXBzLmFzSW1tdXRhYmxlKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGdyb3VwQnlGYWN0b3J5KGl0ZXJhYmxlLCBncm91cGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIGlzS2V5ZWRJdGVyID0gaXNLZXllZChpdGVyYWJsZSk7XG4gICAgdmFyIGdyb3VwcyA9IChpc09yZGVyZWQoaXRlcmFibGUpID8gT3JkZXJlZE1hcCgpIDogTWFwKCkpLmFzTXV0YWJsZSgpO1xuICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAge1xuICAgICAgZ3JvdXBzLnVwZGF0ZShcbiAgICAgICAgZ3JvdXBlci5jYWxsKGNvbnRleHQsIHYsIGssIGl0ZXJhYmxlKSxcbiAgICAgICAgZnVuY3Rpb24oYSApIHtyZXR1cm4gKGEgPSBhIHx8IFtdLCBhLnB1c2goaXNLZXllZEl0ZXIgPyBbaywgdl0gOiB2KSwgYSl9XG4gICAgICApO1xuICAgIH0pO1xuICAgIHZhciBjb2VyY2UgPSBpdGVyYWJsZUNsYXNzKGl0ZXJhYmxlKTtcbiAgICByZXR1cm4gZ3JvdXBzLm1hcChmdW5jdGlvbihhcnIgKSB7cmV0dXJuIHJlaWZ5KGl0ZXJhYmxlLCBjb2VyY2UoYXJyKSl9KTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gc2xpY2VGYWN0b3J5KGl0ZXJhYmxlLCBiZWdpbiwgZW5kLCB1c2VLZXlzKSB7XG4gICAgdmFyIG9yaWdpbmFsU2l6ZSA9IGl0ZXJhYmxlLnNpemU7XG5cbiAgICAvLyBTYW5pdGl6ZSBiZWdpbiAmIGVuZCB1c2luZyB0aGlzIHNob3J0aGFuZCBmb3IgVG9JbnQzMihhcmd1bWVudClcbiAgICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9pbnQzMlxuICAgIGlmIChiZWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiZWdpbiA9IGJlZ2luIHwgMDtcbiAgICB9XG4gICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBlbmQgfCAwO1xuICAgIH1cblxuICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIG9yaWdpbmFsU2l6ZSkpIHtcbiAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZWRCZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgb3JpZ2luYWxTaXplKTtcbiAgICB2YXIgcmVzb2x2ZWRFbmQgPSByZXNvbHZlRW5kKGVuZCwgb3JpZ2luYWxTaXplKTtcblxuICAgIC8vIGJlZ2luIG9yIGVuZCB3aWxsIGJlIE5hTiBpZiB0aGV5IHdlcmUgcHJvdmlkZWQgYXMgbmVnYXRpdmUgbnVtYmVycyBhbmRcbiAgICAvLyB0aGlzIGl0ZXJhYmxlJ3Mgc2l6ZSBpcyB1bmtub3duLiBJbiB0aGF0IGNhc2UsIGNhY2hlIGZpcnN0IHNvIHRoZXJlIGlzXG4gICAgLy8gYSBrbm93biBzaXplIGFuZCB0aGVzZSBkbyBub3QgcmVzb2x2ZSB0byBOYU4uXG4gICAgaWYgKHJlc29sdmVkQmVnaW4gIT09IHJlc29sdmVkQmVnaW4gfHwgcmVzb2x2ZWRFbmQgIT09IHJlc29sdmVkRW5kKSB7XG4gICAgICByZXR1cm4gc2xpY2VGYWN0b3J5KGl0ZXJhYmxlLnRvU2VxKCkuY2FjaGVSZXN1bHQoKSwgYmVnaW4sIGVuZCwgdXNlS2V5cyk7XG4gICAgfVxuXG4gICAgLy8gTm90ZTogcmVzb2x2ZWRFbmQgaXMgdW5kZWZpbmVkIHdoZW4gdGhlIG9yaWdpbmFsIHNlcXVlbmNlJ3MgbGVuZ3RoIGlzXG4gICAgLy8gdW5rbm93biBhbmQgdGhpcyBzbGljZSBkaWQgbm90IHN1cHBseSBhbiBlbmQgYW5kIHNob3VsZCBjb250YWluIGFsbFxuICAgIC8vIGVsZW1lbnRzIGFmdGVyIHJlc29sdmVkQmVnaW4uXG4gICAgLy8gSW4gdGhhdCBjYXNlLCByZXNvbHZlZFNpemUgd2lsbCBiZSBOYU4gYW5kIHNsaWNlU2l6ZSB3aWxsIHJlbWFpbiB1bmRlZmluZWQuXG4gICAgdmFyIHJlc29sdmVkU2l6ZSA9IHJlc29sdmVkRW5kIC0gcmVzb2x2ZWRCZWdpbjtcbiAgICB2YXIgc2xpY2VTaXplO1xuICAgIGlmIChyZXNvbHZlZFNpemUgPT09IHJlc29sdmVkU2l6ZSkge1xuICAgICAgc2xpY2VTaXplID0gcmVzb2x2ZWRTaXplIDwgMCA/IDAgOiByZXNvbHZlZFNpemU7XG4gICAgfVxuXG4gICAgdmFyIHNsaWNlU2VxID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcblxuICAgIC8vIElmIGl0ZXJhYmxlLnNpemUgaXMgdW5kZWZpbmVkLCB0aGUgc2l6ZSBvZiB0aGUgcmVhbGl6ZWQgc2xpY2VTZXEgaXNcbiAgICAvLyB1bmtub3duIGF0IHRoaXMgcG9pbnQgdW5sZXNzIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gc2xpY2UgaXMgMFxuICAgIHNsaWNlU2VxLnNpemUgPSBzbGljZVNpemUgPT09IDAgPyBzbGljZVNpemUgOiBpdGVyYWJsZS5zaXplICYmIHNsaWNlU2l6ZSB8fCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIXVzZUtleXMgJiYgaXNTZXEoaXRlcmFibGUpICYmIHNsaWNlU2l6ZSA+PSAwKSB7XG4gICAgICBzbGljZVNlcS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCBzbGljZVNpemUgP1xuICAgICAgICAgIGl0ZXJhYmxlLmdldChpbmRleCArIHJlc29sdmVkQmVnaW4sIG5vdFNldFZhbHVlKSA6XG4gICAgICAgICAgbm90U2V0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2xpY2VTZXEuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgaWYgKHNsaWNlU2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBza2lwcGVkID0gMDtcbiAgICAgIHZhciBpc1NraXBwaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAge1xuICAgICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gc2tpcHBlZCsrIDwgcmVzb2x2ZWRCZWdpbikpKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDApICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICBpdGVyYXRpb25zICE9PSBzbGljZVNpemU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcblxuICAgIHNsaWNlU2VxLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmIChzbGljZVNpemUgIT09IDAgJiYgcmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICAvLyBEb24ndCBib3RoZXIgaW5zdGFudGlhdGluZyBwYXJlbnQgaXRlcmF0b3IgaWYgdGFraW5nIDAuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBzbGljZVNpemUgIT09IDAgJiYgaXRlcmFibGUuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIHZhciBza2lwcGVkID0gMDtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB3aGlsZSAoc2tpcHBlZCsrIDwgcmVzb2x2ZWRCZWdpbikge1xuICAgICAgICAgIGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKytpdGVyYXRpb25zID4gc2xpY2VTaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAodXNlS2V5cyB8fCB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUykge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IElURVJBVEVfS0VZUykge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMgLSAxLCB1bmRlZmluZWQsIHN0ZXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMgLSAxLCBzdGVwLnZhbHVlWzFdLCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNsaWNlU2VxO1xuICB9XG5cblxuICBmdW5jdGlvbiB0YWtlV2hpbGVGYWN0b3J5KGl0ZXJhYmxlLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgdGFrZVNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcbiAgICB0YWtlU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGssIGMpIFxuICAgICAgICB7cmV0dXJuIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpICYmICsraXRlcmF0aW9ucyAmJiBmbih2LCBrLCB0aGlzJDApfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgdGFrZVNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhYmxlLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpdGVyYXRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIGlmICghaXRlcmF0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgdmFyIGsgPSBlbnRyeVswXTtcbiAgICAgICAgdmFyIHYgPSBlbnRyeVsxXTtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDApKSB7XG4gICAgICAgICAgaXRlcmF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMgPyBzdGVwIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGssIHYsIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gdGFrZVNlcXVlbmNlO1xuICB9XG5cblxuICBmdW5jdGlvbiBza2lwV2hpbGVGYWN0b3J5KGl0ZXJhYmxlLCBwcmVkaWNhdGUsIGNvbnRleHQsIHVzZUtleXMpIHtcbiAgICB2YXIgc2tpcFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcbiAgICBza2lwU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1NraXBwaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrLCBjKSAge1xuICAgICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpKSkge1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgdGhpcyQwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIHNraXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgc2tpcHBpbmcgPSB0cnVlO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBzdGVwLCBrLCB2O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICBpZiAodXNlS2V5cyB8fCB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUykge1xuICAgICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gSVRFUkFURV9LRVlTKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgdW5kZWZpbmVkLCBzdGVwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZVsxXSwgc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgayA9IGVudHJ5WzBdO1xuICAgICAgICAgIHYgPSBlbnRyeVsxXTtcbiAgICAgICAgICBza2lwcGluZyAmJiAoc2tpcHBpbmcgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDApKTtcbiAgICAgICAgfSB3aGlsZSAoc2tpcHBpbmcpO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHNraXBTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gY29uY2F0RmFjdG9yeShpdGVyYWJsZSwgdmFsdWVzKSB7XG4gICAgdmFyIGlzS2V5ZWRJdGVyYWJsZSA9IGlzS2V5ZWQoaXRlcmFibGUpO1xuICAgIHZhciBpdGVycyA9IFtpdGVyYWJsZV0uY29uY2F0KHZhbHVlcykubWFwKGZ1bmN0aW9uKHYgKSB7XG4gICAgICBpZiAoIWlzSXRlcmFibGUodikpIHtcbiAgICAgICAgdiA9IGlzS2V5ZWRJdGVyYWJsZSA/XG4gICAgICAgICAga2V5ZWRTZXFGcm9tVmFsdWUodikgOlxuICAgICAgICAgIGluZGV4ZWRTZXFGcm9tVmFsdWUoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbdl0pO1xuICAgICAgfSBlbHNlIGlmIChpc0tleWVkSXRlcmFibGUpIHtcbiAgICAgICAgdiA9IEtleWVkSXRlcmFibGUodik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24odiApIHtyZXR1cm4gdi5zaXplICE9PSAwfSk7XG5cbiAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgfVxuXG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIHNpbmdsZXRvbiA9IGl0ZXJzWzBdO1xuICAgICAgaWYgKHNpbmdsZXRvbiA9PT0gaXRlcmFibGUgfHxcbiAgICAgICAgICBpc0tleWVkSXRlcmFibGUgJiYgaXNLZXllZChzaW5nbGV0b24pIHx8XG4gICAgICAgICAgaXNJbmRleGVkKGl0ZXJhYmxlKSAmJiBpc0luZGV4ZWQoc2luZ2xldG9uKSkge1xuICAgICAgICByZXR1cm4gc2luZ2xldG9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb25jYXRTZXEgPSBuZXcgQXJyYXlTZXEoaXRlcnMpO1xuICAgIGlmIChpc0tleWVkSXRlcmFibGUpIHtcbiAgICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS50b0tleWVkU2VxKCk7XG4gICAgfSBlbHNlIGlmICghaXNJbmRleGVkKGl0ZXJhYmxlKSkge1xuICAgICAgY29uY2F0U2VxID0gY29uY2F0U2VxLnRvU2V0U2VxKCk7XG4gICAgfVxuICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS5mbGF0dGVuKHRydWUpO1xuICAgIGNvbmNhdFNlcS5zaXplID0gaXRlcnMucmVkdWNlKFxuICAgICAgZnVuY3Rpb24oc3VtLCBzZXEpICB7XG4gICAgICAgIGlmIChzdW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzaXplID0gc2VxLnNpemU7XG4gICAgICAgICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1bSArIHNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgMFxuICAgICk7XG4gICAgcmV0dXJuIGNvbmNhdFNlcTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZmxhdHRlbkZhY3RvcnkoaXRlcmFibGUsIGRlcHRoLCB1c2VLZXlzKSB7XG4gICAgdmFyIGZsYXRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgZmxhdFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICBmdW5jdGlvbiBmbGF0RGVlcChpdGVyLCBjdXJyZW50RGVwdGgpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgICAgaXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHtcbiAgICAgICAgICBpZiAoKCFkZXB0aCB8fCBjdXJyZW50RGVwdGggPCBkZXB0aCkgJiYgaXNJdGVyYWJsZSh2KSkge1xuICAgICAgICAgICAgZmxhdERlZXAodiwgY3VycmVudERlcHRoICsgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMrKywgdGhpcyQwKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gIXN0b3BwZWQ7XG4gICAgICAgIH0sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgZmxhdERlZXAoaXRlcmFibGUsIDApO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfVxuICAgIGZsYXRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgd2hpbGUgKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHYgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMpIHtcbiAgICAgICAgICAgIHYgPSB2WzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKCFkZXB0aCB8fCBzdGFjay5sZW5ndGggPCBkZXB0aCkgJiYgaXNJdGVyYWJsZSh2KSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChpdGVyYXRvcik7XG4gICAgICAgICAgICBpdGVyYXRvciA9IHYuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVzZUtleXMgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHYsIHN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZsYXRTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZmxhdE1hcEZhY3RvcnkoaXRlcmFibGUsIG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciBjb2VyY2UgPSBpdGVyYWJsZUNsYXNzKGl0ZXJhYmxlKTtcbiAgICByZXR1cm4gaXRlcmFibGUudG9TZXEoKS5tYXAoXG4gICAgICBmdW5jdGlvbih2LCBrKSAge3JldHVybiBjb2VyY2UobWFwcGVyLmNhbGwoY29udGV4dCwgdiwgaywgaXRlcmFibGUpKX1cbiAgICApLmZsYXR0ZW4odHJ1ZSk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGludGVycG9zZUZhY3RvcnkoaXRlcmFibGUsIHNlcGFyYXRvcikge1xuICAgIHZhciBpbnRlcnBvc2VkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuICAgIGludGVycG9zZWRTZXF1ZW5jZS5zaXplID0gaXRlcmFibGUuc2l6ZSAmJiBpdGVyYWJsZS5zaXplICogMiAtMTtcbiAgICBpbnRlcnBvc2VkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspIFxuICAgICAgICB7cmV0dXJuICghaXRlcmF0aW9ucyB8fCBmbihzZXBhcmF0b3IsIGl0ZXJhdGlvbnMrKywgdGhpcyQwKSAhPT0gZmFsc2UpICYmXG4gICAgICAgIGZuKHYsIGl0ZXJhdGlvbnMrKywgdGhpcyQwKSAhPT0gZmFsc2V9LFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICBpbnRlcnBvc2VkU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGUuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICBpZiAoIXN0ZXAgfHwgaXRlcmF0aW9ucyAlIDIpIHtcbiAgICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0aW9ucyAlIDIgP1xuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzZXBhcmF0b3IpIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZSwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBpbnRlcnBvc2VkU2VxdWVuY2U7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNvcnRGYWN0b3J5KGl0ZXJhYmxlLCBjb21wYXJhdG9yLCBtYXBwZXIpIHtcbiAgICBpZiAoIWNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSBkZWZhdWx0Q29tcGFyYXRvcjtcbiAgICB9XG4gICAgdmFyIGlzS2V5ZWRJdGVyYWJsZSA9IGlzS2V5ZWQoaXRlcmFibGUpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGVudHJpZXMgPSBpdGVyYWJsZS50b1NlcSgpLm1hcChcbiAgICAgIGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIFtrLCB2LCBpbmRleCsrLCBtYXBwZXIgPyBtYXBwZXIodiwgaywgaXRlcmFibGUpIDogdl19XG4gICAgKS50b0FycmF5KCk7XG4gICAgZW50cmllcy5zb3J0KGZ1bmN0aW9uKGEsIGIpICB7cmV0dXJuIGNvbXBhcmF0b3IoYVszXSwgYlszXSkgfHwgYVsyXSAtIGJbMl19KS5mb3JFYWNoKFxuICAgICAgaXNLZXllZEl0ZXJhYmxlID9cbiAgICAgIGZ1bmN0aW9uKHYsIGkpICB7IGVudHJpZXNbaV0ubGVuZ3RoID0gMjsgfSA6XG4gICAgICBmdW5jdGlvbih2LCBpKSAgeyBlbnRyaWVzW2ldID0gdlsxXTsgfVxuICAgICk7XG4gICAgcmV0dXJuIGlzS2V5ZWRJdGVyYWJsZSA/IEtleWVkU2VxKGVudHJpZXMpIDpcbiAgICAgIGlzSW5kZXhlZChpdGVyYWJsZSkgPyBJbmRleGVkU2VxKGVudHJpZXMpIDpcbiAgICAgIFNldFNlcShlbnRyaWVzKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gbWF4RmFjdG9yeShpdGVyYWJsZSwgY29tcGFyYXRvciwgbWFwcGVyKSB7XG4gICAgaWYgKCFjb21wYXJhdG9yKSB7XG4gICAgICBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3I7XG4gICAgfVxuICAgIGlmIChtYXBwZXIpIHtcbiAgICAgIHZhciBlbnRyeSA9IGl0ZXJhYmxlLnRvU2VxKClcbiAgICAgICAgLm1hcChmdW5jdGlvbih2LCBrKSAge3JldHVybiBbdiwgbWFwcGVyKHYsIGssIGl0ZXJhYmxlKV19KVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uKGEsIGIpICB7cmV0dXJuIG1heENvbXBhcmUoY29tcGFyYXRvciwgYVsxXSwgYlsxXSkgPyBiIDogYX0pO1xuICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXRlcmFibGUucmVkdWNlKGZ1bmN0aW9uKGEsIGIpICB7cmV0dXJuIG1heENvbXBhcmUoY29tcGFyYXRvciwgYSwgYikgPyBiIDogYX0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1heENvbXBhcmUoY29tcGFyYXRvciwgYSwgYikge1xuICAgIHZhciBjb21wID0gY29tcGFyYXRvcihiLCBhKTtcbiAgICAvLyBiIGlzIGNvbnNpZGVyZWQgdGhlIG5ldyBtYXggaWYgdGhlIGNvbXBhcmF0b3IgZGVjbGFyZXMgdGhlbSBlcXVhbCwgYnV0XG4gICAgLy8gdGhleSBhcmUgbm90IGVxdWFsIGFuZCBiIGlzIGluIGZhY3QgYSBudWxsaXNoIHZhbHVlLlxuICAgIHJldHVybiAoY29tcCA9PT0gMCAmJiBiICE9PSBhICYmIChiID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiICE9PSBiKSkgfHwgY29tcCA+IDA7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHppcFdpdGhGYWN0b3J5KGtleUl0ZXIsIHppcHBlciwgaXRlcnMpIHtcbiAgICB2YXIgemlwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2Uoa2V5SXRlcik7XG4gICAgemlwU2VxdWVuY2Uuc2l6ZSA9IG5ldyBBcnJheVNlcShpdGVycykubWFwKGZ1bmN0aW9uKGkgKSB7cmV0dXJuIGkuc2l6ZX0pLm1pbigpO1xuICAgIC8vIE5vdGU6IHRoaXMgYSBnZW5lcmljIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgX19pdGVyYXRlIGluIHRlcm1zIG9mXG4gICAgLy8gX19pdGVyYXRvciB3aGljaCBtYXkgYmUgbW9yZSBnZW5lcmljYWxseSB1c2VmdWwgaW4gdGhlIGZ1dHVyZS5cbiAgICB6aXBTZXF1ZW5jZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgLyogZ2VuZXJpYzpcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgaWYgKGZuKHN0ZXAudmFsdWVbMV0sIHN0ZXAudmFsdWVbMF0sIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICAgICovXG4gICAgICAvLyBpbmRleGVkOlxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBpZiAoZm4oc3RlcC52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICB6aXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JzID0gaXRlcnMubWFwKGZ1bmN0aW9uKGkgKVxuICAgICAgICB7cmV0dXJuIChpID0gSXRlcmFibGUoaSksIGdldEl0ZXJhdG9yKHJldmVyc2UgPyBpLnJldmVyc2UoKSA6IGkpKX1cbiAgICAgICk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgaXNEb25lID0gZmFsc2U7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHN0ZXBzO1xuICAgICAgICBpZiAoIWlzRG9uZSkge1xuICAgICAgICAgIHN0ZXBzID0gaXRlcmF0b3JzLm1hcChmdW5jdGlvbihpICkge3JldHVybiBpLm5leHQoKX0pO1xuICAgICAgICAgIGlzRG9uZSA9IHN0ZXBzLnNvbWUoZnVuY3Rpb24ocyApIHtyZXR1cm4gcy5kb25lfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRG9uZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGl0ZXJhdGlvbnMrKyxcbiAgICAgICAgICB6aXBwZXIuYXBwbHkobnVsbCwgc3RlcHMubWFwKGZ1bmN0aW9uKHMgKSB7cmV0dXJuIHMudmFsdWV9KSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHppcFNlcXVlbmNlXG4gIH1cblxuXG4gIC8vICNwcmFnbWEgSGVscGVyIEZ1bmN0aW9uc1xuXG4gIGZ1bmN0aW9uIHJlaWZ5KGl0ZXIsIHNlcSkge1xuICAgIHJldHVybiBpc1NlcShpdGVyKSA/IHNlcSA6IGl0ZXIuY29uc3RydWN0b3Ioc2VxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlRW50cnkoZW50cnkpIHtcbiAgICBpZiAoZW50cnkgIT09IE9iamVjdChlbnRyeSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFtLLCBWXSB0dXBsZTogJyArIGVudHJ5KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlU2l6ZShpdGVyKSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICByZXR1cm4gZW5zdXJlU2l6ZShpdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGl0ZXJhYmxlQ2xhc3MoaXRlcmFibGUpIHtcbiAgICByZXR1cm4gaXNLZXllZChpdGVyYWJsZSkgPyBLZXllZEl0ZXJhYmxlIDpcbiAgICAgIGlzSW5kZXhlZChpdGVyYWJsZSkgPyBJbmRleGVkSXRlcmFibGUgOlxuICAgICAgU2V0SXRlcmFibGU7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlU2VxdWVuY2UoaXRlcmFibGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShcbiAgICAgIChcbiAgICAgICAgaXNLZXllZChpdGVyYWJsZSkgPyBLZXllZFNlcSA6XG4gICAgICAgIGlzSW5kZXhlZChpdGVyYWJsZSkgPyBJbmRleGVkU2VxIDpcbiAgICAgICAgU2V0U2VxXG4gICAgICApLnByb3RvdHlwZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjYWNoZVJlc3VsdFRocm91Z2goKSB7XG4gICAgaWYgKHRoaXMuX2l0ZXIuY2FjaGVSZXN1bHQpIHtcbiAgICAgIHRoaXMuX2l0ZXIuY2FjaGVSZXN1bHQoKTtcbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX2l0ZXIuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gU2VxLnByb3RvdHlwZS5jYWNoZVJlc3VsdC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRDb21wYXJhdG9yKGEsIGIpIHtcbiAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JjZUl0ZXJhdG9yKGtleVBhdGgpIHtcbiAgICB2YXIgaXRlciA9IGdldEl0ZXJhdG9yKGtleVBhdGgpO1xuICAgIGlmICghaXRlcikge1xuICAgICAgLy8gQXJyYXkgbWlnaHQgbm90IGJlIGl0ZXJhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQsIHNvIHdlIG5lZWQgYSBmYWxsYmFja1xuICAgICAgLy8gdG8gb3VyIHdyYXBwZWQgdHlwZS5cbiAgICAgIGlmICghaXNBcnJheUxpa2Uoa2V5UGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgaXRlcmFibGUgb3IgYXJyYXktbGlrZTogJyArIGtleVBhdGgpO1xuICAgICAgfVxuICAgICAgaXRlciA9IGdldEl0ZXJhdG9yKEl0ZXJhYmxlKGtleVBhdGgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXI7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhSZWNvcmQsIEtleWVkQ29sbGVjdGlvbik7XG5cbiAgICBmdW5jdGlvbiBSZWNvcmQoZGVmYXVsdFZhbHVlcywgbmFtZSkge1xuICAgICAgdmFyIGhhc0luaXRpYWxpemVkO1xuXG4gICAgICB2YXIgUmVjb3JkVHlwZSA9IGZ1bmN0aW9uIFJlY29yZCh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFJlY29yZFR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWNvcmRUeXBlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVjb3JkVHlwZSh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICBoYXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0VmFsdWVzKTtcbiAgICAgICAgICBzZXRQcm9wcyhSZWNvcmRUeXBlUHJvdG90eXBlLCBrZXlzKTtcbiAgICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLnNpemUgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9uYW1lID0gbmFtZTtcbiAgICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9rZXlzID0ga2V5cztcbiAgICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9kZWZhdWx0VmFsdWVzID0gZGVmYXVsdFZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXAgPSBNYXAodmFsdWVzKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBSZWNvcmRUeXBlUHJvdG90eXBlID0gUmVjb3JkVHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlY29yZFByb3RvdHlwZSk7XG4gICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjb3JkVHlwZTtcblxuICAgICAgcmV0dXJuIFJlY29yZFR5cGU7XG4gICAgfVxuXG4gICAgUmVjb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZyhyZWNvcmROYW1lKHRoaXMpICsgJyB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIFJlY29yZC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oaykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZXMuaGFzT3duUHJvcGVydHkoayk7XG4gICAgfTtcblxuICAgIFJlY29yZC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaywgbm90U2V0VmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5oYXMoaykpIHtcbiAgICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGRlZmF1bHRWYWwgPSB0aGlzLl9kZWZhdWx0VmFsdWVzW2tdO1xuICAgICAgcmV0dXJuIHRoaXMuX21hcCA/IHRoaXMuX21hcC5nZXQoaywgZGVmYXVsdFZhbCkgOiBkZWZhdWx0VmFsO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgUmVjb3JkLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgUmVjb3JkVHlwZSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gUmVjb3JkVHlwZS5fZW1wdHkgfHwgKFJlY29yZFR5cGUuX2VtcHR5ID0gbWFrZVJlY29yZCh0aGlzLCBlbXB0eU1hcCgpKSk7XG4gICAgfTtcblxuICAgIFJlY29yZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaywgdikge1xuICAgICAgaWYgKCF0aGlzLmhhcyhrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgdW5rbm93biBrZXkgXCInICsgayArICdcIiBvbiAnICsgcmVjb3JkTmFtZSh0aGlzKSk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwICYmIHRoaXMuX21hcC5zZXQoaywgdik7XG4gICAgICBpZiAodGhpcy5fX293bmVySUQgfHwgbmV3TWFwID09PSB0aGlzLl9tYXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdNYXApO1xuICAgIH07XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmICghdGhpcy5oYXMoaykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwICYmIHRoaXMuX21hcC5yZW1vdmUoayk7XG4gICAgICBpZiAodGhpcy5fX293bmVySUQgfHwgbmV3TWFwID09PSB0aGlzLl9tYXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdNYXApO1xuICAgIH07XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpO1xuICAgIH07XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gS2V5ZWRJdGVyYWJsZSh0aGlzLl9kZWZhdWx0VmFsdWVzKS5tYXAoZnVuY3Rpb24oXywgaykgIHtyZXR1cm4gdGhpcyQwLmdldChrKX0pLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIFJlY29yZC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiBLZXllZEl0ZXJhYmxlKHRoaXMuX2RlZmF1bHRWYWx1ZXMpLm1hcChmdW5jdGlvbihfLCBrKSAge3JldHVybiB0aGlzJDAuZ2V0KGspfSkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgUmVjb3JkLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24ob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdNYXAsIG93bmVySUQpO1xuICAgIH07XG5cblxuICB2YXIgUmVjb3JkUHJvdG90eXBlID0gUmVjb3JkLnByb3RvdHlwZTtcbiAgUmVjb3JkUHJvdG90eXBlW0RFTEVURV0gPSBSZWNvcmRQcm90b3R5cGUucmVtb3ZlO1xuICBSZWNvcmRQcm90b3R5cGUuZGVsZXRlSW4gPVxuICBSZWNvcmRQcm90b3R5cGUucmVtb3ZlSW4gPSBNYXBQcm90b3R5cGUucmVtb3ZlSW47XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZSA9IE1hcFByb3RvdHlwZS5tZXJnZTtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlV2l0aCA9IE1hcFByb3RvdHlwZS5tZXJnZVdpdGg7XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZUluID0gTWFwUHJvdG90eXBlLm1lcmdlSW47XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZURlZXAgPSBNYXBQcm90b3R5cGUubWVyZ2VEZWVwO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IE1hcFByb3RvdHlwZS5tZXJnZURlZXBXaXRoO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBNYXBQcm90b3R5cGUubWVyZ2VEZWVwSW47XG4gIFJlY29yZFByb3RvdHlwZS5zZXRJbiA9IE1hcFByb3RvdHlwZS5zZXRJbjtcbiAgUmVjb3JkUHJvdG90eXBlLnVwZGF0ZSA9IE1hcFByb3RvdHlwZS51cGRhdGU7XG4gIFJlY29yZFByb3RvdHlwZS51cGRhdGVJbiA9IE1hcFByb3RvdHlwZS51cGRhdGVJbjtcbiAgUmVjb3JkUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSBNYXBQcm90b3R5cGUud2l0aE11dGF0aW9ucztcbiAgUmVjb3JkUHJvdG90eXBlLmFzTXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc011dGFibGU7XG4gIFJlY29yZFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc0ltbXV0YWJsZTtcblxuXG4gIGZ1bmN0aW9uIG1ha2VSZWNvcmQobGlrZVJlY29yZCwgbWFwLCBvd25lcklEKSB7XG4gICAgdmFyIHJlY29yZCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGxpa2VSZWNvcmQpKTtcbiAgICByZWNvcmQuX21hcCA9IG1hcDtcbiAgICByZWNvcmQuX19vd25lcklEID0gb3duZXJJRDtcbiAgICByZXR1cm4gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkTmFtZShyZWNvcmQpIHtcbiAgICByZXR1cm4gcmVjb3JkLl9uYW1lIHx8IHJlY29yZC5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdSZWNvcmQnO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJvcHMocHJvdG90eXBlLCBuYW1lcykge1xuICAgIHRyeSB7XG4gICAgICBuYW1lcy5mb3JFYWNoKHNldFByb3AuYmluZCh1bmRlZmluZWQsIHByb3RvdHlwZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkgZmFpbGVkLiBQcm9iYWJseSBJRTguXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJvcChwcm90b3R5cGUsIG5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBuYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQobmFtZSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpbnZhcmlhbnQodGhpcy5fX293bmVySUQsICdDYW5ub3Qgc2V0IG9uIGFuIGltbXV0YWJsZSByZWNvcmQuJyk7XG4gICAgICAgIHRoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFNldCwgU2V0Q29sbGVjdGlvbik7XG5cbiAgICAvLyBAcHJhZ21hIENvbnN0cnVjdGlvblxuXG4gICAgZnVuY3Rpb24gU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5U2V0KCkgOlxuICAgICAgICBpc1NldCh2YWx1ZSkgJiYgIWlzT3JkZXJlZCh2YWx1ZSkgPyB2YWx1ZSA6XG4gICAgICAgIGVtcHR5U2V0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbihzZXQgKSB7XG4gICAgICAgICAgdmFyIGl0ZXIgPSBTZXRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24odiApIHtyZXR1cm4gc2V0LmFkZCh2KX0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBTZXQub2YgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBTZXQuZnJvbUtleXMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMoS2V5ZWRJdGVyYWJsZSh2YWx1ZSkua2V5U2VxKCkpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXQgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdXBkYXRlU2V0KHRoaXMsIHRoaXMuX21hcC5zZXQodmFsdWUsIHRydWUpKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAucmVtb3ZlKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLmNsZWFyKCkpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIENvbXBvc2l0aW9uXG5cbiAgICBTZXQucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24oKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICBpdGVycyA9IGl0ZXJzLmZpbHRlcihmdW5jdGlvbih4ICkge3JldHVybiB4LnNpemUgIT09IDB9KTtcbiAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwICYmICF0aGlzLl9fb3duZXJJRCAmJiBpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IoaXRlcnNbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbihzZXQgKSB7XG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICBTZXRJdGVyYWJsZShpdGVyc1tpaV0pLmZvckVhY2goZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIHNldC5hZGQodmFsdWUpfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLmludGVyc2VjdCA9IGZ1bmN0aW9uKCkge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGl0ZXJzID0gaXRlcnMubWFwKGZ1bmN0aW9uKGl0ZXIgKSB7cmV0dXJuIFNldEl0ZXJhYmxlKGl0ZXIpfSk7XG4gICAgICB2YXIgb3JpZ2luYWxTZXQgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbihzZXQgKSB7XG4gICAgICAgIG9yaWdpbmFsU2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUgKSB7XG4gICAgICAgICAgaWYgKCFpdGVycy5ldmVyeShmdW5jdGlvbihpdGVyICkge3JldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKX0pKSB7XG4gICAgICAgICAgICBzZXQucmVtb3ZlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbigpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpdGVycyA9IGl0ZXJzLm1hcChmdW5jdGlvbihpdGVyICkge3JldHVybiBTZXRJdGVyYWJsZShpdGVyKX0pO1xuICAgICAgdmFyIG9yaWdpbmFsU2V0ID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oc2V0ICkge1xuICAgICAgICBvcmlnaW5hbFNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlICkge1xuICAgICAgICAgIGlmIChpdGVycy5zb21lKGZ1bmN0aW9uKGl0ZXIgKSB7cmV0dXJuIGl0ZXIuaW5jbHVkZXModmFsdWUpfSkpIHtcbiAgICAgICAgICAgIHNldC5yZW1vdmUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudW5pb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5tZXJnZVdpdGggPSBmdW5jdGlvbihtZXJnZXIpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiB0aGlzLnVuaW9uLmFwcGx5KHRoaXMsIGl0ZXJzKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgICByZXR1cm4gT3JkZXJlZFNldChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24obWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICAgIHJldHVybiBPcmRlcmVkU2V0KHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLl9faXRlcmF0ZShmdW5jdGlvbihfLCBrKSAge3JldHVybiBmbihrLCBrLCB0aGlzJDApfSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAubWFwKGZ1bmN0aW9uKF8sIGspICB7cmV0dXJuIGt9KS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbihvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXdNYXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19tYWtlKG5ld01hcCwgb3duZXJJRCk7XG4gICAgfTtcblxuXG4gIGZ1bmN0aW9uIGlzU2V0KG1heWJlU2V0KSB7XG4gICAgcmV0dXJuICEhKG1heWJlU2V0ICYmIG1heWJlU2V0W0lTX1NFVF9TRU5USU5FTF0pO1xuICB9XG5cbiAgU2V0LmlzU2V0ID0gaXNTZXQ7XG5cbiAgdmFyIElTX1NFVF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX1NFVF9fQEAnO1xuXG4gIHZhciBTZXRQcm90b3R5cGUgPSBTZXQucHJvdG90eXBlO1xuICBTZXRQcm90b3R5cGVbSVNfU0VUX1NFTlRJTkVMXSA9IHRydWU7XG4gIFNldFByb3RvdHlwZVtERUxFVEVdID0gU2V0UHJvdG90eXBlLnJlbW92ZTtcbiAgU2V0UHJvdG90eXBlLm1lcmdlRGVlcCA9IFNldFByb3RvdHlwZS5tZXJnZTtcbiAgU2V0UHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBTZXRQcm90b3R5cGUubWVyZ2VXaXRoO1xuICBTZXRQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IE1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zO1xuICBTZXRQcm90b3R5cGUuYXNNdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzTXV0YWJsZTtcbiAgU2V0UHJvdG90eXBlLmFzSW1tdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzSW1tdXRhYmxlO1xuXG4gIFNldFByb3RvdHlwZS5fX2VtcHR5ID0gZW1wdHlTZXQ7XG4gIFNldFByb3RvdHlwZS5fX21ha2UgPSBtYWtlU2V0O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNldChzZXQsIG5ld01hcCkge1xuICAgIGlmIChzZXQuX19vd25lcklEKSB7XG4gICAgICBzZXQuc2l6ZSA9IG5ld01hcC5zaXplO1xuICAgICAgc2V0Ll9tYXAgPSBuZXdNYXA7XG4gICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3TWFwID09PSBzZXQuX21hcCA/IHNldCA6XG4gICAgICBuZXdNYXAuc2l6ZSA9PT0gMCA/IHNldC5fX2VtcHR5KCkgOlxuICAgICAgc2V0Ll9fbWFrZShuZXdNYXApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVNldChtYXAsIG93bmVySUQpIHtcbiAgICB2YXIgc2V0ID0gT2JqZWN0LmNyZWF0ZShTZXRQcm90b3R5cGUpO1xuICAgIHNldC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICAgIHNldC5fbWFwID0gbWFwO1xuICAgIHNldC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIHJldHVybiBzZXQ7XG4gIH1cblxuICB2YXIgRU1QVFlfU0VUO1xuICBmdW5jdGlvbiBlbXB0eVNldCgpIHtcbiAgICByZXR1cm4gRU1QVFlfU0VUIHx8IChFTVBUWV9TRVQgPSBtYWtlU2V0KGVtcHR5TWFwKCkpKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE9yZGVyZWRTZXQsIFNldCk7XG5cbiAgICAvLyBAcHJhZ21hIENvbnN0cnVjdGlvblxuXG4gICAgZnVuY3Rpb24gT3JkZXJlZFNldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eU9yZGVyZWRTZXQoKSA6XG4gICAgICAgIGlzT3JkZXJlZFNldCh2YWx1ZSkgPyB2YWx1ZSA6XG4gICAgICAgIGVtcHR5T3JkZXJlZFNldCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oc2V0ICkge1xuICAgICAgICAgIHZhciBpdGVyID0gU2V0SXRlcmFibGUodmFsdWUpO1xuICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIHNldC5hZGQodil9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgT3JkZXJlZFNldC5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRTZXQuZnJvbUtleXMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMoS2V5ZWRJdGVyYWJsZSh2YWx1ZSkua2V5U2VxKCkpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnT3JkZXJlZFNldCB7JywgJ30nKTtcbiAgICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNPcmRlcmVkU2V0KG1heWJlT3JkZXJlZFNldCkge1xuICAgIHJldHVybiBpc1NldChtYXliZU9yZGVyZWRTZXQpICYmIGlzT3JkZXJlZChtYXliZU9yZGVyZWRTZXQpO1xuICB9XG5cbiAgT3JkZXJlZFNldC5pc09yZGVyZWRTZXQgPSBpc09yZGVyZWRTZXQ7XG5cbiAgdmFyIE9yZGVyZWRTZXRQcm90b3R5cGUgPSBPcmRlcmVkU2V0LnByb3RvdHlwZTtcbiAgT3JkZXJlZFNldFByb3RvdHlwZVtJU19PUkRFUkVEX1NFTlRJTkVMXSA9IHRydWU7XG5cbiAgT3JkZXJlZFNldFByb3RvdHlwZS5fX2VtcHR5ID0gZW1wdHlPcmRlcmVkU2V0O1xuICBPcmRlcmVkU2V0UHJvdG90eXBlLl9fbWFrZSA9IG1ha2VPcmRlcmVkU2V0O1xuXG4gIGZ1bmN0aW9uIG1ha2VPcmRlcmVkU2V0KG1hcCwgb3duZXJJRCkge1xuICAgIHZhciBzZXQgPSBPYmplY3QuY3JlYXRlKE9yZGVyZWRTZXRQcm90b3R5cGUpO1xuICAgIHNldC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICAgIHNldC5fbWFwID0gbWFwO1xuICAgIHNldC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIHJldHVybiBzZXQ7XG4gIH1cblxuICB2YXIgRU1QVFlfT1JERVJFRF9TRVQ7XG4gIGZ1bmN0aW9uIGVtcHR5T3JkZXJlZFNldCgpIHtcbiAgICByZXR1cm4gRU1QVFlfT1JERVJFRF9TRVQgfHwgKEVNUFRZX09SREVSRURfU0VUID0gbWFrZU9yZGVyZWRTZXQoZW1wdHlPcmRlcmVkTWFwKCkpKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFN0YWNrLCBJbmRleGVkQ29sbGVjdGlvbik7XG5cbiAgICAvLyBAcHJhZ21hIENvbnN0cnVjdGlvblxuXG4gICAgZnVuY3Rpb24gU3RhY2sodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlTdGFjaygpIDpcbiAgICAgICAgaXNTdGFjayh2YWx1ZSkgPyB2YWx1ZSA6XG4gICAgICAgIGVtcHR5U3RhY2soKS51bnNoaWZ0QWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICBTdGFjay5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU3RhY2sgWycsICddJyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICB3aGlsZSAoaGVhZCAmJiBpbmRleC0tKSB7XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVhZCA/IGhlYWQudmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oZWFkICYmIHRoaXMuX2hlYWQudmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemUgKyBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgZm9yICh2YXIgaWkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaWkgPj0gMDsgaWktLSkge1xuICAgICAgICBoZWFkID0ge1xuICAgICAgICAgIHZhbHVlOiBhcmd1bWVudHNbaWldLFxuICAgICAgICAgIG5leHQ6IGhlYWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xuICAgICAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVN0YWNrKG5ld1NpemUsIGhlYWQpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUucHVzaEFsbCA9IGZ1bmN0aW9uKGl0ZXIpIHtcbiAgICAgIGl0ZXIgPSBJbmRleGVkSXRlcmFibGUoaXRlcik7XG4gICAgICBpZiAoaXRlci5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgIHZhciBuZXdTaXplID0gdGhpcy5zaXplO1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgaXRlci5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSApIHtcbiAgICAgICAgbmV3U2l6ZSsrO1xuICAgICAgICBoZWFkID0ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBuZXh0OiBoZWFkXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xuICAgICAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVN0YWNrKG5ld1NpemUsIGhlYWQpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgxKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS51bnNoaWZ0QWxsID0gZnVuY3Rpb24oaXRlcikge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaEFsbChpdGVyKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3AuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5U3RhY2soKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgdGhpcy5zaXplKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciByZXNvbHZlZEJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCB0aGlzLnNpemUpO1xuICAgICAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIHRoaXMuc2l6ZSk7XG4gICAgICBpZiAocmVzb2x2ZWRFbmQgIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAvLyBzdXBlci5zbGljZShiZWdpbiwgZW5kKTtcbiAgICAgICAgcmV0dXJuIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemUgLSByZXNvbHZlZEJlZ2luO1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgd2hpbGUgKHJlc29sdmVkQmVnaW4tLSkge1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTXV0YWJpbGl0eVxuXG4gICAgU3RhY2sucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbihvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sodGhpcy5zaXplLCB0aGlzLl9oZWFkLCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgSXRlcmF0aW9uXG5cbiAgICBTdGFjay5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5fX2l0ZXJhdGUoZm4pO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKGZuKG5vZGUudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5fX2l0ZXJhdG9yKHR5cGUpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cblxuICBmdW5jdGlvbiBpc1N0YWNrKG1heWJlU3RhY2spIHtcbiAgICByZXR1cm4gISEobWF5YmVTdGFjayAmJiBtYXliZVN0YWNrW0lTX1NUQUNLX1NFTlRJTkVMXSk7XG4gIH1cblxuICBTdGFjay5pc1N0YWNrID0gaXNTdGFjaztcblxuICB2YXIgSVNfU1RBQ0tfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9TVEFDS19fQEAnO1xuXG4gIHZhciBTdGFja1Byb3RvdHlwZSA9IFN0YWNrLnByb3RvdHlwZTtcbiAgU3RhY2tQcm90b3R5cGVbSVNfU1RBQ0tfU0VOVElORUxdID0gdHJ1ZTtcbiAgU3RhY2tQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IE1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zO1xuICBTdGFja1Byb3RvdHlwZS5hc011dGFibGUgPSBNYXBQcm90b3R5cGUuYXNNdXRhYmxlO1xuICBTdGFja1Byb3RvdHlwZS5hc0ltbXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc0ltbXV0YWJsZTtcbiAgU3RhY2tQcm90b3R5cGUud2FzQWx0ZXJlZCA9IE1hcFByb3RvdHlwZS53YXNBbHRlcmVkO1xuXG5cbiAgZnVuY3Rpb24gbWFrZVN0YWNrKHNpemUsIGhlYWQsIG93bmVySUQsIGhhc2gpIHtcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShTdGFja1Byb3RvdHlwZSk7XG4gICAgbWFwLnNpemUgPSBzaXplO1xuICAgIG1hcC5faGVhZCA9IGhlYWQ7XG4gICAgbWFwLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgbWFwLl9faGFzaCA9IGhhc2g7XG4gICAgbWFwLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICB2YXIgRU1QVFlfU1RBQ0s7XG4gIGZ1bmN0aW9uIGVtcHR5U3RhY2soKSB7XG4gICAgcmV0dXJuIEVNUFRZX1NUQUNLIHx8IChFTVBUWV9TVEFDSyA9IG1ha2VTdGFjaygwKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udHJpYnV0ZXMgYWRkaXRpb25hbCBtZXRob2RzIHRvIGEgY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIG1peGluKGN0b3IsIG1ldGhvZHMpIHtcbiAgICB2YXIga2V5Q29waWVyID0gZnVuY3Rpb24oa2V5ICkgeyBjdG9yLnByb3RvdHlwZVtrZXldID0gbWV0aG9kc1trZXldOyB9O1xuICAgIE9iamVjdC5rZXlzKG1ldGhvZHMpLmZvckVhY2goa2V5Q29waWVyKTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmXG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1ldGhvZHMpLmZvckVhY2goa2V5Q29waWVyKTtcbiAgICByZXR1cm4gY3RvcjtcbiAgfVxuXG4gIEl0ZXJhYmxlLkl0ZXJhdG9yID0gSXRlcmF0b3I7XG5cbiAgbWl4aW4oSXRlcmFibGUsIHtcblxuICAgIC8vICMjIyBDb252ZXJzaW9uIHRvIG90aGVyIHR5cGVzXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkodGhpcy5zaXplIHx8IDApO1xuICAgICAgdGhpcy52YWx1ZVNlcSgpLl9faXRlcmF0ZShmdW5jdGlvbih2LCBpKSAgeyBhcnJheVtpXSA9IHY7IH0pO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH0sXG5cbiAgICB0b0luZGV4ZWRTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBUb0luZGV4ZWRTZXF1ZW5jZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9KUzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1NlcSgpLm1hcChcbiAgICAgICAgZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b0pTID09PSAnZnVuY3Rpb24nID8gdmFsdWUudG9KUygpIDogdmFsdWV9XG4gICAgICApLl9fdG9KUygpO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TZXEoKS5tYXAoXG4gICAgICAgIGZ1bmN0aW9uKHZhbHVlICkge3JldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nID8gdmFsdWUudG9KU09OKCkgOiB2YWx1ZX1cbiAgICAgICkuX190b0pTKCk7XG4gICAgfSxcblxuICAgIHRvS2V5ZWRTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBUb0tleWVkU2VxdWVuY2UodGhpcywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIHRvTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBNYXAodGhpcy50b0tleWVkU2VxKCkpO1xuICAgIH0sXG5cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHsgb2JqZWN0W2tdID0gdjsgfSk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICB0b09yZGVyZWRNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIE9yZGVyZWRNYXAodGhpcy50b0tleWVkU2VxKCkpO1xuICAgIH0sXG5cbiAgICB0b09yZGVyZWRTZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIE9yZGVyZWRTZXQoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b1NldDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gU2V0KGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9TZXRTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBUb1NldFNlcXVlbmNlKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b1NlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNJbmRleGVkKHRoaXMpID8gdGhpcy50b0luZGV4ZWRTZXEoKSA6XG4gICAgICAgIGlzS2V5ZWQodGhpcykgPyB0aGlzLnRvS2V5ZWRTZXEoKSA6XG4gICAgICAgIHRoaXMudG9TZXRTZXEoKTtcbiAgICB9LFxuXG4gICAgdG9TdGFjazogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gU3RhY2soaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b0xpc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIExpc3QoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICAgIH0sXG5cblxuICAgIC8vICMjIyBDb21tb24gSmF2YVNjcmlwdCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ1tJdGVyYWJsZV0nO1xuICAgIH0sXG5cbiAgICBfX3RvU3RyaW5nOiBmdW5jdGlvbihoZWFkLCB0YWlsKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZWFkICsgJyAnICsgdGhpcy50b1NlcSgpLm1hcCh0aGlzLl9fdG9TdHJpbmdNYXBwZXIpLmpvaW4oJywgJykgKyAnICcgKyB0YWlsO1xuICAgIH0sXG5cblxuICAgIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICAgIGNvbmNhdDogZnVuY3Rpb24oKSB7dmFyIHZhbHVlcyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGNvbmNhdEZhY3RvcnkodGhpcywgdmFsdWVzKSk7XG4gICAgfSxcblxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbih2YWx1ZSApIHtyZXR1cm4gaXModmFsdWUsIHNlYXJjaFZhbHVlKX0pO1xuICAgIH0sXG5cbiAgICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTKTtcbiAgICB9LFxuXG4gICAgZXZlcnk6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrLCBjKSAge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0sXG5cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZpbHRlckZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCB0cnVlKSk7XG4gICAgfSxcblxuICAgIGZpbmQ6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gZW50cnkgPyBlbnRyeVsxXSA6IG5vdFNldFZhbHVlO1xuICAgIH0sXG5cbiAgICBmaW5kRW50cnk6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgdmFyIGZvdW5kO1xuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaywgYykgIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgICAgZm91bmQgPSBbaywgdl07XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9LFxuXG4gICAgZmluZExhc3RFbnRyeTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy50b1NlcSgpLnJldmVyc2UoKS5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oc2lkZUVmZmVjdCwgY29udGV4dCkge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0ZShjb250ZXh0ID8gc2lkZUVmZmVjdC5iaW5kKGNvbnRleHQpIDogc2lkZUVmZmVjdCk7XG4gICAgfSxcblxuICAgIGpvaW46IGZ1bmN0aW9uKHNlcGFyYXRvcikge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gJycgKyBzZXBhcmF0b3IgOiAnLCc7XG4gICAgICB2YXIgam9pbmVkID0gJyc7XG4gICAgICB2YXIgaXNGaXJzdCA9IHRydWU7XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbih2ICkge1xuICAgICAgICBpc0ZpcnN0ID8gKGlzRmlyc3QgPSBmYWxzZSkgOiAoam9pbmVkICs9IHNlcGFyYXRvcik7XG4gICAgICAgIGpvaW5lZCArPSB2ICE9PSBudWxsICYmIHYgIT09IHVuZGVmaW5lZCA/IHYudG9TdHJpbmcoKSA6ICcnO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gam9pbmVkO1xuICAgIH0sXG5cbiAgICBrZXlzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9LRVlTKTtcbiAgICB9LFxuXG4gICAgbWFwOiBmdW5jdGlvbihtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBtYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCkpO1xuICAgIH0sXG5cbiAgICByZWR1Y2U6IGZ1bmN0aW9uKHJlZHVjZXIsIGluaXRpYWxSZWR1Y3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgcmVkdWN0aW9uO1xuICAgICAgdmFyIHVzZUZpcnN0O1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHVzZUZpcnN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZHVjdGlvbiA9IGluaXRpYWxSZWR1Y3Rpb247XG4gICAgICB9XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrLCBjKSAge1xuICAgICAgICBpZiAodXNlRmlyc3QpIHtcbiAgICAgICAgICB1c2VGaXJzdCA9IGZhbHNlO1xuICAgICAgICAgIHJlZHVjdGlvbiA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVkdWN0aW9uID0gcmVkdWNlci5jYWxsKGNvbnRleHQsIHJlZHVjdGlvbiwgdiwgaywgYyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlZHVjdGlvbjtcbiAgICB9LFxuXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uKHJlZHVjZXIsIGluaXRpYWxSZWR1Y3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXZlcnNlZCA9IHRoaXMudG9LZXllZFNlcSgpLnJldmVyc2UoKTtcbiAgICAgIHJldHVybiByZXZlcnNlZC5yZWR1Y2UuYXBwbHkocmV2ZXJzZWQsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHJldmVyc2VGYWN0b3J5KHRoaXMsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgc2xpY2U6IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzbGljZUZhY3RvcnkodGhpcywgYmVnaW4sIGVuZCwgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICBzb21lOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiAhdGhpcy5ldmVyeShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIHNvcnQ6IGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gICAgfSxcblxuICAgIHZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTKTtcbiAgICB9LFxuXG5cbiAgICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICAgIGJ1dExhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgLTEpO1xuICAgIH0sXG5cbiAgICBpc0VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCA/IHRoaXMuc2l6ZSA9PT0gMCA6ICF0aGlzLnNvbWUoZnVuY3Rpb24oKSAge3JldHVybiB0cnVlfSk7XG4gICAgfSxcblxuICAgIGNvdW50OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBlbnN1cmVTaXplKFxuICAgICAgICBwcmVkaWNhdGUgPyB0aGlzLnRvU2VxKCkuZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCkgOiB0aGlzXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBjb3VudEJ5OiBmdW5jdGlvbihncm91cGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gY291bnRCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIHJldHVybiBkZWVwRXF1YWwodGhpcywgb3RoZXIpO1xuICAgIH0sXG5cbiAgICBlbnRyeVNlcTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlcmFibGUgPSB0aGlzO1xuICAgICAgaWYgKGl0ZXJhYmxlLl9jYWNoZSkge1xuICAgICAgICAvLyBXZSBjYWNoZSBhcyBhbiBlbnRyaWVzIGFycmF5LCBzbyB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGNhY2hlIVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5U2VxKGl0ZXJhYmxlLl9jYWNoZSk7XG4gICAgICB9XG4gICAgICB2YXIgZW50cmllc1NlcXVlbmNlID0gaXRlcmFibGUudG9TZXEoKS5tYXAoZW50cnlNYXBwZXIpLnRvSW5kZXhlZFNlcSgpO1xuICAgICAgZW50cmllc1NlcXVlbmNlLmZyb21FbnRyeVNlcSA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gaXRlcmFibGUudG9TZXEoKX07XG4gICAgICByZXR1cm4gZW50cmllc1NlcXVlbmNlO1xuICAgIH0sXG5cbiAgICBmaWx0ZXJOb3Q6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgZmluZExhc3Q6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChyZXR1cm5UcnVlKTtcbiAgICB9LFxuXG4gICAgZmxhdE1hcDogZnVuY3Rpb24obWFwcGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdE1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KSk7XG4gICAgfSxcblxuICAgIGZsYXR0ZW46IGZ1bmN0aW9uKGRlcHRoKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdHRlbkZhY3RvcnkodGhpcywgZGVwdGgsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgZnJvbUVudHJ5U2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRnJvbUVudHJpZXNTZXF1ZW5jZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbihzZWFyY2hLZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uKF8sIGtleSkgIHtyZXR1cm4gaXMoa2V5LCBzZWFyY2hLZXkpfSwgdW5kZWZpbmVkLCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGdldEluOiBmdW5jdGlvbihzZWFyY2hLZXlQYXRoLCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIG5lc3RlZCA9IHRoaXM7XG4gICAgICAvLyBOb3RlOiBpbiBhbiBFUzYgZW52aXJvbm1lbnQsIHdlIHdvdWxkIHByZWZlcjpcbiAgICAgIC8vIGZvciAodmFyIGtleSBvZiBzZWFyY2hLZXlQYXRoKSB7XG4gICAgICB2YXIgaXRlciA9IGZvcmNlSXRlcmF0b3Ioc2VhcmNoS2V5UGF0aCk7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICB2YXIga2V5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkICYmIG5lc3RlZC5nZXQgPyBuZXN0ZWQuZ2V0KGtleSwgTk9UX1NFVCkgOiBOT1RfU0VUO1xuICAgICAgICBpZiAobmVzdGVkID09PSBOT1RfU0VUKSB7XG4gICAgICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmVzdGVkO1xuICAgIH0sXG5cbiAgICBncm91cEJ5OiBmdW5jdGlvbihncm91cGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gZ3JvdXBCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24oc2VhcmNoS2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoc2VhcmNoS2V5LCBOT1RfU0VUKSAhPT0gTk9UX1NFVDtcbiAgICB9LFxuXG4gICAgaGFzSW46IGZ1bmN0aW9uKHNlYXJjaEtleVBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEluKHNlYXJjaEtleVBhdGgsIE5PVF9TRVQpICE9PSBOT1RfU0VUO1xuICAgIH0sXG5cbiAgICBpc1N1YnNldDogZnVuY3Rpb24oaXRlcikge1xuICAgICAgaXRlciA9IHR5cGVvZiBpdGVyLmluY2x1ZGVzID09PSAnZnVuY3Rpb24nID8gaXRlciA6IEl0ZXJhYmxlKGl0ZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZXZlcnkoZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIGl0ZXIuaW5jbHVkZXModmFsdWUpfSk7XG4gICAgfSxcblxuICAgIGlzU3VwZXJzZXQ6IGZ1bmN0aW9uKGl0ZXIpIHtcbiAgICAgIGl0ZXIgPSB0eXBlb2YgaXRlci5pc1N1YnNldCA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZXIgOiBJdGVyYWJsZShpdGVyKTtcbiAgICAgIHJldHVybiBpdGVyLmlzU3Vic2V0KHRoaXMpO1xuICAgIH0sXG5cbiAgICBrZXlTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TZXEoKS5tYXAoa2V5TWFwcGVyKS50b0luZGV4ZWRTZXEoKTtcbiAgICB9LFxuXG4gICAgbGFzdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1NlcSgpLnJldmVyc2UoKS5maXJzdCgpO1xuICAgIH0sXG5cbiAgICBtYXg6IGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpO1xuICAgIH0sXG5cbiAgICBtYXhCeTogZnVuY3Rpb24obWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gbWF4RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpO1xuICAgIH0sXG5cbiAgICBtaW46IGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IgPyBuZWcoY29tcGFyYXRvcikgOiBkZWZhdWx0TmVnQ29tcGFyYXRvcik7XG4gICAgfSxcblxuICAgIG1pbkJ5OiBmdW5jdGlvbihtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IgPyBuZWcoY29tcGFyYXRvcikgOiBkZWZhdWx0TmVnQ29tcGFyYXRvciwgbWFwcGVyKTtcbiAgICB9LFxuXG4gICAgcmVzdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgxKTtcbiAgICB9LFxuXG4gICAgc2tpcDogZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZShNYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgICB9LFxuXG4gICAgc2tpcExhc3Q6IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHRoaXMudG9TZXEoKS5yZXZlcnNlKCkuc2tpcChhbW91bnQpLnJldmVyc2UoKSk7XG4gICAgfSxcblxuICAgIHNraXBXaGlsZTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2tpcFdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgc2tpcFVudGlsOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNraXBXaGlsZShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIHNvcnRCeTogZnVuY3Rpb24obWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gICAgfSxcblxuICAgIHRha2U6IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gICAgfSxcblxuICAgIHRha2VMYXN0OiBmdW5jdGlvbihhbW91bnQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCB0aGlzLnRvU2VxKCkucmV2ZXJzZSgpLnRha2UoYW1vdW50KS5yZXZlcnNlKCkpO1xuICAgIH0sXG5cbiAgICB0YWtlV2hpbGU6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHRha2VXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KSk7XG4gICAgfSxcblxuICAgIHRha2VVbnRpbDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy50YWtlV2hpbGUobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICB2YWx1ZVNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0luZGV4ZWRTZXEoKTtcbiAgICB9LFxuXG5cbiAgICAvLyAjIyMgSGFzaGFibGUgT2JqZWN0XG5cbiAgICBoYXNoQ29kZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2hhc2ggfHwgKHRoaXMuX19oYXNoID0gaGFzaEl0ZXJhYmxlKHRoaXMpKTtcbiAgICB9XG5cblxuICAgIC8vICMjIyBJbnRlcm5hbFxuXG4gICAgLy8gYWJzdHJhY3QgX19pdGVyYXRlKGZuLCByZXZlcnNlKVxuXG4gICAgLy8gYWJzdHJhY3QgX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKVxuICB9KTtcblxuICAvLyB2YXIgSVNfSVRFUkFCTEVfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9JVEVSQUJMRV9fQEAnO1xuICAvLyB2YXIgSVNfS0VZRURfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9LRVlFRF9fQEAnO1xuICAvLyB2YXIgSVNfSU5ERVhFRF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0lOREVYRURfX0BAJztcbiAgLy8gdmFyIElTX09SREVSRURfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9PUkRFUkVEX19AQCc7XG5cbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICBJdGVyYWJsZVByb3RvdHlwZVtJU19JVEVSQUJMRV9TRU5USU5FTF0gPSB0cnVlO1xuICBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gSXRlcmFibGVQcm90b3R5cGUudmFsdWVzO1xuICBJdGVyYWJsZVByb3RvdHlwZS5fX3RvSlMgPSBJdGVyYWJsZVByb3RvdHlwZS50b0FycmF5O1xuICBJdGVyYWJsZVByb3RvdHlwZS5fX3RvU3RyaW5nTWFwcGVyID0gcXVvdGVTdHJpbmc7XG4gIEl0ZXJhYmxlUHJvdG90eXBlLmluc3BlY3QgPVxuICBJdGVyYWJsZVByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50b1N0cmluZygpOyB9O1xuICBJdGVyYWJsZVByb3RvdHlwZS5jaGFpbiA9IEl0ZXJhYmxlUHJvdG90eXBlLmZsYXRNYXA7XG4gIEl0ZXJhYmxlUHJvdG90eXBlLmNvbnRhaW5zID0gSXRlcmFibGVQcm90b3R5cGUuaW5jbHVkZXM7XG5cbiAgLy8gVGVtcG9yYXJ5IHdhcm5pbmcgYWJvdXQgdXNpbmcgbGVuZ3RoXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJdGVyYWJsZVByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFJdGVyYWJsZS5ub0xlbmd0aFdhcm5pbmcpIHtcbiAgICAgICAgICAgIHZhciBzdGFjaztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFjay5pbmRleE9mKCdfd3JhcE9iamVjdCcpID09PSAtMSkge1xuICAgICAgICAgICAgICBjb25zb2xlICYmIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ2l0ZXJhYmxlLmxlbmd0aCBoYXMgYmVlbiBkZXByZWNhdGVkLCAnK1xuICAgICAgICAgICAgICAgICd1c2UgaXRlcmFibGUuc2l6ZSBvciBpdGVyYWJsZS5jb3VudCgpLiAnK1xuICAgICAgICAgICAgICAgICdUaGlzIHdhcm5pbmcgd2lsbCBiZWNvbWUgYSBzaWxlbnQgZXJyb3IgaW4gYSBmdXR1cmUgdmVyc2lvbi4gJyArXG4gICAgICAgICAgICAgICAgc3RhY2tcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0pKCk7XG5cblxuXG4gIG1peGluKEtleWVkSXRlcmFibGUsIHtcblxuICAgIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG4gICAgZmxpcDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxpcEZhY3RvcnkodGhpcykpO1xuICAgIH0sXG5cbiAgICBmaW5kS2V5OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF07XG4gICAgfSxcblxuICAgIGZpbmRMYXN0S2V5OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU2VxKCkucmV2ZXJzZSgpLmZpbmRLZXkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAga2V5T2Y6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kS2V5KGZ1bmN0aW9uKHZhbHVlICkge3JldHVybiBpcyh2YWx1ZSwgc2VhcmNoVmFsdWUpfSk7XG4gICAgfSxcblxuICAgIGxhc3RLZXlPZjogZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRMYXN0S2V5KGZ1bmN0aW9uKHZhbHVlICkge3JldHVybiBpcyh2YWx1ZSwgc2VhcmNoVmFsdWUpfSk7XG4gICAgfSxcblxuICAgIG1hcEVudHJpZXM6IGZ1bmN0aW9uKG1hcHBlciwgY29udGV4dCkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsXG4gICAgICAgIHRoaXMudG9TZXEoKS5tYXAoXG4gICAgICAgICAgZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gbWFwcGVyLmNhbGwoY29udGV4dCwgW2ssIHZdLCBpdGVyYXRpb25zKyssIHRoaXMkMCl9XG4gICAgICAgICkuZnJvbUVudHJ5U2VxKClcbiAgICAgICk7XG4gICAgfSxcblxuICAgIG1hcEtleXM6IGZ1bmN0aW9uKG1hcHBlciwgY29udGV4dCkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsXG4gICAgICAgIHRoaXMudG9TZXEoKS5mbGlwKCkubWFwKFxuICAgICAgICAgIGZ1bmN0aW9uKGssIHYpICB7cmV0dXJuIG1hcHBlci5jYWxsKGNvbnRleHQsIGssIHYsIHRoaXMkMCl9XG4gICAgICAgICkuZmxpcCgpXG4gICAgICApO1xuICAgIH1cblxuICB9KTtcblxuICB2YXIgS2V5ZWRJdGVyYWJsZVByb3RvdHlwZSA9IEtleWVkSXRlcmFibGUucHJvdG90eXBlO1xuICBLZXllZEl0ZXJhYmxlUHJvdG90eXBlW0lTX0tFWUVEX1NFTlRJTkVMXSA9IHRydWU7XG4gIEtleWVkSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXM7XG4gIEtleWVkSXRlcmFibGVQcm90b3R5cGUuX190b0pTID0gSXRlcmFibGVQcm90b3R5cGUudG9PYmplY3Q7XG4gIEtleWVkSXRlcmFibGVQcm90b3R5cGUuX190b1N0cmluZ01hcHBlciA9IGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIEpTT04uc3RyaW5naWZ5KGspICsgJzogJyArIHF1b3RlU3RyaW5nKHYpfTtcblxuXG5cbiAgbWl4aW4oSW5kZXhlZEl0ZXJhYmxlLCB7XG5cbiAgICAvLyAjIyMgQ29udmVyc2lvbiB0byBvdGhlciB0eXBlc1xuXG4gICAgdG9LZXllZFNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFRvS2V5ZWRTZXF1ZW5jZSh0aGlzLCBmYWxzZSk7XG4gICAgfSxcblxuXG4gICAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG4gICAgZmlsdGVyOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmaWx0ZXJGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gZW50cnkgPyBlbnRyeVswXSA6IC0xO1xuICAgIH0sXG5cbiAgICBpbmRleE9mOiBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIGtleSA9IHRoaXMudG9LZXllZFNlcSgpLmtleU9mKHNlYXJjaFZhbHVlKTtcbiAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/IC0xIDoga2V5O1xuICAgIH0sXG5cbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkua2V5T2Yoc2VhcmNoVmFsdWUpO1xuICAgICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID8gLTEgOiBrZXk7XG5cbiAgICAgIC8vIHZhciBpbmRleCA9XG4gICAgICAvLyByZXR1cm4gdGhpcy50b1NlcSgpLnJldmVyc2UoKS5pbmRleE9mKHNlYXJjaFZhbHVlKTtcbiAgICB9LFxuXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgcmV2ZXJzZUZhY3RvcnkodGhpcywgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgc2xpY2U6IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzbGljZUZhY3RvcnkodGhpcywgYmVnaW4sIGVuZCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgc3BsaWNlOiBmdW5jdGlvbihpbmRleCwgcmVtb3ZlTnVtIC8qLCAuLi52YWx1ZXMqLykge1xuICAgICAgdmFyIG51bUFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgcmVtb3ZlTnVtID0gTWF0aC5tYXgocmVtb3ZlTnVtIHwgMCwgMCk7XG4gICAgICBpZiAobnVtQXJncyA9PT0gMCB8fCAobnVtQXJncyA9PT0gMiAmJiAhcmVtb3ZlTnVtKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIElmIGluZGV4IGlzIG5lZ2F0aXZlLCBpdCBzaG91bGQgcmVzb2x2ZSByZWxhdGl2ZSB0byB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgIC8vIGNvbGxlY3Rpb24uIEhvd2V2ZXIgc2l6ZSBtYXkgYmUgZXhwZW5zaXZlIHRvIGNvbXB1dGUgaWYgbm90IGNhY2hlZCwgc29cbiAgICAgIC8vIG9ubHkgY2FsbCBjb3VudCgpIGlmIHRoZSBudW1iZXIgaXMgaW4gZmFjdCBuZWdhdGl2ZS5cbiAgICAgIGluZGV4ID0gcmVzb2x2ZUJlZ2luKGluZGV4LCBpbmRleCA8IDAgPyB0aGlzLmNvdW50KCkgOiB0aGlzLnNpemUpO1xuICAgICAgdmFyIHNwbGljZWQgPSB0aGlzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgIHJldHVybiByZWlmeShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbnVtQXJncyA9PT0gMSA/XG4gICAgICAgICAgc3BsaWNlZCA6XG4gICAgICAgICAgc3BsaWNlZC5jb25jYXQoYXJyQ29weShhcmd1bWVudHMsIDIpLCB0aGlzLnNsaWNlKGluZGV4ICsgcmVtb3ZlTnVtKSlcbiAgICAgICk7XG4gICAgfSxcblxuXG4gICAgLy8gIyMjIE1vcmUgY29sbGVjdGlvbiBtZXRob2RzXG5cbiAgICBmaW5kTGFzdEluZGV4OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLnRvS2V5ZWRTZXEoKS5maW5kTGFzdEtleShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID8gLTEgOiBrZXk7XG4gICAgfSxcblxuICAgIGZpcnN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgwKTtcbiAgICB9LFxuXG4gICAgZmxhdHRlbjogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGF0dGVuRmFjdG9yeSh0aGlzLCBkZXB0aCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIHJldHVybiAoaW5kZXggPCAwIHx8ICh0aGlzLnNpemUgPT09IEluZmluaXR5IHx8XG4gICAgICAgICAgKHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGluZGV4ID4gdGhpcy5zaXplKSkpID9cbiAgICAgICAgbm90U2V0VmFsdWUgOlxuICAgICAgICB0aGlzLmZpbmQoZnVuY3Rpb24oXywga2V5KSAge3JldHVybiBrZXkgPT09IGluZGV4fSwgdW5kZWZpbmVkLCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIHJldHVybiBpbmRleCA+PSAwICYmICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHwgaW5kZXggPCB0aGlzLnNpemUgOlxuICAgICAgICB0aGlzLmluZGV4T2YoaW5kZXgpICE9PSAtMVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgaW50ZXJwb3NlOiBmdW5jdGlvbihzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBpbnRlcnBvc2VGYWN0b3J5KHRoaXMsIHNlcGFyYXRvcikpO1xuICAgIH0sXG5cbiAgICBpbnRlcmxlYXZlOiBmdW5jdGlvbigvKi4uLml0ZXJhYmxlcyovKSB7XG4gICAgICB2YXIgaXRlcmFibGVzID0gW3RoaXNdLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cykpO1xuICAgICAgdmFyIHppcHBlZCA9IHppcFdpdGhGYWN0b3J5KHRoaXMudG9TZXEoKSwgSW5kZXhlZFNlcS5vZiwgaXRlcmFibGVzKTtcbiAgICAgIHZhciBpbnRlcmxlYXZlZCA9IHppcHBlZC5mbGF0dGVuKHRydWUpO1xuICAgICAgaWYgKHppcHBlZC5zaXplKSB7XG4gICAgICAgIGludGVybGVhdmVkLnNpemUgPSB6aXBwZWQuc2l6ZSAqIGl0ZXJhYmxlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgaW50ZXJsZWF2ZWQpO1xuICAgIH0sXG5cbiAgICBsYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgtMSk7XG4gICAgfSxcblxuICAgIHNraXBXaGlsZTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2tpcFdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHppcDogZnVuY3Rpb24oLyosIC4uLml0ZXJhYmxlcyAqLykge1xuICAgICAgdmFyIGl0ZXJhYmxlcyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCB6aXBXaXRoRmFjdG9yeSh0aGlzLCBkZWZhdWx0WmlwcGVyLCBpdGVyYWJsZXMpKTtcbiAgICB9LFxuXG4gICAgemlwV2l0aDogZnVuY3Rpb24oemlwcGVyLyosIC4uLml0ZXJhYmxlcyAqLykge1xuICAgICAgdmFyIGl0ZXJhYmxlcyA9IGFyckNvcHkoYXJndW1lbnRzKTtcbiAgICAgIGl0ZXJhYmxlc1swXSA9IHRoaXM7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgemlwcGVyLCBpdGVyYWJsZXMpKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgSW5kZXhlZEl0ZXJhYmxlLnByb3RvdHlwZVtJU19JTkRFWEVEX1NFTlRJTkVMXSA9IHRydWU7XG4gIEluZGV4ZWRJdGVyYWJsZS5wcm90b3R5cGVbSVNfT1JERVJFRF9TRU5USU5FTF0gPSB0cnVlO1xuXG5cblxuICBtaXhpbihTZXRJdGVyYWJsZSwge1xuXG4gICAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG4gICAgZ2V0OiBmdW5jdGlvbih2YWx1ZSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyh2YWx1ZSkgPyB2YWx1ZSA6IG5vdFNldFZhbHVlO1xuICAgIH0sXG5cbiAgICBpbmNsdWRlczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyh2YWx1ZSk7XG4gICAgfSxcblxuXG4gICAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cbiAgICBrZXlTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVTZXEoKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgU2V0SXRlcmFibGUucHJvdG90eXBlLmhhcyA9IEl0ZXJhYmxlUHJvdG90eXBlLmluY2x1ZGVzO1xuXG5cbiAgLy8gTWl4aW4gc3ViY2xhc3Nlc1xuXG4gIG1peGluKEtleWVkU2VxLCBLZXllZEl0ZXJhYmxlLnByb3RvdHlwZSk7XG4gIG1peGluKEluZGV4ZWRTZXEsIEluZGV4ZWRJdGVyYWJsZS5wcm90b3R5cGUpO1xuICBtaXhpbihTZXRTZXEsIFNldEl0ZXJhYmxlLnByb3RvdHlwZSk7XG5cbiAgbWl4aW4oS2V5ZWRDb2xsZWN0aW9uLCBLZXllZEl0ZXJhYmxlLnByb3RvdHlwZSk7XG4gIG1peGluKEluZGV4ZWRDb2xsZWN0aW9uLCBJbmRleGVkSXRlcmFibGUucHJvdG90eXBlKTtcbiAgbWl4aW4oU2V0Q29sbGVjdGlvbiwgU2V0SXRlcmFibGUucHJvdG90eXBlKTtcblxuXG4gIC8vICNwcmFnbWEgSGVscGVyIGZ1bmN0aW9uc1xuXG4gIGZ1bmN0aW9uIGtleU1hcHBlcih2LCBrKSB7XG4gICAgcmV0dXJuIGs7XG4gIH1cblxuICBmdW5jdGlvbiBlbnRyeU1hcHBlcih2LCBrKSB7XG4gICAgcmV0dXJuIFtrLCB2XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZyhwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gLXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHF1b3RlU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRaaXBwZXIoKSB7XG4gICAgcmV0dXJuIGFyckNvcHkoYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHROZWdDb21wYXJhdG9yKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAxIDogYSA+IGIgPyAtMSA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNoSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUuc2l6ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgb3JkZXJlZCA9IGlzT3JkZXJlZChpdGVyYWJsZSk7XG4gICAgdmFyIGtleWVkID0gaXNLZXllZChpdGVyYWJsZSk7XG4gICAgdmFyIGggPSBvcmRlcmVkID8gMSA6IDA7XG4gICAgdmFyIHNpemUgPSBpdGVyYWJsZS5fX2l0ZXJhdGUoXG4gICAgICBrZXllZCA/XG4gICAgICAgIG9yZGVyZWQgP1xuICAgICAgICAgIGZ1bmN0aW9uKHYsIGspICB7IGggPSAzMSAqIGggKyBoYXNoTWVyZ2UoaGFzaCh2KSwgaGFzaChrKSkgfCAwOyB9IDpcbiAgICAgICAgICBmdW5jdGlvbih2LCBrKSAgeyBoID0gaCArIGhhc2hNZXJnZShoYXNoKHYpLCBoYXNoKGspKSB8IDA7IH0gOlxuICAgICAgICBvcmRlcmVkID9cbiAgICAgICAgICBmdW5jdGlvbih2ICkgeyBoID0gMzEgKiBoICsgaGFzaCh2KSB8IDA7IH0gOlxuICAgICAgICAgIGZ1bmN0aW9uKHYgKSB7IGggPSBoICsgaGFzaCh2KSB8IDA7IH1cbiAgICApO1xuICAgIHJldHVybiBtdXJtdXJIYXNoT2ZTaXplKHNpemUsIGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKSB7XG4gICAgaCA9IGltdWwoaCwgMHhDQzlFMkQ1MSk7XG4gICAgaCA9IGltdWwoaCA8PCAxNSB8IGggPj4+IC0xNSwgMHgxQjg3MzU5Myk7XG4gICAgaCA9IGltdWwoaCA8PCAxMyB8IGggPj4+IC0xMywgNSk7XG4gICAgaCA9IChoICsgMHhFNjU0NkI2NCB8IDApIF4gc2l6ZTtcbiAgICBoID0gaW11bChoIF4gaCA+Pj4gMTYsIDB4ODVFQkNBNkIpO1xuICAgIGggPSBpbXVsKGggXiBoID4+PiAxMywgMHhDMkIyQUUzNSk7XG4gICAgaCA9IHNtaShoIF4gaCA+Pj4gMTYpO1xuICAgIHJldHVybiBoO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzaE1lcmdlKGEsIGIpIHtcbiAgICByZXR1cm4gYSBeIGIgKyAweDlFMzc3OUI5ICsgKGEgPDwgNikgKyAoYSA+PiAyKSB8IDA7IC8vIGludFxuICB9XG5cbiAgdmFyIEltbXV0YWJsZSA9IHtcblxuICAgIEl0ZXJhYmxlOiBJdGVyYWJsZSxcblxuICAgIFNlcTogU2VxLFxuICAgIENvbGxlY3Rpb246IENvbGxlY3Rpb24sXG4gICAgTWFwOiBNYXAsXG4gICAgT3JkZXJlZE1hcDogT3JkZXJlZE1hcCxcbiAgICBMaXN0OiBMaXN0LFxuICAgIFN0YWNrOiBTdGFjayxcbiAgICBTZXQ6IFNldCxcbiAgICBPcmRlcmVkU2V0OiBPcmRlcmVkU2V0LFxuXG4gICAgUmVjb3JkOiBSZWNvcmQsXG4gICAgUmFuZ2U6IFJhbmdlLFxuICAgIFJlcGVhdDogUmVwZWF0LFxuXG4gICAgaXM6IGlzLFxuICAgIGZyb21KUzogZnJvbUpTXG5cbiAgfTtcblxuICByZXR1cm4gSW1tdXRhYmxlO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbm9kZV9tb2R1bGVzL2ltbXV0YWJsZS9kaXN0L2ltbXV0YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFZGl0b3JTdGF0ZVxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9leHRlbmRzID0gX2Fzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJsb2NrVHJlZSA9IHJlcXVpcmUoJy4vQmxvY2tUcmVlJyk7XG52YXIgQ29udGVudFN0YXRlID0gcmVxdWlyZSgnLi9Db250ZW50U3RhdGUnKTtcbnZhciBFZGl0b3JCaWRpU2VydmljZSA9IHJlcXVpcmUoJy4vRWRpdG9yQmlkaVNlcnZpY2UnKTtcbnZhciBJbW11dGFibGUgPSByZXF1aXJlKCdpbW11dGFibGUnKTtcbnZhciBTZWxlY3Rpb25TdGF0ZSA9IHJlcXVpcmUoJy4vU2VsZWN0aW9uU3RhdGUnKTtcblxudmFyIE9yZGVyZWRTZXQgPSBJbW11dGFibGUuT3JkZXJlZFNldCxcbiAgICBSZWNvcmQgPSBJbW11dGFibGUuUmVjb3JkLFxuICAgIFN0YWNrID0gSW1tdXRhYmxlLlN0YWNrO1xuXG5cbnZhciBkZWZhdWx0UmVjb3JkID0ge1xuICBhbGxvd1VuZG86IHRydWUsXG4gIGN1cnJlbnRDb250ZW50OiBudWxsLFxuICBkZWNvcmF0b3I6IG51bGwsXG4gIGRpcmVjdGlvbk1hcDogbnVsbCxcbiAgZm9yY2VTZWxlY3Rpb246IGZhbHNlLFxuICBpbkNvbXBvc2l0aW9uTW9kZTogZmFsc2UsXG4gIGlubGluZVN0eWxlT3ZlcnJpZGU6IG51bGwsXG4gIGxhc3RDaGFuZ2VUeXBlOiBudWxsLFxuICBuYXRpdmVseVJlbmRlcmVkQ29udGVudDogbnVsbCxcbiAgcmVkb1N0YWNrOiBTdGFjaygpLFxuICBzZWxlY3Rpb246IG51bGwsXG4gIHRyZWVNYXA6IG51bGwsXG4gIHVuZG9TdGFjazogU3RhY2soKVxufTtcblxudmFyIEVkaXRvclN0YXRlUmVjb3JkID0gUmVjb3JkKGRlZmF1bHRSZWNvcmQpO1xuXG52YXIgRWRpdG9yU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIEVkaXRvclN0YXRlLmNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gY3JlYXRlRW1wdHkoZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIEVkaXRvclN0YXRlLmNyZWF0ZVdpdGhDb250ZW50KENvbnRlbnRTdGF0ZS5jcmVhdGVGcm9tVGV4dCgnJyksIGRlY29yYXRvcik7XG4gIH07XG5cbiAgRWRpdG9yU3RhdGUuY3JlYXRlV2l0aENvbnRlbnQgPSBmdW5jdGlvbiBjcmVhdGVXaXRoQ29udGVudChjb250ZW50U3RhdGUsIGRlY29yYXRvcikge1xuICAgIHZhciBmaXJzdEtleSA9IGNvbnRlbnRTdGF0ZS5nZXRCbG9ja01hcCgpLmZpcnN0KCkuZ2V0S2V5KCk7XG4gICAgcmV0dXJuIEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICBjdXJyZW50Q29udGVudDogY29udGVudFN0YXRlLFxuICAgICAgdW5kb1N0YWNrOiBTdGFjaygpLFxuICAgICAgcmVkb1N0YWNrOiBTdGFjaygpLFxuICAgICAgZGVjb3JhdG9yOiBkZWNvcmF0b3IgfHwgbnVsbCxcbiAgICAgIHNlbGVjdGlvbjogU2VsZWN0aW9uU3RhdGUuY3JlYXRlRW1wdHkoZmlyc3RLZXkpXG4gICAgfSk7XG4gIH07XG5cbiAgRWRpdG9yU3RhdGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGNvbmZpZykge1xuICAgIHZhciBjdXJyZW50Q29udGVudCA9IGNvbmZpZy5jdXJyZW50Q29udGVudCxcbiAgICAgICAgZGVjb3JhdG9yID0gY29uZmlnLmRlY29yYXRvcjtcblxuICAgIHZhciByZWNvcmRDb25maWcgPSBfZXh0ZW5kcyh7fSwgY29uZmlnLCB7XG4gICAgICB0cmVlTWFwOiBnZW5lcmF0ZU5ld1RyZWVNYXAoY3VycmVudENvbnRlbnQsIGRlY29yYXRvciksXG4gICAgICBkaXJlY3Rpb25NYXA6IEVkaXRvckJpZGlTZXJ2aWNlLmdldERpcmVjdGlvbk1hcChjdXJyZW50Q29udGVudClcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEVkaXRvclN0YXRlKG5ldyBFZGl0b3JTdGF0ZVJlY29yZChyZWNvcmRDb25maWcpKTtcbiAgfTtcblxuICBFZGl0b3JTdGF0ZS5zZXQgPSBmdW5jdGlvbiBzZXQoZWRpdG9yU3RhdGUsIHB1dCkge1xuICAgIHZhciBtYXAgPSBlZGl0b3JTdGF0ZS5nZXRJbW11dGFibGUoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgdmFyIGV4aXN0aW5nRGVjb3JhdG9yID0gc3RhdGUuZ2V0KCdkZWNvcmF0b3InKTtcbiAgICAgIHZhciBkZWNvcmF0b3IgPSBleGlzdGluZ0RlY29yYXRvcjtcbiAgICAgIGlmIChwdXQuZGVjb3JhdG9yID09PSBudWxsKSB7XG4gICAgICAgIGRlY29yYXRvciA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHB1dC5kZWNvcmF0b3IpIHtcbiAgICAgICAgZGVjb3JhdG9yID0gcHV0LmRlY29yYXRvcjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0NvbnRlbnQgPSBwdXQuY3VycmVudENvbnRlbnQgfHwgZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKTtcblxuICAgICAgaWYgKGRlY29yYXRvciAhPT0gZXhpc3RpbmdEZWNvcmF0b3IpIHtcbiAgICAgICAgdmFyIHRyZWVNYXAgPSBzdGF0ZS5nZXQoJ3RyZWVNYXAnKTtcbiAgICAgICAgdmFyIG5ld1RyZWVNYXA7XG4gICAgICAgIGlmIChkZWNvcmF0b3IgJiYgZXhpc3RpbmdEZWNvcmF0b3IpIHtcbiAgICAgICAgICBuZXdUcmVlTWFwID0gcmVnZW5lcmF0ZVRyZWVGb3JOZXdEZWNvcmF0b3IobmV3Q29udGVudCwgbmV3Q29udGVudC5nZXRCbG9ja01hcCgpLCB0cmVlTWFwLCBkZWNvcmF0b3IsIGV4aXN0aW5nRGVjb3JhdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdUcmVlTWFwID0gZ2VuZXJhdGVOZXdUcmVlTWFwKG5ld0NvbnRlbnQsIGRlY29yYXRvcik7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5tZXJnZSh7XG4gICAgICAgICAgZGVjb3JhdG9yOiBkZWNvcmF0b3IsXG4gICAgICAgICAgdHJlZU1hcDogbmV3VHJlZU1hcCxcbiAgICAgICAgICBuYXRpdmVseVJlbmRlcmVkQ29udGVudDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXhpc3RpbmdDb250ZW50ID0gZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKTtcbiAgICAgIGlmIChuZXdDb250ZW50ICE9PSBleGlzdGluZ0NvbnRlbnQpIHtcbiAgICAgICAgc3RhdGUuc2V0KCd0cmVlTWFwJywgcmVnZW5lcmF0ZVRyZWVGb3JOZXdCbG9ja3MoZWRpdG9yU3RhdGUsIG5ld0NvbnRlbnQuZ2V0QmxvY2tNYXAoKSwgbmV3Q29udGVudC5nZXRFbnRpdHlNYXAoKSwgZGVjb3JhdG9yKSk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLm1lcmdlKHB1dCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IEVkaXRvclN0YXRlKG1hcCk7XG4gIH07XG5cbiAgRWRpdG9yU3RhdGUucHJvdG90eXBlLnRvSlMgPSBmdW5jdGlvbiB0b0pTKCkge1xuICAgIHJldHVybiB0aGlzLmdldEltbXV0YWJsZSgpLnRvSlMoKTtcbiAgfTtcblxuICBFZGl0b3JTdGF0ZS5wcm90b3R5cGUuZ2V0QWxsb3dVbmRvID0gZnVuY3Rpb24gZ2V0QWxsb3dVbmRvKCkge1xuICAgIHJldHVybiB0aGlzLmdldEltbXV0YWJsZSgpLmdldCgnYWxsb3dVbmRvJyk7XG4gIH07XG5cbiAgRWRpdG9yU3RhdGUucHJvdG90eXBlLmdldEN1cnJlbnRDb250ZW50ID0gZnVuY3Rpb24gZ2V0Q3VycmVudENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW1tdXRhYmxlKCkuZ2V0KCdjdXJyZW50Q29udGVudCcpO1xuICB9O1xuXG4gIEVkaXRvclN0YXRlLnByb3RvdHlwZS5nZXRVbmRvU3RhY2sgPSBmdW5jdGlvbiBnZXRVbmRvU3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW1tdXRhYmxlKCkuZ2V0KCd1bmRvU3RhY2snKTtcbiAgfTtcblxuICBFZGl0b3JTdGF0ZS5wcm90b3R5cGUuZ2V0UmVkb1N0YWNrID0gZnVuY3Rpb24gZ2V0UmVkb1N0YWNrKCkge1xuICAgIHJldHVybiB0aGlzLmdldEltbXV0YWJsZSgpLmdldCgncmVkb1N0YWNrJyk7XG4gIH07XG5cbiAgRWRpdG9yU3RhdGUucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIGdldFNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbW11dGFibGUoKS5nZXQoJ3NlbGVjdGlvbicpO1xuICB9O1xuXG4gIEVkaXRvclN0YXRlLnByb3RvdHlwZS5nZXREZWNvcmF0b3IgPSBmdW5jdGlvbiBnZXREZWNvcmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW1tdXRhYmxlKCkuZ2V0KCdkZWNvcmF0b3InKTtcbiAgfTtcblxuICBFZGl0b3JTdGF0ZS5wcm90b3R5cGUuaXNJbkNvbXBvc2l0aW9uTW9kZSA9IGZ1bmN0aW9uIGlzSW5Db21wb3NpdGlvbk1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW1tdXRhYmxlKCkuZ2V0KCdpbkNvbXBvc2l0aW9uTW9kZScpO1xuICB9O1xuXG4gIEVkaXRvclN0YXRlLnByb3RvdHlwZS5tdXN0Rm9yY2VTZWxlY3Rpb24gPSBmdW5jdGlvbiBtdXN0Rm9yY2VTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW1tdXRhYmxlKCkuZ2V0KCdmb3JjZVNlbGVjdGlvbicpO1xuICB9O1xuXG4gIEVkaXRvclN0YXRlLnByb3RvdHlwZS5nZXROYXRpdmVseVJlbmRlcmVkQ29udGVudCA9IGZ1bmN0aW9uIGdldE5hdGl2ZWx5UmVuZGVyZWRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldEltbXV0YWJsZSgpLmdldCgnbmF0aXZlbHlSZW5kZXJlZENvbnRlbnQnKTtcbiAgfTtcblxuICBFZGl0b3JTdGF0ZS5wcm90b3R5cGUuZ2V0TGFzdENoYW5nZVR5cGUgPSBmdW5jdGlvbiBnZXRMYXN0Q2hhbmdlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbW11dGFibGUoKS5nZXQoJ2xhc3RDaGFuZ2VUeXBlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoaWxlIGVkaXRpbmcsIHRoZSB1c2VyIG1heSBhcHBseSBpbmxpbmUgc3R5bGUgY29tbWFuZHMgd2l0aCBhIGNvbGxhcHNlZFxuICAgKiBjdXJzb3IsIGludGVuZGluZyB0byB0eXBlIHRleHQgdGhhdCBhZG9wdHMgdGhlIHNwZWNpZmllZCBzdHlsZS4gSW4gdGhpc1xuICAgKiBjYXNlLCB3ZSB0cmFjayB0aGUgc3BlY2lmaWVkIHN0eWxlIGFzIGFuIFwib3ZlcnJpZGVcIiB0aGF0IHRha2VzIHByZWNlZGVuY2VcbiAgICogb3ZlciB0aGUgaW5saW5lIHN0eWxlIG9mIHRoZSB0ZXh0IGFkamFjZW50IHRvIHRoZSBjdXJzb3IuXG4gICAqXG4gICAqIElmIG51bGwsIHRoZXJlIGlzIG5vIG92ZXJyaWRlIGluIHBsYWNlLlxuICAgKi9cblxuXG4gIEVkaXRvclN0YXRlLnByb3RvdHlwZS5nZXRJbmxpbmVTdHlsZU92ZXJyaWRlID0gZnVuY3Rpb24gZ2V0SW5saW5lU3R5bGVPdmVycmlkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbW11dGFibGUoKS5nZXQoJ2lubGluZVN0eWxlT3ZlcnJpZGUnKTtcbiAgfTtcblxuICBFZGl0b3JTdGF0ZS5zZXRJbmxpbmVTdHlsZU92ZXJyaWRlID0gZnVuY3Rpb24gc2V0SW5saW5lU3R5bGVPdmVycmlkZShlZGl0b3JTdGF0ZSwgaW5saW5lU3R5bGVPdmVycmlkZSkge1xuICAgIHJldHVybiBFZGl0b3JTdGF0ZS5zZXQoZWRpdG9yU3RhdGUsIHsgaW5saW5lU3R5bGVPdmVycmlkZTogaW5saW5lU3R5bGVPdmVycmlkZSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBhcHByb3ByaWF0ZSBpbmxpbmUgc3R5bGUgZm9yIHRoZSBlZGl0b3Igc3RhdGUuIElmIGFuXG4gICAqIG92ZXJyaWRlIGlzIGluIHBsYWNlLCB1c2UgaXQuIE90aGVyd2lzZSwgdGhlIGN1cnJlbnQgc3R5bGUgaXNcbiAgICogYmFzZWQgb24gdGhlIGxvY2F0aW9uIG9mIHRoZSBzZWxlY3Rpb24gc3RhdGUuXG4gICAqL1xuXG5cbiAgRWRpdG9yU3RhdGUucHJvdG90eXBlLmdldEN1cnJlbnRJbmxpbmVTdHlsZSA9IGZ1bmN0aW9uIGdldEN1cnJlbnRJbmxpbmVTdHlsZSgpIHtcbiAgICB2YXIgb3ZlcnJpZGUgPSB0aGlzLmdldElubGluZVN0eWxlT3ZlcnJpZGUoKTtcbiAgICBpZiAob3ZlcnJpZGUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXRDdXJyZW50Q29udGVudCgpO1xuICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICByZXR1cm4gZ2V0SW5saW5lU3R5bGVGb3JDb2xsYXBzZWRTZWxlY3Rpb24oY29udGVudCwgc2VsZWN0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0SW5saW5lU3R5bGVGb3JOb25Db2xsYXBzZWRTZWxlY3Rpb24oY29udGVudCwgc2VsZWN0aW9uKTtcbiAgfTtcblxuICBFZGl0b3JTdGF0ZS5wcm90b3R5cGUuZ2V0QmxvY2tUcmVlID0gZnVuY3Rpb24gZ2V0QmxvY2tUcmVlKGJsb2NrS2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW1tdXRhYmxlKCkuZ2V0SW4oWyd0cmVlTWFwJywgYmxvY2tLZXldKTtcbiAgfTtcblxuICBFZGl0b3JTdGF0ZS5wcm90b3R5cGUuaXNTZWxlY3Rpb25BdFN0YXJ0T2ZDb250ZW50ID0gZnVuY3Rpb24gaXNTZWxlY3Rpb25BdFN0YXJ0T2ZDb250ZW50KCkge1xuICAgIHZhciBmaXJzdEtleSA9IHRoaXMuZ2V0Q3VycmVudENvbnRlbnQoKS5nZXRCbG9ja01hcCgpLmZpcnN0KCkuZ2V0S2V5KCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uKCkuaGFzRWRnZVdpdGhpbihmaXJzdEtleSwgMCwgMCk7XG4gIH07XG5cbiAgRWRpdG9yU3RhdGUucHJvdG90eXBlLmlzU2VsZWN0aW9uQXRFbmRPZkNvbnRlbnQgPSBmdW5jdGlvbiBpc1NlbGVjdGlvbkF0RW5kT2ZDb250ZW50KCkge1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXRDdXJyZW50Q29udGVudCgpO1xuICAgIHZhciBibG9ja01hcCA9IGNvbnRlbnQuZ2V0QmxvY2tNYXAoKTtcbiAgICB2YXIgbGFzdCA9IGJsb2NrTWFwLmxhc3QoKTtcbiAgICB2YXIgZW5kID0gbGFzdC5nZXRMZW5ndGgoKTtcbiAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb24oKS5oYXNFZGdlV2l0aGluKGxhc3QuZ2V0S2V5KCksIGVuZCwgZW5kKTtcbiAgfTtcblxuICBFZGl0b3JTdGF0ZS5wcm90b3R5cGUuZ2V0RGlyZWN0aW9uTWFwID0gZnVuY3Rpb24gZ2V0RGlyZWN0aW9uTWFwKCkge1xuICAgIHJldHVybiB0aGlzLmdldEltbXV0YWJsZSgpLmdldCgnZGlyZWN0aW9uTWFwJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY29ycG9yYXRlIG5hdGl2ZSBET00gc2VsZWN0aW9uIGNoYW5nZXMgaW50byB0aGUgRWRpdG9yU3RhdGUuIFRoaXNcbiAgICogbWV0aG9kIGNhbiBiZSB1c2VkIHdoZW4gd2Ugc2ltcGx5IHdhbnQgdG8gYWNjZXB0IHdoYXRldmVyIHRoZSBET01cbiAgICogaGFzIGdpdmVuIHVzIHRvIHJlcHJlc2VudCBzZWxlY3Rpb24sIGFuZCB3ZSBkbyBub3QgbmVlZCB0byByZS1yZW5kZXJcbiAgICogdGhlIGVkaXRvci5cbiAgICpcbiAgICogVG8gZm9yY2libHkgbW92ZSB0aGUgRE9NIHNlbGVjdGlvbiwgc2VlIGBFZGl0b3JTdGF0ZS5mb3JjZVNlbGVjdGlvbmAuXG4gICAqL1xuXG5cbiAgRWRpdG9yU3RhdGUuYWNjZXB0U2VsZWN0aW9uID0gZnVuY3Rpb24gYWNjZXB0U2VsZWN0aW9uKGVkaXRvclN0YXRlLCBzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gdXBkYXRlU2VsZWN0aW9uKGVkaXRvclN0YXRlLCBzZWxlY3Rpb24sIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogQXQgdGltZXMsIHdlIG5lZWQgdG8gZm9yY2UgdGhlIERPTSBzZWxlY3Rpb24gdG8gYmUgd2hlcmUgd2VcbiAgICogbmVlZCBpdCB0byBiZS4gVGhpcyBjYW4gb2NjdXIgd2hlbiB0aGUgYW5jaG9yIG9yIGZvY3VzIG5vZGVzXG4gICAqIGFyZSBub24tdGV4dCBub2RlcywgZm9yIGluc3RhbmNlLiBJbiB0aGlzIGNhc2UsIHdlIHdhbnQgdG8gdHJpZ2dlclxuICAgKiBhIHJlLXJlbmRlciBvZiB0aGUgZWRpdG9yLCB3aGljaCBpbiB0dXJuIGZvcmNlcyBzZWxlY3Rpb24gaW50b1xuICAgKiB0aGUgY29ycmVjdCBwbGFjZSBpbiB0aGUgRE9NLiBUaGUgYGZvcmNlU2VsZWN0aW9uYCBtZXRob2RcbiAgICogYWNjb21wbGlzaGVzIHRoaXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIGluIGNhc2VzIHdoZXJlIHlvdSBuZWVkIHRvIGV4cGxpY2l0bHlcbiAgICogbW92ZSB0aGUgRE9NIHNlbGVjdGlvbiBmcm9tIG9uZSBwbGFjZSB0byBhbm90aGVyIHdpdGhvdXQgYSBjaGFuZ2VcbiAgICogaW4gQ29udGVudFN0YXRlLlxuICAgKi9cblxuXG4gIEVkaXRvclN0YXRlLmZvcmNlU2VsZWN0aW9uID0gZnVuY3Rpb24gZm9yY2VTZWxlY3Rpb24oZWRpdG9yU3RhdGUsIHNlbGVjdGlvbikge1xuICAgIGlmICghc2VsZWN0aW9uLmdldEhhc0ZvY3VzKCkpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5zZXQoJ2hhc0ZvY3VzJywgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVTZWxlY3Rpb24oZWRpdG9yU3RhdGUsIHNlbGVjdGlvbiwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGVkaXRvciB3aXRob3V0IGZvcmNpbmcgZm9jdXMuXG4gICAqL1xuXG5cbiAgRWRpdG9yU3RhdGUubW92ZVNlbGVjdGlvblRvRW5kID0gZnVuY3Rpb24gbW92ZVNlbGVjdGlvblRvRW5kKGVkaXRvclN0YXRlKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBlZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpO1xuICAgIHZhciBsYXN0QmxvY2sgPSBjb250ZW50LmdldExhc3RCbG9jaygpO1xuICAgIHZhciBsYXN0S2V5ID0gbGFzdEJsb2NrLmdldEtleSgpO1xuICAgIHZhciBsZW5ndGggPSBsYXN0QmxvY2suZ2V0TGVuZ3RoKCk7XG5cbiAgICByZXR1cm4gRWRpdG9yU3RhdGUuYWNjZXB0U2VsZWN0aW9uKGVkaXRvclN0YXRlLCBuZXcgU2VsZWN0aW9uU3RhdGUoe1xuICAgICAgYW5jaG9yS2V5OiBsYXN0S2V5LFxuICAgICAgYW5jaG9yT2Zmc2V0OiBsZW5ndGgsXG4gICAgICBmb2N1c0tleTogbGFzdEtleSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBsZW5ndGgsXG4gICAgICBpc0JhY2t3YXJkOiBmYWxzZVxuICAgIH0pKTtcbiAgfTtcblxuICAvKipcbiAgICogRm9yY2UgZm9jdXMgdG8gdGhlIGVuZCBvZiB0aGUgZWRpdG9yLiBUaGlzIGlzIHVzZWZ1bCBpbiBzY2VuYXJpb3NcbiAgICogd2hlcmUgd2Ugd2FudCB0byBwcm9ncmFtbWF0aWNhbGx5IGZvY3VzIHRoZSBpbnB1dCBhbmQgaXQgbWFrZXMgc2Vuc2VcbiAgICogdG8gYWxsb3cgdGhlIHVzZXIgdG8gY29udGludWUgd29ya2luZyBzZWFtbGVzc2x5LlxuICAgKi9cblxuXG4gIEVkaXRvclN0YXRlLm1vdmVGb2N1c1RvRW5kID0gZnVuY3Rpb24gbW92ZUZvY3VzVG9FbmQoZWRpdG9yU3RhdGUpIHtcbiAgICB2YXIgYWZ0ZXJTZWxlY3Rpb25Nb3ZlID0gRWRpdG9yU3RhdGUubW92ZVNlbGVjdGlvblRvRW5kKGVkaXRvclN0YXRlKTtcbiAgICByZXR1cm4gRWRpdG9yU3RhdGUuZm9yY2VTZWxlY3Rpb24oYWZ0ZXJTZWxlY3Rpb25Nb3ZlLCBhZnRlclNlbGVjdGlvbk1vdmUuZ2V0U2VsZWN0aW9uKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdXNoIHRoZSBjdXJyZW50IENvbnRlbnRTdGF0ZSBvbnRvIHRoZSB1bmRvIHN0YWNrIGlmIGl0IHNob3VsZCBiZVxuICAgKiBjb25zaWRlcmVkIGEgYm91bmRhcnkgc3RhdGUsIGFuZCBzZXQgdGhlIHByb3ZpZGVkIENvbnRlbnRTdGF0ZSBhcyB0aGVcbiAgICogbmV3IGN1cnJlbnQgY29udGVudC5cbiAgICovXG5cblxuICBFZGl0b3JTdGF0ZS5wdXNoID0gZnVuY3Rpb24gcHVzaChlZGl0b3JTdGF0ZSwgY29udGVudFN0YXRlLCBjaGFuZ2VUeXBlKSB7XG4gICAgaWYgKGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCkgPT09IGNvbnRlbnRTdGF0ZSkge1xuICAgICAgcmV0dXJuIGVkaXRvclN0YXRlO1xuICAgIH1cblxuICAgIHZhciBmb3JjZVNlbGVjdGlvbiA9IGNoYW5nZVR5cGUgIT09ICdpbnNlcnQtY2hhcmFjdGVycyc7XG4gICAgdmFyIGRpcmVjdGlvbk1hcCA9IEVkaXRvckJpZGlTZXJ2aWNlLmdldERpcmVjdGlvbk1hcChjb250ZW50U3RhdGUsIGVkaXRvclN0YXRlLmdldERpcmVjdGlvbk1hcCgpKTtcblxuICAgIGlmICghZWRpdG9yU3RhdGUuZ2V0QWxsb3dVbmRvKCkpIHtcbiAgICAgIHJldHVybiBFZGl0b3JTdGF0ZS5zZXQoZWRpdG9yU3RhdGUsIHtcbiAgICAgICAgY3VycmVudENvbnRlbnQ6IGNvbnRlbnRTdGF0ZSxcbiAgICAgICAgZGlyZWN0aW9uTWFwOiBkaXJlY3Rpb25NYXAsXG4gICAgICAgIGxhc3RDaGFuZ2VUeXBlOiBjaGFuZ2VUeXBlLFxuICAgICAgICBzZWxlY3Rpb246IGNvbnRlbnRTdGF0ZS5nZXRTZWxlY3Rpb25BZnRlcigpLFxuICAgICAgICBmb3JjZVNlbGVjdGlvbjogZm9yY2VTZWxlY3Rpb24sXG4gICAgICAgIGlubGluZVN0eWxlT3ZlcnJpZGU6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKTtcbiAgICB2YXIgY3VycmVudENvbnRlbnQgPSBlZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpO1xuICAgIHZhciB1bmRvU3RhY2sgPSBlZGl0b3JTdGF0ZS5nZXRVbmRvU3RhY2soKTtcbiAgICB2YXIgbmV3Q29udGVudCA9IGNvbnRlbnRTdGF0ZTtcblxuICAgIGlmIChzZWxlY3Rpb24gIT09IGN1cnJlbnRDb250ZW50LmdldFNlbGVjdGlvbkFmdGVyKCkgfHwgbXVzdEJlY29tZUJvdW5kYXJ5KGVkaXRvclN0YXRlLCBjaGFuZ2VUeXBlKSkge1xuICAgICAgdW5kb1N0YWNrID0gdW5kb1N0YWNrLnB1c2goY3VycmVudENvbnRlbnQpO1xuICAgICAgbmV3Q29udGVudCA9IG5ld0NvbnRlbnQuc2V0KCdzZWxlY3Rpb25CZWZvcmUnLCBzZWxlY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlVHlwZSA9PT0gJ2luc2VydC1jaGFyYWN0ZXJzJyB8fCBjaGFuZ2VUeXBlID09PSAnYmFja3NwYWNlLWNoYXJhY3RlcicgfHwgY2hhbmdlVHlwZSA9PT0gJ2RlbGV0ZS1jaGFyYWN0ZXInKSB7XG4gICAgICAvLyBQcmVzZXJ2ZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLlxuICAgICAgbmV3Q29udGVudCA9IG5ld0NvbnRlbnQuc2V0KCdzZWxlY3Rpb25CZWZvcmUnLCBjdXJyZW50Q29udGVudC5nZXRTZWxlY3Rpb25CZWZvcmUoKSk7XG4gICAgfVxuXG4gICAgdmFyIGlubGluZVN0eWxlT3ZlcnJpZGUgPSBlZGl0b3JTdGF0ZS5nZXRJbmxpbmVTdHlsZU92ZXJyaWRlKCk7XG5cbiAgICAvLyBEb24ndCBkaXNjYXJkIGlubGluZSBzdHlsZSBvdmVycmlkZXMgZm9yIHRoZSBmb2xsb3dpbmcgY2hhbmdlIHR5cGVzOlxuICAgIHZhciBvdmVycmlkZUNoYW5nZVR5cGVzID0gWydhZGp1c3QtZGVwdGgnLCAnY2hhbmdlLWJsb2NrLXR5cGUnLCAnc3BsaXQtYmxvY2snXTtcblxuICAgIGlmIChvdmVycmlkZUNoYW5nZVR5cGVzLmluZGV4T2YoY2hhbmdlVHlwZSkgPT09IC0xKSB7XG4gICAgICBpbmxpbmVTdHlsZU92ZXJyaWRlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZWRpdG9yU3RhdGVDaGFuZ2VzID0ge1xuICAgICAgY3VycmVudENvbnRlbnQ6IG5ld0NvbnRlbnQsXG4gICAgICBkaXJlY3Rpb25NYXA6IGRpcmVjdGlvbk1hcCxcbiAgICAgIHVuZG9TdGFjazogdW5kb1N0YWNrLFxuICAgICAgcmVkb1N0YWNrOiBTdGFjaygpLFxuICAgICAgbGFzdENoYW5nZVR5cGU6IGNoYW5nZVR5cGUsXG4gICAgICBzZWxlY3Rpb246IGNvbnRlbnRTdGF0ZS5nZXRTZWxlY3Rpb25BZnRlcigpLFxuICAgICAgZm9yY2VTZWxlY3Rpb246IGZvcmNlU2VsZWN0aW9uLFxuICAgICAgaW5saW5lU3R5bGVPdmVycmlkZTogaW5saW5lU3R5bGVPdmVycmlkZVxuICAgIH07XG5cbiAgICByZXR1cm4gRWRpdG9yU3RhdGUuc2V0KGVkaXRvclN0YXRlLCBlZGl0b3JTdGF0ZUNoYW5nZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIHRoZSB0b3AgQ29udGVudFN0YXRlIGluIHRoZSB1bmRvIHN0YWNrIHRoZSBuZXcgY3VycmVudCBjb250ZW50IGFuZFxuICAgKiBwdXNoIHRoZSBjdXJyZW50IGNvbnRlbnQgb250byB0aGUgcmVkbyBzdGFjay5cbiAgICovXG5cblxuICBFZGl0b3JTdGF0ZS51bmRvID0gZnVuY3Rpb24gdW5kbyhlZGl0b3JTdGF0ZSkge1xuICAgIGlmICghZWRpdG9yU3RhdGUuZ2V0QWxsb3dVbmRvKCkpIHtcbiAgICAgIHJldHVybiBlZGl0b3JTdGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgdW5kb1N0YWNrID0gZWRpdG9yU3RhdGUuZ2V0VW5kb1N0YWNrKCk7XG4gICAgdmFyIG5ld0N1cnJlbnRDb250ZW50ID0gdW5kb1N0YWNrLnBlZWsoKTtcbiAgICBpZiAoIW5ld0N1cnJlbnRDb250ZW50KSB7XG4gICAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRDb250ZW50ID0gZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKTtcbiAgICB2YXIgZGlyZWN0aW9uTWFwID0gRWRpdG9yQmlkaVNlcnZpY2UuZ2V0RGlyZWN0aW9uTWFwKG5ld0N1cnJlbnRDb250ZW50LCBlZGl0b3JTdGF0ZS5nZXREaXJlY3Rpb25NYXAoKSk7XG5cbiAgICByZXR1cm4gRWRpdG9yU3RhdGUuc2V0KGVkaXRvclN0YXRlLCB7XG4gICAgICBjdXJyZW50Q29udGVudDogbmV3Q3VycmVudENvbnRlbnQsXG4gICAgICBkaXJlY3Rpb25NYXA6IGRpcmVjdGlvbk1hcCxcbiAgICAgIHVuZG9TdGFjazogdW5kb1N0YWNrLnNoaWZ0KCksXG4gICAgICByZWRvU3RhY2s6IGVkaXRvclN0YXRlLmdldFJlZG9TdGFjaygpLnB1c2goY3VycmVudENvbnRlbnQpLFxuICAgICAgZm9yY2VTZWxlY3Rpb246IHRydWUsXG4gICAgICBpbmxpbmVTdHlsZU92ZXJyaWRlOiBudWxsLFxuICAgICAgbGFzdENoYW5nZVR5cGU6ICd1bmRvJyxcbiAgICAgIG5hdGl2ZWx5UmVuZGVyZWRDb250ZW50OiBudWxsLFxuICAgICAgc2VsZWN0aW9uOiBjdXJyZW50Q29udGVudC5nZXRTZWxlY3Rpb25CZWZvcmUoKVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIHRoZSB0b3AgQ29udGVudFN0YXRlIGluIHRoZSByZWRvIHN0YWNrIHRoZSBuZXcgY3VycmVudCBjb250ZW50IGFuZFxuICAgKiBwdXNoIHRoZSBjdXJyZW50IGNvbnRlbnQgb250byB0aGUgdW5kbyBzdGFjay5cbiAgICovXG5cblxuICBFZGl0b3JTdGF0ZS5yZWRvID0gZnVuY3Rpb24gcmVkbyhlZGl0b3JTdGF0ZSkge1xuICAgIGlmICghZWRpdG9yU3RhdGUuZ2V0QWxsb3dVbmRvKCkpIHtcbiAgICAgIHJldHVybiBlZGl0b3JTdGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgcmVkb1N0YWNrID0gZWRpdG9yU3RhdGUuZ2V0UmVkb1N0YWNrKCk7XG4gICAgdmFyIG5ld0N1cnJlbnRDb250ZW50ID0gcmVkb1N0YWNrLnBlZWsoKTtcbiAgICBpZiAoIW5ld0N1cnJlbnRDb250ZW50KSB7XG4gICAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRDb250ZW50ID0gZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKTtcbiAgICB2YXIgZGlyZWN0aW9uTWFwID0gRWRpdG9yQmlkaVNlcnZpY2UuZ2V0RGlyZWN0aW9uTWFwKG5ld0N1cnJlbnRDb250ZW50LCBlZGl0b3JTdGF0ZS5nZXREaXJlY3Rpb25NYXAoKSk7XG5cbiAgICByZXR1cm4gRWRpdG9yU3RhdGUuc2V0KGVkaXRvclN0YXRlLCB7XG4gICAgICBjdXJyZW50Q29udGVudDogbmV3Q3VycmVudENvbnRlbnQsXG4gICAgICBkaXJlY3Rpb25NYXA6IGRpcmVjdGlvbk1hcCxcbiAgICAgIHVuZG9TdGFjazogZWRpdG9yU3RhdGUuZ2V0VW5kb1N0YWNrKCkucHVzaChjdXJyZW50Q29udGVudCksXG4gICAgICByZWRvU3RhY2s6IHJlZG9TdGFjay5zaGlmdCgpLFxuICAgICAgZm9yY2VTZWxlY3Rpb246IHRydWUsXG4gICAgICBpbmxpbmVTdHlsZU92ZXJyaWRlOiBudWxsLFxuICAgICAgbGFzdENoYW5nZVR5cGU6ICdyZWRvJyxcbiAgICAgIG5hdGl2ZWx5UmVuZGVyZWRDb250ZW50OiBudWxsLFxuICAgICAgc2VsZWN0aW9uOiBuZXdDdXJyZW50Q29udGVudC5nZXRTZWxlY3Rpb25BZnRlcigpXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE5vdCBmb3IgcHVibGljIGNvbnN1bXB0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIEVkaXRvclN0YXRlKGltbXV0YWJsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGl0b3JTdGF0ZSk7XG5cbiAgICB0aGlzLl9pbW11dGFibGUgPSBpbW11dGFibGU7XG4gIH1cblxuICAvKipcbiAgICogTm90IGZvciBwdWJsaWMgY29uc3VtcHRpb24uXG4gICAqL1xuXG5cbiAgRWRpdG9yU3RhdGUucHJvdG90eXBlLmdldEltbXV0YWJsZSA9IGZ1bmN0aW9uIGdldEltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW1tdXRhYmxlO1xuICB9O1xuXG4gIHJldHVybiBFZGl0b3JTdGF0ZTtcbn0oKTtcblxuLyoqXG4gKiBTZXQgdGhlIHN1cHBsaWVkIFNlbGVjdGlvblN0YXRlIGFzIHRoZSBuZXcgY3VycmVudCBzZWxlY3Rpb24sIGFuZCBzZXRcbiAqIHRoZSBgZm9yY2VgIGZsYWcgdG8gdHJpZ2dlciBtYW51YWwgc2VsZWN0aW9uIHBsYWNlbWVudCBieSB0aGUgdmlldy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbihlZGl0b3JTdGF0ZSwgc2VsZWN0aW9uLCBmb3JjZVNlbGVjdGlvbikge1xuICByZXR1cm4gRWRpdG9yU3RhdGUuc2V0KGVkaXRvclN0YXRlLCB7XG4gICAgc2VsZWN0aW9uOiBzZWxlY3Rpb24sXG4gICAgZm9yY2VTZWxlY3Rpb246IGZvcmNlU2VsZWN0aW9uLFxuICAgIG5hdGl2ZWx5UmVuZGVyZWRDb250ZW50OiBudWxsLFxuICAgIGlubGluZVN0eWxlT3ZlcnJpZGU6IG51bGxcbiAgfSk7XG59XG5cbi8qKlxuICogUmVnZW5lcmF0ZSB0aGUgZW50aXJlIHRyZWUgbWFwIGZvciBhIGdpdmVuIENvbnRlbnRTdGF0ZSBhbmQgZGVjb3JhdG9yLlxuICogUmV0dXJucyBhbiBPcmRlcmVkTWFwIHRoYXQgbWFwcyBhbGwgYXZhaWxhYmxlIENvbnRlbnRCbG9jayBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZU5ld1RyZWVNYXAoY29udGVudFN0YXRlLCBkZWNvcmF0b3IpIHtcbiAgcmV0dXJuIGNvbnRlbnRTdGF0ZS5nZXRCbG9ja01hcCgpLm1hcChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICByZXR1cm4gQmxvY2tUcmVlLmdlbmVyYXRlKGNvbnRlbnRTdGF0ZSwgYmxvY2ssIGRlY29yYXRvcik7XG4gIH0pLnRvT3JkZXJlZE1hcCgpO1xufVxuXG4vKipcbiAqIFJlZ2VuZXJhdGUgdHJlZSBtYXAgb2JqZWN0cyBmb3IgYWxsIENvbnRlbnRCbG9ja3MgdGhhdCBoYXZlIGNoYW5nZWRcbiAqIGJldHdlZW4gdGhlIGN1cnJlbnQgZWRpdG9yU3RhdGUgYW5kIG5ld0NvbnRlbnQuIFJldHVybnMgYW4gT3JkZXJlZE1hcFxuICogd2l0aCBvbmx5IGNoYW5nZWQgcmVnZW5lcmF0ZWQgdHJlZSBtYXAgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gcmVnZW5lcmF0ZVRyZWVGb3JOZXdCbG9ja3MoZWRpdG9yU3RhdGUsIG5ld0Jsb2NrTWFwLCBuZXdFbnRpdHlNYXAsIGRlY29yYXRvcikge1xuICB2YXIgY29udGVudFN0YXRlID0gZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKS5zZXQoJ2VudGl0eU1hcCcsIG5ld0VudGl0eU1hcCk7XG4gIHZhciBwcmV2QmxvY2tNYXAgPSBjb250ZW50U3RhdGUuZ2V0QmxvY2tNYXAoKTtcbiAgdmFyIHByZXZUcmVlTWFwID0gZWRpdG9yU3RhdGUuZ2V0SW1tdXRhYmxlKCkuZ2V0KCd0cmVlTWFwJyk7XG4gIHJldHVybiBwcmV2VHJlZU1hcC5tZXJnZShuZXdCbG9ja01hcC50b1NlcSgpLmZpbHRlcihmdW5jdGlvbiAoYmxvY2ssIGtleSkge1xuICAgIHJldHVybiBibG9jayAhPT0gcHJldkJsb2NrTWFwLmdldChrZXkpO1xuICB9KS5tYXAoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgcmV0dXJuIEJsb2NrVHJlZS5nZW5lcmF0ZShjb250ZW50U3RhdGUsIGJsb2NrLCBkZWNvcmF0b3IpO1xuICB9KSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgdHJlZSBtYXAgb2JqZWN0cyBmb3IgYSBuZXcgZGVjb3JhdG9yIG9iamVjdCwgcHJlc2VydmluZyBhbnlcbiAqIGRlY29yYXRpb25zIHRoYXQgYXJlIHVuY2hhbmdlZCBmcm9tIHRoZSBwcmV2aW91cyBkZWNvcmF0b3IuXG4gKlxuICogTm90ZSB0aGF0IGluIG9yZGVyIGZvciB0aGlzIHRvIHBlcmZvcm0gb3B0aW1hbGx5LCBkZWNvcmF0aW9uIExpc3RzIGZvclxuICogZGVjb3JhdG9ycyBzaG91bGQgYmUgcHJlc2VydmVkIHdoZW4gcG9zc2libGUgdG8gYWxsb3cgZm9yIGRpcmVjdCBpbW11dGFibGVcbiAqIExpc3QgY29tcGFyaXNvbi5cbiAqL1xuZnVuY3Rpb24gcmVnZW5lcmF0ZVRyZWVGb3JOZXdEZWNvcmF0b3IoY29udGVudCwgYmxvY2tNYXAsIHByZXZpb3VzVHJlZU1hcCwgZGVjb3JhdG9yLCBleGlzdGluZ0RlY29yYXRvcikge1xuICByZXR1cm4gcHJldmlvdXNUcmVlTWFwLm1lcmdlKGJsb2NrTWFwLnRvU2VxKCkuZmlsdGVyKGZ1bmN0aW9uIChibG9jaykge1xuICAgIHJldHVybiBkZWNvcmF0b3IuZ2V0RGVjb3JhdGlvbnMoYmxvY2ssIGNvbnRlbnQpICE9PSBleGlzdGluZ0RlY29yYXRvci5nZXREZWNvcmF0aW9ucyhibG9jaywgY29udGVudCk7XG4gIH0pLm1hcChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICByZXR1cm4gQmxvY2tUcmVlLmdlbmVyYXRlKGNvbnRlbnQsIGJsb2NrLCBkZWNvcmF0b3IpO1xuICB9KSk7XG59XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBjaGFuZ2Ugc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBib3VuZGFyeSBzdGF0ZSwgZ2l2ZW5cbiAqIHRoZSBwcmV2aW91cyBjaGFuZ2UgdHlwZS4gQWxsb3dzIHVzIHRvIGRpc2NhcmQgcG90ZW50aWFsIGJvdW5kYXJ5IHN0YXRlc1xuICogZHVyaW5nIHN0YW5kYXJkIHR5cGluZyBvciBkZWxldGlvbiBiZWhhdmlvci5cbiAqL1xuZnVuY3Rpb24gbXVzdEJlY29tZUJvdW5kYXJ5KGVkaXRvclN0YXRlLCBjaGFuZ2VUeXBlKSB7XG4gIHZhciBsYXN0Q2hhbmdlVHlwZSA9IGVkaXRvclN0YXRlLmdldExhc3RDaGFuZ2VUeXBlKCk7XG4gIHJldHVybiBjaGFuZ2VUeXBlICE9PSBsYXN0Q2hhbmdlVHlwZSB8fCBjaGFuZ2VUeXBlICE9PSAnaW5zZXJ0LWNoYXJhY3RlcnMnICYmIGNoYW5nZVR5cGUgIT09ICdiYWNrc3BhY2UtY2hhcmFjdGVyJyAmJiBjaGFuZ2VUeXBlICE9PSAnZGVsZXRlLWNoYXJhY3Rlcic7XG59XG5cbmZ1bmN0aW9uIGdldElubGluZVN0eWxlRm9yQ29sbGFwc2VkU2VsZWN0aW9uKGNvbnRlbnQsIHNlbGVjdGlvbikge1xuICB2YXIgc3RhcnRLZXkgPSBzZWxlY3Rpb24uZ2V0U3RhcnRLZXkoKTtcbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gc2VsZWN0aW9uLmdldFN0YXJ0T2Zmc2V0KCk7XG4gIHZhciBzdGFydEJsb2NrID0gY29udGVudC5nZXRCbG9ja0ZvcktleShzdGFydEtleSk7XG5cbiAgLy8gSWYgdGhlIGN1cnNvciBpcyBub3QgYXQgdGhlIHN0YXJ0IG9mIHRoZSBibG9jaywgbG9vayBiYWNrd2FyZCB0b1xuICAvLyBwcmVzZXJ2ZSB0aGUgc3R5bGUgb2YgdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIuXG4gIGlmIChzdGFydE9mZnNldCA+IDApIHtcbiAgICByZXR1cm4gc3RhcnRCbG9jay5nZXRJbmxpbmVTdHlsZUF0KHN0YXJ0T2Zmc2V0IC0gMSk7XG4gIH1cblxuICAvLyBUaGUgY2FyZXQgaXMgYXQgcG9zaXRpb24gemVybyBpbiB0aGlzIGJsb2NrLiBJZiB0aGUgYmxvY2sgaGFzIGFueVxuICAvLyB0ZXh0IGF0IGFsbCwgdXNlIHRoZSBzdHlsZSBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyLlxuICBpZiAoc3RhcnRCbG9jay5nZXRMZW5ndGgoKSkge1xuICAgIHJldHVybiBzdGFydEJsb2NrLmdldElubGluZVN0eWxlQXQoMCk7XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGxvb2sgdXB3YXJkIGluIHRoZSBkb2N1bWVudCB0byBmaW5kIHRoZSBjbG9zZXN0IGNoYXJhY3Rlci5cbiAgcmV0dXJuIGxvb2tVcHdhcmRGb3JJbmxpbmVTdHlsZShjb250ZW50LCBzdGFydEtleSk7XG59XG5cbmZ1bmN0aW9uIGdldElubGluZVN0eWxlRm9yTm9uQ29sbGFwc2VkU2VsZWN0aW9uKGNvbnRlbnQsIHNlbGVjdGlvbikge1xuICB2YXIgc3RhcnRLZXkgPSBzZWxlY3Rpb24uZ2V0U3RhcnRLZXkoKTtcbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gc2VsZWN0aW9uLmdldFN0YXJ0T2Zmc2V0KCk7XG4gIHZhciBzdGFydEJsb2NrID0gY29udGVudC5nZXRCbG9ja0ZvcktleShzdGFydEtleSk7XG5cbiAgLy8gSWYgdGhlcmUgaXMgYSBjaGFyYWN0ZXIganVzdCBpbnNpZGUgdGhlIHNlbGVjdGlvbiwgdXNlIGl0cyBzdHlsZS5cbiAgaWYgKHN0YXJ0T2Zmc2V0IDwgc3RhcnRCbG9jay5nZXRMZW5ndGgoKSkge1xuICAgIHJldHVybiBzdGFydEJsb2NrLmdldElubGluZVN0eWxlQXQoc3RhcnRPZmZzZXQpO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIHNlbGVjdGlvbiBhdCB0aGUgZW5kIG9mIGEgbm9uLWVtcHR5IGJsb2NrLiBVc2UgdGhlIGxhc3RcbiAgLy8gc3R5bGUgaW4gdGhlIGJsb2NrLlxuICBpZiAoc3RhcnRPZmZzZXQgPiAwKSB7XG4gICAgcmV0dXJuIHN0YXJ0QmxvY2suZ2V0SW5saW5lU3R5bGVBdChzdGFydE9mZnNldCAtIDEpO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBsb29rIHVwd2FyZCBpbiB0aGUgZG9jdW1lbnQgdG8gZmluZCB0aGUgY2xvc2VzdCBjaGFyYWN0ZXIuXG4gIHJldHVybiBsb29rVXB3YXJkRm9ySW5saW5lU3R5bGUoY29udGVudCwgc3RhcnRLZXkpO1xufVxuXG5mdW5jdGlvbiBsb29rVXB3YXJkRm9ySW5saW5lU3R5bGUoY29udGVudCwgZnJvbUtleSkge1xuICB2YXIgbGFzdE5vbkVtcHR5ID0gY29udGVudC5nZXRCbG9ja01hcCgpLnJldmVyc2UoKS5za2lwVW50aWwoZnVuY3Rpb24gKF8sIGspIHtcbiAgICByZXR1cm4gayA9PT0gZnJvbUtleTtcbiAgfSkuc2tpcCgxKS5za2lwVW50aWwoZnVuY3Rpb24gKGJsb2NrLCBfKSB7XG4gICAgcmV0dXJuIGJsb2NrLmdldExlbmd0aCgpO1xuICB9KS5maXJzdCgpO1xuXG4gIGlmIChsYXN0Tm9uRW1wdHkpIHJldHVybiBsYXN0Tm9uRW1wdHkuZ2V0SW5saW5lU3R5bGVBdChsYXN0Tm9uRW1wdHkuZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgcmV0dXJuIE9yZGVyZWRTZXQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFZGl0b3JTdGF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRWRpdG9yU3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDMyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRHJhZnRNb2RpZmllclxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2hhcmFjdGVyTWV0YWRhdGEgPSByZXF1aXJlKCcuL0NoYXJhY3Rlck1ldGFkYXRhJyk7XG52YXIgQ29udGVudFN0YXRlSW5saW5lU3R5bGUgPSByZXF1aXJlKCcuL0NvbnRlbnRTdGF0ZUlubGluZVN0eWxlJyk7XG52YXIgRHJhZnRGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL0RyYWZ0RmVhdHVyZUZsYWdzJyk7XG52YXIgSW1tdXRhYmxlID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG5cbnZhciBhcHBseUVudGl0eVRvQ29udGVudFN0YXRlID0gcmVxdWlyZSgnLi9hcHBseUVudGl0eVRvQ29udGVudFN0YXRlJyk7XG52YXIgZ2V0Q2hhcmFjdGVyUmVtb3ZhbFJhbmdlID0gcmVxdWlyZSgnLi9nZXRDaGFyYWN0ZXJSZW1vdmFsUmFuZ2UnKTtcbnZhciBnZXRDb250ZW50U3RhdGVGcmFnbWVudCA9IHJlcXVpcmUoJy4vZ2V0Q29udGVudFN0YXRlRnJhZ21lbnQnKTtcbnZhciBpbnNlcnRGcmFnbWVudEludG9Db250ZW50U3RhdGUgPSByZXF1aXJlKCcuL2luc2VydEZyYWdtZW50SW50b0NvbnRlbnRTdGF0ZScpO1xudmFyIGluc2VydFRleHRJbnRvQ29udGVudFN0YXRlID0gcmVxdWlyZSgnLi9pbnNlcnRUZXh0SW50b0NvbnRlbnRTdGF0ZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIG1vZGlmeUJsb2NrRm9yQ29udGVudFN0YXRlID0gcmVxdWlyZSgnLi9tb2RpZnlCbG9ja0ZvckNvbnRlbnRTdGF0ZScpO1xudmFyIHJlbW92ZUVudGl0aWVzQXRFZGdlcyA9IHJlcXVpcmUoJy4vcmVtb3ZlRW50aXRpZXNBdEVkZ2VzJyk7XG52YXIgcmVtb3ZlUmFuZ2VGcm9tQ29udGVudFN0YXRlID0gcmVxdWlyZSgnLi9yZW1vdmVSYW5nZUZyb21Db250ZW50U3RhdGUnKTtcbnZhciBzcGxpdEJsb2NrSW5Db250ZW50U3RhdGUgPSByZXF1aXJlKCcuL3NwbGl0QmxvY2tJbkNvbnRlbnRTdGF0ZScpO1xuXG52YXIgT3JkZXJlZFNldCA9IEltbXV0YWJsZS5PcmRlcmVkU2V0O1xuXG4vKipcbiAqIGBEcmFmdE1vZGlmaWVyYCBwcm92aWRlcyBhIHNldCBvZiBjb252ZW5pZW5jZSBtZXRob2RzIHRoYXQgYXBwbHlcbiAqIG1vZGlmaWNhdGlvbnMgdG8gYSBgQ29udGVudFN0YXRlYCBvYmplY3QgYmFzZWQgb24gYSB0YXJnZXQgYFNlbGVjdGlvblN0YXRlYC5cbiAqXG4gKiBBbnkgY2hhbmdlIHRvIGEgYENvbnRlbnRTdGF0ZWAgc2hvdWxkIGJlIGRlY29tcG9zYWJsZSBpbnRvIGEgc2VyaWVzIG9mXG4gKiB0cmFuc2FjdGlvbiBmdW5jdGlvbnMgdGhhdCBhcHBseSB0aGUgcmVxdWlyZWQgY2hhbmdlcyBhbmQgcmV0dXJuIG91dHB1dFxuICogYENvbnRlbnRTdGF0ZWAgb2JqZWN0cy5cbiAqXG4gKiBUaGVzZSBmdW5jdGlvbnMgZW5jYXBzdWxhdGUgc29tZSBvZiB0aGUgbW9zdCBjb21tb24gdHJhbnNhY3Rpb24gc2VxdWVuY2VzLlxuICovXG5cbnZhciBEcmFmdE1vZGlmaWVyID0ge1xuICByZXBsYWNlVGV4dDogZnVuY3Rpb24gcmVwbGFjZVRleHQoY29udGVudFN0YXRlLCByYW5nZVRvUmVwbGFjZSwgdGV4dCwgaW5saW5lU3R5bGUsIGVudGl0eUtleSkge1xuICAgIHZhciB3aXRob3V0RW50aXRpZXMgPSByZW1vdmVFbnRpdGllc0F0RWRnZXMoY29udGVudFN0YXRlLCByYW5nZVRvUmVwbGFjZSk7XG4gICAgdmFyIHdpdGhvdXRUZXh0ID0gcmVtb3ZlUmFuZ2VGcm9tQ29udGVudFN0YXRlKHdpdGhvdXRFbnRpdGllcywgcmFuZ2VUb1JlcGxhY2UpO1xuXG4gICAgdmFyIGNoYXJhY3RlciA9IENoYXJhY3Rlck1ldGFkYXRhLmNyZWF0ZSh7XG4gICAgICBzdHlsZTogaW5saW5lU3R5bGUgfHwgT3JkZXJlZFNldCgpLFxuICAgICAgZW50aXR5OiBlbnRpdHlLZXkgfHwgbnVsbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluc2VydFRleHRJbnRvQ29udGVudFN0YXRlKHdpdGhvdXRUZXh0LCB3aXRob3V0VGV4dC5nZXRTZWxlY3Rpb25BZnRlcigpLCB0ZXh0LCBjaGFyYWN0ZXIpO1xuICB9LFxuXG4gIGluc2VydFRleHQ6IGZ1bmN0aW9uIGluc2VydFRleHQoY29udGVudFN0YXRlLCB0YXJnZXRSYW5nZSwgdGV4dCwgaW5saW5lU3R5bGUsIGVudGl0eUtleSkge1xuICAgICF0YXJnZXRSYW5nZS5pc0NvbGxhcHNlZCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCByYW5nZSBtdXN0IGJlIGNvbGxhcHNlZCBmb3IgYGluc2VydFRleHRgLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gRHJhZnRNb2RpZmllci5yZXBsYWNlVGV4dChjb250ZW50U3RhdGUsIHRhcmdldFJhbmdlLCB0ZXh0LCBpbmxpbmVTdHlsZSwgZW50aXR5S2V5KTtcbiAgfSxcblxuICBtb3ZlVGV4dDogZnVuY3Rpb24gbW92ZVRleHQoY29udGVudFN0YXRlLCByZW1vdmFsUmFuZ2UsIHRhcmdldFJhbmdlKSB7XG4gICAgdmFyIG1vdmVkRnJhZ21lbnQgPSBnZXRDb250ZW50U3RhdGVGcmFnbWVudChjb250ZW50U3RhdGUsIHJlbW92YWxSYW5nZSk7XG5cbiAgICB2YXIgYWZ0ZXJSZW1vdmFsID0gRHJhZnRNb2RpZmllci5yZW1vdmVSYW5nZShjb250ZW50U3RhdGUsIHJlbW92YWxSYW5nZSwgJ2JhY2t3YXJkJyk7XG5cbiAgICByZXR1cm4gRHJhZnRNb2RpZmllci5yZXBsYWNlV2l0aEZyYWdtZW50KGFmdGVyUmVtb3ZhbCwgdGFyZ2V0UmFuZ2UsIG1vdmVkRnJhZ21lbnQpO1xuICB9LFxuXG4gIHJlcGxhY2VXaXRoRnJhZ21lbnQ6IGZ1bmN0aW9uIHJlcGxhY2VXaXRoRnJhZ21lbnQoY29udGVudFN0YXRlLCB0YXJnZXRSYW5nZSwgZnJhZ21lbnQpIHtcbiAgICB2YXIgd2l0aG91dEVudGl0aWVzID0gcmVtb3ZlRW50aXRpZXNBdEVkZ2VzKGNvbnRlbnRTdGF0ZSwgdGFyZ2V0UmFuZ2UpO1xuICAgIHZhciB3aXRob3V0VGV4dCA9IHJlbW92ZVJhbmdlRnJvbUNvbnRlbnRTdGF0ZSh3aXRob3V0RW50aXRpZXMsIHRhcmdldFJhbmdlKTtcblxuICAgIHJldHVybiBpbnNlcnRGcmFnbWVudEludG9Db250ZW50U3RhdGUod2l0aG91dFRleHQsIHdpdGhvdXRUZXh0LmdldFNlbGVjdGlvbkFmdGVyKCksIGZyYWdtZW50KTtcbiAgfSxcblxuICByZW1vdmVSYW5nZTogZnVuY3Rpb24gcmVtb3ZlUmFuZ2UoY29udGVudFN0YXRlLCByYW5nZVRvUmVtb3ZlLCByZW1vdmFsRGlyZWN0aW9uKSB7XG4gICAgdmFyIHN0YXJ0S2V5ID0gdm9pZCAwLFxuICAgICAgICBlbmRLZXkgPSB2b2lkIDAsXG4gICAgICAgIHN0YXJ0QmxvY2sgPSB2b2lkIDAsXG4gICAgICAgIGVuZEJsb2NrID0gdm9pZCAwO1xuICAgIGlmIChyYW5nZVRvUmVtb3ZlLmdldElzQmFja3dhcmQoKSkge1xuICAgICAgcmFuZ2VUb1JlbW92ZSA9IHJhbmdlVG9SZW1vdmUubWVyZ2Uoe1xuICAgICAgICBhbmNob3JLZXk6IHJhbmdlVG9SZW1vdmUuZ2V0Rm9jdXNLZXkoKSxcbiAgICAgICAgYW5jaG9yT2Zmc2V0OiByYW5nZVRvUmVtb3ZlLmdldEZvY3VzT2Zmc2V0KCksXG4gICAgICAgIGZvY3VzS2V5OiByYW5nZVRvUmVtb3ZlLmdldEFuY2hvcktleSgpLFxuICAgICAgICBmb2N1c09mZnNldDogcmFuZ2VUb1JlbW92ZS5nZXRBbmNob3JPZmZzZXQoKSxcbiAgICAgICAgaXNCYWNrd2FyZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydEtleSA9IHJhbmdlVG9SZW1vdmUuZ2V0QW5jaG9yS2V5KCk7XG4gICAgZW5kS2V5ID0gcmFuZ2VUb1JlbW92ZS5nZXRGb2N1c0tleSgpO1xuICAgIHN0YXJ0QmxvY2sgPSBjb250ZW50U3RhdGUuZ2V0QmxvY2tGb3JLZXkoc3RhcnRLZXkpO1xuICAgIGVuZEJsb2NrID0gY29udGVudFN0YXRlLmdldEJsb2NrRm9yS2V5KGVuZEtleSk7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gcmFuZ2VUb1JlbW92ZS5nZXRTdGFydE9mZnNldCgpO1xuICAgIHZhciBlbmRPZmZzZXQgPSByYW5nZVRvUmVtb3ZlLmdldEVuZE9mZnNldCgpO1xuXG4gICAgdmFyIHN0YXJ0RW50aXR5S2V5ID0gc3RhcnRCbG9jay5nZXRFbnRpdHlBdChzdGFydE9mZnNldCk7XG4gICAgdmFyIGVuZEVudGl0eUtleSA9IGVuZEJsb2NrLmdldEVudGl0eUF0KGVuZE9mZnNldCAtIDEpO1xuXG4gICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgc2VsZWN0aW9uIHN0YXRlIG92ZXJsYXBzIHdpdGggYSBzaW5nbGUgZW50aXR5LlxuICAgIC8vIElmIHNvLCB0cnkgdG8gcmVtb3ZlIHRoZSBhcHByb3ByaWF0ZSBzdWJzdHJpbmcgb2YgdGhlIGVudGl0eSB0ZXh0LlxuICAgIGlmIChzdGFydEtleSA9PT0gZW5kS2V5KSB7XG4gICAgICBpZiAoc3RhcnRFbnRpdHlLZXkgJiYgc3RhcnRFbnRpdHlLZXkgPT09IGVuZEVudGl0eUtleSkge1xuICAgICAgICB2YXIgX2FkanVzdGVkUmVtb3ZhbFJhbmdlID0gZ2V0Q2hhcmFjdGVyUmVtb3ZhbFJhbmdlKGNvbnRlbnRTdGF0ZS5nZXRFbnRpdHlNYXAoKSwgc3RhcnRCbG9jaywgZW5kQmxvY2ssIHJhbmdlVG9SZW1vdmUsIHJlbW92YWxEaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmVtb3ZlUmFuZ2VGcm9tQ29udGVudFN0YXRlKGNvbnRlbnRTdGF0ZSwgX2FkanVzdGVkUmVtb3ZhbFJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFkanVzdGVkUmVtb3ZhbFJhbmdlID0gcmFuZ2VUb1JlbW92ZTtcbiAgICBpZiAoRHJhZnRGZWF0dXJlRmxhZ3MuZHJhZnRfc2VnbWVudGVkX2VudGl0aWVzX2JlaGF2aW9yKSB7XG4gICAgICAvLyBBZGp1c3QgdGhlIHNlbGVjdGlvbiB0byBwcm9wZXJseSBkZWxldGUgc2VnZW1lbnRlZCBhbmQgaW1tdXRhYmxlXG4gICAgICAvLyBlbnRpdGllc1xuICAgICAgYWRqdXN0ZWRSZW1vdmFsUmFuZ2UgPSBnZXRDaGFyYWN0ZXJSZW1vdmFsUmFuZ2UoY29udGVudFN0YXRlLmdldEVudGl0eU1hcCgpLCBzdGFydEJsb2NrLCBlbmRCbG9jaywgcmFuZ2VUb1JlbW92ZSwgcmVtb3ZhbERpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgdmFyIHdpdGhvdXRFbnRpdGllcyA9IHJlbW92ZUVudGl0aWVzQXRFZGdlcyhjb250ZW50U3RhdGUsIGFkanVzdGVkUmVtb3ZhbFJhbmdlKTtcbiAgICByZXR1cm4gcmVtb3ZlUmFuZ2VGcm9tQ29udGVudFN0YXRlKHdpdGhvdXRFbnRpdGllcywgYWRqdXN0ZWRSZW1vdmFsUmFuZ2UpO1xuICB9LFxuXG4gIHNwbGl0QmxvY2s6IGZ1bmN0aW9uIHNwbGl0QmxvY2soY29udGVudFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSkge1xuICAgIHZhciB3aXRob3V0RW50aXRpZXMgPSByZW1vdmVFbnRpdGllc0F0RWRnZXMoY29udGVudFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSk7XG4gICAgdmFyIHdpdGhvdXRUZXh0ID0gcmVtb3ZlUmFuZ2VGcm9tQ29udGVudFN0YXRlKHdpdGhvdXRFbnRpdGllcywgc2VsZWN0aW9uU3RhdGUpO1xuXG4gICAgcmV0dXJuIHNwbGl0QmxvY2tJbkNvbnRlbnRTdGF0ZSh3aXRob3V0VGV4dCwgd2l0aG91dFRleHQuZ2V0U2VsZWN0aW9uQWZ0ZXIoKSk7XG4gIH0sXG5cbiAgYXBwbHlJbmxpbmVTdHlsZTogZnVuY3Rpb24gYXBwbHlJbmxpbmVTdHlsZShjb250ZW50U3RhdGUsIHNlbGVjdGlvblN0YXRlLCBpbmxpbmVTdHlsZSkge1xuICAgIHJldHVybiBDb250ZW50U3RhdGVJbmxpbmVTdHlsZS5hZGQoY29udGVudFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSwgaW5saW5lU3R5bGUpO1xuICB9LFxuXG4gIHJlbW92ZUlubGluZVN0eWxlOiBmdW5jdGlvbiByZW1vdmVJbmxpbmVTdHlsZShjb250ZW50U3RhdGUsIHNlbGVjdGlvblN0YXRlLCBpbmxpbmVTdHlsZSkge1xuICAgIHJldHVybiBDb250ZW50U3RhdGVJbmxpbmVTdHlsZS5yZW1vdmUoY29udGVudFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSwgaW5saW5lU3R5bGUpO1xuICB9LFxuXG4gIHNldEJsb2NrVHlwZTogZnVuY3Rpb24gc2V0QmxvY2tUeXBlKGNvbnRlbnRTdGF0ZSwgc2VsZWN0aW9uU3RhdGUsIGJsb2NrVHlwZSkge1xuICAgIHJldHVybiBtb2RpZnlCbG9ja0ZvckNvbnRlbnRTdGF0ZShjb250ZW50U3RhdGUsIHNlbGVjdGlvblN0YXRlLCBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgIHJldHVybiBibG9jay5tZXJnZSh7IHR5cGU6IGJsb2NrVHlwZSwgZGVwdGg6IDAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgc2V0QmxvY2tEYXRhOiBmdW5jdGlvbiBzZXRCbG9ja0RhdGEoY29udGVudFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSwgYmxvY2tEYXRhKSB7XG4gICAgcmV0dXJuIG1vZGlmeUJsb2NrRm9yQ29udGVudFN0YXRlKGNvbnRlbnRTdGF0ZSwgc2VsZWN0aW9uU3RhdGUsIGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgcmV0dXJuIGJsb2NrLm1lcmdlKHsgZGF0YTogYmxvY2tEYXRhIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIG1lcmdlQmxvY2tEYXRhOiBmdW5jdGlvbiBtZXJnZUJsb2NrRGF0YShjb250ZW50U3RhdGUsIHNlbGVjdGlvblN0YXRlLCBibG9ja0RhdGEpIHtcbiAgICByZXR1cm4gbW9kaWZ5QmxvY2tGb3JDb250ZW50U3RhdGUoY29udGVudFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSwgZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICByZXR1cm4gYmxvY2subWVyZ2UoeyBkYXRhOiBibG9jay5nZXREYXRhKCkubWVyZ2UoYmxvY2tEYXRhKSB9KTtcbiAgICB9KTtcbiAgfSxcblxuICBhcHBseUVudGl0eTogZnVuY3Rpb24gYXBwbHlFbnRpdHkoY29udGVudFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSwgZW50aXR5S2V5KSB7XG4gICAgdmFyIHdpdGhvdXRFbnRpdGllcyA9IHJlbW92ZUVudGl0aWVzQXRFZGdlcyhjb250ZW50U3RhdGUsIHNlbGVjdGlvblN0YXRlKTtcbiAgICByZXR1cm4gYXBwbHlFbnRpdHlUb0NvbnRlbnRTdGF0ZSh3aXRob3V0RW50aXRpZXMsIHNlbGVjdGlvblN0YXRlLCBlbnRpdHlLZXkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWZ0TW9kaWZpZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0TW9kaWZpZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2hhcmFjdGVyTWV0YWRhdGFcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdpbW11dGFibGUnKSxcbiAgICBNYXAgPSBfcmVxdWlyZS5NYXAsXG4gICAgT3JkZXJlZFNldCA9IF9yZXF1aXJlLk9yZGVyZWRTZXQsXG4gICAgUmVjb3JkID0gX3JlcXVpcmUuUmVjb3JkO1xuXG4vLyBJbW11dGFibGUubWFwIGlzIHR5cGVkIHN1Y2ggdGhhdCB0aGUgdmFsdWUgZm9yIGV2ZXJ5IGtleSBpbiB0aGUgbWFwXG4vLyBtdXN0IGJlIHRoZSBzYW1lIHR5cGVcblxuXG52YXIgRU1QVFlfU0VUID0gT3JkZXJlZFNldCgpO1xuXG52YXIgZGVmYXVsdFJlY29yZCA9IHtcbiAgc3R5bGU6IEVNUFRZX1NFVCxcbiAgZW50aXR5OiBudWxsXG59O1xuXG52YXIgQ2hhcmFjdGVyTWV0YWRhdGFSZWNvcmQgPSBSZWNvcmQoZGVmYXVsdFJlY29yZCk7XG5cbnZhciBDaGFyYWN0ZXJNZXRhZGF0YSA9IGZ1bmN0aW9uIChfQ2hhcmFjdGVyTWV0YWRhdGFSZWMpIHtcbiAgX2luaGVyaXRzKENoYXJhY3Rlck1ldGFkYXRhLCBfQ2hhcmFjdGVyTWV0YWRhdGFSZWMpO1xuXG4gIGZ1bmN0aW9uIENoYXJhY3Rlck1ldGFkYXRhKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGFyYWN0ZXJNZXRhZGF0YSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NoYXJhY3Rlck1ldGFkYXRhUmVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgQ2hhcmFjdGVyTWV0YWRhdGEucHJvdG90eXBlLmdldFN0eWxlID0gZnVuY3Rpb24gZ2V0U3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdzdHlsZScpO1xuICB9O1xuXG4gIENoYXJhY3Rlck1ldGFkYXRhLnByb3RvdHlwZS5nZXRFbnRpdHkgPSBmdW5jdGlvbiBnZXRFbnRpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdlbnRpdHknKTtcbiAgfTtcblxuICBDaGFyYWN0ZXJNZXRhZGF0YS5wcm90b3R5cGUuaGFzU3R5bGUgPSBmdW5jdGlvbiBoYXNTdHlsZShzdHlsZSkge1xuICAgIHJldHVybiB0aGlzLmdldFN0eWxlKCkuaW5jbHVkZXMoc3R5bGUpO1xuICB9O1xuXG4gIENoYXJhY3Rlck1ldGFkYXRhLmFwcGx5U3R5bGUgPSBmdW5jdGlvbiBhcHBseVN0eWxlKHJlY29yZCwgc3R5bGUpIHtcbiAgICB2YXIgd2l0aFN0eWxlID0gcmVjb3JkLnNldCgnc3R5bGUnLCByZWNvcmQuZ2V0U3R5bGUoKS5hZGQoc3R5bGUpKTtcbiAgICByZXR1cm4gQ2hhcmFjdGVyTWV0YWRhdGEuY3JlYXRlKHdpdGhTdHlsZSk7XG4gIH07XG5cbiAgQ2hhcmFjdGVyTWV0YWRhdGEucmVtb3ZlU3R5bGUgPSBmdW5jdGlvbiByZW1vdmVTdHlsZShyZWNvcmQsIHN0eWxlKSB7XG4gICAgdmFyIHdpdGhvdXRTdHlsZSA9IHJlY29yZC5zZXQoJ3N0eWxlJywgcmVjb3JkLmdldFN0eWxlKCkucmVtb3ZlKHN0eWxlKSk7XG4gICAgcmV0dXJuIENoYXJhY3Rlck1ldGFkYXRhLmNyZWF0ZSh3aXRob3V0U3R5bGUpO1xuICB9O1xuXG4gIENoYXJhY3Rlck1ldGFkYXRhLmFwcGx5RW50aXR5ID0gZnVuY3Rpb24gYXBwbHlFbnRpdHkocmVjb3JkLCBlbnRpdHlLZXkpIHtcbiAgICB2YXIgd2l0aEVudGl0eSA9IHJlY29yZC5nZXRFbnRpdHkoKSA9PT0gZW50aXR5S2V5ID8gcmVjb3JkIDogcmVjb3JkLnNldCgnZW50aXR5JywgZW50aXR5S2V5KTtcbiAgICByZXR1cm4gQ2hhcmFjdGVyTWV0YWRhdGEuY3JlYXRlKHdpdGhFbnRpdHkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBmdW5jdGlvbiBpbnN0ZWFkIG9mIHRoZSBgQ2hhcmFjdGVyTWV0YWRhdGFgIGNvbnN0cnVjdG9yLlxuICAgKiBTaW5jZSBtb3N0IGNvbnRlbnQgZ2VuZXJhbGx5IHVzZXMgb25seSBhIHZlcnkgc21hbGwgbnVtYmVyIG9mXG4gICAqIHN0eWxlL2VudGl0eSBwZXJtdXRhdGlvbnMsIHdlIGNhbiByZXVzZSB0aGVzZSBvYmplY3RzIGFzIG9mdGVuIGFzXG4gICAqIHBvc3NpYmxlLlxuICAgKi9cblxuXG4gIENoYXJhY3Rlck1ldGFkYXRhLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShjb25maWcpIHtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q29uZmlnID0ge1xuICAgICAgc3R5bGU6IEVNUFRZX1NFVCxcbiAgICAgIGVudGl0eTogbnVsbFxuICAgIH07XG5cbiAgICAvLyBGaWxsIGluIHVuc3BlY2lmaWVkIHByb3BlcnRpZXMsIGlmIG5lY2Vzc2FyeS5cbiAgICB2YXIgY29uZmlnTWFwID0gTWFwKGRlZmF1bHRDb25maWcpLm1lcmdlKGNvbmZpZyk7XG5cbiAgICB2YXIgZXhpc3RpbmcgPSBwb29sLmdldChjb25maWdNYXApO1xuICAgIGlmIChleGlzdGluZykge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cblxuICAgIHZhciBuZXdDaGFyYWN0ZXIgPSBuZXcgQ2hhcmFjdGVyTWV0YWRhdGEoY29uZmlnTWFwKTtcbiAgICBwb29sID0gcG9vbC5zZXQoY29uZmlnTWFwLCBuZXdDaGFyYWN0ZXIpO1xuICAgIHJldHVybiBuZXdDaGFyYWN0ZXI7XG4gIH07XG5cbiAgcmV0dXJuIENoYXJhY3Rlck1ldGFkYXRhO1xufShDaGFyYWN0ZXJNZXRhZGF0YVJlY29yZCk7XG5cbnZhciBFTVBUWSA9IG5ldyBDaGFyYWN0ZXJNZXRhZGF0YSgpO1xudmFyIHBvb2wgPSBNYXAoW1tNYXAoZGVmYXVsdFJlY29yZCksIEVNUFRZXV0pO1xuXG5DaGFyYWN0ZXJNZXRhZGF0YS5FTVBUWSA9IEVNUFRZO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYXJhY3Rlck1ldGFkYXRhO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9DaGFyYWN0ZXJNZXRhZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDb250ZW50QmxvY2tOb2RlXG4gKiBAZm9ybWF0XG4gKiBcbiAqXG4gKiBUaGlzIGZpbGUgaXMgYSBmb3JrIG9mIENvbnRlbnRCbG9jayBhZGRpbmcgc3VwcG9ydCBmb3IgbmVzdGluZyByZWZlcmVuY2VzIGJ5XG4gKiBwcm92aWRpbmcgbGlua3MgdG8gY2hpbGRyZW4sIHBhcmVudCwgcHJldlNpYmxpbmcsIGFuZCBuZXh0U2libGluZy5cbiAqXG4gKiBUaGlzIGlzIHVuc3RhYmxlIGFuZCBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSSBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGJ5XG4gKiBwcm9kdWN0aW9uIHN5c3RlbXMuIFRoaXMgZmlsZSBtYXkgYmUgdXBkYXRlL3JlbW92ZWQgd2l0aG91dCBub3RpY2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDaGFyYWN0ZXJNZXRhZGF0YSA9IHJlcXVpcmUoJy4vQ2hhcmFjdGVyTWV0YWRhdGEnKTtcbnZhciBJbW11dGFibGUgPSByZXF1aXJlKCdpbW11dGFibGUnKTtcblxudmFyIGZpbmRSYW5nZXNJbW11dGFibGUgPSByZXF1aXJlKCcuL2ZpbmRSYW5nZXNJbW11dGFibGUnKTtcblxudmFyIExpc3QgPSBJbW11dGFibGUuTGlzdCxcbiAgICBNYXAgPSBJbW11dGFibGUuTWFwLFxuICAgIE9yZGVyZWRTZXQgPSBJbW11dGFibGUuT3JkZXJlZFNldCxcbiAgICBSZWNvcmQgPSBJbW11dGFibGUuUmVjb3JkLFxuICAgIFJlcGVhdCA9IEltbXV0YWJsZS5SZXBlYXQ7XG5cblxudmFyIEVNUFRZX1NFVCA9IE9yZGVyZWRTZXQoKTtcblxudmFyIGRlZmF1bHRSZWNvcmQgPSB7XG4gIHBhcmVudDogbnVsbCxcbiAgY2hhcmFjdGVyTGlzdDogTGlzdCgpLFxuICBkYXRhOiBNYXAoKSxcbiAgZGVwdGg6IDAsXG4gIGtleTogJycsXG4gIHRleHQ6ICcnLFxuICB0eXBlOiAndW5zdHlsZWQnLFxuICBjaGlsZHJlbjogTGlzdCgpLFxuICBwcmV2U2libGluZzogbnVsbCxcbiAgbmV4dFNpYmxpbmc6IG51bGxcbn07XG5cbnZhciBoYXZlRXF1YWxTdHlsZSA9IGZ1bmN0aW9uIGhhdmVFcXVhbFN0eWxlKGNoYXJBLCBjaGFyQikge1xuICByZXR1cm4gY2hhckEuZ2V0U3R5bGUoKSA9PT0gY2hhckIuZ2V0U3R5bGUoKTtcbn07XG5cbnZhciBoYXZlRXF1YWxFbnRpdHkgPSBmdW5jdGlvbiBoYXZlRXF1YWxFbnRpdHkoY2hhckEsIGNoYXJCKSB7XG4gIHJldHVybiBjaGFyQS5nZXRFbnRpdHkoKSA9PT0gY2hhckIuZ2V0RW50aXR5KCk7XG59O1xuXG52YXIgZGVjb3JhdGVDaGFyYWN0ZXJMaXN0ID0gZnVuY3Rpb24gZGVjb3JhdGVDaGFyYWN0ZXJMaXN0KGNvbmZpZykge1xuICBpZiAoIWNvbmZpZykge1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICB2YXIgY2hhcmFjdGVyTGlzdCA9IGNvbmZpZy5jaGFyYWN0ZXJMaXN0LFxuICAgICAgdGV4dCA9IGNvbmZpZy50ZXh0O1xuXG5cbiAgaWYgKHRleHQgJiYgIWNoYXJhY3Rlckxpc3QpIHtcbiAgICBjb25maWcuY2hhcmFjdGVyTGlzdCA9IExpc3QoUmVwZWF0KENoYXJhY3Rlck1ldGFkYXRhLkVNUFRZLCB0ZXh0Lmxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbnZhciBDb250ZW50QmxvY2tOb2RlID0gZnVuY3Rpb24gKF9SZWNvcmQpIHtcbiAgX2luaGVyaXRzKENvbnRlbnRCbG9ja05vZGUsIF9SZWNvcmQpO1xuXG4gIGZ1bmN0aW9uIENvbnRlbnRCbG9ja05vZGUoKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBkZWZhdWx0UmVjb3JkO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRlbnRCbG9ja05vZGUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWNvcmQuY2FsbCh0aGlzLCBkZWNvcmF0ZUNoYXJhY3Rlckxpc3QocHJvcHMpKSk7XG4gIH1cblxuICBDb250ZW50QmxvY2tOb2RlLnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdrZXknKTtcbiAgfTtcblxuICBDb250ZW50QmxvY2tOb2RlLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3R5cGUnKTtcbiAgfTtcblxuICBDb250ZW50QmxvY2tOb2RlLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3RleHQnKTtcbiAgfTtcblxuICBDb250ZW50QmxvY2tOb2RlLnByb3RvdHlwZS5nZXRDaGFyYWN0ZXJMaXN0ID0gZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyTGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2NoYXJhY3Rlckxpc3QnKTtcbiAgfTtcblxuICBDb250ZW50QmxvY2tOb2RlLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGV4dCgpLmxlbmd0aDtcbiAgfTtcblxuICBDb250ZW50QmxvY2tOb2RlLnByb3RvdHlwZS5nZXREZXB0aCA9IGZ1bmN0aW9uIGdldERlcHRoKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnZGVwdGgnKTtcbiAgfTtcblxuICBDb250ZW50QmxvY2tOb2RlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2RhdGEnKTtcbiAgfTtcblxuICBDb250ZW50QmxvY2tOb2RlLnByb3RvdHlwZS5nZXRJbmxpbmVTdHlsZUF0ID0gZnVuY3Rpb24gZ2V0SW5saW5lU3R5bGVBdChvZmZzZXQpIHtcbiAgICB2YXIgY2hhcmFjdGVyID0gdGhpcy5nZXRDaGFyYWN0ZXJMaXN0KCkuZ2V0KG9mZnNldCk7XG4gICAgcmV0dXJuIGNoYXJhY3RlciA/IGNoYXJhY3Rlci5nZXRTdHlsZSgpIDogRU1QVFlfU0VUO1xuICB9O1xuXG4gIENvbnRlbnRCbG9ja05vZGUucHJvdG90eXBlLmdldEVudGl0eUF0ID0gZnVuY3Rpb24gZ2V0RW50aXR5QXQob2Zmc2V0KSB7XG4gICAgdmFyIGNoYXJhY3RlciA9IHRoaXMuZ2V0Q2hhcmFjdGVyTGlzdCgpLmdldChvZmZzZXQpO1xuICAgIHJldHVybiBjaGFyYWN0ZXIgPyBjaGFyYWN0ZXIuZ2V0RW50aXR5KCkgOiBudWxsO1xuICB9O1xuXG4gIENvbnRlbnRCbG9ja05vZGUucHJvdG90eXBlLmdldENoaWxkS2V5cyA9IGZ1bmN0aW9uIGdldENoaWxkS2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2NoaWxkcmVuJyk7XG4gIH07XG5cbiAgQ29udGVudEJsb2NrTm9kZS5wcm90b3R5cGUuZ2V0UGFyZW50S2V5ID0gZnVuY3Rpb24gZ2V0UGFyZW50S2V5KCkge1xuICAgIHJldHVybiB0aGlzLmdldCgncGFyZW50Jyk7XG4gIH07XG5cbiAgQ29udGVudEJsb2NrTm9kZS5wcm90b3R5cGUuZ2V0UHJldlNpYmxpbmdLZXkgPSBmdW5jdGlvbiBnZXRQcmV2U2libGluZ0tleSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3ByZXZTaWJsaW5nJyk7XG4gIH07XG5cbiAgQ29udGVudEJsb2NrTm9kZS5wcm90b3R5cGUuZ2V0TmV4dFNpYmxpbmdLZXkgPSBmdW5jdGlvbiBnZXROZXh0U2libGluZ0tleSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ25leHRTaWJsaW5nJyk7XG4gIH07XG5cbiAgQ29udGVudEJsb2NrTm9kZS5wcm90b3R5cGUuZmluZFN0eWxlUmFuZ2VzID0gZnVuY3Rpb24gZmluZFN0eWxlUmFuZ2VzKGZpbHRlckZuLCBjYWxsYmFjaykge1xuICAgIGZpbmRSYW5nZXNJbW11dGFibGUodGhpcy5nZXRDaGFyYWN0ZXJMaXN0KCksIGhhdmVFcXVhbFN0eWxlLCBmaWx0ZXJGbiwgY2FsbGJhY2spO1xuICB9O1xuXG4gIENvbnRlbnRCbG9ja05vZGUucHJvdG90eXBlLmZpbmRFbnRpdHlSYW5nZXMgPSBmdW5jdGlvbiBmaW5kRW50aXR5UmFuZ2VzKGZpbHRlckZuLCBjYWxsYmFjaykge1xuICAgIGZpbmRSYW5nZXNJbW11dGFibGUodGhpcy5nZXRDaGFyYWN0ZXJMaXN0KCksIGhhdmVFcXVhbEVudGl0eSwgZmlsdGVyRm4sIGNhbGxiYWNrKTtcbiAgfTtcblxuICByZXR1cm4gQ29udGVudEJsb2NrTm9kZTtcbn0oUmVjb3JkKGRlZmF1bHRSZWNvcmQpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250ZW50QmxvY2tOb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9Db250ZW50QmxvY2tOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgbnVsbHRocm93cyA9IGZ1bmN0aW9uIG51bGx0aHJvd3MoeCkge1xuICBpZiAoeCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiR290IHVuZXhwZWN0ZWQgbnVsbCBvciB1bmRlZmluZWRcIik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG51bGx0aHJvd3M7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvbnVsbHRocm93cy5qc1xuLy8gbW9kdWxlIGlkID0gMzI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVXNlckFnZW50RGF0YSA9IHJlcXVpcmUoJy4vVXNlckFnZW50RGF0YScpO1xudmFyIFZlcnNpb25SYW5nZSA9IHJlcXVpcmUoJy4vVmVyc2lvblJhbmdlJyk7XG5cbnZhciBtYXBPYmplY3QgPSByZXF1aXJlKCcuL21hcE9iamVjdCcpO1xudmFyIG1lbW9pemVTdHJpbmdPbmx5ID0gcmVxdWlyZSgnLi9tZW1vaXplU3RyaW5nT25seScpO1xuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgd2hldGhlciBgbmFtZWAgYW5kIGB2ZXJzaW9uYCBzYXRpc2Z5IGBxdWVyeWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgYnJvd3NlciwgZGV2aWNlLCBlbmdpbmUgb3IgcGxhdGZvcm1cbiAqIEBwYXJhbSB7P3N0cmluZ30gdmVyc2lvbiBWZXJzaW9uIG9mIHRoZSBicm93c2VyLCBlbmdpbmUgb3IgcGxhdGZvcm1cbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSBRdWVyeSBvZiBmb3JtIFwiTmFtZSBbcmFuZ2UgZXhwcmVzc2lvbl1cIlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IG5vcm1hbGl6ZXIgT3B0aW9uYWwgcHJlLXByb2Nlc3NvciBmb3IgcmFuZ2UgZXhwcmVzc2lvblxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZShuYW1lLCB2ZXJzaW9uLCBxdWVyeSwgbm9ybWFsaXplcikge1xuICAvLyBjaGVjayBmb3IgZXhhY3QgbWF0Y2ggd2l0aCBubyB2ZXJzaW9uXG4gIGlmIChuYW1lID09PSBxdWVyeSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIG5vbi1tYXRjaGluZyBuYW1lc1xuICBpZiAoIXF1ZXJ5LnN0YXJ0c1dpdGgobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBmdWxsIGNvbXBhcmlzb24gd2l0aCB2ZXJzaW9uXG4gIHZhciByYW5nZSA9IHF1ZXJ5LnNsaWNlKG5hbWUubGVuZ3RoKTtcbiAgaWYgKHZlcnNpb24pIHtcbiAgICByYW5nZSA9IG5vcm1hbGl6ZXIgPyBub3JtYWxpemVyKHJhbmdlKSA6IHJhbmdlO1xuICAgIHJldHVybiBWZXJzaW9uUmFuZ2UuY29udGFpbnMocmFuZ2UsIHZlcnNpb24pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYHZlcnNpb25gIGJ5IHN0cmlwcGluZyBhbnkgXCJOVFwiIHByZWZpeCwgYnV0IG9ubHkgb24gdGhlIFdpbmRvd3NcbiAqIHBsYXRmb3JtLlxuICpcbiAqIE1pbWljcyB0aGUgc3RyaXBwaW5nIHBlcmZvcm1lZCBieSB0aGUgYFVzZXJBZ2VudFdpbmRvd3NQbGF0Zm9ybWAgUEhQIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBsYXRmb3JtVmVyc2lvbih2ZXJzaW9uKSB7XG4gIGlmIChVc2VyQWdlbnREYXRhLnBsYXRmb3JtTmFtZSA9PT0gJ1dpbmRvd3MnKSB7XG4gICAgcmV0dXJuIHZlcnNpb24ucmVwbGFjZSgvXlxccypOVC8sICcnKTtcbiAgfVxuXG4gIHJldHVybiB2ZXJzaW9uO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGNsaWVudC1zaWRlIGFjY2VzcyB0byB0aGUgYXV0aG9yaXRhdGl2ZSBQSFAtZ2VuZXJhdGVkIFVzZXIgQWdlbnRcbiAqIGluZm9ybWF0aW9uIHN1cHBsaWVkIGJ5IHRoZSBzZXJ2ZXIuXG4gKi9cbnZhciBVc2VyQWdlbnQgPSB7XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgVXNlciBBZ2VudCBicm93c2VyIG1hdGNoZXMgYHF1ZXJ5YC5cbiAgICpcbiAgICogYHF1ZXJ5YCBzaG91bGQgYmUgYSBzdHJpbmcgbGlrZSBcIkNocm9tZVwiIG9yIFwiQ2hyb21lID4gMzNcIi5cbiAgICpcbiAgICogVmFsaWQgYnJvd3NlciBuYW1lcyBpbmNsdWRlOlxuICAgKlxuICAgKiAtIEFDQ0VTUyBOZXRGcm9udFxuICAgKiAtIEFPTFxuICAgKiAtIEFtYXpvbiBTaWxrXG4gICAqIC0gQW5kcm9pZFxuICAgKiAtIEJsYWNrQmVycnlcbiAgICogLSBCbGFja0JlcnJ5IFBsYXlCb29rXG4gICAqIC0gQ2hyb21lXG4gICAqIC0gQ2hyb21lIGZvciBpT1NcbiAgICogLSBDaHJvbWUgZnJhbWVcbiAgICogLSBGYWNlYm9vayBQSFAgU0RLXG4gICAqIC0gRmFjZWJvb2sgZm9yIGlPU1xuICAgKiAtIEZpcmVmb3hcbiAgICogLSBJRVxuICAgKiAtIElFIE1vYmlsZVxuICAgKiAtIE1vYmlsZSBTYWZhcmlcbiAgICogLSBNb3Rvcm9sYSBJbnRlcm5ldCBCcm93c2VyXG4gICAqIC0gTm9raWFcbiAgICogLSBPcGVud2F2ZSBNb2JpbGUgQnJvd3NlclxuICAgKiAtIE9wZXJhXG4gICAqIC0gT3BlcmEgTWluaVxuICAgKiAtIE9wZXJhIE1vYmlsZVxuICAgKiAtIFNhZmFyaVxuICAgKiAtIFVJV2ViVmlld1xuICAgKiAtIFVua25vd25cbiAgICogLSB3ZWJPU1xuICAgKiAtIGV0Yy4uLlxuICAgKlxuICAgKiBBbiBhdXRob3JpdGF0aXZlIGxpc3QgY2FuIGJlIGZvdW5kIGluIHRoZSBQSFAgYEJyb3dzZXJEZXRlY3RvcmAgY2xhc3MgYW5kXG4gICAqIHJlbGF0ZWQgY2xhc3NlcyBpbiB0aGUgc2FtZSBmaWxlIChzZWUgY2FsbHMgdG8gYG5ldyBVc2VyQWdlbnRCcm93c2VyYCBoZXJlOlxuICAgKiBodHRwczovL2ZidXJsLmNvbS81MDcyODEwNCkuXG4gICAqXG4gICAqIEBub3RlIEZ1bmN0aW9uIHJlc3VsdHMgYXJlIG1lbW9pemVkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSBRdWVyeSBvZiB0aGUgZm9ybSBcIk5hbWUgW3JhbmdlIGV4cHJlc3Npb25dXCJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQnJvd3NlcjogZnVuY3Rpb24gaXNCcm93c2VyKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoVXNlckFnZW50RGF0YS5icm93c2VyTmFtZSwgVXNlckFnZW50RGF0YS5icm93c2VyRnVsbFZlcnNpb24sIHF1ZXJ5KTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgVXNlciBBZ2VudCBicm93c2VyIHVzZXMgYSAzMiBvciA2NCBiaXQgYXJjaGl0ZWN0dXJlLlxuICAgKlxuICAgKiBAbm90ZSBGdW5jdGlvbiByZXN1bHRzIGFyZSBtZW1vaXplZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgUXVlcnkgb2YgdGhlIGZvcm0gXCIzMlwiIG9yIFwiNjRcIi5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQnJvd3NlckFyY2hpdGVjdHVyZTogZnVuY3Rpb24gaXNCcm93c2VyQXJjaGl0ZWN0dXJlKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoVXNlckFnZW50RGF0YS5icm93c2VyQXJjaGl0ZWN0dXJlLCBudWxsLCBxdWVyeSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIFVzZXIgQWdlbnQgZGV2aWNlIG1hdGNoZXMgYHF1ZXJ5YC5cbiAgICpcbiAgICogYHF1ZXJ5YCBzaG91bGQgYmUgYSBzdHJpbmcgbGlrZSBcImlQaG9uZVwiIG9yIFwiaVBhZFwiLlxuICAgKlxuICAgKiBWYWxpZCBkZXZpY2UgbmFtZXMgaW5jbHVkZTpcbiAgICpcbiAgICogLSBLaW5kbGVcbiAgICogLSBLaW5kbGUgRmlyZVxuICAgKiAtIFVua25vd25cbiAgICogLSBpUGFkXG4gICAqIC0gaVBob25lXG4gICAqIC0gaVBvZFxuICAgKiAtIGV0Yy4uLlxuICAgKlxuICAgKiBBbiBhdXRob3JpdGF0aXZlIGxpc3QgY2FuIGJlIGZvdW5kIGluIHRoZSBQSFAgYERldmljZURldGVjdG9yYCBjbGFzcyBhbmRcbiAgICogcmVsYXRlZCBjbGFzc2VzIGluIHRoZSBzYW1lIGZpbGUgKHNlZSBjYWxscyB0byBgbmV3IFVzZXJBZ2VudERldmljZWAgaGVyZTpcbiAgICogaHR0cHM6Ly9mYnVybC5jb20vNTA3MjgzMzIpLlxuICAgKlxuICAgKiBAbm90ZSBGdW5jdGlvbiByZXN1bHRzIGFyZSBtZW1vaXplZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgUXVlcnkgb2YgdGhlIGZvcm0gXCJOYW1lXCJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRGV2aWNlOiBmdW5jdGlvbiBpc0RldmljZShxdWVyeSkge1xuICAgIHJldHVybiBjb21wYXJlKFVzZXJBZ2VudERhdGEuZGV2aWNlTmFtZSwgbnVsbCwgcXVlcnkpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBVc2VyIEFnZW50IHJlbmRlcmluZyBlbmdpbmUgbWF0Y2hlcyBgcXVlcnlgLlxuICAgKlxuICAgKiBgcXVlcnlgIHNob3VsZCBiZSBhIHN0cmluZyBsaWtlIFwiV2ViS2l0XCIgb3IgXCJXZWJLaXQgPj0gNTM3XCIuXG4gICAqXG4gICAqIFZhbGlkIGVuZ2luZSBuYW1lcyBpbmNsdWRlOlxuICAgKlxuICAgKiAtIEdlY2tvXG4gICAqIC0gUHJlc3RvXG4gICAqIC0gVHJpZGVudFxuICAgKiAtIFdlYktpdFxuICAgKiAtIGV0Yy4uLlxuICAgKlxuICAgKiBBbiBhdXRob3JpdGF0aXZlIGxpc3QgY2FuIGJlIGZvdW5kIGluIHRoZSBQSFAgYFJlbmRlcmluZ0VuZ2luZURldGVjdG9yYFxuICAgKiBjbGFzcyByZWxhdGVkIGNsYXNzZXMgaW4gdGhlIHNhbWUgZmlsZSAoc2VlIGNhbGxzIHRvIGBuZXdcbiAgICogVXNlckFnZW50UmVuZGVyaW5nRW5naW5lYCBoZXJlOiBodHRwczovL2ZidXJsLmNvbS81MDcyODYxNykuXG4gICAqXG4gICAqIEBub3RlIEZ1bmN0aW9uIHJlc3VsdHMgYXJlIG1lbW9pemVkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSBRdWVyeSBvZiB0aGUgZm9ybSBcIk5hbWUgW3JhbmdlIGV4cHJlc3Npb25dXCJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRW5naW5lOiBmdW5jdGlvbiBpc0VuZ2luZShxdWVyeSkge1xuICAgIHJldHVybiBjb21wYXJlKFVzZXJBZ2VudERhdGEuZW5naW5lTmFtZSwgVXNlckFnZW50RGF0YS5lbmdpbmVWZXJzaW9uLCBxdWVyeSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIFVzZXIgQWdlbnQgcGxhdGZvcm0gbWF0Y2hlcyBgcXVlcnlgLlxuICAgKlxuICAgKiBgcXVlcnlgIHNob3VsZCBiZSBhIHN0cmluZyBsaWtlIFwiV2luZG93c1wiIG9yIFwiaU9TIDUgLSA2XCIuXG4gICAqXG4gICAqIFZhbGlkIHBsYXRmb3JtIG5hbWVzIGluY2x1ZGU6XG4gICAqXG4gICAqIC0gQW5kcm9pZFxuICAgKiAtIEJsYWNrQmVycnkgT1NcbiAgICogLSBKYXZhIE1FXG4gICAqIC0gTGludXhcbiAgICogLSBNYWMgT1MgWFxuICAgKiAtIE1hYyBPUyBYIENhbGVuZGFyXG4gICAqIC0gTWFjIE9TIFggSW50ZXJuZXQgQWNjb3VudFxuICAgKiAtIFN5bWJpYW5cbiAgICogLSBTeW1iaWFuT1NcbiAgICogLSBXaW5kb3dzXG4gICAqIC0gV2luZG93cyBNb2JpbGVcbiAgICogLSBXaW5kb3dzIFBob25lXG4gICAqIC0gaU9TXG4gICAqIC0gaU9TIEZhY2Vib29rIEludGVncmF0aW9uIEFjY291bnRcbiAgICogLSBpT1MgRmFjZWJvb2sgU29jaWFsIFNoYXJpbmcgVUlcbiAgICogLSB3ZWJPU1xuICAgKiAtIENocm9tZSBPU1xuICAgKiAtIGV0Yy4uLlxuICAgKlxuICAgKiBBbiBhdXRob3JpdGF0aXZlIGxpc3QgY2FuIGJlIGZvdW5kIGluIHRoZSBQSFAgYFBsYXRmb3JtRGV0ZWN0b3JgIGNsYXNzIGFuZFxuICAgKiByZWxhdGVkIGNsYXNzZXMgaW4gdGhlIHNhbWUgZmlsZSAoc2VlIGNhbGxzIHRvIGBuZXcgVXNlckFnZW50UGxhdGZvcm1gXG4gICAqIGhlcmU6IGh0dHBzOi8vZmJ1cmwuY29tLzUwNzI5MjI2KS5cbiAgICpcbiAgICogQG5vdGUgRnVuY3Rpb24gcmVzdWx0cyBhcmUgbWVtb2l6ZWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IFF1ZXJ5IG9mIHRoZSBmb3JtIFwiTmFtZSBbcmFuZ2UgZXhwcmVzc2lvbl1cIlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNQbGF0Zm9ybTogZnVuY3Rpb24gaXNQbGF0Zm9ybShxdWVyeSkge1xuICAgIHJldHVybiBjb21wYXJlKFVzZXJBZ2VudERhdGEucGxhdGZvcm1OYW1lLCBVc2VyQWdlbnREYXRhLnBsYXRmb3JtRnVsbFZlcnNpb24sIHF1ZXJ5LCBub3JtYWxpemVQbGF0Zm9ybVZlcnNpb24pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBVc2VyIEFnZW50IHBsYXRmb3JtIGlzIGEgMzIgb3IgNjQgYml0IGFyY2hpdGVjdHVyZS5cbiAgICpcbiAgICogQG5vdGUgRnVuY3Rpb24gcmVzdWx0cyBhcmUgbWVtb2l6ZWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IFF1ZXJ5IG9mIHRoZSBmb3JtIFwiMzJcIiBvciBcIjY0XCIuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1BsYXRmb3JtQXJjaGl0ZWN0dXJlOiBmdW5jdGlvbiBpc1BsYXRmb3JtQXJjaGl0ZWN0dXJlKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoVXNlckFnZW50RGF0YS5wbGF0Zm9ybUFyY2hpdGVjdHVyZSwgbnVsbCwgcXVlcnkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcE9iamVjdChVc2VyQWdlbnQsIG1lbW9pemVTdHJpbmdPbmx5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9Vc2VyQWdlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDMzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2VuZXJhdGVSYW5kb21LZXlcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNlZW5LZXlzID0ge307XG52YXIgTVVMVElQTElFUiA9IE1hdGgucG93KDIsIDI0KTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21LZXkoKSB7XG4gIHZhciBrZXkgPSB2b2lkIDA7XG4gIHdoaWxlIChrZXkgPT09IHVuZGVmaW5lZCB8fCBzZWVuS2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8ICFpc05hTigra2V5KSkge1xuICAgIGtleSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1VTFRJUExJRVIpLnRvU3RyaW5nKDMyKTtcbiAgfVxuICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgcmV0dXJuIGtleTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZVJhbmRvbUtleTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZ2VuZXJhdGVSYW5kb21LZXkuanNcbi8vIG1vZHVsZSBpZCA9IDMzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEcmFmdEZlYXR1cmVGbGFnc1xuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRHJhZnRGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL0RyYWZ0RmVhdHVyZUZsYWdzLWNvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFmdEZlYXR1cmVGbGFncztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRHJhZnRGZWF0dXJlRmxhZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDMzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ29udGVudEJsb2NrXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENoYXJhY3Rlck1ldGFkYXRhID0gcmVxdWlyZSgnLi9DaGFyYWN0ZXJNZXRhZGF0YScpO1xudmFyIEltbXV0YWJsZSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xuXG52YXIgZmluZFJhbmdlc0ltbXV0YWJsZSA9IHJlcXVpcmUoJy4vZmluZFJhbmdlc0ltbXV0YWJsZScpO1xuXG52YXIgTGlzdCA9IEltbXV0YWJsZS5MaXN0LFxuICAgIE1hcCA9IEltbXV0YWJsZS5NYXAsXG4gICAgT3JkZXJlZFNldCA9IEltbXV0YWJsZS5PcmRlcmVkU2V0LFxuICAgIFJlY29yZCA9IEltbXV0YWJsZS5SZWNvcmQsXG4gICAgUmVwZWF0ID0gSW1tdXRhYmxlLlJlcGVhdDtcblxuXG52YXIgRU1QVFlfU0VUID0gT3JkZXJlZFNldCgpO1xuXG52YXIgZGVmYXVsdFJlY29yZCA9IHtcbiAga2V5OiAnJyxcbiAgdHlwZTogJ3Vuc3R5bGVkJyxcbiAgdGV4dDogJycsXG4gIGNoYXJhY3Rlckxpc3Q6IExpc3QoKSxcbiAgZGVwdGg6IDAsXG4gIGRhdGE6IE1hcCgpXG59O1xuXG52YXIgQ29udGVudEJsb2NrUmVjb3JkID0gUmVjb3JkKGRlZmF1bHRSZWNvcmQpO1xuXG52YXIgZGVjb3JhdGVDaGFyYWN0ZXJMaXN0ID0gZnVuY3Rpb24gZGVjb3JhdGVDaGFyYWN0ZXJMaXN0KGNvbmZpZykge1xuICBpZiAoIWNvbmZpZykge1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICB2YXIgY2hhcmFjdGVyTGlzdCA9IGNvbmZpZy5jaGFyYWN0ZXJMaXN0LFxuICAgICAgdGV4dCA9IGNvbmZpZy50ZXh0O1xuXG5cbiAgaWYgKHRleHQgJiYgIWNoYXJhY3Rlckxpc3QpIHtcbiAgICBjb25maWcuY2hhcmFjdGVyTGlzdCA9IExpc3QoUmVwZWF0KENoYXJhY3Rlck1ldGFkYXRhLkVNUFRZLCB0ZXh0Lmxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbnZhciBDb250ZW50QmxvY2sgPSBmdW5jdGlvbiAoX0NvbnRlbnRCbG9ja1JlY29yZCkge1xuICBfaW5oZXJpdHMoQ29udGVudEJsb2NrLCBfQ29udGVudEJsb2NrUmVjb3JkKTtcblxuICBmdW5jdGlvbiBDb250ZW50QmxvY2soY29uZmlnKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRlbnRCbG9jayk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbnRlbnRCbG9ja1JlY29yZC5jYWxsKHRoaXMsIGRlY29yYXRlQ2hhcmFjdGVyTGlzdChjb25maWcpKSk7XG4gIH1cblxuICBDb250ZW50QmxvY2sucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uIGdldEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2tleScpO1xuICB9O1xuXG4gIENvbnRlbnRCbG9jay5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCd0eXBlJyk7XG4gIH07XG5cbiAgQ29udGVudEJsb2NrLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3RleHQnKTtcbiAgfTtcblxuICBDb250ZW50QmxvY2sucHJvdG90eXBlLmdldENoYXJhY3Rlckxpc3QgPSBmdW5jdGlvbiBnZXRDaGFyYWN0ZXJMaXN0KCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnY2hhcmFjdGVyTGlzdCcpO1xuICB9O1xuXG4gIENvbnRlbnRCbG9jay5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRleHQoKS5sZW5ndGg7XG4gIH07XG5cbiAgQ29udGVudEJsb2NrLnByb3RvdHlwZS5nZXREZXB0aCA9IGZ1bmN0aW9uIGdldERlcHRoKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnZGVwdGgnKTtcbiAgfTtcblxuICBDb250ZW50QmxvY2sucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnZGF0YScpO1xuICB9O1xuXG4gIENvbnRlbnRCbG9jay5wcm90b3R5cGUuZ2V0SW5saW5lU3R5bGVBdCA9IGZ1bmN0aW9uIGdldElubGluZVN0eWxlQXQob2Zmc2V0KSB7XG4gICAgdmFyIGNoYXJhY3RlciA9IHRoaXMuZ2V0Q2hhcmFjdGVyTGlzdCgpLmdldChvZmZzZXQpO1xuICAgIHJldHVybiBjaGFyYWN0ZXIgPyBjaGFyYWN0ZXIuZ2V0U3R5bGUoKSA6IEVNUFRZX1NFVDtcbiAgfTtcblxuICBDb250ZW50QmxvY2sucHJvdG90eXBlLmdldEVudGl0eUF0ID0gZnVuY3Rpb24gZ2V0RW50aXR5QXQob2Zmc2V0KSB7XG4gICAgdmFyIGNoYXJhY3RlciA9IHRoaXMuZ2V0Q2hhcmFjdGVyTGlzdCgpLmdldChvZmZzZXQpO1xuICAgIHJldHVybiBjaGFyYWN0ZXIgPyBjaGFyYWN0ZXIuZ2V0RW50aXR5KCkgOiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGNvbnRpZ3VvdXMgcmFuZ2Ugb2Ygc3R5bGVzIHdpdGhpbiB0aGUgYmxvY2suXG4gICAqL1xuXG5cbiAgQ29udGVudEJsb2NrLnByb3RvdHlwZS5maW5kU3R5bGVSYW5nZXMgPSBmdW5jdGlvbiBmaW5kU3R5bGVSYW5nZXMoZmlsdGVyRm4sIGNhbGxiYWNrKSB7XG4gICAgZmluZFJhbmdlc0ltbXV0YWJsZSh0aGlzLmdldENoYXJhY3Rlckxpc3QoKSwgaGF2ZUVxdWFsU3R5bGUsIGZpbHRlckZuLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgY29udGlndW91cyByYW5nZSBvZiBlbnRpdGllcyB3aXRoaW4gdGhlIGJsb2NrLlxuICAgKi9cblxuXG4gIENvbnRlbnRCbG9jay5wcm90b3R5cGUuZmluZEVudGl0eVJhbmdlcyA9IGZ1bmN0aW9uIGZpbmRFbnRpdHlSYW5nZXMoZmlsdGVyRm4sIGNhbGxiYWNrKSB7XG4gICAgZmluZFJhbmdlc0ltbXV0YWJsZSh0aGlzLmdldENoYXJhY3Rlckxpc3QoKSwgaGF2ZUVxdWFsRW50aXR5LCBmaWx0ZXJGbiwgY2FsbGJhY2spO1xuICB9O1xuXG4gIHJldHVybiBDb250ZW50QmxvY2s7XG59KENvbnRlbnRCbG9ja1JlY29yZCk7XG5cbmZ1bmN0aW9uIGhhdmVFcXVhbFN0eWxlKGNoYXJBLCBjaGFyQikge1xuICByZXR1cm4gY2hhckEuZ2V0U3R5bGUoKSA9PT0gY2hhckIuZ2V0U3R5bGUoKTtcbn1cblxuZnVuY3Rpb24gaGF2ZUVxdWFsRW50aXR5KGNoYXJBLCBjaGFyQikge1xuICByZXR1cm4gY2hhckEuZ2V0RW50aXR5KCkgPT09IGNoYXJCLmdldEVudGl0eSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRlbnRCbG9jaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvQ29udGVudEJsb2NrLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBVbmljb2RlLWVuYWJsZWQgcmVwbGFjZXNtZW50cyBmb3IgYmFzaWMgU3RyaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbGwgdGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSBhc3N1bWUgdGhhdCB0aGUgaW5wdXQgc3RyaW5nIGlzIGEgdmFsaWRcbiAqIFVURi0xNiBlbmNvZGluZyBvZiBhIFVuaWNvZGUgc2VxdWVuY2UuIElmIGl0J3Mgbm90IHRoZSBjYXNlLCB0aGUgYmVoYXZpb3JcbiAqIHdpbGwgYmUgdW5kZWZpbmVkLlxuICpcbiAqIFdBUk5JTkc6IFNpbmNlIHRoaXMgbW9kdWxlIGlzIHR5cGVjaGVja3MtZW5mb3JjZWQsIHlvdSBtYXkgZmluZCBuZXcgYnVnc1xuICogd2hlbiByZXBsYWNpbmcgbm9ybWFsIFN0cmluZyBmdW5jdGlvbnMgd2l0aCBvbmVzIHByb3ZpZGVkIGhlcmUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLy8gVGhlc2UgdHdvIHJhbmdlcyBhcmUgY29uc2VjdXRpdmUgc28gYW55dGhpbmcgaW4gW0hJR0hfU1RBUlQsIExPV19FTkRdIGlzIGFcbi8vIHN1cnJvZ2F0ZSBjb2RlIHVuaXQuXG52YXIgU1VSUk9HQVRFX0hJR0hfU1RBUlQgPSAweEQ4MDA7XG52YXIgU1VSUk9HQVRFX0hJR0hfRU5EID0gMHhEQkZGO1xudmFyIFNVUlJPR0FURV9MT1dfU1RBUlQgPSAweERDMDA7XG52YXIgU1VSUk9HQVRFX0xPV19FTkQgPSAweERGRkY7XG52YXIgU1VSUk9HQVRFX1VOSVRTX1JFR0VYID0gL1tcXHVEODAwLVxcdURGRkZdLztcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVVuaXQgICBBIFVuaWNvZGUgY29kZS11bml0LCBpbiByYW5nZSBbMCwgMHgxMEZGRkZdXG4gKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgICBXaGV0aGVyIGNvZGUtdW5pdCBpcyBpbiBhIHN1cnJvZ2F0ZSAoaGkvbG93KSByYW5nZVxuICovXG5mdW5jdGlvbiBpc0NvZGVVbml0SW5TdXJyb2dhdGVSYW5nZShjb2RlVW5pdCkge1xuICByZXR1cm4gU1VSUk9HQVRFX0hJR0hfU1RBUlQgPD0gY29kZVVuaXQgJiYgY29kZVVuaXQgPD0gU1VSUk9HQVRFX0xPV19FTkQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSB0d28gY2hhcmFjdGVycyBzdGFydGluZyBhdCBgaW5kZXhgIGZvcm0gYSBzdXJyb2dhdGUgcGFpci5cbiAqIEZvciBleGFtcGxlLCBnaXZlbiB0aGUgc3RyaW5nIHMgPSBcIlxcdUQ4M0RcXHVERTBBXCIsIChzLCAwKSByZXR1cm5zIHRydWUgYW5kXG4gKiAocywgMSkgcmV0dXJucyBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihzdHIsIGluZGV4KSB7XG4gICEoMCA8PSBpbmRleCAmJiBpbmRleCA8IHN0ci5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2lzU3Vycm9nYXRlUGFpcjogSW52YWxpZCBpbmRleCAlcyBmb3Igc3RyaW5nIGxlbmd0aCAlcy4nLCBpbmRleCwgc3RyLmxlbmd0aCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBpZiAoaW5kZXggKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBmaXJzdCA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgdmFyIHNlY29uZCA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gIHJldHVybiBTVVJST0dBVEVfSElHSF9TVEFSVCA8PSBmaXJzdCAmJiBmaXJzdCA8PSBTVVJST0dBVEVfSElHSF9FTkQgJiYgU1VSUk9HQVRFX0xPV19TVEFSVCA8PSBzZWNvbmQgJiYgc2Vjb25kIDw9IFNVUlJPR0FURV9MT1dfRU5EO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgIE5vbi1lbXB0eSBzdHJpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59ICAgIFRydWUgaWYgdGhlIGlucHV0IGluY2x1ZGVzIGFueSBzdXJyb2dhdGUgY29kZSB1bml0c1xuICovXG5mdW5jdGlvbiBoYXNTdXJyb2dhdGVVbml0KHN0cikge1xuICByZXR1cm4gU1VSUk9HQVRFX1VOSVRTX1JFR0VYLnRlc3Qoc3RyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgb3JpZ2luYWwgVW5pY29kZSBjaGFyYWN0ZXIgYXQgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlXG4gKiBTdHJpbmcgYnkgbG9va2luZyBpbnRvIHRoZSBVVEYtMTYgY29kZSB1bml0OyB0aGF0IGlzIGVxdWFsIHRvIDEgZm9yIGFueVxuICogbm9uLXN1cnJvZ2F0ZSBjaGFyYWN0ZXJzIGluIEJNUCAoW1UrMDAwMC4uVStEN0ZGXSBhbmQgW1UrRTAwMCwgVStGRkZGXSk7IGFuZFxuICogcmV0dXJucyAyIGZvciB0aGUgaGkvbG93IHN1cnJvZ2F0ZXMgKFtVK0Q4MDAuLlUrREZGRl0pLCB3aGljaCBhcmUgaW4gZmFjdFxuICogcmVwcmVzZW50aW5nIG5vbi1CTVAgY2hhcmFjdGVycyAoW1UrMTAwMDAuLlUrMTBGRkZGXSkuXG4gKlxuICogRXhhbXBsZXM6XG4gKiAtICdcXHUwMDIwJyA9PiAxXG4gKiAtICdcXHUzMDIwJyA9PiAxXG4gKiAtICdcXHVEODM1JyA9PiAyXG4gKiAtICdcXHVEODM1XFx1RERFRicgPT4gMlxuICogLSAnXFx1RERFRicgPT4gMlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgIE5vbi1lbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgIFBvc2l0aW9uIGluIHRoZSBzdHJpbmcgdG8gbG9vayBmb3Igb25lIGNvZGUgdW5pdFxuICogQHJldHVybiB7bnVtYmVyfSAgICAgIE51bWJlciAxIG9yIDJcbiAqL1xuZnVuY3Rpb24gZ2V0VVRGMTZMZW5ndGgoc3RyLCBwb3MpIHtcbiAgcmV0dXJuIDEgKyBpc0NvZGVVbml0SW5TdXJyb2dhdGVSYW5nZShzdHIuY2hhckNvZGVBdChwb3MpKTtcbn1cblxuLyoqXG4gKiBGdWxseSBVbmljb2RlLWVuYWJsZWQgcmVwbGFjZW1lbnQgZm9yIFN0cmluZyNsZW5ndGhcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyICBWYWxpZCBVbmljb2RlIHN0cmluZ1xuICogQHJldHVybiB7bnVtYmVyfSAgICAgVGhlIG51bWJlciBvZiBVbmljb2RlIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZ1xuICovXG5mdW5jdGlvbiBzdHJsZW4oc3RyKSB7XG4gIC8vIENhbGwgdGhlIG5hdGl2ZSBmdW5jdGlvbnMgaWYgdGhlcmUncyBubyBzdXJyb2dhdGUgY2hhclxuICBpZiAoIWhhc1N1cnJvZ2F0ZVVuaXQoc3RyKSkge1xuICAgIHJldHVybiBzdHIubGVuZ3RoO1xuICB9XG5cbiAgdmFyIGxlbiA9IDA7XG4gIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8IHN0ci5sZW5ndGg7IHBvcyArPSBnZXRVVEYxNkxlbmd0aChzdHIsIHBvcykpIHtcbiAgICBsZW4rKztcbiAgfVxuICByZXR1cm4gbGVuO1xufVxuXG4vKipcbiAqIEZ1bGx5IFVuaWNvZGUtZW5hYmxlZCByZXBsYWNlbWVudCBmb3IgU3RyaW5nI3N1YnN0cigpXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAgICAgIFZhbGlkIFVuaWNvZGUgc3RyaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgICAgTG9jYXRpb24gaW4gVW5pY29kZSBzZXF1ZW5jZSB0byBiZWdpbiBleHRyYWN0aW5nXG4gKiBAcGFyYW0gez9udW1iZXJ9IGxlbmd0aCAgVGhlIG51bWJlciBvZiBVbmljb2RlIGNoYXJhY3RlcnMgdG8gZXh0cmFjdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIChkZWZhdWx0OiB0byB0aGUgZW5kIG9mIHRoZSBzdHJpbmcpXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgRXh0cmFjdGVkIHN1Yi1zdHJpbmdcbiAqL1xuZnVuY3Rpb24gc3Vic3RyKHN0ciwgc3RhcnQsIGxlbmd0aCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiBsZW5ndGggfHwgMDtcblxuICAvLyBDYWxsIHRoZSBuYXRpdmUgZnVuY3Rpb25zIGlmIHRoZXJlJ3Mgbm8gc3Vycm9nYXRlIGNoYXJcbiAgaWYgKCFoYXNTdXJyb2dhdGVVbml0KHN0cikpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuZ3RoKTtcbiAgfVxuXG4gIC8vIE9idmlvdXMgY2FzZXNcbiAgdmFyIHNpemUgPSBzdHIubGVuZ3RoO1xuICBpZiAoc2l6ZSA8PSAwIHx8IHN0YXJ0ID4gc2l6ZSB8fCBsZW5ndGggPD0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGFjdHVhbCBzdGFydGluZyBwb3NpdGlvblxuICB2YXIgcG9zQSA9IDA7XG4gIGlmIChzdGFydCA+IDApIHtcbiAgICBmb3IgKDsgc3RhcnQgPiAwICYmIHBvc0EgPCBzaXplOyBzdGFydC0tKSB7XG4gICAgICBwb3NBICs9IGdldFVURjE2TGVuZ3RoKHN0ciwgcG9zQSk7XG4gICAgfVxuICAgIGlmIChwb3NBID49IHNpemUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhcnQgPCAwKSB7XG4gICAgZm9yIChwb3NBID0gc2l6ZTsgc3RhcnQgPCAwICYmIDAgPCBwb3NBOyBzdGFydCsrKSB7XG4gICAgICBwb3NBIC09IGdldFVURjE2TGVuZ3RoKHN0ciwgcG9zQSAtIDEpO1xuICAgIH1cbiAgICBpZiAocG9zQSA8IDApIHtcbiAgICAgIHBvc0EgPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGFjdHVhbCBlbmRpbmcgcG9zaXRpb25cbiAgdmFyIHBvc0IgPSBzaXplO1xuICBpZiAobGVuZ3RoIDwgc2l6ZSkge1xuICAgIGZvciAocG9zQiA9IHBvc0E7IGxlbmd0aCA+IDAgJiYgcG9zQiA8IHNpemU7IGxlbmd0aC0tKSB7XG4gICAgICBwb3NCICs9IGdldFVURjE2TGVuZ3RoKHN0ciwgcG9zQik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcocG9zQSwgcG9zQik7XG59XG5cbi8qKlxuICogRnVsbHkgVW5pY29kZS1lbmFibGVkIHJlcGxhY2VtZW50IGZvciBTdHJpbmcjc3Vic3RyaW5nKClcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyICAgIFZhbGlkIFVuaWNvZGUgc3RyaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgIExvY2F0aW9uIGluIFVuaWNvZGUgc2VxdWVuY2UgdG8gYmVnaW4gZXh0cmFjdGluZ1xuICogQHBhcmFtIHs/bnVtYmVyfSBlbmQgICBMb2NhdGlvbiBpbiBVbmljb2RlIHNlcXVlbmNlIHRvIGVuZCBleHRyYWN0aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIChkZWZhdWx0OiBlbmQgb2YgdGhlIHN0cmluZylcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgRXh0cmFjdGVkIHN1Yi1zdHJpbmdcbiAqL1xuZnVuY3Rpb24gc3Vic3RyaW5nKHN0ciwgc3RhcnQsIGVuZCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiBlbmQgfHwgMDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kID0gMDtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBNYXRoLmFicyhlbmQgLSBzdGFydCk7XG4gIHN0YXJ0ID0gc3RhcnQgPCBlbmQgPyBzdGFydCA6IGVuZDtcbiAgcmV0dXJuIHN1YnN0cihzdHIsIHN0YXJ0LCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgVW5pY29kZSBjb2RlLXBvaW50cyBmcm9tIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAgICAgICAgVmFsaWQgVW5pY29kZSBzdHJpbmdcbiAqIEByZXR1cm4ge2FycmF5PG51bWJlcj59ICAgIEEgbGlzdCBvZiBjb2RlLXBvaW50cyBpbiBbMC4uMHgxMEZGRkZdXG4gKi9cbmZ1bmN0aW9uIGdldENvZGVQb2ludHMoc3RyKSB7XG4gIHZhciBjb2RlUG9pbnRzID0gW107XG4gIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8IHN0ci5sZW5ndGg7IHBvcyArPSBnZXRVVEYxNkxlbmd0aChzdHIsIHBvcykpIHtcbiAgICBjb2RlUG9pbnRzLnB1c2goc3RyLmNvZGVQb2ludEF0KHBvcykpO1xuICB9XG4gIHJldHVybiBjb2RlUG9pbnRzO1xufVxuXG52YXIgVW5pY29kZVV0aWxzID0ge1xuICBnZXRDb2RlUG9pbnRzOiBnZXRDb2RlUG9pbnRzLFxuICBnZXRVVEYxNkxlbmd0aDogZ2V0VVRGMTZMZW5ndGgsXG4gIGhhc1N1cnJvZ2F0ZVVuaXQ6IGhhc1N1cnJvZ2F0ZVVuaXQsXG4gIGlzQ29kZVVuaXRJblN1cnJvZ2F0ZVJhbmdlOiBpc0NvZGVVbml0SW5TdXJyb2dhdGVSYW5nZSxcbiAgaXNTdXJyb2dhdGVQYWlyOiBpc1N1cnJvZ2F0ZVBhaXIsXG4gIHN0cmxlbjogc3RybGVuLFxuICBzdWJzdHJpbmc6IHN1YnN0cmluZyxcbiAgc3Vic3RyOiBzdWJzdHJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pY29kZVV0aWxzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL1VuaWNvZGVVdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMzM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTZWxlY3Rpb25TdGF0ZVxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBJbW11dGFibGUgPSByZXF1aXJlKCdpbW11dGFibGUnKTtcblxudmFyIFJlY29yZCA9IEltbXV0YWJsZS5SZWNvcmQ7XG5cblxudmFyIGRlZmF1bHRSZWNvcmQgPSB7XG4gIGFuY2hvcktleTogJycsXG4gIGFuY2hvck9mZnNldDogMCxcbiAgZm9jdXNLZXk6ICcnLFxuICBmb2N1c09mZnNldDogMCxcbiAgaXNCYWNrd2FyZDogZmFsc2UsXG4gIGhhc0ZvY3VzOiBmYWxzZVxufTtcblxudmFyIFNlbGVjdGlvblN0YXRlUmVjb3JkID0gUmVjb3JkKGRlZmF1bHRSZWNvcmQpO1xuXG52YXIgU2VsZWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoX1NlbGVjdGlvblN0YXRlUmVjb3JkKSB7XG4gIF9pbmhlcml0cyhTZWxlY3Rpb25TdGF0ZSwgX1NlbGVjdGlvblN0YXRlUmVjb3JkKTtcblxuICBmdW5jdGlvbiBTZWxlY3Rpb25TdGF0ZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0aW9uU3RhdGUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9TZWxlY3Rpb25TdGF0ZVJlY29yZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFNlbGVjdGlvblN0YXRlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuICdBbmNob3I6ICcgKyB0aGlzLmdldEFuY2hvcktleSgpICsgJzonICsgdGhpcy5nZXRBbmNob3JPZmZzZXQoKSArICcsICcgKyAnRm9jdXM6ICcgKyB0aGlzLmdldEZvY3VzS2V5KCkgKyAnOicgKyB0aGlzLmdldEZvY3VzT2Zmc2V0KCkgKyAnLCAnICsgJ0lzIEJhY2t3YXJkOiAnICsgU3RyaW5nKHRoaXMuZ2V0SXNCYWNrd2FyZCgpKSArICcsICcgKyAnSGFzIEZvY3VzOiAnICsgU3RyaW5nKHRoaXMuZ2V0SGFzRm9jdXMoKSk7XG4gIH07XG5cbiAgU2VsZWN0aW9uU3RhdGUucHJvdG90eXBlLmdldEFuY2hvcktleSA9IGZ1bmN0aW9uIGdldEFuY2hvcktleSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2FuY2hvcktleScpO1xuICB9O1xuXG4gIFNlbGVjdGlvblN0YXRlLnByb3RvdHlwZS5nZXRBbmNob3JPZmZzZXQgPSBmdW5jdGlvbiBnZXRBbmNob3JPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdhbmNob3JPZmZzZXQnKTtcbiAgfTtcblxuICBTZWxlY3Rpb25TdGF0ZS5wcm90b3R5cGUuZ2V0Rm9jdXNLZXkgPSBmdW5jdGlvbiBnZXRGb2N1c0tleSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2ZvY3VzS2V5Jyk7XG4gIH07XG5cbiAgU2VsZWN0aW9uU3RhdGUucHJvdG90eXBlLmdldEZvY3VzT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0Rm9jdXNPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdmb2N1c09mZnNldCcpO1xuICB9O1xuXG4gIFNlbGVjdGlvblN0YXRlLnByb3RvdHlwZS5nZXRJc0JhY2t3YXJkID0gZnVuY3Rpb24gZ2V0SXNCYWNrd2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2lzQmFja3dhcmQnKTtcbiAgfTtcblxuICBTZWxlY3Rpb25TdGF0ZS5wcm90b3R5cGUuZ2V0SGFzRm9jdXMgPSBmdW5jdGlvbiBnZXRIYXNGb2N1cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2hhc0ZvY3VzJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgcmFuZ2Ugb3ZlcmxhcHMgd2l0aCBhbiBlZGdlIG9mIHRoZVxuICAgKiBTZWxlY3Rpb25TdGF0ZS5cbiAgICovXG5cblxuICBTZWxlY3Rpb25TdGF0ZS5wcm90b3R5cGUuaGFzRWRnZVdpdGhpbiA9IGZ1bmN0aW9uIGhhc0VkZ2VXaXRoaW4oYmxvY2tLZXksIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgYW5jaG9yS2V5ID0gdGhpcy5nZXRBbmNob3JLZXkoKTtcbiAgICB2YXIgZm9jdXNLZXkgPSB0aGlzLmdldEZvY3VzS2V5KCk7XG5cbiAgICBpZiAoYW5jaG9yS2V5ID09PSBmb2N1c0tleSAmJiBhbmNob3JLZXkgPT09IGJsb2NrS2V5KSB7XG4gICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLmdldFN0YXJ0T2Zmc2V0KCk7XG4gICAgICB2YXIgc2VsZWN0aW9uRW5kID0gdGhpcy5nZXRFbmRPZmZzZXQoKTtcbiAgICAgIHJldHVybiBzdGFydCA8PSBzZWxlY3Rpb25FbmQgJiYgc2VsZWN0aW9uU3RhcnQgPD0gZW5kO1xuICAgIH1cblxuICAgIGlmIChibG9ja0tleSAhPT0gYW5jaG9yS2V5ICYmIGJsb2NrS2V5ICE9PSBmb2N1c0tleSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRUb0NoZWNrID0gYmxvY2tLZXkgPT09IGFuY2hvcktleSA/IHRoaXMuZ2V0QW5jaG9yT2Zmc2V0KCkgOiB0aGlzLmdldEZvY3VzT2Zmc2V0KCk7XG5cbiAgICByZXR1cm4gc3RhcnQgPD0gb2Zmc2V0VG9DaGVjayAmJiBlbmQgPj0gb2Zmc2V0VG9DaGVjaztcbiAgfTtcblxuICBTZWxlY3Rpb25TdGF0ZS5wcm90b3R5cGUuaXNDb2xsYXBzZWQgPSBmdW5jdGlvbiBpc0NvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBbmNob3JLZXkoKSA9PT0gdGhpcy5nZXRGb2N1c0tleSgpICYmIHRoaXMuZ2V0QW5jaG9yT2Zmc2V0KCkgPT09IHRoaXMuZ2V0Rm9jdXNPZmZzZXQoKTtcbiAgfTtcblxuICBTZWxlY3Rpb25TdGF0ZS5wcm90b3R5cGUuZ2V0U3RhcnRLZXkgPSBmdW5jdGlvbiBnZXRTdGFydEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJc0JhY2t3YXJkKCkgPyB0aGlzLmdldEZvY3VzS2V5KCkgOiB0aGlzLmdldEFuY2hvcktleSgpO1xuICB9O1xuXG4gIFNlbGVjdGlvblN0YXRlLnByb3RvdHlwZS5nZXRTdGFydE9mZnNldCA9IGZ1bmN0aW9uIGdldFN0YXJ0T2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmdldElzQmFja3dhcmQoKSA/IHRoaXMuZ2V0Rm9jdXNPZmZzZXQoKSA6IHRoaXMuZ2V0QW5jaG9yT2Zmc2V0KCk7XG4gIH07XG5cbiAgU2VsZWN0aW9uU3RhdGUucHJvdG90eXBlLmdldEVuZEtleSA9IGZ1bmN0aW9uIGdldEVuZEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJc0JhY2t3YXJkKCkgPyB0aGlzLmdldEFuY2hvcktleSgpIDogdGhpcy5nZXRGb2N1c0tleSgpO1xuICB9O1xuXG4gIFNlbGVjdGlvblN0YXRlLnByb3RvdHlwZS5nZXRFbmRPZmZzZXQgPSBmdW5jdGlvbiBnZXRFbmRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SXNCYWNrd2FyZCgpID8gdGhpcy5nZXRBbmNob3JPZmZzZXQoKSA6IHRoaXMuZ2V0Rm9jdXNPZmZzZXQoKTtcbiAgfTtcblxuICBTZWxlY3Rpb25TdGF0ZS5jcmVhdGVFbXB0eSA9IGZ1bmN0aW9uIGNyZWF0ZUVtcHR5KGtleSkge1xuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uU3RhdGUoe1xuICAgICAgYW5jaG9yS2V5OiBrZXksXG4gICAgICBhbmNob3JPZmZzZXQ6IDAsXG4gICAgICBmb2N1c0tleToga2V5LFxuICAgICAgZm9jdXNPZmZzZXQ6IDAsXG4gICAgICBpc0JhY2t3YXJkOiBmYWxzZSxcbiAgICAgIGhhc0ZvY3VzOiBmYWxzZVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTZWxlY3Rpb25TdGF0ZTtcbn0oU2VsZWN0aW9uU3RhdGVSZWNvcmQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdGlvblN0YXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9TZWxlY3Rpb25TdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBtYXJrIHN0cmluZyBsaXRlcmFscyByZXByZXNlbnRpbmcgQ1NTIGNsYXNzIG5hbWVzXG4gKiBzbyB0aGF0IHRoZXkgY2FuIGJlIHRyYW5zZm9ybWVkIHN0YXRpY2FsbHkuIFRoaXMgYWxsb3dzIGZvciBtb2R1bGFyaXphdGlvblxuICogYW5kIG1pbmlmaWNhdGlvbiBvZiBDU1MgY2xhc3MgbmFtZXMuXG4gKlxuICogSW4gc3RhdGljX3Vwc3RyZWFtLCB0aGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IGltcGxlbWVudGVkLCBidXQgaXQgc2hvdWxkXG4gKiBldmVudHVhbGx5IGJlIHJlcGxhY2VkIHdpdGggc29tZXRoaW5nIG1vcmUgZGVzY3JpcHRpdmUsIGFuZCB0aGUgdHJhbnNmb3JtXG4gKiB0aGF0IGlzIHVzZWQgaW4gdGhlIG1haW4gc3RhY2sgc2hvdWxkIGJlIHBvcnRlZCBmb3IgdXNlIGVsc2V3aGVyZS5cbiAqXG4gKiBAcGFyYW0gc3RyaW5nfG9iamVjdCBjbGFzc05hbWUgdG8gbW9kdWxhcml6ZSwgb3IgYW4gb2JqZWN0IG9mIGtleS92YWx1ZXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICBJbiB0aGUgb2JqZWN0IGNhc2UsIHRoZSB2YWx1ZXMgYXJlIGNvbmRpdGlvbnMgdGhhdFxuICogICAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lIGlmIHRoZSBjbGFzc05hbWUga2V5cyBzaG91bGQgYmUgaW5jbHVkZWQuXG4gKiBAcGFyYW0gW3N0cmluZyAuLi5dICBWYXJpYWJsZSBsaXN0IG9mIGNsYXNzTmFtZXMgaW4gdGhlIHN0cmluZyBjYXNlLlxuICogQHJldHVybiBzdHJpbmcgICAgICAgUmVuZGVyYWJsZSBzcGFjZS1zZXBhcmF0ZWQgQ1NTIGNsYXNzTmFtZS5cbiAqL1xuZnVuY3Rpb24gY3goY2xhc3NOYW1lcykge1xuICBpZiAodHlwZW9mIGNsYXNzTmFtZXMgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoY2xhc3NOYW1lcykuZmlsdGVyKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBjbGFzc05hbWVzW2NsYXNzTmFtZV07XG4gICAgfSkubWFwKHJlcGxhY2UpLmpvaW4oJyAnKTtcbiAgfVxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGFyZ3VtZW50cywgcmVwbGFjZSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcLy9nLCAnLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGN4O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2N4LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCdcbmltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi91dGlscy9Nb2RlbCdcbmltcG9ydCBVc2VyIGZyb20gJy4uLy4uL21vZHVsZXMvdXNlci9Vc2VyJ1xuXG5jbGFzcyBBcnRpY2xlIGV4dGVuZHMgTW9kZWwge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuXG4gICAgdGhpcy5pbml0aWFsaXplKHByb3BzKVxuICB9XG5cbiAgaW5pdGlhbGl6ZShwcm9wcykge1xuICAgIHN1cGVyLmluaXRpYWxpemUocHJvcHMpXG5cbiAgICB0aGlzLnNsdWcgPSBwcm9wcy5zbHVnIHx8ICcnXG4gICAgdGhpcy50aXRsZSA9IHByb3BzLnRpdGxlIHx8ICcnXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IHByb3BzLmRlc2NyaXB0aW9uIHx8ICcnXG4gICAgdGhpcy5jb250ZW50ID0gcHJvcHMuY29udGVudCB8fCAnJ1xuICAgIHRoaXMucHVibGlzaGVkID0gcHJvcHMucHVibGlzaGVkIHx8IGZhbHNlXG4gICAgdGhpcy5wdWJsaXNoZWRBdCA9IHByb3BzLnB1Ymxpc2hlZEF0ID8gbW9tZW50KHByb3BzLnB1Ymxpc2hlZEF0KSA6IG51bGxcblxuICAgIC8vIHJlbGF0ZSB1c2VyIG1vZGVsXG4gICAgdGhpcy51c2VyID0gcHJvcHMudXNlciA/IG5ldyBVc2VyKHByb3BzLnVzZXIpIDogbnVsbFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFydGljbGVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvbW9kdWxlcy9hcnRpY2xlL0FydGljbGUuanMiLCJpbXBvcnQgSHR0cCBmcm9tICcuLi8uLi91dGlscy9IdHRwJ1xuaW1wb3J0IFRyYW5zZm9ybWVyIGZyb20gJy4uLy4uL3V0aWxzL1RyYW5zZm9ybWVyJ1xuaW1wb3J0ICogYXMgYXJ0aWNsZUFjdGlvbnMgZnJvbSAnLi9zdG9yZS9hY3Rpb25zJ1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KHBhcm1zKSB7XG4gIHJldHVybiBUcmFuc2Zvcm1lci5zZW5kKHBhcm1zKVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShwYXJhbXMpIHtcbiAgcmV0dXJuIFRyYW5zZm9ybWVyLmZldGNoKHBhcmFtcylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFydGljbGVBZGRSZXF1ZXN0KHBhcmFtcykge1xuICByZXR1cm4gZGlzcGF0Y2ggPT4gKFxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIEh0dHAucG9zdCgnL2FydGljbGVzJywgdHJhbnNmb3JtUmVxdWVzdChwYXJhbXMpKVxuICAgICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICAgIGRpc3BhdGNoKGFydGljbGVBY3Rpb25zLmFkZCh0cmFuc2Zvcm1SZXNwb25zZShyZXMuZGF0YSkpKVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gZXJyLnJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gNDIyKSB7XG4gICAgICAgICAgICBjb25zdCByZXNldEVycm9ycyA9IHtcbiAgICAgICAgICAgICAgZXJyb3JzOiBlcnIucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICAgICAgcmVwbGFjZTogZmFsc2UsXG4gICAgICAgICAgICAgIHNlYXJjaFN0cjogJycsXG4gICAgICAgICAgICAgIHJlcGxhY2VTdHI6ICcnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRhdGEuZXJyb3IgPSBUcmFuc2Zvcm1lci5yZXNldFZhbGlkYXRpb25GaWVsZHMocmVzZXRFcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzQ29kZSA9PT0gNDAxKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yID0gZXJyLnJlc3BvbnNlLmRhdGEubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChkYXRhKTtcbiAgICAgICAgfSlcbiAgICB9KVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnRpY2xlVXBkYXRlUmVxdWVzdChwYXJhbXMpIHtcbiAgcmV0dXJuIGRpc3BhdGNoID0+IChcbiAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBIdHRwLnBhdGNoKGBhcnRpY2xlcy8ke3BhcmFtcy5pZH1gLCB0cmFuc2Zvcm1SZXF1ZXN0KHBhcmFtcykpXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2goYXJ0aWNsZUFjdGlvbnMuYWRkKHRyYW5zZm9ybVJlc3BvbnNlKHJlcy5kYXRhKSkpXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBlcnIucmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChzdGF0dXNDb2RlID09PSA0MjIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0RXJyb3JzID0ge1xuICAgICAgICAgICAgICBlcnJvcnM6IGVyci5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgICAgICByZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgc2VhcmNoU3RyOiAnJyxcbiAgICAgICAgICAgICAgcmVwbGFjZVN0cjogJycsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YS5lcnJvciA9IFRyYW5zZm9ybWVyLnJlc2V0VmFsaWRhdGlvbkZpZWxkcyhyZXNldEVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXNDb2RlID09PSA0MDEpIHtcbiAgICAgICAgICAgIGRhdGEuZXJyb3IgPSBlcnIucmVzcG9uc2UuZGF0YS5tZXNzYWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGRhdGEpO1xuICAgICAgICB9KVxuICAgIH0pXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFydGljbGVSZW1vdmVSZXF1ZXN0KGlkKSB7XG4gIHJldHVybiBkaXNwYXRjaCA9PiB7XG4gICAgSHR0cC5kZWxldGUoYGFydGljbGVzLyR7aWR9YClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goYXJ0aWNsZUFjdGlvbnMucmVtb3ZlKGlkKSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAvLyBUT0RPOiBoYW5kbGUgZXJyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLnJlc3BvbnNlKVxuICAgICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJ0aWNsZUxpc3RSZXF1ZXN0KHtwYWdlTnVtYmVyID0gMSwgdXJsID0gJy9hcnRpY2xlcyd9KSB7XG4gIHJldHVybiBkaXNwYXRjaCA9PiB7XG4gICAgaWYgKHBhZ2VOdW1iZXIgPiAxKSB7XG4gICAgICB1cmwgPSB1cmwgKyBgP3BhZ2U9JHtwYWdlTnVtYmVyfWBcbiAgICB9XG5cbiAgICBIdHRwLmdldCh1cmwpXG4gICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKGFydGljbGVBY3Rpb25zLmxpc3QodHJhbnNmb3JtUmVzcG9uc2UocmVzLmRhdGEpKSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAvLyBUT0RPOiBoYW5kbGUgZXJyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLnJlc3BvbnNlKVxuICAgICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJ0aWNsZUVkaXRSZXF1ZXN0KGlkKSB7XG4gIHJldHVybiBkaXNwYXRjaCA9PiB7XG4gICAgSHR0cC5nZXQoYGFydGljbGVzLyR7aWR9YClcbiAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goYXJ0aWNsZUFjdGlvbnMuYWRkKHRyYW5zZm9ybVJlc3BvbnNlKHJlcy5kYXRhKSkpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIGVyclxuICAgICAgICBjb25zb2xlLmVycm9yKGVyci5yZXNwb25zZSlcbiAgICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFydGljbGVGZXRjaFJlcXVlc3Qoc2x1Zykge1xuICByZXR1cm4gZGlzcGF0Y2ggPT4ge1xuICAgIEh0dHAuZ2V0KGBhcnRpY2xlcy9wdWJsaXNoZWQvJHtzbHVnfWApXG4gICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKGFydGljbGVBY3Rpb25zLmFkZCh0cmFuc2Zvcm1SZXNwb25zZShyZXMuZGF0YSkpKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSBlcnJcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIucmVzcG9uc2UpXG4gICAgICB9KVxuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9tb2R1bGVzL2FydGljbGUvc2VydmljZS5qcyIsIi8qID09PT09PT09PT09PVxuICogQWN0aW9ucyBmb3IgdGhlIGFydGljbGUgbW9kdWxlXG4gKiA9PT09PT09PT09PT1cbiAqXG4gKiBUaGUgYWN0aW9ucyB0aGF0IGFyZSBhdmFpbGFibGUgb24gdGhlXG4gKiBhcnRpY2xlIG1vZHVsZS5cbiAqL1xuXG5pbXBvcnQge1xuICBBUlRJQ0xFX0FERCxcbiAgQVJUSUNMRV9VUERBVEUsXG4gIEFSVElDTEVfUkVNT1ZFLFxuICBBUlRJQ0xFX0xJU1QsXG59IGZyb20gJy4vYWN0aW9uLXR5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChwYXlsb2FkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVJUSUNMRV9BREQsXG4gICAgcGF5bG9hZFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGUocGF5bG9hZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFSVElDTEVfVVBEQVRFLFxuICAgIHBheWxvYWRcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKHBheWxvYWQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBUlRJQ0xFX1JFTU9WRSxcbiAgICBwYXlsb2FkXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3QocGF5bG9hZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFSVElDTEVfTElTVCxcbiAgICBwYXlsb2FkXG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL2pzL21vZHVsZXMvYXJ0aWNsZS9zdG9yZS9hY3Rpb25zLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBCbG9ja01hcEJ1aWxkZXJcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEltbXV0YWJsZSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xuXG52YXIgT3JkZXJlZE1hcCA9IEltbXV0YWJsZS5PcmRlcmVkTWFwO1xuXG5cbnZhciBCbG9ja01hcEJ1aWxkZXIgPSB7XG4gIGNyZWF0ZUZyb21BcnJheTogZnVuY3Rpb24gY3JlYXRlRnJvbUFycmF5KGJsb2Nrcykge1xuICAgIHJldHVybiBPcmRlcmVkTWFwKGJsb2Nrcy5tYXAoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICByZXR1cm4gW2Jsb2NrLmdldEtleSgpLCBibG9ja107XG4gICAgfSkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJsb2NrTWFwQnVpbGRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvQmxvY2tNYXBCdWlsZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZpbmRSYW5nZXNJbW11dGFibGVcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTZWFyY2ggdGhyb3VnaCBhbiBhcnJheSB0byBmaW5kIGNvbnRpZ3VvdXMgc3RyZXRjaGVzIG9mIGVsZW1lbnRzIHRoYXRcbiAqIG1hdGNoIGEgc3BlY2lmaWVkIGZpbHRlciBmdW5jdGlvbi5cbiAqXG4gKiBXaGVuIHJhbmdlcyBhcmUgZm91bmQsIGV4ZWN1dGUgYSBzcGVjaWZpZWQgYGZvdW5kYCBmdW5jdGlvbiB0byBzdXBwbHlcbiAqIHRoZSB2YWx1ZXMgdG8gdGhlIGNhbGxlci5cbiAqL1xuZnVuY3Rpb24gZmluZFJhbmdlc0ltbXV0YWJsZShoYXlzdGFjaywgYXJlRXF1YWxGbiwgZmlsdGVyRm4sIGZvdW5kRm4pIHtcbiAgaWYgKCFoYXlzdGFjay5zaXplKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnNvciA9IDA7XG5cbiAgaGF5c3RhY2sucmVkdWNlKGZ1bmN0aW9uICh2YWx1ZSwgbmV4dFZhbHVlLCBuZXh0SW5kZXgpIHtcbiAgICBpZiAoIWFyZUVxdWFsRm4odmFsdWUsIG5leHRWYWx1ZSkpIHtcbiAgICAgIGlmIChmaWx0ZXJGbih2YWx1ZSkpIHtcbiAgICAgICAgZm91bmRGbihjdXJzb3IsIG5leHRJbmRleCk7XG4gICAgICB9XG4gICAgICBjdXJzb3IgPSBuZXh0SW5kZXg7XG4gICAgfVxuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH0pO1xuXG4gIGZpbHRlckZuKGhheXN0YWNrLmxhc3QoKSkgJiYgZm91bmRGbihjdXJzb3IsIGhheXN0YWNrLmNvdW50KCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRSYW5nZXNJbW11dGFibGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2ZpbmRSYW5nZXNJbW11dGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDM0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNFdmVudEhhbmRsZWRcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciBvciBub3QgdGhlIHZhbHVlIHJldHVybmVkXG4gKiBmcm9tIGEgaGFuZGxlciBpbmRpY2F0ZXMgdGhhdCBpdCB3YXMgaGFuZGxlZC5cbiAqL1xuZnVuY3Rpb24gaXNFdmVudEhhbmRsZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSAnaGFuZGxlZCcgfHwgdmFsdWUgPT09IHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudEhhbmRsZWQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2lzRXZlbnRIYW5kbGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHJlbW92ZVRleHRXaXRoU3RyYXRlZ3lcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERyYWZ0TW9kaWZpZXIgPSByZXF1aXJlKCcuL0RyYWZ0TW9kaWZpZXInKTtcblxuLyoqXG4gKiBGb3IgYSBjb2xsYXBzZWQgc2VsZWN0aW9uIHN0YXRlLCByZW1vdmUgdGV4dCBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIHN0cmF0ZWd5LlxuICogSWYgdGhlIHNlbGVjdGlvbiBzdGF0ZSBpcyBub3QgY29sbGFwc2VkLCByZW1vdmUgdGhlIGVudGlyZSBzZWxlY3RlZCByYW5nZS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlVGV4dFdpdGhTdHJhdGVneShlZGl0b3JTdGF0ZSwgc3RyYXRlZ3ksIGRpcmVjdGlvbikge1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBjb250ZW50ID0gZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKTtcbiAgdmFyIHRhcmdldCA9IHNlbGVjdGlvbjtcbiAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICBpZiAoZWRpdG9yU3RhdGUuaXNTZWxlY3Rpb25BdEVuZE9mQ29udGVudCgpKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWRpdG9yU3RhdGUuaXNTZWxlY3Rpb25BdFN0YXJ0T2ZDb250ZW50KCkpIHtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cblxuICAgIHRhcmdldCA9IHN0cmF0ZWd5KGVkaXRvclN0YXRlKTtcbiAgICBpZiAodGFyZ2V0ID09PSBzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gRHJhZnRNb2RpZmllci5yZW1vdmVSYW5nZShjb250ZW50LCB0YXJnZXQsIGRpcmVjdGlvbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVtb3ZlVGV4dFdpdGhTdHJhdGVneTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvcmVtb3ZlVGV4dFdpdGhTdHJhdGVneS5qc1xuLy8gbW9kdWxlIGlkID0gMzQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gICogcmVlLXZhbGlkYXRlIHYyLjAuM1xuICAqIChjKSAyMDE4IE1vZWVuIEJhc3JhXG4gICogQGxpY2Vuc2UgTUlUXG4gICovXG4vKipcbiAqIEZvcm1hdGVzIGZpbGUgc2l6ZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHNpemVcbiAqL1xudmFyIGZvcm1hdEZpbGVTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgdmFyIHVuaXRzID0gWydCeXRlJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ107XG4gIHZhciB0aHJlc2hvbGQgPSAxMDI0O1xuICBzaXplID0gTnVtYmVyKHNpemUpICogdGhyZXNob2xkO1xuICB2YXIgaSA9IHNpemUgPT09IDAgPyAwIDogTWF0aC5mbG9vcihNYXRoLmxvZyhzaXplKSAvIE1hdGgubG9nKHRocmVzaG9sZCkpO1xuICByZXR1cm4gKCgoc2l6ZSAvIE1hdGgucG93KHRocmVzaG9sZCwgaSkpLnRvRml4ZWQoMikgKiAxKSArIFwiIFwiICsgKHVuaXRzW2ldKSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB2ZWUtdmFsaWRhdGUgaXMgZGVmaW5lZCBnbG9iYWxseS5cbiAqL1xudmFyIGlzRGVmaW5lZEdsb2JhbGx5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIFZlZVZhbGlkYXRlICE9PSAndW5kZWZpbmVkJztcbn07XG5cbnZhciBvYmo7XG52YXIgbWVzc2FnZXMgPSB7XG4gIF9kZWZhdWx0OiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgdmFsdWUgaXMgbm90IHZhbGlkLlwiKTsgfSxcbiAgYWZ0ZXI6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgdmFyIHRhcmdldCA9IHJlZlswXTtcbiAgICB2YXIgaW5jbHVzaW9uID0gcmVmWzFdO1xuXG4gICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgbXVzdCBiZSBhZnRlciBcIiArIChpbmNsdXNpb24gPyAnb3IgZXF1YWwgdG8gJyA6ICcnKSArIHRhcmdldCArIFwiLlwiKTtcbn0sXG4gIGFscGhhX2Rhc2g6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtYXkgY29udGFpbiBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMgYXMgd2VsbCBhcyBkYXNoZXMgYW5kIHVuZGVyc2NvcmVzLlwiKTsgfSxcbiAgYWxwaGFfbnVtOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbWF5IG9ubHkgY29udGFpbiBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMuXCIpOyB9LFxuICBhbHBoYV9zcGFjZXM6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtYXkgb25seSBjb250YWluIGFscGhhYmV0aWMgY2hhcmFjdGVycyBhcyB3ZWxsIGFzIHNwYWNlcy5cIik7IH0sXG4gIGFscGhhOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbWF5IG9ubHkgY29udGFpbiBhbHBoYWJldGljIGNoYXJhY3RlcnMuXCIpOyB9LFxuICBiZWZvcmU6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgdmFyIHRhcmdldCA9IHJlZlswXTtcbiAgICB2YXIgaW5jbHVzaW9uID0gcmVmWzFdO1xuXG4gICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgbXVzdCBiZSBiZWZvcmUgXCIgKyAoaW5jbHVzaW9uID8gJ29yIGVxdWFsIHRvICcgOiAnJykgKyB0YXJnZXQgKyBcIi5cIik7XG59LFxuICBiZXR3ZWVuOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xuICAgIHZhciBtaW4gPSByZWZbMF07XG4gICAgdmFyIG1heCA9IHJlZlsxXTtcblxuICAgIHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgYmV0d2VlbiBcIiArIG1pbiArIFwiIGFuZCBcIiArIG1heCArIFwiLlwiKTtcbn0sXG4gIGNvbmZpcm1lZDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGNvbmZpcm1hdGlvbiBkb2VzIG5vdCBtYXRjaC5cIik7IH0sXG4gIGNyZWRpdF9jYXJkOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgaXMgaW52YWxpZC5cIik7IH0sXG4gIGRhdGVfYmV0d2VlbjogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICB2YXIgbWluID0gcmVmWzBdO1xuICAgIHZhciBtYXggPSByZWZbMV07XG5cbiAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBtdXN0IGJlIGJldHdlZW4gXCIgKyBtaW4gKyBcIiBhbmQgXCIgKyBtYXggKyBcIi5cIik7XG59LFxuICBkYXRlX2Zvcm1hdDogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICB2YXIgZm9ybWF0ID0gcmVmWzBdO1xuXG4gICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgbXVzdCBiZSBpbiB0aGUgZm9ybWF0IFwiICsgZm9ybWF0ICsgXCIuXCIpO1xufSxcbiAgZGVjaW1hbDogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0gW107XG4gICAgdmFyIGRlY2ltYWxzID0gcmVmWzBdOyBpZiAoIGRlY2ltYWxzID09PSB2b2lkIDAgKSBkZWNpbWFscyA9ICcqJztcblxuICAgIHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgbnVtZXJpYyBhbmQgbWF5IGNvbnRhaW4gXCIgKyAoIWRlY2ltYWxzIHx8IGRlY2ltYWxzID09PSAnKicgPyAnJyA6IGRlY2ltYWxzKSArIFwiIGRlY2ltYWwgcG9pbnRzLlwiKTtcbn0sXG4gIGRpZ2l0czogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICB2YXIgbGVuZ3RoID0gcmVmWzBdO1xuXG4gICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBudW1lcmljIGFuZCBleGFjdGx5IGNvbnRhaW4gXCIgKyBsZW5ndGggKyBcIiBkaWdpdHMuXCIpO1xufSxcbiAgZGltZW5zaW9uczogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICB2YXIgd2lkdGggPSByZWZbMF07XG4gICAgdmFyIGhlaWdodCA9IHJlZlsxXTtcblxuICAgIHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgXCIgKyB3aWR0aCArIFwiIHBpeGVscyBieSBcIiArIGhlaWdodCArIFwiIHBpeGVscy5cIik7XG59LFxuICBlbWFpbDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgYSB2YWxpZCBlbWFpbC5cIik7IH0sXG4gIGV4dDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgYSB2YWxpZCBmaWxlLlwiKTsgfSxcbiAgaW1hZ2U6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGJlIGFuIGltYWdlLlwiKTsgfSxcbiAgaW46IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgdmFsdWUuXCIpOyB9LFxuICBpbnRlZ2VyOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTsgfSxcbiAgaXA6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgaXAgYWRkcmVzcy5cIik7IH0sXG4gIGxlbmd0aDogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICB2YXIgbGVuZ3RoID0gcmVmWzBdO1xuICAgIHZhciBtYXggPSByZWZbMV07XG5cbiAgICBpZiAobWF4KSB7XG4gICAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBsZW5ndGggYmUgYmV0d2VlbiBcIiArIGxlbmd0aCArIFwiIGFuZCBcIiArIG1heCArIFwiLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBsZW5ndGggbXVzdCBiZSBcIiArIGxlbmd0aCArIFwiLlwiKTtcbiAgfSxcbiAgbWF4OiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xuICAgIHZhciBsZW5ndGggPSByZWZbMF07XG5cbiAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiBcIiArIGxlbmd0aCArIFwiIGNoYXJhY3RlcnMuXCIpO1xufSxcbiAgbWF4X3ZhbHVlOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xuICAgIHZhciBtYXggPSByZWZbMF07XG5cbiAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGJlIFwiICsgbWF4ICsgXCIgb3IgbGVzcy5cIik7XG59LFxuICBtaW1lczogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgaGF2ZSBhIHZhbGlkIGZpbGUgdHlwZS5cIik7IH0sXG4gIG1pbjogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICB2YXIgbGVuZ3RoID0gcmVmWzBdO1xuXG4gICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBhdCBsZWFzdCBcIiArIGxlbmd0aCArIFwiIGNoYXJhY3RlcnMuXCIpO1xufSxcbiAgbWluX3ZhbHVlOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xuICAgIHZhciBtaW4gPSByZWZbMF07XG5cbiAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGJlIFwiICsgbWluICsgXCIgb3IgbW9yZS5cIik7XG59LFxuICBub3RfaW46IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgdmFsdWUuXCIpOyB9LFxuICBudW1lcmljOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbWF5IG9ubHkgY29udGFpbiBudW1lcmljIGNoYXJhY3RlcnMuXCIpOyB9LFxuICByZWdleDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIGZvcm1hdCBpcyBpbnZhbGlkLlwiKTsgfSxcbiAgcmVxdWlyZWQ6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBpcyByZXF1aXJlZC5cIik7IH0sXG4gIHNpemU6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgdmFyIHNpemUgPSByZWZbMF07XG5cbiAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBzaXplIG11c3QgYmUgbGVzcyB0aGFuIFwiICsgKGZvcm1hdEZpbGVTaXplKHNpemUpKSArIFwiLlwiKTtcbn0sXG4gIHVybDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIGlzIG5vdCBhIHZhbGlkIFVSTC5cIik7IH1cbn07XG5cbnZhciBsb2NhbGUgPSB7XG4gIG5hbWU6ICdlbicsXG4gIG1lc3NhZ2VzOiBtZXNzYWdlcyxcbiAgYXR0cmlidXRlczoge31cbn07XG5cbmlmIChpc0RlZmluZWRHbG9iYWxseSgpKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBWZWVWYWxpZGF0ZS5WYWxpZGF0b3IubG9jYWxpemUoKCBvYmogPSB7fSwgb2JqW2xvY2FsZS5uYW1lXSA9IGxvY2FsZSwgb2JqKSk7XG59XG5cbi8vIFxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgYXR0cmlidXRlLiB0aGUgbmFtZSBtdXN0IGJlIGtlYmFiLWNhc2UuXG4gKi9cbnZhciBnZXREYXRhQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7IHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoKFwiZGF0YS12di1cIiArIG5hbWUpKTsgfTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGVpdGhlciBudWxsIG9yIHVuZGVmaW5lZC5cbiAqL1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGRhdGEgYXR0cmlidXRlLlxuICovXG52YXIgc2V0RGF0YUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHsgcmV0dXJuIGVsLnNldEF0dHJpYnV0ZSgoXCJkYXRhLXZ2LVwiICsgbmFtZSksIHZhbHVlKTsgfTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBkZWZhdWx0IGZsYWdzIG9iamVjdC5cbiAqL1xudmFyIGNyZWF0ZUZsYWdzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgdW50b3VjaGVkOiB0cnVlLFxuICB0b3VjaGVkOiBmYWxzZSxcbiAgZGlydHk6IGZhbHNlLFxuICBwcmlzdGluZTogdHJ1ZSxcbiAgdmFsaWQ6IG51bGwsXG4gIGludmFsaWQ6IG51bGwsXG4gIHZhbGlkYXRlZDogZmFsc2UsXG4gIHBlbmRpbmc6IGZhbHNlLFxuICByZXF1aXJlZDogZmFsc2UsXG59KTsgfTtcblxuLyoqXG4gKiBTaGFsbG93IG9iamVjdCBjb21wYXJpc29uLlxuICovXG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBpbnB1dCBmaWVsZCBzY29wZS5cbiAqL1xuXG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgaW4gYW4gb2JqZWN0IHNhZmVseS5cbiAqL1xudmFyIGdldFBhdGggPSBmdW5jdGlvbiAocGF0aCwgdGFyZ2V0LCBkZWYpIHtcbiAgaWYgKCBkZWYgPT09IHZvaWQgMCApIGRlZiA9IHVuZGVmaW5lZDtcblxuICBpZiAoIXBhdGggfHwgIXRhcmdldCkgeyByZXR1cm4gZGVmIH1cblxuICB2YXIgdmFsdWUgPSB0YXJnZXQ7XG4gIHBhdGguc3BsaXQoJy4nKS5ldmVyeShmdW5jdGlvbiAocHJvcCkge1xuICAgIGlmICghIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcHJvcCkgJiYgdmFsdWVbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSBkZWY7XG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHZhbHVlID0gdmFsdWVbcHJvcF07XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHBhdGggZXhpc3RzIHdpdGhpbiBhbiBvYmplY3QuXG4gKi9cblxuXG4vKipcbiAqIFBhcnNlcyBhIHJ1bGUgc3RyaW5nIGV4cHJlc3Npb24uXG4gKi9cbnZhciBwYXJzZVJ1bGUgPSBmdW5jdGlvbiAocnVsZSkge1xuICB2YXIgcGFyYW1zID0gW107XG4gIHZhciBuYW1lID0gcnVsZS5zcGxpdCgnOicpWzBdO1xuXG4gIGlmICh+cnVsZS5pbmRleE9mKCc6JykpIHtcbiAgICBwYXJhbXMgPSBydWxlLnNwbGl0KCc6Jykuc2xpY2UoMSkuam9pbignOicpLnNwbGl0KCcsJyk7XG4gIH1cblxuICByZXR1cm4geyBuYW1lOiBuYW1lLCBwYXJhbXM6IHBhcmFtcyB9XG59O1xuXG4vKipcbiAqIERlYm91bmNlcyBhIGZ1bmN0aW9uLlxuICovXG52YXIgZGVib3VuY2UgPSBmdW5jdGlvbiAoZm4sIHdhaXQsIGltbWVkaWF0ZSkge1xuICBpZiAoIHdhaXQgPT09IHZvaWQgMCApIHdhaXQgPSAwO1xuICBpZiAoIGltbWVkaWF0ZSA9PT0gdm9pZCAwICkgaW1tZWRpYXRlID0gZmFsc2U7XG5cbiAgaWYgKHdhaXQgPT09IDApIHtcbiAgICByZXR1cm4gZm5cbiAgfVxuXG4gIHZhciB0aW1lb3V0O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBpZiAoIWltbWVkaWF0ZSkgeyBmbi5hcHBseSh2b2lkIDAsIGFyZ3MpOyB9XG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoY2FsbE5vdykgeyBmbi5hcHBseSh2b2lkIDAsIGFyZ3MpOyB9XG4gIH1cbn07XG5cbi8qKlxuICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gcnVsZXMgZXhwcmVzc2lvbi5cbiAqL1xudmFyIG5vcm1hbGl6ZVJ1bGVzID0gZnVuY3Rpb24gKHJ1bGVzKSB7XG4gIC8vIGlmIGZhbHN5IHZhbHVlIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG4gIGlmICghcnVsZXMpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIGlmIChpc09iamVjdChydWxlcykpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJ1bGVzKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGlmIChydWxlc1tjdXJyXSA9PT0gdHJ1ZSkge1xuICAgICAgICBwYXJhbXMgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShydWxlc1tjdXJyXSkpIHtcbiAgICAgICAgcGFyYW1zID0gcnVsZXNbY3Vycl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMgPSBbcnVsZXNbY3Vycl1dO1xuICAgICAgfVxuXG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBpZiAocnVsZXNbY3Vycl0gIT09IGZhbHNlKSB7XG4gICAgICAgIHByZXZbY3Vycl0gPSBwYXJhbXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2XG4gICAgfSwge30pXG4gIH1cblxuICBpZiAodHlwZW9mIHJ1bGVzICE9PSAnc3RyaW5nJykge1xuICAgIHdhcm4oJ3J1bGVzIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdC4nKTtcbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIHJldHVybiBydWxlcy5zcGxpdCgnfCcpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgcnVsZSkge1xuICAgIHZhciBwYXJzZWRSdWxlID0gcGFyc2VSdWxlKHJ1bGUpO1xuICAgIGlmICghcGFyc2VkUnVsZS5uYW1lKSB7XG4gICAgICByZXR1cm4gcHJldlxuICAgIH1cblxuICAgIHByZXZbcGFyc2VkUnVsZS5uYW1lXSA9IHBhcnNlZFJ1bGUucGFyYW1zO1xuICAgIHJldHVybiBwcmV2XG4gIH0sIHt9KVxufTtcblxuLyoqXG4gKiBFbWl0cyBhIHdhcm5pbmcgdG8gdGhlIGNvbnNvbGUuXG4gKi9cbnZhciB3YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgY29uc29sZS53YXJuKChcIltyZWUtdmFsaWRhdGVdIFwiICsgbWVzc2FnZSkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBicmFuZGVkIGVycm9yIG9iamVjdC5cbiAqL1xudmFyIGNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIG5ldyBFcnJvcigoXCJbcmVlLXZhbGlkYXRlXSBcIiArIG1lc3NhZ2UpKTsgfTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqL1xudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhIEFycmF5LmlzQXJyYXkob2JqKTsgfTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBmdW5jdGlvbiBpcyBjYWxsYWJsZS5cbiAqL1xudmFyIGlzQ2FsbGFibGUgPSBmdW5jdGlvbiAoZnVuYykgeyByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbic7IH07XG5cbi8qKlxuICogQ2hlY2sgaWYgZWxlbWVudCBoYXMgdGhlIGNzcyBjbGFzcyBvbiBpdC5cbiAqL1xudmFyIGhhc0NsYXNzID0gZnVuY3Rpb24gKGVsLCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICB9XG5cbiAgcmV0dXJuICEhZWwuY2xhc3NOYW1lLm1hdGNoKG5ldyBSZWdFeHAoKFwiKFxcXFxzfF4pXCIgKyBjbGFzc05hbWUgKyBcIihcXFxcc3wkKVwiKSkpXG59O1xuXG4vKipcbiAqIEFkZHMgdGhlIHByb3ZpZGVkIGNzcyBjbGFzc05hbWUgdG8gdGhlIGVsZW1lbnQuXG4gKi9cbnZhciBhZGRDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoIWhhc0NsYXNzKGVsLCBjbGFzc05hbWUpKSB7XG4gICAgZWwuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgcHJvdmlkZWQgY3NzIGNsYXNzTmFtZSBmcm9tIHRoZSBlbGVtZW50LlxuICovXG52YXIgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIGNsYXNzTmFtZSkge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKGhhc0NsYXNzKGVsLCBjbGFzc05hbWUpKSB7XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoKFwiKFxcXFxzfF4pXCIgKyBjbGFzc05hbWUgKyBcIihcXFxcc3wkKVwiKSk7XG4gICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UocmVnLCAnICcpO1xuICB9XG59O1xuXG4vKipcbiAqIEFkZHMgb3IgcmVtb3ZlcyBhIGNsYXNzIG5hbWUgb24gdGhlIGlucHV0IGRlcGVuZGluZyBvbiB0aGUgc3RhdHVzIGZsYWcuXG4gKi9cbnZhciB0b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xhc3NOYW1lLCBzdGF0dXMpIHtcbiAgaWYgKCFlbCB8fCAhY2xhc3NOYW1lKSB7IHJldHVybjsgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGNsYXNzTmFtZSkpIHtcbiAgICBjbGFzc05hbWUuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gdG9nZ2xlQ2xhc3MoZWwsIGl0ZW0sIHN0YXR1cyk7IH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0dXMpIHtcbiAgICByZXR1cm4gYWRkQ2xhc3MoZWwsIGNsYXNzTmFtZSlcbiAgfVxuXG4gIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheS1saWtlIG9iamVjdCB0byBhcnJheSwgcHJvdmlkZXMgYSBzaW1wbGUgcG9seWZpbGwgZm9yIEFycmF5LmZyb21cbiAqL1xudmFyIHRvQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXlMaWtlKSB7XG4gIGlmIChpc0NhbGxhYmxlKEFycmF5LmZyb20pKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXlMaWtlKVxuICB9XG5cbiAgdmFyIGFycmF5ID0gW107XG4gIHZhciBsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXkucHVzaChhcnJheUxpa2VbaV0pO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5XG59O1xuXG4vKipcbiAqIEFzc2lnbiBwb2x5ZmlsbCBmcm9tIHRoZSBtZG4uXG4gKi9cbnZhciBhc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHZhciBvdGhlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgb3RoZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpc0NhbGxhYmxlKE9iamVjdC5hc3NpZ24pKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBbIHRhcmdldCBdLmNvbmNhdCggb3RoZXJzICkpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIG90aGVycy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAvLyBTa2lwIG92ZXIgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICBpZiAoYXJnICE9IG51bGwpIHtcbiAgICAgIE9iamVjdC5rZXlzKGFyZykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRvW2tleV0gPSBhcmdba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiB0b1xufTtcblxudmFyIGlkID0gMDtcbnZhciBpZFRlbXBsYXRlID0gJ3tpZH0nO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBpZC5cbiAqL1xudmFyIHVuaXFJZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gaGFuZGxlIHRvbyBtYW55IHVzZXMgb2YgdW5pcUlkLCBhbHRob3VnaCB1bmxpa2VseS5cbiAgaWYgKGlkID49IDk5OTkpIHtcbiAgICBpZCA9IDA7XG4gICAgLy8gc2hpZnQgdGhlIHRlbXBsYXRlLlxuICAgIGlkVGVtcGxhdGUgPSBpZFRlbXBsYXRlLnJlcGxhY2UoJ3tpZH0nLCAnX3tpZH0nKTtcbiAgfVxuXG4gIGlkKys7XG4gIHZhciBuZXdJZCA9IGlkVGVtcGxhdGUucmVwbGFjZSgne2lkfScsIFN0cmluZyhpZCkpO1xuXG4gIHJldHVybiBuZXdJZFxufTtcblxuLyoqXG4gKiBmaW5kcyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlIGNhbGxiYWNrLCBwb2x5ZmlsbHMgYXJyYXkuZmluZFxuICovXG52YXIgZmluZCA9IGZ1bmN0aW9uIChhcnJheUxpa2UsIHByZWRpY2F0ZSkge1xuICB2YXIgYXJyYXkgPSBBcnJheS5pc0FycmF5KGFycmF5TGlrZSkgPyBhcnJheUxpa2UgOiB0b0FycmF5KGFycmF5TGlrZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2ldKSkge1xuICAgICAgcmV0dXJuIGFycmF5W2ldXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZFxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3VpdGFibGUgZXZlbnQgbmFtZSBmb3IgdGhlIGlucHV0IGVsZW1lbnQuXG4gKi9cbnZhciBnZXRJbnB1dEV2ZW50TmFtZSA9IGZ1bmN0aW9uIChlbCkge1xuICBpZiAoZWwgJiYgKGVsLnRhZ05hbWUgPT09ICdTRUxFQ1QnIHx8IH5bJ3JhZGlvJywgJ2NoZWNrYm94JywgJ2ZpbGUnXS5pbmRleE9mKGVsLnR5cGUpKSkge1xuICAgIHJldHVybiAnY2hhbmdlJ1xuICB9XG5cbiAgcmV0dXJuICdpbnB1dCdcbn07XG5cblxuXG52YXIgbWFrZUV2ZW50c0FycmF5ID0gZnVuY3Rpb24gKGV2ZW50cykge1xuICByZXR1cm4gKHR5cGVvZiBldmVudHMgPT09ICdzdHJpbmcnICYmIGV2ZW50cy5sZW5ndGgpID8gZXZlbnRzLnNwbGl0KCd8JykgOiBbXVxufTtcblxudmFyIG1ha2VEZWxheU9iamVjdCA9IGZ1bmN0aW9uIChldmVudHMsIGRlbGF5LCBkZWxheUNvbmZpZykge1xuICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBldmVudHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBlKSB7XG4gICAgICBwcmV2W2VdID0gZGVsYXk7XG4gICAgICByZXR1cm4gcHJldlxuICAgIH0sIHt9KVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGUpIHtcbiAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnb2JqZWN0JyAmJiBlIGluIGRlbGF5KSB7XG4gICAgICBwcmV2W2VdID0gZGVsYXlbZV07XG4gICAgICByZXR1cm4gcHJldlxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGVsYXlDb25maWcgPT09ICdudW1iZXInKSB7XG4gICAgICBwcmV2W2VdID0gZGVsYXlDb25maWc7XG4gICAgICByZXR1cm4gcHJldlxuICAgIH1cblxuICAgIHByZXZbZV0gPSAoZGVsYXlDb25maWcgJiYgZGVsYXlDb25maWdbZV0pIHx8IDA7XG5cbiAgICByZXR1cm4gcHJldlxuICB9LCB7fSlcbn07XG5cblxuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKCEgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0XG4gIH1cblxuICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBvYmosIG9iaiQxO1xuXG4gICAgaWYgKGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgaWYgKCEgdGFyZ2V0W2tleV0pIHtcbiAgICAgICAgYXNzaWduKHRhcmdldCwgKCBvYmogPSB7fSwgb2JqW2tleV0gPSB7fSwgb2JqKSk7XG4gICAgICB9XG5cbiAgICAgIG1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NpZ24odGFyZ2V0LCAoIG9iaiQxID0ge30sIG9iaiQxW2tleV0gPSBzb3VyY2Vba2V5XSwgb2JqJDEpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRhcmdldFxufTtcblxuLy8gXG5cbnZhciBFcnJvckJhZyA9IGZ1bmN0aW9uIEVycm9yQmFnICgpIHtcbiAgdGhpcy5pdGVtcyA9IFtdO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGVycm9yIHRvIHRoZSBpbnRlcm5hbCBhcnJheS5cbiAqL1xuRXJyb3JCYWcucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoZXJyb3IpIHtcbiAgLy8gaGFuZGxlIG9sZCBzaWduYXR1cmUuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGVycm9yID0ge1xuICAgICAgZmllbGQ6IGFyZ3VtZW50c1swXSxcbiAgICAgIG1zZzogYXJndW1lbnRzWzFdLFxuICAgICAgcnVsZTogYXJndW1lbnRzWzJdLFxuICAgICAgc2NvcGU6ICFpc051bGxPclVuZGVmaW5lZChhcmd1bWVudHNbM10pID8gYXJndW1lbnRzWzNdIDogbnVsbCxcbiAgICAgIHJlZ2VuZXJhdGU6IG51bGwsXG4gICAgfTtcbiAgfVxuXG4gIGVycm9yLnNjb3BlID0gIWlzTnVsbE9yVW5kZWZpbmVkKGVycm9yLnNjb3BlKSA/IGVycm9yLnNjb3BlIDogbnVsbDtcbiAgdGhpcy5pdGVtcy5wdXNoKGVycm9yKTtcbn07XG5cbi8qKlxuICogUmVnZW5yYXRlcyBlcnJvciBtZXNzYWdlcyBpZiB0aGV5IGhhdmUgYSBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS5yZWdlbmVyYXRlID0gZnVuY3Rpb24gcmVnZW5lcmF0ZSAoKSB7XG4gIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgIGkubXNnID0gaXNDYWxsYWJsZShpLnJlZ2VuZXJhdGUpID8gaS5yZWdlbmVyYXRlKCkgOiBpLm1zZztcbiAgfSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYSBmaWVsZCBlcnJvciB3aXRoIHRoZSBuZXcgZmllbGQgc2NvcGUuXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGlkLCBlcnJvcikge1xuICB2YXIgaXRlbSA9IGZpbmQodGhpcy5pdGVtcywgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuaWQgPT09IGlkOyB9KTtcbiAgaWYgKCFpdGVtKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgaWR4ID0gdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICB0aGlzLml0ZW1zLnNwbGljZShpZHgsIDEpO1xuICBpdGVtLnNjb3BlID0gZXJyb3Iuc2NvcGU7XG4gIHRoaXMuaXRlbXMucHVzaChpdGVtKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbGwgZXJyb3IgbWVzc2FnZXMgZnJvbSB0aGUgaW50ZXJuYWwgYXJyYXkuXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiBhbGwgKHNjb3BlKSB7XG4gIGlmIChpc051bGxPclVuZGVmaW5lZChzY29wZSkpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUubXNnOyB9KVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnNjb3BlID09PSBzY29wZTsgfSkubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLm1zZzsgfSlcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZXJlIGFyZSBhbnkgZXJyb3JzIGluIHRoZSBpbnRlcm5hbCBhcnJheS5cbiAqL1xuRXJyb3JCYWcucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uIGFueSAoc2NvcGUpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSkge1xuICAgIHJldHVybiAhIXRoaXMuaXRlbXMubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gISF0aGlzLml0ZW1zLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5zY29wZSA9PT0gc2NvcGU7IH0pLmxlbmd0aFxufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBpdGVtcyBmcm9tIHRoZSBpbnRlcm5hbCBhcnJheS5cbiAqL1xuRXJyb3JCYWcucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKHNjb3BlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSkge1xuICAgIHNjb3BlID0gbnVsbDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0aGlzJDEuaXRlbXNbaV0uc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICB0aGlzJDEuaXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgLS1pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDb2xsZWN0cyBlcnJvcnMgaW50byBncm91cHMgb3IgZm9yIGEgc3BlY2lmaWMgZmllbGQuXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS5jb2xsZWN0ID0gZnVuY3Rpb24gY29sbGVjdCAoZmllbGQsIHNjb3BlLCBtYXApIHtcbiAgICBpZiAoIG1hcCA9PT0gdm9pZCAwICkgbWFwID0gdHJ1ZTtcblxuICBpZiAoIWZpZWxkKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB7fTtcbiAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghY29sbGVjdGlvbltlLmZpZWxkXSkge1xuICAgICAgICBjb2xsZWN0aW9uW2UuZmllbGRdID0gW107XG4gICAgICB9XG5cbiAgICAgIGNvbGxlY3Rpb25bZS5maWVsZF0ucHVzaChtYXAgPyBlLm1zZyA6IGUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbGxlY3Rpb25cbiAgfVxuXG4gIGZpZWxkID0gIWlzTnVsbE9yVW5kZWZpbmVkKGZpZWxkKSA/IFN0cmluZyhmaWVsZCkgOiBmaWVsZDtcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5maWVsZCA9PT0gZmllbGQ7IH0pLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKG1hcCA/IGUubXNnIDogZSk7IH0pXG4gIH1cblxuICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuZmllbGQgPT09IGZpZWxkICYmIGUuc2NvcGUgPT09IHNjb3BlOyB9KVxuICAgIC5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChtYXAgPyBlLm1zZyA6IGUpOyB9KVxufTtcbi8qKlxuICogR2V0cyB0aGUgaW50ZXJuYWwgYXJyYXkgbGVuZ3RoLlxuICovXG5FcnJvckJhZy5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiBjb3VudCAoKSB7XG4gIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aFxufTtcblxuLyoqXG4gKiBGaW5kcyBhbmQgZmV0Y2hlcyB0aGUgZmlyc3QgZXJyb3IgbWVzc2FnZSBmb3IgdGhlIHNwZWNpZmllZCBmaWVsZCBpZC5cbiAqL1xuRXJyb3JCYWcucHJvdG90eXBlLmZpcnN0QnlJZCA9IGZ1bmN0aW9uIGZpcnN0QnlJZCAoaWQpIHtcbiAgdmFyIGVycm9yID0gZmluZCh0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5pZCA9PT0gaWQ7IH0pO1xuXG4gIHJldHVybiBlcnJvciA/IGVycm9yLm1zZyA6IG51bGxcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgZmlyc3QgZXJyb3IgbWVzc2FnZSBmb3IgYSBzcGVjaWZpYyBmaWVsZC5cbiAqL1xuRXJyb3JCYWcucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gZmlyc3QgKGZpZWxkLCBzY29wZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIGlmICggc2NvcGUgPT09IHZvaWQgMCApIHNjb3BlID0gbnVsbDtcblxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoZmllbGQpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZpZWxkID0gU3RyaW5nKGZpZWxkKTtcbiAgdmFyIHNlbGVjdG9yID0gdGhpcy5fc2VsZWN0b3IoZmllbGQpO1xuICB2YXIgc2NvcGVkID0gdGhpcy5fc2NvcGUoZmllbGQpO1xuXG4gIGlmIChzY29wZWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5maXJzdChzY29wZWQubmFtZSwgc2NvcGVkLnNjb3BlKTtcbiAgICAvLyBpZiBzdWNoIHJlc3VsdCBleGlzdCwgcmV0dXJuIGl0LiBvdGhlcndpc2UgaXQgY291bGQgYmUgYSBmaWVsZC5cbiAgICAvLyB3aXRoIGRvdCBpbiBpdHMgbmFtZS5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3RCeVJ1bGUoc2VsZWN0b3IubmFtZSwgc2VsZWN0b3IucnVsZSwgc2NvcGUpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodGhpcyQxLml0ZW1zW2ldLmZpZWxkID09PSBmaWVsZCAmJiAodGhpcyQxLml0ZW1zW2ldLnNjb3BlID09PSBzY29wZSkpIHtcbiAgICAgIHJldHVybiB0aGlzJDEuaXRlbXNbaV0ubXNnXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgZXJyb3IgcnVsZSBmb3IgdGhlIHNwZWNpZmllZCBmaWVsZFxuICovXG5FcnJvckJhZy5wcm90b3R5cGUuZmlyc3RSdWxlID0gZnVuY3Rpb24gZmlyc3RSdWxlIChmaWVsZCwgc2NvcGUpIHtcbiAgdmFyIGVycm9ycyA9IHRoaXMuY29sbGVjdChmaWVsZCwgc2NvcGUsIGZhbHNlKTtcblxuICByZXR1cm4gKGVycm9ycy5sZW5ndGggJiYgZXJyb3JzWzBdLnJ1bGUpIHx8IG51bGxcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBpbnRlcm5hbCBhcnJheSBoYXMgYXQgbGVhc3Qgb25lIGVycm9yIGZvciB0aGUgc3BlY2lmaWVkIGZpZWxkLlxuICovXG5FcnJvckJhZy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChmaWVsZCwgc2NvcGUpIHtcbiAgICBpZiAoIHNjb3BlID09PSB2b2lkIDAgKSBzY29wZSA9IG51bGw7XG5cbiAgcmV0dXJuICEhdGhpcy5maXJzdChmaWVsZCwgc2NvcGUpXG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGZpcnN0IGVycm9yIG1lc3NhZ2UgZm9yIGEgc3BlY2lmaWMgZmllbGQgYW5kIGEgcnVsZS5cbiAqL1xuRXJyb3JCYWcucHJvdG90eXBlLmZpcnN0QnlSdWxlID0gZnVuY3Rpb24gZmlyc3RCeVJ1bGUgKG5hbWUsIHJ1bGUsIHNjb3BlKSB7XG4gICAgaWYgKCBzY29wZSA9PT0gdm9pZCAwICkgc2NvcGUgPSBudWxsO1xuXG4gIHZhciBlcnJvciA9IHRoaXMuY29sbGVjdChuYW1lLCBzY29wZSwgZmFsc2UpLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5ydWxlID09PSBydWxlOyB9KVswXTtcblxuICByZXR1cm4gKGVycm9yICYmIGVycm9yLm1zZykgfHwgbnVsbFxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBmaXJzdCBlcnJvciBtZXNzYWdlIGZvciBhIHNwZWNpZmljIGZpZWxkIHRoYXQgbm90IG1hdGNoIHRoZSBydWxlLlxuICovXG5FcnJvckJhZy5wcm90b3R5cGUuZmlyc3ROb3QgPSBmdW5jdGlvbiBmaXJzdE5vdCAobmFtZSwgcnVsZSwgc2NvcGUpIHtcbiAgICBpZiAoIHJ1bGUgPT09IHZvaWQgMCApIHJ1bGUgPSAncmVxdWlyZWQnO1xuICAgIGlmICggc2NvcGUgPT09IHZvaWQgMCApIHNjb3BlID0gbnVsbDtcblxuICB2YXIgZXJyb3IgPSB0aGlzLmNvbGxlY3QobmFtZSwgc2NvcGUsIGZhbHNlKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUucnVsZSAhPT0gcnVsZTsgfSlbMF07XG5cbiAgcmV0dXJuIChlcnJvciAmJiBlcnJvci5tc2cpIHx8IG51bGxcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBlcnJvcnMgYnkgbWF0Y2hpbmcgYWdhaW5zdCB0aGUgaWQuXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS5yZW1vdmVCeUlkID0gZnVuY3Rpb24gcmVtb3ZlQnlJZCAoaWQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodGhpcyQxLml0ZW1zW2ldLmlkID09PSBpZCkge1xuICAgICAgdGhpcyQxLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgIC0taTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgZXJyb3IgbWVzc2FnZXMgYXNzb2NpYXRlZCB3aXRoIGEgc3BlY2lmaWMgZmllbGQuXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGZpZWxkLCBzY29wZSwgaWQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmaWVsZCA9ICFpc051bGxPclVuZGVmaW5lZChmaWVsZCkgPyBTdHJpbmcoZmllbGQpIDogZmllbGQ7XG4gIHZhciByZW1vdmVDb25kaXRpb24gPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLmlkICYmIGlkKSB7XG4gICAgICByZXR1cm4gZS5pZCA9PT0gaWRcbiAgICB9XG5cbiAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSkge1xuICAgICAgcmV0dXJuIGUuZmllbGQgPT09IGZpZWxkICYmIGUuc2NvcGUgPT09IHNjb3BlXG4gICAgfVxuXG4gICAgcmV0dXJuIGUuZmllbGQgPT09IGZpZWxkICYmIGUuc2NvcGUgPT09IG51bGxcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAocmVtb3ZlQ29uZGl0aW9uKHRoaXMkMS5pdGVtc1tpXSkpIHtcbiAgICAgIHRoaXMkMS5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAtLWk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZmllbGQgYXR0cmlidXRlcyBpZiB0aGVyZSdzIGEgcnVsZSBzZWxlY3Rvci5cbiAqL1xuRXJyb3JCYWcucHJvdG90eXBlLl9zZWxlY3RvciA9IGZ1bmN0aW9uIF9zZWxlY3RvciAoZmllbGQpIHtcbiAgaWYgKGZpZWxkLmluZGV4T2YoJzonKSA+IC0xKSB7XG4gICAgdmFyIHJlZiA9IGZpZWxkLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIgbmFtZSA9IHJlZlswXTtcbiAgICAgIHZhciBydWxlID0gcmVmWzFdO1xuXG4gICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgcnVsZTogcnVsZSB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGZpZWxkIHNjb3BlIGlmIHNwZWNpZmllZCB1c2luZyBkb3Qgbm90YXRpb24uXG4gKi9cbkVycm9yQmFnLnByb3RvdHlwZS5fc2NvcGUgPSBmdW5jdGlvbiBfc2NvcGUgKGZpZWxkKSB7XG4gIGlmIChmaWVsZC5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgIHZhciByZWYgPSBmaWVsZC5zcGxpdCgnLicpO1xuICAgICAgdmFyIHNjb3BlID0gcmVmWzBdO1xuICAgICAgdmFyIG5hbWUgPSByZWYuc2xpY2UoMSk7XG5cbiAgICByZXR1cm4geyBuYW1lOiBuYW1lLmpvaW4oJy4nKSwgc2NvcGU6IHNjb3BlIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59O1xuXG4vLyBcblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgdGFyZ2V0T2Y6IG51bGwsXG4gIGluaXRpYWw6IGZhbHNlLFxuICBzY29wZTogbnVsbCxcbiAgbGlzdGVuOiB0cnVlLFxuICBuYW1lOiBudWxsLFxuICBydWxlczoge30sXG4gIHZtOiBudWxsLFxuICBjbGFzc2VzOiBmYWxzZSxcbiAgdmFsaWRpdHk6IHRydWUsXG4gIGFyaWE6IHRydWUsXG4gIGV2ZW50czogJ2lucHV0fGJsdXInLFxuICBkZWxheTogMCxcbiAgY2xhc3NOYW1lczoge1xuICAgIHRvdWNoZWQ6ICd0b3VjaGVkJywgLy8gdGhlIGNvbnRyb2wgaGFzIGJlZW4gYmx1cnJlZFxuICAgIHVudG91Y2hlZDogJ3VudG91Y2hlZCcsIC8vIHRoZSBjb250cm9sIGhhc24ndCBiZWVuIGJsdXJyZWRcbiAgICB2YWxpZDogJ3ZhbGlkJywgLy8gbW9kZWwgaXMgdmFsaWRcbiAgICBpbnZhbGlkOiAnaW52YWxpZCcsIC8vIG1vZGVsIGlzIGludmFsaWRcbiAgICBwcmlzdGluZTogJ3ByaXN0aW5lJywgLy8gY29udHJvbCBoYXMgbm90IGJlZW4gaW50ZXJhY3RlZCB3aXRoXG4gICAgZGlydHk6ICdkaXJ0eScsIC8vIGNvbnRyb2wgaGFzIGJlZW4gaW50ZXJhY3RlZCB3aXRoXG4gIH0sXG59O1xuXG52YXIgRmllbGQgPSBmdW5jdGlvbiBGaWVsZCAoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgdGhpcy5pZCA9IHVuaXFJZCgpO1xuICB0aGlzLmVsID0gZWw7XG4gIHRoaXMudXBkYXRlZCA9IGZhbHNlO1xuICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xuICB0aGlzLndhdGNoZXJzID0gW107XG4gIHRoaXMuZXZlbnRzID0gW107XG4gIHRoaXMuZGVsYXkgPSAwO1xuICB0aGlzLnJ1bGVzID0ge307XG4gIHRoaXMuX2NhY2hlSWQob3B0aW9ucyk7XG4gIHRoaXMuY2xhc3NOYW1lcyA9IGFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLmNsYXNzTmFtZXMpO1xuICBvcHRpb25zID0gYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICB0aGlzLl9kZWxheSA9ICFpc051bGxPclVuZGVmaW5lZChvcHRpb25zLmRlbGF5KSA/IG9wdGlvbnMuZGVsYXkgOiAwOyAvLyBjYWNoZSBpbml0aWFsIGRlbGF5XG4gIHRoaXMudmFsaWRpdHkgPSBvcHRpb25zLnZhbGlkaXR5O1xuICB0aGlzLmFyaWEgPSBvcHRpb25zLmFyaWE7XG4gIHRoaXMuZmxhZ3MgPSBjcmVhdGVGbGFncygpO1xuICB0aGlzLnZtID0gb3B0aW9ucy52bTtcbiAgdGhpcy5jb21wb25lbnQgPSBvcHRpb25zLmNvbXBvbmVudDtcbiAgdGhpcy5jdG9yQ29uZmlnID0gdGhpcy5jb21wb25lbnQgPyBnZXRQYXRoKCckb3B0aW9ucy4kX3JlZVZhbGlkYXRlJywgdGhpcy5jb21wb25lbnQpIDogdW5kZWZpbmVkO1xuICB0aGlzLnVwZGF0ZShvcHRpb25zKTtcbiAgdGhpcy51cGRhdGVkID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyB2YWxpZGF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saXNSZXF1aXJlZDogeyBjb25maWd1cmFibGU6IHRydWUgfSxpc0Rpc2FibGVkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsaWFzOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHZhbHVlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHJlamVjdHNGYWxzZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMudmFsaWRhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnZtIHx8ICF0aGlzLnZtLiR2YWxpZGF0b3IpIHtcbiAgICB3YXJuKCdObyB2YWxpZGF0b3IgaW5zdGFuY2UgZGV0ZWN0ZWQuJyk7XG4gICAgcmV0dXJuIHsgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHt9IH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLnZtLiR2YWxpZGF0b3Jcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pc1JlcXVpcmVkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhdGhpcy5ydWxlcy5yZXF1aXJlZFxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmlzRGlzYWJsZWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISEodGhpcy5jb21wb25lbnQgJiYgdGhpcy5jb21wb25lbnQuZGlzYWJsZWQpIHx8ICEhKHRoaXMuZWwgJiYgdGhpcy5lbC5kaXNhYmxlZClcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgZGlzcGxheSBuYW1lICh1c2VyLWZyaWVuZGx5IG5hbWUpLlxuICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuYWxpYXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fYWxpYXMpIHtcbiAgICByZXR1cm4gdGhpcy5fYWxpYXNcbiAgfVxuXG4gIHZhciBhbGlhcyA9IG51bGw7XG4gIGlmICh0aGlzLmVsKSB7XG4gICAgYWxpYXMgPSBnZXREYXRhQXR0cmlidXRlKHRoaXMuZWwsICdhcycpO1xuICB9XG5cbiAgaWYgKCFhbGlhcyAmJiB0aGlzLmNvbXBvbmVudCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC4kYXR0cnMgJiYgdGhpcy5jb21wb25lbnQuJGF0dHJzWydkYXRhLXZ2LWFzJ11cbiAgfVxuXG4gIHJldHVybiBhbGlhc1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbnB1dCB2YWx1ZS5cbiAqL1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMudmFsdWUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIWlzQ2FsbGFibGUodGhpcy5nZXR0ZXIpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIHRoaXMuZ2V0dGVyKClcbn07XG5cbi8qKlxuICogSWYgdGhlIGZpZWxkIHJlamVjdHMgZmFsc2UgYXMgYSB2YWxpZCB2YWx1ZSBmb3IgdGhlIHJlcXVpcmVkIHJ1bGUuXG4gKi9cblxucHJvdG90eXBlQWNjZXNzb3JzLnJlamVjdHNGYWxzZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbXBvbmVudCAmJiB0aGlzLmN0b3JDb25maWcpIHtcbiAgICByZXR1cm4gISF0aGlzLmN0b3JDb25maWcucmVqZWN0c0ZhbHNlXG4gIH1cblxuICBpZiAoIXRoaXMuZWwpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVsLnR5cGUgPT09ICdjaGVja2JveCdcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5zdGFuY2UgbWF0Y2hlcyB0aGUgb3B0aW9ucyBwcm92aWRlZC5cbiAqL1xuRmllbGQucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQgPT09IG9wdGlvbnMuaWRcbiAgfVxuXG4gIGlmIChvcHRpb25zLm5hbWUgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnNjb3BlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuc2NvcGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLm5hbWUgPT09IG9wdGlvbnMubmFtZVxuICB9XG5cbiAgaWYgKG9wdGlvbnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGUgPT09IG9wdGlvbnMuc2NvcGVcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zLm5hbWUgPT09IHRoaXMubmFtZSAmJiBvcHRpb25zLnNjb3BlID09PSB0aGlzLnNjb3BlXG59O1xuXG4vKipcbiAqIENhY2hlcyB0aGUgZmllbGQgaWQuXG4gKi9cbkZpZWxkLnByb3RvdHlwZS5fY2FjaGVJZCA9IGZ1bmN0aW9uIF9jYWNoZUlkIChvcHRpb25zKSB7XG4gIGlmICh0aGlzLmVsICYmICFvcHRpb25zLnRhcmdldE9mKSB7XG4gICAgc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLmVsLCAnaWQnLCB0aGlzLmlkKTsgLy8gY2FjaGUgZmllbGQgaWQgaWYgaXQgaXMgaW5kZXBlbmRlbnQgYW5kIGhhcyBhIHJvb3QgZWxlbWVudC5cbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBmaWVsZCB3aXRoIGNoYW5nZWQgZGF0YS5cbiAqL1xuRmllbGQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3B0aW9ucykge1xuICB0aGlzLnRhcmdldE9mID0gb3B0aW9ucy50YXJnZXRPZiB8fCBudWxsO1xuICB0aGlzLmluaXRpYWwgPSBvcHRpb25zLmluaXRpYWwgfHwgdGhpcy5pbml0aWFsIHx8IGZhbHNlO1xuXG4gIC8vIHVwZGF0ZSBlcnJvcnMgc2NvcGUgaWYgdGhlIGZpZWxkIHNjb3BlIHdhcyBjaGFuZ2VkLlxuICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG9wdGlvbnMuc2NvcGUpICYmIG9wdGlvbnMuc2NvcGUgIT09IHRoaXMuc2NvcGUgJiYgaXNDYWxsYWJsZSh0aGlzLnZhbGlkYXRvci51cGRhdGUpKSB7XG4gICAgdGhpcy52YWxpZGF0b3IudXBkYXRlKHRoaXMuaWQsIHsgc2NvcGU6IG9wdGlvbnMuc2NvcGUgfSk7XG4gIH1cbiAgdGhpcy5zY29wZSA9ICFpc051bGxPclVuZGVmaW5lZChvcHRpb25zLnNjb3BlKSA/IG9wdGlvbnMuc2NvcGVcbiAgICA6ICFpc051bGxPclVuZGVmaW5lZCh0aGlzLnNjb3BlKSA/IHRoaXMuc2NvcGUgOiBudWxsO1xuICB0aGlzLm5hbWUgPSAoIWlzTnVsbE9yVW5kZWZpbmVkKG9wdGlvbnMubmFtZSkgPyBTdHJpbmcob3B0aW9ucy5uYW1lKSA6IG9wdGlvbnMubmFtZSkgfHwgdGhpcy5uYW1lIHx8IG51bGw7XG4gIHRoaXMucnVsZXMgPSBvcHRpb25zLnJ1bGVzICE9PSB1bmRlZmluZWQgPyBub3JtYWxpemVSdWxlcyhvcHRpb25zLnJ1bGVzKSA6IHRoaXMucnVsZXM7XG4gIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsIHx8IHRoaXMubW9kZWw7XG4gIHRoaXMubGlzdGVuID0gb3B0aW9ucy5saXN0ZW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubGlzdGVuIDogdGhpcy5saXN0ZW47XG4gIHRoaXMuY2xhc3NlcyA9IChvcHRpb25zLmNsYXNzZXMgfHwgdGhpcy5jbGFzc2VzIHx8IGZhbHNlKSAmJiAhdGhpcy5jb21wb25lbnQ7XG4gIHRoaXMuY2xhc3NOYW1lcyA9IGlzT2JqZWN0KG9wdGlvbnMuY2xhc3NOYW1lcykgPyBtZXJnZSh0aGlzLmNsYXNzTmFtZXMsIG9wdGlvbnMuY2xhc3NOYW1lcykgOiB0aGlzLmNsYXNzTmFtZXM7XG4gIHRoaXMuZ2V0dGVyID0gaXNDYWxsYWJsZShvcHRpb25zLmdldHRlcikgPyBvcHRpb25zLmdldHRlciA6IHRoaXMuZ2V0dGVyO1xuICB0aGlzLl9hbGlhcyA9IG9wdGlvbnMuYWxpYXMgfHwgdGhpcy5fYWxpYXM7XG4gIHRoaXMuZXZlbnRzID0gKG9wdGlvbnMuZXZlbnRzKSA/IG1ha2VFdmVudHNBcnJheShvcHRpb25zLmV2ZW50cykgOiB0aGlzLmV2ZW50cztcbiAgdGhpcy5kZWxheSA9IChvcHRpb25zLmRlbGF5KSA/IG1ha2VEZWxheU9iamVjdCh0aGlzLmV2ZW50cywgb3B0aW9ucy5kZWxheSwgdGhpcy5fZGVsYXkpIDogbWFrZURlbGF5T2JqZWN0KHRoaXMuZXZlbnRzLCB0aGlzLmRlbGF5LCB0aGlzLl9kZWxheSk7XG4gIHRoaXMudXBkYXRlRGVwZW5kZW5jaWVzKCk7XG4gIHRoaXMuYWRkQWN0aW9uTGlzdGVuZXJzKCk7XG5cbiAgLy8gdXBkYXRlIHJlcXVpcmVkIGZsYWcgZmxhZ3NcbiAgaWYgKG9wdGlvbnMucnVsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuZmxhZ3MucmVxdWlyZWQgPSB0aGlzLmlzUmVxdWlyZWQ7XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBpZiBpdCB3YXMgdmFsaWRhdGVkIGJlZm9yZSBhbmQgZmllbGQgd2FzIHVwZGF0ZWQgYW5kIHRoZXJlIHdhcyBhIHJ1bGVzIG11dGF0aW9uLlxuICBpZiAodGhpcy5mbGFncy52YWxpZGF0ZWQgJiYgb3B0aW9ucy5ydWxlcyAhPT0gdW5kZWZpbmVkICYmIHRoaXMudXBkYXRlZCkge1xuICAgIHRoaXMudmFsaWRhdG9yLnZhbGlkYXRlKChcIiNcIiArICh0aGlzLmlkKSkpO1xuICB9XG5cbiAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgdGhpcy5hZGRWYWx1ZUxpc3RlbmVycygpO1xuXG4gIC8vIG5vIG5lZWQgdG8gY29udGludWUuXG4gIGlmICghdGhpcy5lbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy51cGRhdGVDbGFzc2VzKCk7XG4gIHRoaXMudXBkYXRlQXJpYUF0dHJzKCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBmaWVsZCBmbGFncyBhbmQgZXJyb3JzLlxuICovXG5GaWVsZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGRlZmF1bHRzID0gY3JlYXRlRmxhZ3MoKTtcbiAgT2JqZWN0LmtleXModGhpcy5mbGFncykuZmlsdGVyKGZ1bmN0aW9uIChmbGFnKSB7IHJldHVybiBmbGFnICE9PSAncmVxdWlyZWQnOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgdGhpcyQxLmZsYWdzW2ZsYWddID0gZGVmYXVsdHNbZmxhZ107XG4gIH0pO1xuXG4gIHRoaXMuYWRkQWN0aW9uTGlzdGVuZXJzKCk7XG4gIHRoaXMudXBkYXRlQ2xhc3NlcygpO1xuICB0aGlzLnVwZGF0ZUFyaWFBdHRycygpO1xuICB0aGlzLnVwZGF0ZUN1c3RvbVZhbGlkaXR5KCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGZsYWdzIGFuZCB0aGVpciBuZWdhdGVkIGNvdW50ZXJwYXJ0cywgYW5kIHVwZGF0ZXMgdGhlIGNsYXNzZXMgYW5kIHJlLWFkZHMgYWN0aW9uIGxpc3RlbmVycy5cbiAqL1xuRmllbGQucHJvdG90eXBlLnNldEZsYWdzID0gZnVuY3Rpb24gc2V0RmxhZ3MgKGZsYWdzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5lZ2F0ZWQgPSB7XG4gICAgcHJpc3RpbmU6ICdkaXJ0eScsXG4gICAgZGlydHk6ICdwcmlzdGluZScsXG4gICAgdmFsaWQ6ICdpbnZhbGlkJyxcbiAgICBpbnZhbGlkOiAndmFsaWQnLFxuICAgIHRvdWNoZWQ6ICd1bnRvdWNoZWQnLFxuICAgIHVudG91Y2hlZDogJ3RvdWNoZWQnLFxuICB9O1xuXG4gIE9iamVjdC5rZXlzKGZsYWdzKS5mb3JFYWNoKGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgdGhpcyQxLmZsYWdzW2ZsYWddID0gZmxhZ3NbZmxhZ107XG4gICAgLy8gaWYgaXQgaGFzIGEgbmVnYXRpb24gYW5kIHdhcyBub3Qgc3BlY2lmaWVkLCBzZXQgaXQgYXMgd2VsbC5cbiAgICBpZiAobmVnYXRlZFtmbGFnXSAmJiBmbGFnc1tuZWdhdGVkW2ZsYWddXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzJDEuZmxhZ3NbbmVnYXRlZFtmbGFnXV0gPSAhZmxhZ3NbZmxhZ107XG4gICAgfVxuICB9KTtcblxuICBpZiAoXG4gICAgZmxhZ3MudW50b3VjaGVkICE9PSB1bmRlZmluZWQgfHxcbiAgICBmbGFncy50b3VjaGVkICE9PSB1bmRlZmluZWQgfHxcbiAgICBmbGFncy5kaXJ0eSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgZmxhZ3MucHJpc3RpbmUgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0aGlzLmFkZEFjdGlvbkxpc3RlbmVycygpO1xuICB9XG4gIHRoaXMudXBkYXRlQ2xhc3NlcygpO1xuICB0aGlzLnVwZGF0ZUFyaWFBdHRycygpO1xuICB0aGlzLnVwZGF0ZUN1c3RvbVZhbGlkaXR5KCk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGZpZWxkIHJlcXVpcmVzIHJlZmVyZW5jZXMgdG8gdGFyZ2V0IGZpZWxkcy5cbiAqL1xuRmllbGQucHJvdG90eXBlLnVwZGF0ZURlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIHVwZGF0ZURlcGVuZGVuY2llcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gcmVzZXQgZGVwZW5kZW5jaWVzLlxuICB0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmZpZWxkLmRlc3Ryb3koKTsgfSk7XG4gIHRoaXMuZGVwZW5kZW5jaWVzID0gW107XG5cbiAgLy8gd2UgZ2V0IHRoZSBzZWxlY3RvcnMgZm9yIGVhY2ggZmllbGQuXG4gIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyh0aGlzLnJ1bGVzKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHIpIHtcbiAgICBpZiAoVmFsaWRhdG9yLmlzVGFyZ2V0UnVsZShyKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcyQxLnJ1bGVzW3JdWzBdO1xuICAgICAgaWYgKHIgPT09ICdjb25maXJtZWQnICYmICFzZWxlY3Rvcikge1xuICAgICAgICBzZWxlY3RvciA9ICh0aGlzJDEubmFtZSkgKyBcIl9jb25maXJtYXRpb25cIjtcbiAgICAgIH1cblxuICAgICAgcHJldi5wdXNoKHsgc2VsZWN0b3I6IHNlbGVjdG9yLCBuYW1lOiByIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2XG4gIH0sIFtdKTtcblxuICBpZiAoIWZpZWxkcy5sZW5ndGggfHwgIXRoaXMudm0gfHwgIXRoaXMudm0uJGVsKSB7IHJldHVybiB9XG5cbiAgLy8gbXVzdCBiZSBjb250YWluZWQgd2l0aGluIHRoZSBzYW1lIGNvbXBvbmVudCwgc28gd2UgdXNlIHRoZSB2bSByb290IGVsZW1lbnQgY29uc3RyYWluIG91ciBkb20gc2VhcmNoLlxuICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSByZWYuc2VsZWN0b3I7XG4gICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuXG4gICAgdmFyIGVsID0gbnVsbDtcbiAgICAvLyB2dWUgcmVmIHNlbGVjdG9yLlxuICAgIGlmIChzZWxlY3RvclswXSA9PT0gJyQnKSB7XG4gICAgICB2YXIgcmVmJDEgPSB0aGlzJDEudm0uJHJlZnNbc2VsZWN0b3Iuc2xpY2UoMSldO1xuICAgICAgZWwgPSBBcnJheS5pc0FycmF5KHJlZiQxKSA/IHJlZiQxWzBdIDogcmVmJDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHRyeSBxdWVyeSBzZWxlY3RvclxuICAgICAgICBlbCA9IHRoaXMkMS52bS4kZWwucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZWwgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsID0gdGhpcyQxLnZtLiRlbC5xdWVyeVNlbGVjdG9yKChcImlucHV0W25hbWU9XFxcIlwiICsgc2VsZWN0b3IgKyBcIlxcXCJdXCIpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlbCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFlbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB2bTogdGhpcyQxLnZtLFxuICAgICAgY2xhc3NlczogdGhpcyQxLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWVzOiB0aGlzJDEuY2xhc3NOYW1lcyxcbiAgICAgIGRlbGF5OiB0aGlzJDEuZGVsYXksXG4gICAgICBzY29wZTogdGhpcyQxLnNjb3BlLFxuICAgICAgZXZlbnRzOiB0aGlzJDEuZXZlbnRzLmpvaW4oJ3wnKSxcbiAgICAgIGluaXRpYWw6IHRoaXMkMS5pbml0aWFsLFxuICAgICAgdGFyZ2V0T2Y6IHRoaXMkMS5pZCxcbiAgICB9O1xuXG4gICAgdGhpcyQxLmRlcGVuZGVuY2llcy5wdXNoKHsgbmFtZTogbmFtZSwgZmllbGQ6IG5ldyBGaWVsZChvcHRpb25zLmVsLCBvcHRpb25zKSB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgbGlzdGVuZXJzLlxuICovXG5GaWVsZC5wcm90b3R5cGUudW53YXRjaCA9IGZ1bmN0aW9uIHVud2F0Y2ggKHRhZykge1xuICAgIGlmICggdGFnID09PSB2b2lkIDAgKSB0YWcgPSBudWxsO1xuXG4gIGlmICghdGFnKSB7XG4gICAgdGhpcy53YXRjaGVycy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnVud2F0Y2goKTsgfSk7XG4gICAgdGhpcy53YXRjaGVycyA9IFtdO1xuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy53YXRjaGVycy5maWx0ZXIoZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHRhZy50ZXN0KHcudGFnKTsgfSkuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy51bndhdGNoKCk7IH0pO1xuICB0aGlzLndhdGNoZXJzID0gdGhpcy53YXRjaGVycy5maWx0ZXIoZnVuY3Rpb24gKHcpIHsgcmV0dXJuICF0YWcudGVzdCh3LnRhZyk7IH0pO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBlbGVtZW50IGNsYXNzZXMgZGVwZW5kaW5nIG9uIGVhY2ggZmllbGQgZmxhZyBzdGF0dXMuXG4gKi9cbkZpZWxkLnByb3RvdHlwZS51cGRhdGVDbGFzc2VzID0gZnVuY3Rpb24gdXBkYXRlQ2xhc3NlcyAoKSB7XG4gIGlmICghdGhpcy5jbGFzc2VzIHx8IHRoaXMuaXNEaXNhYmxlZCkgeyByZXR1cm4gfVxuXG4gIHRvZ2dsZUNsYXNzKHRoaXMuZWwsIHRoaXMuY2xhc3NOYW1lcy5kaXJ0eSwgdGhpcy5mbGFncy5kaXJ0eSk7XG4gIHRvZ2dsZUNsYXNzKHRoaXMuZWwsIHRoaXMuY2xhc3NOYW1lcy5wcmlzdGluZSwgdGhpcy5mbGFncy5wcmlzdGluZSk7XG4gIHRvZ2dsZUNsYXNzKHRoaXMuZWwsIHRoaXMuY2xhc3NOYW1lcy50b3VjaGVkLCB0aGlzLmZsYWdzLnRvdWNoZWQpO1xuICB0b2dnbGVDbGFzcyh0aGlzLmVsLCB0aGlzLmNsYXNzTmFtZXMudW50b3VjaGVkLCB0aGlzLmZsYWdzLnVudG91Y2hlZCk7XG4gIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBzZXQgYW55IGNsYXNzZXMgaWYgdGhlIHN0YXRlIGlzIHVuZGV0ZXJtaW5lZC5cbiAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh0aGlzLmZsYWdzLnZhbGlkKSAmJiB0aGlzLmZsYWdzLnZhbGlkYXRlZCkge1xuICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWwsIHRoaXMuY2xhc3NOYW1lcy52YWxpZCwgdGhpcy5mbGFncy52YWxpZCk7XG4gIH1cblxuICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHRoaXMuZmxhZ3MuaW52YWxpZCkgJiYgdGhpcy5mbGFncy52YWxpZGF0ZWQpIHtcbiAgICB0b2dnbGVDbGFzcyh0aGlzLmVsLCB0aGlzLmNsYXNzTmFtZXMuaW52YWxpZCwgdGhpcy5mbGFncy5pbnZhbGlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGRzIHRoZSBsaXN0ZW5lcnMgcmVxdWlyZWQgZm9yIGF1dG9tYXRpYyBjbGFzc2VzIGFuZCBzb21lIGZsYWdzLlxuICovXG5GaWVsZC5wcm90b3R5cGUuYWRkQWN0aW9uTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkQWN0aW9uTGlzdGVuZXJzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyByZW1vdmUgcHJldmlvdXMgbGlzdGVuZXJzLlxuICB0aGlzLnVud2F0Y2goL2NsYXNzLyk7XG5cbiAgdmFyIG9uQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEuZmxhZ3MudG91Y2hlZCA9IHRydWU7XG4gICAgdGhpcyQxLmZsYWdzLnVudG91Y2hlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzJDEuY2xhc3Nlcykge1xuICAgICAgdG9nZ2xlQ2xhc3ModGhpcyQxLmVsLCB0aGlzJDEuY2xhc3NOYW1lcy50b3VjaGVkLCB0cnVlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMkMS5lbCwgdGhpcyQxLmNsYXNzTmFtZXMudW50b3VjaGVkLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gb25seSBuZWVkZWQgb25jZS5cbiAgICB0aGlzJDEudW53YXRjaCgvXmNsYXNzX2JsdXIkLyk7XG4gIH07XG5cbiAgdmFyIGlucHV0RXZlbnQgPSBnZXRJbnB1dEV2ZW50TmFtZSh0aGlzLmVsKTtcbiAgdmFyIG9uSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLmZsYWdzLmRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzJDEuZmxhZ3MucHJpc3RpbmUgPSBmYWxzZTtcbiAgICBpZiAodGhpcyQxLmNsYXNzZXMpIHtcbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMkMS5lbCwgdGhpcyQxLmNsYXNzTmFtZXMucHJpc3RpbmUsIGZhbHNlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMkMS5lbCwgdGhpcyQxLmNsYXNzTmFtZXMuZGlydHksIHRydWUpO1xuICAgIH1cblxuICAgIC8vIG9ubHkgbmVlZGVkIG9uY2UuXG4gICAgdGhpcyQxLnVud2F0Y2goL15jbGFzc19pbnB1dCQvKTtcbiAgfTtcblxuICBpZiAodGhpcy5jb21wb25lbnQgJiYgaXNDYWxsYWJsZSh0aGlzLmNvbXBvbmVudC4kb25jZSkpIHtcbiAgICB0aGlzLmNvbXBvbmVudC4kb25jZSgnaW5wdXQnLCBvbklucHV0KTtcbiAgICB0aGlzLmNvbXBvbmVudC4kb25jZSgnYmx1cicsIG9uQmx1cik7XG4gICAgdGhpcy53YXRjaGVycy5wdXNoKHtcbiAgICAgIHRhZzogJ2NsYXNzX2lucHV0JyxcbiAgICAgIHVud2F0Y2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcyQxLmNvbXBvbmVudC4kb2ZmKCdpbnB1dCcsIG9uSW5wdXQpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgICB0aGlzLndhdGNoZXJzLnB1c2goe1xuICAgICAgdGFnOiAnY2xhc3NfYmx1cicsXG4gICAgICB1bndhdGNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMkMS5jb21wb25lbnQuJG9mZignYmx1cicsIG9uQmx1cik7XG4gICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKCF0aGlzLmVsKSB7IHJldHVybiB9XG5cbiAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKGlucHV0RXZlbnQsIG9uSW5wdXQpO1xuICAvLyBDaGVja2JveGVzIGFuZCByYWRpbyBidXR0b25zIG9uIE1hYyBkb24ndCBlbWl0IGJsdXIgbmF0dXJhbGx5LCBzbyB3ZSBsaXN0ZW4gb24gY2xpY2sgaW5zdGVhZC5cbiAgdmFyIGJsdXJFdmVudCA9IFsncmFkaW8nLCAnY2hlY2tib3gnXS5pbmRleE9mKHRoaXMuZWwudHlwZSkgPT09IC0xID8gJ2JsdXInIDogJ2NsaWNrJztcbiAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKGJsdXJFdmVudCwgb25CbHVyKTtcbiAgdGhpcy53YXRjaGVycy5wdXNoKHtcbiAgICB0YWc6ICdjbGFzc19pbnB1dCcsXG4gICAgdW53YXRjaDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoaW5wdXRFdmVudCwgb25JbnB1dCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgdGhpcy53YXRjaGVycy5wdXNoKHtcbiAgICB0YWc6ICdjbGFzc19ibHVyJyxcbiAgICB1bndhdGNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihibHVyRXZlbnQsIG9uQmx1cik7XG4gICAgfSxcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFkZHMgdGhlIGxpc3RlbmVycyByZXF1aXJlZCBmb3IgdmFsaWRhdGlvbi5cbiAqL1xuRmllbGQucHJvdG90eXBlLmFkZFZhbHVlTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkVmFsdWVMaXN0ZW5lcnMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMudW53YXRjaCgvXmlucHV0Xy4rLyk7XG4gIGlmICghdGhpcy5saXN0ZW4pIHsgcmV0dXJuIH1cblxuICB2YXIgZm4gPSB0aGlzLnRhcmdldE9mID8gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMkMS52YWxpZGF0b3IudmFsaWRhdGUoKFwiI1wiICsgKHRoaXMkMS50YXJnZXRPZikpKTtcbiAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgLy8gaWYgaXRzIGEgRE9NIGV2ZW50LCByZXNvbHZlIHRoZSB2YWx1ZSwgb3RoZXJ3aXNlIHVzZSB0aGUgZmlyc3QgcGFyYW1ldGVyIGFzIHRoZSB2YWx1ZS5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDAgfHwgKGlzQ2FsbGFibGUoRXZlbnQpICYmIGFyZ3NbMF0gaW5zdGFuY2VvZiBFdmVudCkgfHwgKGFyZ3NbMF0gJiYgYXJnc1swXS5zcmNFbGVtZW50KSkge1xuICAgICAgYXJnc1swXSA9IHRoaXMkMS52YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzJDEudmFsaWRhdG9yLnZhbGlkYXRlKChcIiNcIiArICh0aGlzJDEuaWQpKSwgYXJnc1swXSk7XG4gIH07XG5cbiAgdmFyIGlucHV0RXZlbnQgPSB0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwubGF6eSA/ICdjaGFuZ2UnIDogZ2V0SW5wdXRFdmVudE5hbWUodGhpcy5lbCk7XG4gIC8vIHJlcGxhY2UgaW5wdXQgZXZlbnQgd2l0aCBzdWl0YWJsZSBvbmUuXG4gIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cy5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZSA9PT0gJ2lucHV0JyA/IGlucHV0RXZlbnQgOiBlXG4gIH0pO1xuXG4gIC8vIGlmIHRoZXJlIGlzIGEgd2F0Y2hhYmxlIG1vZGVsIGFuZCBhbiBvbiBpbnB1dCB2YWxpZGF0aW9uIGlzIHJlcXVlc3RlZC5cbiAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC5leHByZXNzaW9uICYmIGV2ZW50cy5pbmRleE9mKGlucHV0RXZlbnQpICE9PSAtMSkge1xuICAgIHZhciBkZWJvdW5jZWRGbiA9IGRlYm91bmNlKGZuLCB0aGlzLmRlbGF5W2lucHV0RXZlbnRdKTtcbiAgICB2YXIgdW53YXRjaCA9IHRoaXMudm0uJHdhdGNoKHRoaXMubW9kZWwuZXhwcmVzc2lvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICB0aGlzJDEuZmxhZ3MucGVuZGluZyA9IHRydWU7XG4gICAgICBkZWJvdW5jZWRGbi5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgIH0pO1xuICAgIHRoaXMud2F0Y2hlcnMucHVzaCh7XG4gICAgICB0YWc6ICdpbnB1dF9tb2RlbCcsXG4gICAgICB1bndhdGNoOiB1bndhdGNoLFxuICAgIH0pO1xuICAgIC8vIGZpbHRlciBvdXQgaW5wdXQgZXZlbnQgYXMgaXQgaXMgYWxyZWFkeSBoYW5kbGVkIGJ5IHRoZSB3YXRjaGVyIEFQSS5cbiAgICBldmVudHMgPSBldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlICE9PSBpbnB1dEV2ZW50OyB9KTtcbiAgfVxuXG4gIC8vIEFkZCBldmVudHMuXG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRlYm91bmNlZEZuID0gZGVib3VuY2UoZm4sIHRoaXMkMS5kZWxheVtlXSk7XG4gICAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICB0aGlzJDEuZmxhZ3MucGVuZGluZyA9IHRydWU7XG4gICAgICBkZWJvdW5jZWRGbi5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgIH07XG5cbiAgICB0aGlzJDEuX2FkZENvbXBvbmVudEV2ZW50TGlzdGVuZXIoZSwgdmFsaWRhdGUpO1xuICAgIHRoaXMkMS5fYWRkSFRNTEV2ZW50TGlzdGVuZXIoZSwgdmFsaWRhdGUpO1xuICB9KTtcbn07XG5cbkZpZWxkLnByb3RvdHlwZS5fYWRkQ29tcG9uZW50RXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRDb21wb25lbnRFdmVudExpc3RlbmVyIChldnQsIHZhbGlkYXRlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmNvbXBvbmVudCkgeyByZXR1cm4gfVxuXG4gIHRoaXMuY29tcG9uZW50LiRvbihldnQsIHZhbGlkYXRlKTtcbiAgdGhpcy53YXRjaGVycy5wdXNoKHtcbiAgICB0YWc6ICdpbnB1dF92dWUnLFxuICAgIHVud2F0Y2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5jb21wb25lbnQuJG9mZihldnQsIHZhbGlkYXRlKTtcbiAgICB9LFxuICB9KTtcbn07XG5cbkZpZWxkLnByb3RvdHlwZS5fYWRkSFRNTEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBfYWRkSFRNTEV2ZW50TGlzdGVuZXIgKGV2dCwgdmFsaWRhdGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoIXRoaXMuZWwpIHsgcmV0dXJuIH1cblxuICBpZiAoflsncmFkaW8nLCAnY2hlY2tib3gnXS5pbmRleE9mKHRoaXMuZWwudHlwZSkpIHtcbiAgICB2YXIgZWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgoXCJpbnB1dFtuYW1lPVxcXCJcIiArICh0aGlzLmVsLm5hbWUpICsgXCJcXFwiXVwiKSk7XG4gICAgdG9BcnJheShlbHMpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgdmFsaWRhdGUpO1xuICAgICAgdGhpcyQxLndhdGNoZXJzLnB1c2goe1xuICAgICAgICB0YWc6ICdpbnB1dF9uYXRpdmUnLFxuICAgICAgICB1bndhdGNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIHZhbGlkYXRlKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCB2YWxpZGF0ZSk7XG4gIHRoaXMud2F0Y2hlcnMucHVzaCh7XG4gICAgdGFnOiAnaW5wdXRfbmF0aXZlJyxcbiAgICB1bndhdGNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIHZhbGlkYXRlKTtcbiAgICB9LFxuICB9KTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyBhcmlhIGF0dHJpYnV0ZXMgb24gdGhlIGVsZW1lbnQuXG4gKi9cbkZpZWxkLnByb3RvdHlwZS51cGRhdGVBcmlhQXR0cnMgPSBmdW5jdGlvbiB1cGRhdGVBcmlhQXR0cnMgKCkge1xuICBpZiAoIXRoaXMuYXJpYSB8fCAhdGhpcy5lbCB8fCAhaXNDYWxsYWJsZSh0aGlzLmVsLnNldEF0dHJpYnV0ZSkpIHsgcmV0dXJuIH1cblxuICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1yZXF1aXJlZCcsIHRoaXMuaXNSZXF1aXJlZCA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgdGhpcy5mbGFncy5pbnZhbGlkID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGN1c3RvbSB2YWxpZGl0eSBmb3IgdGhlIGZpZWxkLlxuICovXG5GaWVsZC5wcm90b3R5cGUudXBkYXRlQ3VzdG9tVmFsaWRpdHkgPSBmdW5jdGlvbiB1cGRhdGVDdXN0b21WYWxpZGl0eSAoKSB7XG4gIGlmICghdGhpcy52YWxpZGl0eSB8fCAhdGhpcy5lbCB8fCAhaXNDYWxsYWJsZSh0aGlzLmVsLnNldEN1c3RvbVZhbGlkaXR5KSkgeyByZXR1cm4gfVxuXG4gIHRoaXMuZWwuc2V0Q3VzdG9tVmFsaWRpdHkodGhpcy5mbGFncy52YWxpZCA/ICcnIDogKHRoaXMudmFsaWRhdG9yLmVycm9ycy5maXJzdEJ5SWQodGhpcy5pZCkgfHwgJycpKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLlxuICovXG5GaWVsZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICB0aGlzLnVud2F0Y2goKTtcbiAgdGhpcy5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5maWVsZC5kZXN0cm95KCk7IH0pO1xuICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEZpZWxkLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbi8vIFxuXG52YXIgRmllbGRCYWcgPSBmdW5jdGlvbiBGaWVsZEJhZyAoKSB7XG4gIHRoaXMuaXRlbXMgPSBbXTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgbGVuZ3RoOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCBpdGVtcyBsZW5ndGguXG4gKi9cblxucHJvdG90eXBlQWNjZXNzb3JzJDEubGVuZ3RoLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoXG59O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBmaWVsZCB0aGF0IG1hdGNoZXMgdGhlIHByb3ZpZGVkIG1hdGNoZXIgb2JqZWN0LlxuICovXG5GaWVsZEJhZy5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQkMSAobWF0Y2hlcikge1xuICByZXR1cm4gZmluZCh0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5tYXRjaGVzKG1hdGNoZXIpOyB9KVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHRoZSBpdGVtcyBkb3duIHRvIHRoZSBtYXRjaGVkIGZpZWxkcy5cbiAqL1xuRmllbGRCYWcucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAobWF0Y2hlcikge1xuICAvLyBtdWx0aXBsZSBtYXRjaGVycyB0byBiZSB0cmllZC5cbiAgaWYgKEFycmF5LmlzQXJyYXkobWF0Y2hlcikpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIG1hdGNoZXIuc29tZShmdW5jdGlvbiAobSkgeyByZXR1cm4gaXRlbS5tYXRjaGVzKG0pOyB9KTsgfSlcbiAgfVxuXG4gIHJldHVybiB0aGlzLml0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5tYXRjaGVzKG1hdGNoZXIpOyB9KVxufTtcblxuLyoqXG4gKiBNYXBzIHRoZSBmaWVsZCBpdGVtcyB1c2luZyB0aGUgbWFwcGluZyBmdW5jdGlvbi5cbiAqL1xuRmllbGRCYWcucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGVyKSB7XG4gIHJldHVybiB0aGlzLml0ZW1zLm1hcChtYXBwZXIpXG59O1xuXG4vKipcbiAqIEZpbmRzIGFuZCByZW1vdmVzIHRoZSBmaXJzdCBmaWVsZCB0aGF0IG1hdGNoZXMgdGhlIHByb3ZpZGVkIG1hdGNoZXIgb2JqZWN0LCByZXR1cm5zIHRoZSByZW1vdmVkIGl0ZW0uXG4gKi9cbkZpZWxkQmFnLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKG1hdGNoZXIpIHtcbiAgdmFyIGl0ZW0gPSBudWxsO1xuICBpZiAobWF0Y2hlciBpbnN0YW5jZW9mIEZpZWxkKSB7XG4gICAgaXRlbSA9IG1hdGNoZXI7XG4gIH0gZWxzZSB7XG4gICAgaXRlbSA9IHRoaXMuZmluZChtYXRjaGVyKTtcbiAgfVxuXG4gIGlmICghaXRlbSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgdmFyIGluZGV4ID0gdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICB0aGlzLml0ZW1zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgcmV0dXJuIGl0ZW1cbn07XG5cbi8qKlxuICogQWRkcyBhIGZpZWxkIGl0ZW0gdG8gdGhlIGxpc3QuXG4gKi9cbkZpZWxkQmFnLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAoaXRlbSkge1xuICBpZiAoISAoaXRlbSBpbnN0YW5jZW9mIEZpZWxkKSkge1xuICAgIHRocm93IGNyZWF0ZUVycm9yKCdGaWVsZEJhZyBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZpZWxkIHRoYXQgaGFzIGFuIGlkIGRlZmluZWQuJylcbiAgfVxuXG4gIGlmICghaXRlbS5pZCkge1xuICAgIHRocm93IGNyZWF0ZUVycm9yKCdGaWVsZCBpZCBtdXN0IGJlIGRlZmluZWQuJylcbiAgfVxuXG4gIGlmICh0aGlzLmZpbmQoeyBpZDogaXRlbS5pZCB9KSkge1xuICAgIHRocm93IGNyZWF0ZUVycm9yKChcIkZpZWxkIHdpdGggaWQgXCIgKyAoaXRlbS5pZCkgKyBcIiBpcyBhbHJlYWR5IGFkZGVkLlwiKSlcbiAgfVxuXG4gIHRoaXMuaXRlbXMucHVzaChpdGVtKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBGaWVsZEJhZy5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbi8vIFxuXG52YXIgTE9DQUxFID0gJ2VuJztcblxudmFyIERpY3Rpb25hcnkgPSBmdW5jdGlvbiBEaWN0aW9uYXJ5IChkaWN0aW9uYXJ5KSB7XG4gIGlmICggZGljdGlvbmFyeSA9PT0gdm9pZCAwICkgZGljdGlvbmFyeSA9IHt9O1xuXG4gIHRoaXMuY29udGFpbmVyID0ge307XG4gIHRoaXMubWVyZ2UoZGljdGlvbmFyeSk7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDIgPSB7IGxvY2FsZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMi5sb2NhbGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gTE9DQUxFXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMi5sb2NhbGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIExPQ0FMRSA9IHZhbHVlIHx8ICdlbic7XG59O1xuXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5oYXNMb2NhbGUgPSBmdW5jdGlvbiBoYXNMb2NhbGUgKGxvY2FsZSkge1xuICByZXR1cm4gISF0aGlzLmNvbnRhaW5lcltsb2NhbGVdXG59O1xuXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5zZXREYXRlRm9ybWF0ID0gZnVuY3Rpb24gc2V0RGF0ZUZvcm1hdCAobG9jYWxlLCBmb3JtYXQpIHtcbiAgaWYgKCF0aGlzLmNvbnRhaW5lcltsb2NhbGVdKSB7XG4gICAgdGhpcy5jb250YWluZXJbbG9jYWxlXSA9IHt9O1xuICB9XG5cbiAgdGhpcy5jb250YWluZXJbbG9jYWxlXS5kYXRlRm9ybWF0ID0gZm9ybWF0O1xufTtcblxuRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0RGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIGdldERhdGVGb3JtYXQgKGxvY2FsZSkge1xuICBpZiAoIXRoaXMuY29udGFpbmVyW2xvY2FsZV0gfHwgIXRoaXMuY29udGFpbmVyW2xvY2FsZV0uZGF0ZUZvcm1hdCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gdGhpcy5jb250YWluZXJbbG9jYWxlXS5kYXRlRm9ybWF0XG59O1xuXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRNZXNzYWdlID0gZnVuY3Rpb24gZ2V0TWVzc2FnZSAobG9jYWxlLCBrZXksIGRhdGEpIHtcbiAgdmFyIG1lc3NhZ2UgPSBudWxsO1xuICBpZiAoIXRoaXMuaGFzTWVzc2FnZShsb2NhbGUsIGtleSkpIHtcbiAgICBtZXNzYWdlID0gdGhpcy5fZ2V0RGVmYXVsdE1lc3NhZ2UobG9jYWxlKTtcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlID0gdGhpcy5jb250YWluZXJbbG9jYWxlXS5tZXNzYWdlc1trZXldO1xuICB9XG5cbiAgcmV0dXJuIGlzQ2FsbGFibGUobWVzc2FnZSkgPyBtZXNzYWdlLmFwcGx5KHZvaWQgMCwgZGF0YSkgOiBtZXNzYWdlXG59O1xuXG4vKipcbiAqIEdldHMgYSBzcGVjaWZpYyBtZXNzYWdlIGZvciBmaWVsZC4gZmFsbHMgYmFjayB0byB0aGUgcnVsZSBtZXNzYWdlLlxuICovXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRGaWVsZE1lc3NhZ2UgPSBmdW5jdGlvbiBnZXRGaWVsZE1lc3NhZ2UgKGxvY2FsZSwgZmllbGQsIGtleSwgZGF0YSkge1xuICBpZiAoIXRoaXMuaGFzTG9jYWxlKGxvY2FsZSkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNZXNzYWdlKGxvY2FsZSwga2V5LCBkYXRhKVxuICB9XG5cbiAgdmFyIGRpY3QgPSB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmN1c3RvbSAmJiB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmN1c3RvbVtmaWVsZF07XG4gIGlmICghZGljdCB8fCAhZGljdFtrZXldKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWVzc2FnZShsb2NhbGUsIGtleSwgZGF0YSlcbiAgfVxuXG4gIHZhciBtZXNzYWdlID0gZGljdFtrZXldO1xuICByZXR1cm4gaXNDYWxsYWJsZShtZXNzYWdlKSA/IG1lc3NhZ2UuYXBwbHkodm9pZCAwLCBkYXRhKSA6IG1lc3NhZ2Vcbn07XG5cbkRpY3Rpb25hcnkucHJvdG90eXBlLl9nZXREZWZhdWx0TWVzc2FnZSA9IGZ1bmN0aW9uIF9nZXREZWZhdWx0TWVzc2FnZSAobG9jYWxlKSB7XG4gIGlmICh0aGlzLmhhc01lc3NhZ2UobG9jYWxlLCAnX2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLm1lc3NhZ2VzLl9kZWZhdWx0XG4gIH1cblxuICByZXR1cm4gdGhpcy5jb250YWluZXIuZW4ubWVzc2FnZXMuX2RlZmF1bHRcbn07XG5cbkRpY3Rpb25hcnkucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZSAobG9jYWxlLCBrZXksIGZhbGxiYWNrKSB7XG4gICAgaWYgKCBmYWxsYmFjayA9PT0gdm9pZCAwICkgZmFsbGJhY2sgPSAnJztcblxuICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKGxvY2FsZSwga2V5KSkge1xuICAgIHJldHVybiBmYWxsYmFja1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY29udGFpbmVyW2xvY2FsZV0uYXR0cmlidXRlc1trZXldXG59O1xuXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5oYXNNZXNzYWdlID0gZnVuY3Rpb24gaGFzTWVzc2FnZSAobG9jYWxlLCBrZXkpIHtcbiAgcmV0dXJuICEhIChcbiAgICB0aGlzLmhhc0xvY2FsZShsb2NhbGUpICYmXG4gICAgICAgICAgdGhpcy5jb250YWluZXJbbG9jYWxlXS5tZXNzYWdlcyAmJlxuICAgICAgICAgIHRoaXMuY29udGFpbmVyW2xvY2FsZV0ubWVzc2FnZXNba2V5XVxuICApXG59O1xuXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5oYXNBdHRyaWJ1dGUgPSBmdW5jdGlvbiBoYXNBdHRyaWJ1dGUgKGxvY2FsZSwga2V5KSB7XG4gIHJldHVybiAhISAoXG4gICAgdGhpcy5oYXNMb2NhbGUobG9jYWxlKSAmJlxuICAgICAgICAgIHRoaXMuY29udGFpbmVyW2xvY2FsZV0uYXR0cmlidXRlcyAmJlxuICAgICAgICAgIHRoaXMuY29udGFpbmVyW2xvY2FsZV0uYXR0cmlidXRlc1trZXldXG4gIClcbn07XG5cbkRpY3Rpb25hcnkucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UkMSAoZGljdGlvbmFyeSkge1xuICBtZXJnZSh0aGlzLmNvbnRhaW5lciwgZGljdGlvbmFyeSk7XG59O1xuXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5zZXRNZXNzYWdlID0gZnVuY3Rpb24gc2V0TWVzc2FnZSAobG9jYWxlLCBrZXksIG1lc3NhZ2UpIHtcbiAgaWYgKCEgdGhpcy5oYXNMb2NhbGUobG9jYWxlKSkge1xuICAgIHRoaXMuY29udGFpbmVyW2xvY2FsZV0gPSB7XG4gICAgICBtZXNzYWdlczoge30sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICB9O1xuICB9XG5cbiAgdGhpcy5jb250YWluZXJbbG9jYWxlXS5tZXNzYWdlc1trZXldID0gbWVzc2FnZTtcbn07XG5cbkRpY3Rpb25hcnkucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobG9jYWxlLCBrZXksIGF0dHJpYnV0ZSkge1xuICBpZiAoISB0aGlzLmhhc0xvY2FsZShsb2NhbGUpKSB7XG4gICAgdGhpcy5jb250YWluZXJbbG9jYWxlXSA9IHtcbiAgICAgIG1lc3NhZ2VzOiB7fSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgIH07XG4gIH1cblxuICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmF0dHJpYnV0ZXNba2V5XSA9IGF0dHJpYnV0ZTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBEaWN0aW9uYXJ5LnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDIgKTtcblxuLy8gXG5cbnZhciBub3JtYWxpemVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGtleSkge1xuICAgICAgcHJldltrZXldID0gbm9ybWFsaXplVmFsdWUodmFsdWVba2V5XSk7XG5cbiAgICAgIHJldHVybiBwcmV2XG4gICAgfSwge30pXG4gIH1cblxuICBpZiAoaXNDYWxsYWJsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUoJ3swfScsIFsnezF9JywgJ3syfScsICd7M30nXSlcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufTtcblxudmFyIG5vcm1hbGl6ZUZvcm1hdCA9IGZ1bmN0aW9uIChsb2NhbGUpIHtcbiAgLy8gbm9ybWFsaXplIG1lc3NhZ2VzXG4gIHZhciBtZXNzYWdlcyA9IG5vcm1hbGl6ZVZhbHVlKGxvY2FsZS5tZXNzYWdlcyk7XG4gIHZhciBjdXN0b20gPSBub3JtYWxpemVWYWx1ZShsb2NhbGUuY3VzdG9tKTtcblxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyxcbiAgICBjdXN0b206IGN1c3RvbSxcbiAgICBhdHRyaWJ1dGVzOiBsb2NhbGUuYXR0cmlidXRlcyxcbiAgICBkYXRlRm9ybWF0OiBsb2NhbGUuZGF0ZUZvcm1hdCxcbiAgfVxufTtcblxudmFyIEkxOG5EaWN0aW9uYXJ5ID0gZnVuY3Rpb24gSTE4bkRpY3Rpb25hcnkgKGkxOG4sIHJvb3RLZXkpIHtcbiAgdGhpcy5pMThuID0gaTE4bjtcbiAgdGhpcy5yb290S2V5ID0gcm9vdEtleTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMyA9IHsgbG9jYWxlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQzLmxvY2FsZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmkxOG4ubG9jYWxlXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMy5sb2NhbGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHdhcm4oJ0Nhbm5vdCBzZXQgbG9jYWxlIGZyb20gdGhlIHZhbGlkYXRvciB3aGVuIHVzaW5nIHZ1ZS1pMThuLCB1c2UgaTE4bi5sb2NhbGUgc2V0dGVyIGluc3RlYWQnKTtcbn07XG5cbkkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXREYXRlRm9ybWF0ID0gZnVuY3Rpb24gZ2V0RGF0ZUZvcm1hdCAobG9jYWxlKSB7XG4gIHJldHVybiB0aGlzLmkxOG4uZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlIHx8IHRoaXMubG9jYWxlKVxufTtcblxuSTE4bkRpY3Rpb25hcnkucHJvdG90eXBlLnNldERhdGVGb3JtYXQgPSBmdW5jdGlvbiBzZXREYXRlRm9ybWF0IChsb2NhbGUsIHZhbHVlKSB7XG4gIHRoaXMuaTE4bi5zZXREYXRlVGltZUZvcm1hdChsb2NhbGUgfHwgdGhpcy5sb2NhbGUsIHZhbHVlKTtcbn07XG5cbkkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRNZXNzYWdlID0gZnVuY3Rpb24gZ2V0TWVzc2FnZSAobG9jYWxlLCBrZXksIGRhdGEpIHtcbiAgdmFyIHBhdGggPSAodGhpcy5yb290S2V5KSArIFwiLm1lc3NhZ2VzLlwiICsga2V5O1xuICBpZiAoIXRoaXMuaTE4bi50ZShwYXRoKSkge1xuICAgIHJldHVybiB0aGlzLmkxOG4udCgoKHRoaXMucm9vdEtleSkgKyBcIi5tZXNzYWdlcy5fZGVmYXVsdFwiKSwgbG9jYWxlLCBkYXRhKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuaTE4bi50KHBhdGgsIGxvY2FsZSwgZGF0YSlcbn07XG5cbkkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUgKGxvY2FsZSwga2V5LCBmYWxsYmFjaykge1xuICAgIGlmICggZmFsbGJhY2sgPT09IHZvaWQgMCApIGZhbGxiYWNrID0gJyc7XG5cbiAgdmFyIHBhdGggPSAodGhpcy5yb290S2V5KSArIFwiLmF0dHJpYnV0ZXMuXCIgKyBrZXk7XG4gIGlmICghdGhpcy5pMThuLnRlKHBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrXG4gIH1cblxuICByZXR1cm4gdGhpcy5pMThuLnQocGF0aCwgbG9jYWxlKVxufTtcblxuSTE4bkRpY3Rpb25hcnkucHJvdG90eXBlLmdldEZpZWxkTWVzc2FnZSA9IGZ1bmN0aW9uIGdldEZpZWxkTWVzc2FnZSAobG9jYWxlLCBmaWVsZCwga2V5LCBkYXRhKSB7XG4gIHZhciBwYXRoID0gKHRoaXMucm9vdEtleSkgKyBcIi5jdXN0b20uXCIgKyBmaWVsZCArIFwiLlwiICsga2V5O1xuICBpZiAodGhpcy5pMThuLnRlKHBhdGgpKSB7XG4gICAgcmV0dXJuIHRoaXMuaTE4bi50KHBhdGgpXG4gIH1cblxuICByZXR1cm4gdGhpcy5nZXRNZXNzYWdlKGxvY2FsZSwga2V5LCBkYXRhKVxufTtcblxuSTE4bkRpY3Rpb25hcnkucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UkMSAoZGljdGlvbmFyeSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIE9iamVjdC5rZXlzKGRpY3Rpb25hcnkpLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsZUtleSkge1xuICAgICAgdmFyIG9iajtcblxuICAgIC8vIGkxOG4gZG9lc24ndCBkZWVwIG1lcmdlXG4gICAgLy8gZmlyc3QgY2xvbmUgdGhlIGV4aXN0aW5nIGxvY2FsZSAoYXZvaWQgbXV0YXRpb25zIHRvIGxvY2FsZSlcbiAgICB2YXIgY2xvbmUgPSBtZXJnZSh7fSwgZ2V0UGF0aCgobG9jYWxlS2V5ICsgXCIuXCIgKyAodGhpcyQxLnJvb3RLZXkpKSwgdGhpcyQxLmkxOG4ubWVzc2FnZXMsIHt9KSk7XG4gICAgLy8gTWVyZ2UgY2xvbmVkIGxvY2FsZSB3aXRoIG5ldyBvbmVcbiAgICB2YXIgbG9jYWxlID0gbWVyZ2UoY2xvbmUsIG5vcm1hbGl6ZUZvcm1hdChkaWN0aW9uYXJ5W2xvY2FsZUtleV0pKTtcbiAgICB0aGlzJDEuaTE4bi5tZXJnZUxvY2FsZU1lc3NhZ2UobG9jYWxlS2V5LCAoIG9iaiA9IHt9LCBvYmpbdGhpcyQxLnJvb3RLZXldID0gbG9jYWxlLCBvYmopKTtcbiAgICBpZiAobG9jYWxlLmRhdGVGb3JtYXQpIHtcbiAgICAgIHRoaXMkMS5pMThuLnNldERhdGVUaW1lRm9ybWF0KGxvY2FsZUtleSwgbG9jYWxlLmRhdGVGb3JtYXQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5JMThuRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0TWVzc2FnZSA9IGZ1bmN0aW9uIHNldE1lc3NhZ2UgKGxvY2FsZSwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBvYmosIG9iaiQxO1xuXG4gIHRoaXMubWVyZ2UoKCBvYmokMSA9IHt9LCBvYmokMVtsb2NhbGVdID0ge1xuICAgICAgbWVzc2FnZXM6ICggb2JqID0ge30sIG9ialtrZXldID0gdmFsdWUsIG9iaiksXG4gICAgfSwgb2JqJDEpKTtcbn07XG5cbkkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKGxvY2FsZSwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBvYmosIG9iaiQxO1xuXG4gIHRoaXMubWVyZ2UoKCBvYmokMSA9IHt9LCBvYmokMVtsb2NhbGVdID0ge1xuICAgICAgYXR0cmlidXRlczogKCBvYmogPSB7fSwgb2JqW2tleV0gPSB2YWx1ZSwgb2JqKSxcbiAgICB9LCBvYmokMSkpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDMgKTtcblxuLy8gXG5cbnZhciBkZWZhdWx0Q29uZmlnID0ge1xuICBsb2NhbGU6ICdlbicsXG4gIGRlbGF5OiAwLFxuICBlcnJvckJhZ05hbWU6ICdlcnJvcnMnLFxuICBkaWN0aW9uYXJ5OiBudWxsLFxuICBzdHJpY3Q6IHRydWUsXG4gIGZpZWxkc0JhZ05hbWU6ICdmaWVsZHMnLFxuICBjbGFzc2VzOiBmYWxzZSxcbiAgY2xhc3NOYW1lczogbnVsbCxcbiAgZXZlbnRzOiAnaW5wdXR8Ymx1cicsXG4gIGluamVjdDogdHJ1ZSxcbiAgZmFzdEV4aXQ6IHRydWUsXG4gIGFyaWE6IHRydWUsXG4gIHZhbGlkaXR5OiBmYWxzZSxcbiAgaTE4bjogbnVsbCxcbiAgaTE4blJvb3RLZXk6ICd2YWxpZGF0aW9uJyxcbn07XG5cbnZhciBjdXJyZW50Q29uZmlnID0gYXNzaWduKHt9LCBkZWZhdWx0Q29uZmlnKTtcbnZhciBkZXBlbmRlbmNpZXMgPSB7XG4gIGRpY3Rpb25hcnk6IG5ldyBEaWN0aW9uYXJ5KHtcbiAgICBlbjoge1xuICAgICAgbWVzc2FnZXM6IHt9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBjdXN0b206IHt9LFxuICAgIH0sXG4gIH0pLFxufTtcblxudmFyIENvbmZpZyA9IGZ1bmN0aW9uIENvbmZpZyAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgZGVmYXVsdDogeyBjb25maWd1cmFibGU6IHRydWUgfSxjdXJyZW50OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbnN0YXRpY0FjY2Vzc29ycy5kZWZhdWx0LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRlZmF1bHRDb25maWdcbn07XG5cbnN0YXRpY0FjY2Vzc29ycy5jdXJyZW50LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGN1cnJlbnRDb25maWdcbn07XG5cbkNvbmZpZy5kZXBlbmRlbmN5ID0gZnVuY3Rpb24gZGVwZW5kZW5jeSAoa2V5KSB7XG4gIHJldHVybiBkZXBlbmRlbmNpZXNba2V5XVxufTtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIGNvbmZpZyB3aXRoIGEgbmV3IG9uZS5cbiAqL1xuQ29uZmlnLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UkJDEgKGNvbmZpZykge1xuICBjdXJyZW50Q29uZmlnID0gYXNzaWduKHt9LCBjdXJyZW50Q29uZmlnLCBjb25maWcpO1xuICBpZiAoY3VycmVudENvbmZpZy5pMThuKSB7XG4gICAgQ29uZmlnLnJlZ2lzdGVyKCdkaWN0aW9uYXJ5JywgbmV3IEkxOG5EaWN0aW9uYXJ5KGN1cnJlbnRDb25maWcuaTE4biwgY3VycmVudENvbmZpZy5pMThuUm9vdEtleSkpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIGRlcGVuZGVuY3kuXG4gKi9cbkNvbmZpZy5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyIChrZXksIHZhbHVlKSB7XG4gIGRlcGVuZGVuY2llc1trZXldID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoZSB3b3JraW5nIGNvbmZpZyBmcm9tIGEgVnVlIGluc3RhbmNlLlxuICovXG5Db25maWcucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKGNvbnRleHQpIHtcbiAgdmFyIHNlbGZDb25maWcgPSBnZXRQYXRoKCckb3B0aW9ucy4kX3JlZVZhbGlkYXRlJywgY29udGV4dCwge30pO1xuXG4gIHJldHVybiBhc3NpZ24oe30sIENvbmZpZy5jdXJyZW50LCBzZWxmQ29uZmlnKVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIENvbmZpZywgc3RhdGljQWNjZXNzb3JzICk7XG5cbi8vIFxuXG52YXIgUlVMRVMgPSB7fTtcbnZhciBTVFJJQ1RfTU9ERSA9IHRydWU7XG52YXIgVEFSR0VUX1JVTEVTID0gWydjb25maXJtZWQnLCAnYWZ0ZXInLCAnYmVmb3JlJ107XG52YXIgRVJST1JTID0gW107IC8vIEhPTEQgZXJyb3JzIHJlZmVyZW5jZXMgdG8gdHJpZ2dlciByZWdlbmVyYXRpb24uXG5cbnZhciBWYWxpZGF0b3IgPSBmdW5jdGlvbiBWYWxpZGF0b3IgKHZhbGlkYXRpb25zLCBvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7IHZtOiBudWxsLCBmYXN0RXhpdDogdHJ1ZSB9O1xuXG4gIHRoaXMuc3RyaWN0ID0gU1RSSUNUX01PREU7XG4gIHRoaXMuZXJyb3JzID0gbmV3IEVycm9yQmFnKCk7XG5cbiAgLy8gV2UgYXJlIHJ1bm5pbmcgaW4gU1NSIE1vZGUuIERvIG5vdCBrZWVwIGEgcmVmZXJlbmNlLiBJdCBwcmV2ZW50IGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgRVJST1JTLnB1c2godGhpcy5lcnJvcnMpO1xuICB9XG4gIHRoaXMuZmllbGRzID0gbmV3IEZpZWxkQmFnKCk7XG4gIHRoaXMuZmxhZ3MgPSB7fTtcbiAgdGhpcy5fY3JlYXRlRmllbGRzKHZhbGlkYXRpb25zKTtcbiAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgdGhpcy5mYXN0RXhpdCA9IG9wdGlvbnMuZmFzdEV4aXQgfHwgZmFsc2U7XG4gIHRoaXMub3duZXJJZCA9IG9wdGlvbnMudm0gJiYgb3B0aW9ucy52bS5fdWlkO1xuICAvLyBjcmVhdGUgaXQgc3RhdGljYWxseSBzaW5jZSB3ZSBkb24ndCBuZWVkIGNvbnN0YW50IGFjY2VzcyB0byB0aGUgdm0uXG4gIHRoaXMucmVzZXQgPSBvcHRpb25zLnZtICYmIGlzQ2FsbGFibGUob3B0aW9ucy52bS4kbmV4dFRpY2spID8gZnVuY3Rpb24gKG1hdGNoZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIG9wdGlvbnMudm0uJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb3B0aW9ucy52bS4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUodGhpcyQxLl9yZXNldChtYXRjaGVyKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSlcbiAgfSA6IHRoaXMuX3Jlc2V0O1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQ0ID0geyBkaWN0aW9uYXJ5OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGxvY2FsZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxydWxlczogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xudmFyIHN0YXRpY0FjY2Vzc29ycyQxID0geyBkaWN0aW9uYXJ5OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGxvY2FsZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxydWxlczogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vKipcbiAqIEdldHRlciBmb3IgdGhlIGRpY3Rpb25hcnkuXG4gKi9cbnByb3RvdHlwZUFjY2Vzc29ycyQ0LmRpY3Rpb25hcnkuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gQ29uZmlnLmRlcGVuZGVuY3koJ2RpY3Rpb25hcnknKVxufTtcblxuLyoqXG4gKiBTdGF0aWMgR2V0dGVyIGZvciB0aGUgZGljdGlvbmFyeS5cbiAqL1xuc3RhdGljQWNjZXNzb3JzJDEuZGljdGlvbmFyeS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBDb25maWcuZGVwZW5kZW5jeSgnZGljdGlvbmFyeScpXG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlLlxuICovXG5wcm90b3R5cGVBY2Nlc3NvcnMkNC5sb2NhbGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5kaWN0aW9uYXJ5LmxvY2FsZVxufTtcblxuLyoqXG4gKiBTZXR0ZXIgZm9yIHRoZSB2YWxpZGF0b3IgbG9jYWxlLlxuICovXG5wcm90b3R5cGVBY2Nlc3NvcnMkNC5sb2NhbGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFZhbGlkYXRvci5sb2NhbGUgPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogU3RhdGljIGdldHRlciBmb3IgdGhlIHZhbGlkYXRvciBsb2NhbGUuXG4gKi9cbnN0YXRpY0FjY2Vzc29ycyQxLmxvY2FsZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBWYWxpZGF0b3IuZGljdGlvbmFyeS5sb2NhbGVcbn07XG5cbi8qKlxuICogU3RhdGljIHNldHRlciBmb3IgdGhlIHZhbGlkYXRvciBsb2NhbGUuXG4gKi9cbnN0YXRpY0FjY2Vzc29ycyQxLmxvY2FsZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIGhhc0NoYW5nZWQgPSB2YWx1ZSAhPT0gVmFsaWRhdG9yLmRpY3Rpb25hcnkubG9jYWxlO1xuICBWYWxpZGF0b3IuZGljdGlvbmFyeS5sb2NhbGUgPSB2YWx1ZTtcbiAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICBWYWxpZGF0b3IucmVnZW5lcmF0ZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgdGhlIHJ1bGVzIG9iamVjdC5cbiAqL1xucHJvdG90eXBlQWNjZXNzb3JzJDQucnVsZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gUlVMRVNcbn07XG5cbi8qKlxuICogU3RhdGljIEdldHRlciBmb3IgdGhlIHJ1bGVzIG9iamVjdC5cbiAqL1xuc3RhdGljQWNjZXNzb3JzJDEucnVsZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gUlVMRVNcbn07XG5cbi8qKlxuICogU3RhdGljIGNvbnN0cnVjdG9yLlxuICovXG5WYWxpZGF0b3IuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlICh2YWxpZGF0aW9ucywgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFZhbGlkYXRvcih2YWxpZGF0aW9ucywgb3B0aW9ucylcbn07XG5cbi8qKlxuICogQWRkcyBhIGN1c3RvbSB2YWxpZGF0b3IgdG8gdGhlIGxpc3Qgb2YgdmFsaWRhdGlvbiBydWxlcy5cbiAqL1xuVmFsaWRhdG9yLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAobmFtZSwgdmFsaWRhdG9yLCBvcHRpb25zKSB7XG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgVmFsaWRhdG9yLl9ndWFyZEV4dGVuZChuYW1lLCB2YWxpZGF0b3IpO1xuICBWYWxpZGF0b3IuX21lcmdlKG5hbWUsIHZhbGlkYXRvcik7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGFzVGFyZ2V0KSB7XG4gICAgVEFSR0VUX1JVTEVTLnB1c2gobmFtZSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVnZW5lcmF0ZXMgZXJyb3IgbWVzc2FnZXMgYWNyb3NzIGFsbCB2YWxpZGF0b3JzLlxuICovXG5WYWxpZGF0b3IucmVnZW5lcmF0ZSA9IGZ1bmN0aW9uIHJlZ2VuZXJhdGUgKCkge1xuICBFUlJPUlMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3JCYWcpIHsgcmV0dXJuIGVycm9yQmFnLnJlZ2VuZXJhdGUoKTsgfSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBydWxlIGZyb20gdGhlIGxpc3Qgb2YgdmFsaWRhdG9ycy5cbiAqL1xuVmFsaWRhdG9yLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAobmFtZSkge1xuICBkZWxldGUgUlVMRVNbbmFtZV07XG4gIHZhciBpZHggPSBUQVJHRVRfUlVMRVMuaW5kZXhPZihuYW1lKTtcbiAgaWYgKGlkeCA9PT0gLTEpIHsgcmV0dXJuIH1cblxuICBUQVJHRVRfUlVMRVMuc3BsaWNlKGlkeCwgMSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gcnVsZSBuYW1lIGlzIGEgcnVsZSB0aGF0IHRhcmdldHMgb3RoZXIgZmllbGRzLlxuICovXG5WYWxpZGF0b3IuaXNUYXJnZXRSdWxlID0gZnVuY3Rpb24gaXNUYXJnZXRSdWxlIChuYW1lKSB7XG4gIHJldHVybiBUQVJHRVRfUlVMRVMuaW5kZXhPZihuYW1lKSAhPT0gLTFcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgb3BlcmF0aW5nIG1vZGUgZm9yIGFsbCBuZXdseSBjcmVhdGVkIHZhbGlkYXRvcnMuXG4gKiBzdHJpY3RNb2RlID0gdHJ1ZTogVmFsdWVzIHdpdGhvdXQgYSBydWxlIGFyZSBpbnZhbGlkIGFuZCBjYXVzZSBmYWlsdXJlLlxuICogc3RyaWN0TW9kZSA9IGZhbHNlOiBWYWx1ZXMgd2l0aG91dCBhIHJ1bGUgYXJlIHZhbGlkIGFuZCBhcmUgc2tpcHBlZC5cbiAqL1xuVmFsaWRhdG9yLnNldFN0cmljdE1vZGUgPSBmdW5jdGlvbiBzZXRTdHJpY3RNb2RlIChzdHJpY3RNb2RlKSB7XG4gICAgaWYgKCBzdHJpY3RNb2RlID09PSB2b2lkIDAgKSBzdHJpY3RNb2RlID0gdHJ1ZTtcblxuICBTVFJJQ1RfTU9ERSA9IHN0cmljdE1vZGU7XG59O1xuXG4vKipcbiAqIEFkZHMgYW5kIHNldHMgdGhlIGN1cnJlbnQgbG9jYWxlIGZvciB0aGUgdmFsaWRhdG9yLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLmxvY2FsaXplID0gZnVuY3Rpb24gbG9jYWxpemUgKGxhbmcsIGRpY3Rpb25hcnkpIHtcbiAgVmFsaWRhdG9yLmxvY2FsaXplKGxhbmcsIGRpY3Rpb25hcnkpO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuZCBzZXRzIHRoZSBjdXJyZW50IGxvY2FsZSBmb3IgdGhlIHZhbGlkYXRvci5cbiAqL1xuVmFsaWRhdG9yLmxvY2FsaXplID0gZnVuY3Rpb24gbG9jYWxpemUgKGxhbmcsIGRpY3Rpb25hcnkpIHtcbiAgICB2YXIgb2JqO1xuXG4gIGlmIChpc09iamVjdChsYW5nKSkge1xuICAgIFZhbGlkYXRvci5kaWN0aW9uYXJ5Lm1lcmdlKGxhbmcpO1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gbWVyZ2UgdGhlIGRpY3Rpb25hcnkuXG4gIGlmIChkaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGxvY2FsZSA9IGxhbmcgfHwgZGljdGlvbmFyeS5uYW1lO1xuICAgIGRpY3Rpb25hcnkgPSBhc3NpZ24oe30sIGRpY3Rpb25hcnkpO1xuICAgIFZhbGlkYXRvci5kaWN0aW9uYXJ5Lm1lcmdlKCggb2JqID0ge30sIG9ialtsb2NhbGVdID0gZGljdGlvbmFyeSwgb2JqKSk7XG4gIH1cblxuICBpZiAobGFuZykge1xuICAgIC8vIHNldCB0aGUgbG9jYWxlLlxuICAgIFZhbGlkYXRvci5sb2NhbGUgPSBsYW5nO1xuICB9XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIGZpZWxkIHRvIGJlIHZhbGlkYXRlZC5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2ggKGZpZWxkKSB7XG4gIC8vIGRlcHJlY2F0ZTogaGFuZGxlIG9sZCBzaWduYXR1cmUuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm4oJ1RoaXMgc2lnbmF0dXJlIG9mIHRoZSBhdHRhY2ggbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSBjb25zdWx0IHRoZSBkb2NzLicpO1xuICAgIGZpZWxkID0gYXNzaWduKHt9LCB7XG4gICAgICBuYW1lOiBhcmd1bWVudHNbMF0sXG4gICAgICBydWxlczogYXJndW1lbnRzWzFdLFxuICAgIH0sIGFyZ3VtZW50c1syXSB8fCB7IHZtOiB7ICR2YWxpZGF0b3I6IHRoaXMgfSB9KTtcbiAgfVxuXG4gIC8vIGZpeGVzIGluaXRpYWwgdmFsdWUgZGV0ZWN0aW9uIHdpdGggdi1tb2RlbCBhbmQgc2VsZWN0IGVsZW1lbnRzLlxuICB2YXIgdmFsdWUgPSBmaWVsZC5pbml0aWFsVmFsdWU7XG4gIGlmICghKGZpZWxkIGluc3RhbmNlb2YgRmllbGQpKSB7XG4gICAgZmllbGQgPSBuZXcgRmllbGQoZmllbGQuZWwgfHwgbnVsbCwgZmllbGQpO1xuICB9XG5cbiAgdGhpcy5maWVsZHMucHVzaChmaWVsZCk7XG5cbiAgLy8gdmFsaWRhdGUgdGhlIGZpZWxkIGluaXRpYWxseVxuICBpZiAoZmllbGQuaW5pdGlhbCkge1xuICAgIHRoaXMudmFsaWRhdGUoKFwiI1wiICsgKGZpZWxkLmlkKSksIHZhbHVlIHx8IGZpZWxkLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl92YWxpZGF0ZShmaWVsZCwgdmFsdWUgfHwgZmllbGQudmFsdWUsIHRydWUpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgZmllbGQuZmxhZ3MudmFsaWQgPSByZXN1bHQudmFsaWQ7XG4gICAgICBmaWVsZC5mbGFncy5pbnZhbGlkID0gIXJlc3VsdC52YWxpZDtcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuX2FkZEZsYWcoZmllbGQsIGZpZWxkLnNjb3BlKTtcbiAgcmV0dXJuIGZpZWxkXG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGZsYWdzIG9uIGEgZmllbGQuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuZmxhZyA9IGZ1bmN0aW9uIGZsYWcgKG5hbWUsIGZsYWdzKSB7XG4gIHZhciBmaWVsZCA9IHRoaXMuX3Jlc29sdmVGaWVsZChuYW1lKTtcbiAgaWYgKCFmaWVsZCB8fCAhZmxhZ3MpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZpZWxkLnNldEZsYWdzKGZsYWdzKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGZpZWxkIGZyb20gdGhlIHZhbGlkYXRvci5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2ggKG5hbWUsIHNjb3BlKSB7XG4gIHZhciBmaWVsZCA9IG5hbWUgaW5zdGFuY2VvZiBGaWVsZCA/IG5hbWUgOiB0aGlzLl9yZXNvbHZlRmllbGQobmFtZSwgc2NvcGUpO1xuICBpZiAoIWZpZWxkKSB7IHJldHVybiB9XG5cbiAgZmllbGQuZGVzdHJveSgpO1xuICB0aGlzLmVycm9ycy5yZW1vdmUoZmllbGQubmFtZSwgZmllbGQuc2NvcGUsIGZpZWxkLmlkKTtcbiAgdGhpcy5maWVsZHMucmVtb3ZlKGZpZWxkKTtcbiAgdmFyIGZsYWdzID0gdGhpcy5mbGFncztcbiAgaWYgKCFpc051bGxPclVuZGVmaW5lZChmaWVsZC5zY29wZSkgJiYgZmxhZ3NbKFwiJFwiICsgKGZpZWxkLnNjb3BlKSldKSB7XG4gICAgZGVsZXRlIGZsYWdzWyhcIiRcIiArIChmaWVsZC5zY29wZSkpXVtmaWVsZC5uYW1lXTtcbiAgfSBlbHNlIGlmIChpc051bGxPclVuZGVmaW5lZChmaWVsZC5zY29wZSkpIHtcbiAgICBkZWxldGUgZmxhZ3NbZmllbGQubmFtZV07XG4gIH1cblxuICB0aGlzLmZsYWdzID0gYXNzaWduKHt9LCBmbGFncyk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjdXN0b20gdmFsaWRhdG9yIHRvIHRoZSBsaXN0IG9mIHZhbGlkYXRpb24gcnVsZXMuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kIChuYW1lLCB2YWxpZGF0b3IsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBWYWxpZGF0b3IuZXh0ZW5kKG5hbWUsIHZhbGlkYXRvciwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYSBmaWVsZCwgdXBkYXRpbmcgYm90aCBlcnJvcnMgYW5kIGZsYWdzLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoaWQsIHJlZikge1xuICAgIHZhciBzY29wZSA9IHJlZi5zY29wZTtcblxuICB2YXIgZmllbGQgPSB0aGlzLl9yZXNvbHZlRmllbGQoKFwiI1wiICsgaWQpKTtcbiAgaWYgKCFmaWVsZCkgeyByZXR1cm4gfVxuXG4gIC8vIHJlbW92ZSBvbGQgc2NvcGUuXG4gIHRoaXMuZXJyb3JzLnVwZGF0ZShpZCwgeyBzY29wZTogc2NvcGUgfSk7XG4gIGlmICghaXNOdWxsT3JVbmRlZmluZWQoZmllbGQuc2NvcGUpICYmIHRoaXMuZmxhZ3NbKFwiJFwiICsgKGZpZWxkLnNjb3BlKSldKSB7XG4gICAgZGVsZXRlIHRoaXMuZmxhZ3NbKFwiJFwiICsgKGZpZWxkLnNjb3BlKSldW2ZpZWxkLm5hbWVdO1xuICB9IGVsc2UgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGZpZWxkLnNjb3BlKSkge1xuICAgIGRlbGV0ZSB0aGlzLmZsYWdzW2ZpZWxkLm5hbWVdO1xuICB9XG5cbiAgdGhpcy5fYWRkRmxhZyhmaWVsZCwgc2NvcGUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgcnVsZSBmcm9tIHRoZSBsaXN0IG9mIHZhbGlkYXRvcnMuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChuYW1lKSB7XG4gIFZhbGlkYXRvci5yZW1vdmUobmFtZSk7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBhIHZhbHVlIGFnYWluc3QgYSByZWdpc3RlcmVkIGZpZWxkIHZhbGlkYXRpb25zLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUgKG5hbWUsIHZhbHVlLCBzY29wZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIGlmICggc2NvcGUgPT09IHZvaWQgMCApIHNjb3BlID0gbnVsbDtcblxuICBpZiAodGhpcy5wYXVzZWQpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKSB9XG5cbiAgLy8gb3ZlcmxvYWQgdG8gdmFsaWRhdGUgYWxsLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU2NvcGVzKClcbiAgfVxuXG4gIC8vIG92ZXJsb2FkIHRvIHZhbGlkYXRlIHNjb3BlLWxlc3MgZmllbGRzLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0gPT09ICcqJykge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlQWxsKClcbiAgfVxuXG4gIC8vIG92ZXJsb2FkIHRvIHZhbGlkYXRlIGEgc2NvcGUuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnICYmIC9eKC4rKVxcLlxcKiQvLnRlc3QoYXJndW1lbnRzWzBdKSkge1xuICAgIHZhciBtYXRjaGVkID0gYXJndW1lbnRzWzBdLm1hdGNoKC9eKC4rKVxcLlxcKiQvKVsxXTtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUFsbChtYXRjaGVkKVxuICB9XG5cbiAgdmFyIGZpZWxkID0gdGhpcy5fcmVzb2x2ZUZpZWxkKG5hbWUsIHNjb3BlKTtcbiAgaWYgKCFmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLl9oYW5kbGVGaWVsZE5vdEZvdW5kKG5hbWUsIHNjb3BlKVxuICB9XG5cbiAgZmllbGQuZmxhZ3MucGVuZGluZyA9IHRydWU7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFsdWUgPSBmaWVsZC52YWx1ZTtcbiAgfVxuXG4gIHZhciBzaWxlbnRSdW4gPSBmaWVsZC5pc0Rpc2FibGVkO1xuXG4gIHJldHVybiB0aGlzLl92YWxpZGF0ZShmaWVsZCwgdmFsdWUsIHNpbGVudFJ1bikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdGhpcyQxLmVycm9ycy5yZW1vdmUoZmllbGQubmFtZSwgZmllbGQuc2NvcGUsIGZpZWxkLmlkKTtcbiAgICBpZiAoc2lsZW50UnVuKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpXG4gICAgfSBlbHNlIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICByZXN1bHQuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRoaXMkMS5lcnJvcnMuYWRkKGUpOyB9KTtcbiAgICB9XG5cbiAgICBmaWVsZC5zZXRGbGFncyh7XG4gICAgICBwZW5kaW5nOiBmYWxzZSxcbiAgICAgIHZhbGlkOiByZXN1bHQudmFsaWQsXG4gICAgICB2YWxpZGF0ZWQ6IHRydWUsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0LnZhbGlkXG4gIH0pXG59O1xuXG4vKipcbiAqIFBhdXNlcyB0aGUgdmFsaWRhdG9yLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UgKCkge1xuICB0aGlzLnBhdXNlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8qKlxuICogUmVzdW1lcyB0aGUgdmFsaWRhdG9yLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSAoKSB7XG4gIHRoaXMucGF1c2VkID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGVhY2ggdmFsdWUgYWdhaW5zdCB0aGUgY29ycmVzcG9uZGluZyBmaWVsZCB2YWxpZGF0aW9ucy5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZUFsbCA9IGZ1bmN0aW9uIHZhbGlkYXRlQWxsICh2YWx1ZXMpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMucGF1c2VkKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSkgfVxuXG4gIHZhciBtYXRjaGVyID0gbnVsbDtcbiAgdmFyIHByb3ZpZGVkVmFsdWVzID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgbWF0Y2hlciA9IHsgc2NvcGU6IHZhbHVlcyB9O1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlcykpIHtcbiAgICBtYXRjaGVyID0gT2JqZWN0LmtleXModmFsdWVzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHsgbmFtZToga2V5LCBzY29wZTogYXJndW1lbnRzJDFbMV0gfHwgbnVsbCB9XG4gICAgfSk7XG4gICAgcHJvdmlkZWRWYWx1ZXMgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBtYXRjaGVyID0geyBzY29wZTogbnVsbCB9OyAvLyBnbG9iYWwgc2NvcGUuXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgbWF0Y2hlciA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHsgbmFtZToga2V5LCBzY29wZTogYXJndW1lbnRzJDFbMV0gfHwgbnVsbCB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcHJvbWlzZXMgPSB0aGlzLmZpZWxkcy5maWx0ZXIobWF0Y2hlcikubWFwKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gdGhpcyQxLnZhbGlkYXRlKFxuICAgIChcIiNcIiArIChmaWVsZC5pZCkpLFxuICAgIHByb3ZpZGVkVmFsdWVzID8gdmFsdWVzW2ZpZWxkLm5hbWVdIDogZmllbGQudmFsdWVcbiAgKTsgfSk7XG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7IHJldHVybiByZXN1bHRzLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9KTsgfSlcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGFsbCBzY29wZXMuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVTY29wZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZVNjb3BlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMucGF1c2VkKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSkgfVxuXG4gIHZhciBwcm9taXNlcyA9IHRoaXMuZmllbGRzLm1hcChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIHRoaXMkMS52YWxpZGF0ZShcbiAgICAoXCIjXCIgKyAoZmllbGQuaWQpKSxcbiAgICBmaWVsZC52YWx1ZVxuICApOyB9KTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHsgcmV0dXJuIHJlc3VsdHMuZXZlcnkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH0pOyB9KVxufTtcblxuLyoqXG4gKiBQZXJmb3JtIGNsZWFudXAuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICAvLyBSZW1vdmUgRXJyb3JCYWcgaW5zdGFuY2UuXG4gIHZhciBpZHggPSBFUlJPUlMuaW5kZXhPZih0aGlzLmVycm9ycyk7XG4gIGlmIChpZHggPT09IC0xKSB7IHJldHVybiB9XG5cbiAgRVJST1JTLnNwbGljZShpZHgsIDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBmaWVsZHMgdG8gYmUgdmFsaWRhdGVkLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLl9jcmVhdGVGaWVsZHMgPSBmdW5jdGlvbiBfY3JlYXRlRmllbGRzICh2YWxpZGF0aW9ucykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICghdmFsaWRhdGlvbnMpIHsgcmV0dXJuIH1cblxuICBPYmplY3Qua2V5cyh2YWxpZGF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFzc2lnbih7fSwgeyBuYW1lOiBmaWVsZCwgcnVsZXM6IHZhbGlkYXRpb25zW2ZpZWxkXSB9KTtcbiAgICB0aGlzJDEuYXR0YWNoKG9wdGlvbnMpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRGF0ZSBydWxlcyBuZWVkIHRoZSBleGlzdGVuY2Ugb2YgYSBmb3JtYXQsIHNvIGRhdGVfZm9ybWF0IG11c3QgYmUgc3VwcGxpZWQuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuX2dldERhdGVGb3JtYXQgPSBmdW5jdGlvbiBfZ2V0RGF0ZUZvcm1hdCAodmFsaWRhdGlvbnMpIHtcbiAgdmFyIGZvcm1hdCA9IG51bGw7XG4gIGlmICh2YWxpZGF0aW9ucy5kYXRlX2Zvcm1hdCAmJiBBcnJheS5pc0FycmF5KHZhbGlkYXRpb25zLmRhdGVfZm9ybWF0KSkge1xuICAgIGZvcm1hdCA9IHZhbGlkYXRpb25zLmRhdGVfZm9ybWF0WzBdO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdCB8fCB0aGlzLmRpY3Rpb25hcnkuZ2V0RGF0ZUZvcm1hdCh0aGlzLmxvY2FsZSlcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwYXNzZWQgcnVsZSBpcyBhIGRhdGUgcnVsZS5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5faXNBRGF0ZVJ1bGUgPSBmdW5jdGlvbiBfaXNBRGF0ZVJ1bGUgKHJ1bGUpIHtcbiAgcmV0dXJuICEhflsnYWZ0ZXInLCAnYmVmb3JlJywgJ2RhdGVfYmV0d2VlbicsICdkYXRlX2Zvcm1hdCddLmluZGV4T2YocnVsZSlcbn07XG5cbi8qKlxuICogRm9ybWF0cyBhbiBlcnJvciBtZXNzYWdlIGZvciBmaWVsZCBhbmQgYSBydWxlLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLl9mb3JtYXRFcnJvck1lc3NhZ2UgPSBmdW5jdGlvbiBfZm9ybWF0RXJyb3JNZXNzYWdlIChmaWVsZCwgcnVsZSwgZGF0YSwgdGFyZ2V0TmFtZSkge1xuICAgIGlmICggZGF0YSA9PT0gdm9pZCAwICkgZGF0YSA9IHt9O1xuICAgIGlmICggdGFyZ2V0TmFtZSA9PT0gdm9pZCAwICkgdGFyZ2V0TmFtZSA9IG51bGw7XG5cbiAgdmFyIG5hbWUgPSB0aGlzLl9nZXRGaWVsZERpc3BsYXlOYW1lKGZpZWxkKTtcbiAgdmFyIHBhcmFtcyA9IHRoaXMuX2dldExvY2FsaXplZFBhcmFtcyhydWxlLCB0YXJnZXROYW1lKTtcblxuICByZXR1cm4gdGhpcy5kaWN0aW9uYXJ5LmdldEZpZWxkTWVzc2FnZSh0aGlzLmxvY2FsZSwgZmllbGQubmFtZSwgcnVsZS5uYW1lLCBbbmFtZSwgcGFyYW1zLCBkYXRhXSlcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlcyB0aGUgcGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIHJ1bGUgKG1haW5seSBmb3IgdGFyZ2V0IGZpZWxkcykuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuX2dldExvY2FsaXplZFBhcmFtcyA9IGZ1bmN0aW9uIF9nZXRMb2NhbGl6ZWRQYXJhbXMgKHJ1bGUsIHRhcmdldE5hbWUpIHtcbiAgICBpZiAoIHRhcmdldE5hbWUgPT09IHZvaWQgMCApIHRhcmdldE5hbWUgPSBudWxsO1xuXG4gIGlmICh+VEFSR0VUX1JVTEVTLmluZGV4T2YocnVsZS5uYW1lKSAmJiBydWxlLnBhcmFtcyAmJiBydWxlLnBhcmFtc1swXSkge1xuICAgIHZhciBsb2NhbGl6ZWROYW1lID0gdGFyZ2V0TmFtZSB8fCB0aGlzLmRpY3Rpb25hcnkuZ2V0QXR0cmlidXRlKHRoaXMubG9jYWxlLCBydWxlLnBhcmFtc1swXSwgcnVsZS5wYXJhbXNbMF0pO1xuICAgIHJldHVybiBbbG9jYWxpemVkTmFtZV0uY29uY2F0KHJ1bGUucGFyYW1zLnNsaWNlKDEpKVxuICB9XG5cbiAgcmV0dXJuIHJ1bGUucGFyYW1zXG59O1xuXG4vKipcbiAqIFJlc29sdmVzIGFuIGFwcHJvcHJpYXRlIGRpc3BsYXkgbmFtZSwgZmlyc3QgY2hlY2tpbmcgJ2RhdGEtYXMnIG9yIHRoZSByZWdpc3RlcmVkICdwcmV0dHlOYW1lJ1xuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLl9nZXRGaWVsZERpc3BsYXlOYW1lID0gZnVuY3Rpb24gX2dldEZpZWxkRGlzcGxheU5hbWUgKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZC5hbGlhcyB8fCB0aGlzLmRpY3Rpb25hcnkuZ2V0QXR0cmlidXRlKHRoaXMubG9jYWxlLCBmaWVsZC5uYW1lLCBmaWVsZC5uYW1lKVxufTtcblxuLyoqXG4gKiBBZGRzIGEgZmllbGQgZmxhZ3MgdG8gdGhlIGZsYWdzIGNvbGxlY3Rpb24uXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuX2FkZEZsYWcgPSBmdW5jdGlvbiBfYWRkRmxhZyAoZmllbGQsIHNjb3BlKSB7XG4gICAgdmFyIG9iaiwgb2JqJDEsIG9iaiQyO1xuXG4gICAgaWYgKCBzY29wZSA9PT0gdm9pZCAwICkgc2NvcGUgPSBudWxsO1xuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpKSB7XG4gICAgdGhpcy5mbGFncyA9IGFzc2lnbih7fSwgdGhpcy5mbGFncywgKCBvYmogPSB7fSwgb2JqWyhcIlwiICsgKGZpZWxkLm5hbWUpKV0gPSBmaWVsZC5mbGFncywgb2JqKSk7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc2NvcGVPYmogPSBhc3NpZ24oe30sIHRoaXMuZmxhZ3NbKFwiJFwiICsgc2NvcGUpXSB8fCB7fSwgKCBvYmokMSA9IHt9LCBvYmokMVsoXCJcIiArIChmaWVsZC5uYW1lKSldID0gZmllbGQuZmxhZ3MsIG9iaiQxKSk7XG4gIHRoaXMuZmxhZ3MgPSBhc3NpZ24oe30sIHRoaXMuZmxhZ3MsICggb2JqJDIgPSB7fSwgb2JqJDJbKFwiJFwiICsgc2NvcGUpXSA9IHNjb3BlT2JqLCBvYmokMikpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgZmllbGRzIHRoYXQgbWF0Y2hlcyB0aGUgbWF0Y2hlciBvcHRpb25zIG9yIGFsbCBmaWVsZHMgaWYgbm90IHNwZWNpZmllZC5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiBfcmVzZXQgKG1hdGNoZXIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICBpZiAobWF0Y2hlcikge1xuICAgICAgdGhpcyQxLmZpZWxkcy5maWx0ZXIobWF0Y2hlcikuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgZmllbGQucmVzZXQoKTsgLy8gcmVzZXQgZmllbGQgZmxhZ3MuXG4gICAgICAgIHRoaXMkMS5lcnJvcnMucmVtb3ZlKGZpZWxkLm5hbWUsIGZpZWxkLnNjb3BlLCBmaWVsZC5pZCk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc29sdmUoKVxuICAgIH1cblxuICAgIHRoaXMkMS5maWVsZHMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5yZXNldCgpOyB9KTtcbiAgICB0aGlzJDEuZXJyb3JzLmNsZWFyKCk7XG4gICAgcmVzb2x2ZSgpO1xuICB9KVxufTtcblxuLyoqXG4gKiBUZXN0cyBhIHNpbmdsZSBpbnB1dCB2YWx1ZSBhZ2FpbnN0IGEgcnVsZS5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5fdGVzdCA9IGZ1bmN0aW9uIF90ZXN0IChmaWVsZCwgdmFsdWUsIHJ1bGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgdmFsaWRhdG9yID0gUlVMRVNbcnVsZS5uYW1lXTtcbiAgdmFyIHBhcmFtcyA9IEFycmF5LmlzQXJyYXkocnVsZS5wYXJhbXMpID8gdG9BcnJheShydWxlLnBhcmFtcykgOiBbXTtcbiAgdmFyIHRhcmdldE5hbWUgPSBudWxsO1xuICBpZiAoIXZhbGlkYXRvciB8fCB0eXBlb2YgdmFsaWRhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgY3JlYXRlRXJyb3IoKFwiTm8gc3VjaCB2YWxpZGF0b3IgJ1wiICsgKHJ1bGUubmFtZSkgKyBcIicgZXhpc3RzLlwiKSlcbiAgfVxuXG4gIC8vIGhhcyBmaWVsZCBkZXBlbmRlbmNpZXMuXG4gIGlmIChUQVJHRVRfUlVMRVMuaW5kZXhPZihydWxlLm5hbWUpICE9PSAtMSkge1xuICAgIHZhciB0YXJnZXQgPSBmaW5kKGZpZWxkLmRlcGVuZGVuY2llcywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gcnVsZS5uYW1lOyB9KTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0YXJnZXROYW1lID0gdGFyZ2V0LmZpZWxkLmFsaWFzO1xuICAgICAgcGFyYW1zID0gW3RhcmdldC5maWVsZC52YWx1ZV0uY29uY2F0KHBhcmFtcy5zbGljZSgxKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJ1bGUubmFtZSA9PT0gJ3JlcXVpcmVkJyAmJiBmaWVsZC5yZWplY3RzRmFsc2UpIHtcbiAgICAvLyBpbnZhbGlkYXRlIGZhbHNlIGlmIG5vIGFyZ3Mgd2VyZSBzcGVjaWZpZWQgYW5kIHRoZSBmaWVsZCByZWplY3RzIGZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgcGFyYW1zID0gcGFyYW1zLmxlbmd0aCA/IHBhcmFtcyA6IFt0cnVlXTtcbiAgfVxuXG4gIGlmICh0aGlzLl9pc0FEYXRlUnVsZShydWxlLm5hbWUpKSB7XG4gICAgdmFyIGRhdGVGb3JtYXQgPSB0aGlzLl9nZXREYXRlRm9ybWF0KGZpZWxkLnJ1bGVzKTtcbiAgICBpZiAocnVsZS5uYW1lICE9PSAnZGF0ZV9mb3JtYXQnKSB7XG4gICAgICBwYXJhbXMucHVzaChkYXRlRm9ybWF0KTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBwYXJhbXMpO1xuXG4gIC8vIElmIGl0IGlzIGEgcHJvbWlzZS5cbiAgaWYgKGlzQ2FsbGFibGUocmVzdWx0LnRoZW4pKSB7XG4gICAgcmV0dXJuIHJlc3VsdC50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgIHZhciBhbGxWYWxpZCA9IHRydWU7XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICBhbGxWYWxpZCA9IHZhbHVlcy5ldmVyeShmdW5jdGlvbiAodCkgeyByZXR1cm4gKGlzT2JqZWN0KHQpID8gdC52YWxpZCA6IHQpOyB9KTtcbiAgICAgIH0gZWxzZSB7IC8vIElzIGEgc2luZ2xlIG9iamVjdC9ib29sZWFuLlxuICAgICAgICBhbGxWYWxpZCA9IGlzT2JqZWN0KHZhbHVlcykgPyB2YWx1ZXMudmFsaWQgOiB2YWx1ZXM7XG4gICAgICAgIGRhdGEgPSB2YWx1ZXMuZGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQ6IGFsbFZhbGlkLFxuICAgICAgICBlcnJvcjogYWxsVmFsaWQgPyB1bmRlZmluZWQgOiB0aGlzJDEuX2NyZWF0ZUZpZWxkRXJyb3IoZmllbGQsIHJ1bGUsIGRhdGEsIHRhcmdldE5hbWUpLFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSB7IHZhbGlkOiByZXN1bHQsIGRhdGE6IHt9IH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbGlkOiByZXN1bHQudmFsaWQsXG4gICAgZXJyb3I6IHJlc3VsdC52YWxpZCA/IHVuZGVmaW5lZCA6IHRoaXMuX2NyZWF0ZUZpZWxkRXJyb3IoZmllbGQsIHJ1bGUsIHJlc3VsdC5kYXRhLCB0YXJnZXROYW1lKSxcbiAgfVxufTtcblxuLyoqXG4gKiBNZXJnZXMgYSB2YWxpZGF0b3Igb2JqZWN0IGludG8gdGhlIFJVTEVTIGFuZCBNZXNzYWdlcy5cbiAqL1xuVmFsaWRhdG9yLl9tZXJnZSA9IGZ1bmN0aW9uIF9tZXJnZSAobmFtZSwgdmFsaWRhdG9yKSB7XG4gIGlmIChpc0NhbGxhYmxlKHZhbGlkYXRvcikpIHtcbiAgICBSVUxFU1tuYW1lXSA9IHZhbGlkYXRvcjtcbiAgICByZXR1cm5cbiAgfVxuXG4gIFJVTEVTW25hbWVdID0gdmFsaWRhdG9yLnZhbGlkYXRlO1xuICBpZiAodmFsaWRhdG9yLmdldE1lc3NhZ2UpIHtcbiAgICBWYWxpZGF0b3IuZGljdGlvbmFyeS5zZXRNZXNzYWdlKHRoaXMubG9jYWxlLCBuYW1lLCB2YWxpZGF0b3IuZ2V0TWVzc2FnZSk7XG4gIH1cbn07XG5cbi8qKlxuICogR3VhcmRzIGZyb20gZXh0ZW5zaW9uIHZpb2xhdGlvbnMuXG4gKi9cblZhbGlkYXRvci5fZ3VhcmRFeHRlbmQgPSBmdW5jdGlvbiBfZ3VhcmRFeHRlbmQgKG5hbWUsIHZhbGlkYXRvcikge1xuICBpZiAoaXNDYWxsYWJsZSh2YWxpZGF0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoIWlzQ2FsbGFibGUodmFsaWRhdG9yLnZhbGlkYXRlKSkge1xuICAgIHRocm93IGNyZWF0ZUVycm9yKFxuICAgICAgKFwiRXh0ZW5zaW9uIEVycm9yOiBUaGUgdmFsaWRhdG9yICdcIiArIG5hbWUgKyBcIicgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGhhdmUgYSAndmFsaWRhdGUnIG1ldGhvZC5cIilcbiAgICApXG4gIH1cblxuICBpZiAoIWlzQ2FsbGFibGUodmFsaWRhdG9yLmdldE1lc3NhZ2UpICYmIHR5cGVvZiB2YWxpZGF0b3IuZ2V0TWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBjcmVhdGVFcnJvcihcbiAgICAgIChcIkV4dGVuc2lvbiBFcnJvcjogVGhlIHZhbGlkYXRvciAnXCIgKyBuYW1lICsgXCInIG9iamVjdCBtdXN0IGhhdmUgYSAnZ2V0TWVzc2FnZScgbWV0aG9kIG9yIHN0cmluZy5cIilcbiAgICApXG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIEZpZWxkIEVycm9yIE9iamVjdC5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5fY3JlYXRlRmllbGRFcnJvciA9IGZ1bmN0aW9uIF9jcmVhdGVGaWVsZEVycm9yIChmaWVsZCwgcnVsZSwgZGF0YSwgdGFyZ2V0TmFtZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6IGZpZWxkLmlkLFxuICAgIGZpZWxkOiBmaWVsZC5uYW1lLFxuICAgIG1zZzogdGhpcy5fZm9ybWF0RXJyb3JNZXNzYWdlKGZpZWxkLCBydWxlLCBkYXRhLCB0YXJnZXROYW1lKSxcbiAgICBydWxlOiBydWxlLm5hbWUsXG4gICAgc2NvcGU6IGZpZWxkLnNjb3BlLFxuICAgIHJlZ2VuZXJhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzJDEuX2Zvcm1hdEVycm9yTWVzc2FnZShmaWVsZCwgcnVsZSwgZGF0YSwgdGFyZ2V0TmFtZSlcbiAgICB9LFxuICB9XG59O1xuXG4vKipcbiAqIFRyaWVzIGRpZmZlcmVudCBzdHJhdGVnaWVzIHRvIGZpbmQgYSBmaWVsZC5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5fcmVzb2x2ZUZpZWxkID0gZnVuY3Rpb24gX3Jlc29sdmVGaWVsZCAobmFtZSwgc2NvcGUpIHtcbiAgaWYgKCFpc051bGxPclVuZGVmaW5lZChzY29wZSkpIHtcbiAgICByZXR1cm4gdGhpcy5maWVsZHMuZmluZCh7IG5hbWU6IG5hbWUsIHNjb3BlOiBzY29wZSB9KVxuICB9XG5cbiAgaWYgKG5hbWVbMF0gPT09ICcjJykge1xuICAgIHJldHVybiB0aGlzLmZpZWxkcy5maW5kKHsgaWQ6IG5hbWUuc2xpY2UoMSkgfSlcbiAgfVxuXG4gIGlmIChuYW1lLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgdmFyIHJlZiA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBmaWVsZFNjb3BlID0gcmVmWzBdO1xuICAgICAgdmFyIGZpZWxkTmFtZSA9IHJlZi5zbGljZSgxKTtcbiAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkcy5maW5kKHsgbmFtZTogZmllbGROYW1lLmpvaW4oJy4nKSwgc2NvcGU6IGZpZWxkU2NvcGUgfSk7XG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGRcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5maWVsZHMuZmluZCh7IG5hbWU6IG5hbWUsIHNjb3BlOiBudWxsIH0pXG59O1xuXG4vKipcbiAqIEhhbmRsZXMgd2hlbiBhIGZpZWxkIGlzIG5vdCBmb3VuZCBkZXBlbmRpbmcgb24gdGhlIHN0cmljdCBmbGFnLlxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLl9oYW5kbGVGaWVsZE5vdEZvdW5kID0gZnVuY3Rpb24gX2hhbmRsZUZpZWxkTm90Rm91bmQgKG5hbWUsIHNjb3BlKSB7XG4gIGlmICghdGhpcy5zdHJpY3QpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKSB9XG5cbiAgdmFyIGZ1bGxOYW1lID0gaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpID8gbmFtZSA6IChcIlwiICsgKCFpc051bGxPclVuZGVmaW5lZChzY29wZSkgPyBzY29wZSArICcuJyA6ICcnKSArIG5hbWUpO1xuICB0aHJvdyBjcmVhdGVFcnJvcihcbiAgICAoXCJWYWxpZGF0aW5nIGEgbm9uLWV4aXN0ZW50IGZpZWxkOiBcXFwiXCIgKyBmdWxsTmFtZSArIFwiXFxcIi4gVXNlIFxcXCJhdHRhY2goKVxcXCIgZmlyc3QuXCIpXG4gIClcbn07XG5cbi8qKlxuICogU3RhcnRzIHRoZSB2YWxpZGF0aW9uIHByb2Nlc3MuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlID0gZnVuY3Rpb24gX3ZhbGlkYXRlIChmaWVsZCwgdmFsdWUsIHNpbGVudCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIGlmICggc2lsZW50ID09PSB2b2lkIDAgKSBzaWxlbnQgPSBmYWxzZTtcblxuICBpZiAoIWZpZWxkLmlzUmVxdWlyZWQgJiYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbGlkOiB0cnVlIH0pXG4gIH1cblxuICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgaXNFeGl0RWFybHkgPSBmYWxzZTtcbiAgLy8gdXNlIG9mICcuc29tZSgpJyBpcyB0byBicmVhayBpdGVyYXRpb24gaW4gbWlkZGxlIGJ5IHJldHVybmluZyB0cnVlXG4gIE9iamVjdC5rZXlzKGZpZWxkLnJ1bGVzKS5zb21lKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMkMS5fdGVzdChmaWVsZCwgdmFsdWUsIHsgbmFtZTogcnVsZSwgcGFyYW1zOiBmaWVsZC5ydWxlc1tydWxlXSB9KTtcbiAgICBpZiAoaXNDYWxsYWJsZShyZXN1bHQudGhlbikpIHtcbiAgICAgIHByb21pc2VzLnB1c2gocmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMkMS5mYXN0RXhpdCAmJiAhcmVzdWx0LnZhbGlkKSB7XG4gICAgICBlcnJvcnMucHVzaChyZXN1bHQuZXJyb3IpO1xuICAgICAgaXNFeGl0RWFybHkgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwcm9taXNpZnkgdGhlIHJlc3VsdC5cbiAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBpc0V4aXRFYXJseVxuICB9KTtcblxuICBpZiAoaXNFeGl0RWFybHkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yczogZXJyb3JzLFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykgeyByZXR1cm4gdmFsdWVzLm1hcChmdW5jdGlvbiAodikge1xuICAgIGlmICghdi52YWxpZCkge1xuICAgICAgZXJyb3JzLnB1c2godi5lcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHYudmFsaWRcbiAgfSkuZXZlcnkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH0pOyB9XG4gICkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbGlkOiByZXN1bHQsXG4gICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICB9XG4gIH0pXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVmFsaWRhdG9yLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDQgKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWYWxpZGF0b3IsIHN0YXRpY0FjY2Vzc29ycyQxICk7XG5cbi8vIFxuXG5mdW5jdGlvbiB1c2UgKHBsdWdpbiwgb3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBpZiAoIWlzQ2FsbGFibGUocGx1Z2luKSkge1xuICAgIHJldHVybiB3YXJuKCdUaGUgcGx1Z2luIG11c3QgYmUgYSBjYWxsYWJsZSBmdW5jdGlvbicpXG4gIH1cblxuICBwbHVnaW4oeyBWYWxpZGF0b3I6IFZhbGlkYXRvciwgRXJyb3JCYWc6IEVycm9yQmFnLCBSdWxlczogVmFsaWRhdG9yLnJ1bGVzIH0sIG9wdGlvbnMpO1xufVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX0hPVVIgPSAzNjAwMDAwO1xudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUgPSA2MDAwMDtcbnZhciBERUZBVUxUX0FERElUSU9OQUxfRElHSVRTID0gMjtcblxudmFyIHBhdHRlcm5zID0ge1xuICBkYXRlVGltZURlbGltZXRlcjogL1tUIF0vLFxuICBwbGFpblRpbWU6IC86LyxcblxuICAvLyB5ZWFyIHRva2Vuc1xuICBZWTogL14oXFxkezJ9KSQvLFxuICBZWVk6IFtcbiAgICAvXihbKy1dXFxkezJ9KSQvLCAvLyAwIGFkZGl0aW9uYWwgZGlnaXRzXG4gICAgL14oWystXVxcZHszfSkkLywgLy8gMSBhZGRpdGlvbmFsIGRpZ2l0XG4gICAgL14oWystXVxcZHs0fSkkLyAvLyAyIGFkZGl0aW9uYWwgZGlnaXRzXG4gIF0sXG4gIFlZWVk6IC9eKFxcZHs0fSkvLFxuICBZWVlZWTogW1xuICAgIC9eKFsrLV1cXGR7NH0pLywgLy8gMCBhZGRpdGlvbmFsIGRpZ2l0c1xuICAgIC9eKFsrLV1cXGR7NX0pLywgLy8gMSBhZGRpdGlvbmFsIGRpZ2l0XG4gICAgL14oWystXVxcZHs2fSkvIC8vIDIgYWRkaXRpb25hbCBkaWdpdHNcbiAgXSxcblxuICAvLyBkYXRlIHRva2Vuc1xuICBNTTogL14tKFxcZHsyfSkkLyxcbiAgREREOiAvXi0/KFxcZHszfSkkLyxcbiAgTU1ERDogL14tPyhcXGR7Mn0pLT8oXFxkezJ9KSQvLFxuICBXd3c6IC9eLT9XKFxcZHsyfSkkLyxcbiAgV3d3RDogL14tP1coXFxkezJ9KS0/KFxcZHsxfSkkLyxcblxuICBISDogL14oXFxkezJ9KFsuLF1cXGQqKT8pJC8sXG4gIEhITU06IC9eKFxcZHsyfSk6PyhcXGR7Mn0oWy4sXVxcZCopPykkLyxcbiAgSEhNTVNTOiAvXihcXGR7Mn0pOj8oXFxkezJ9KTo/KFxcZHsyfShbLixdXFxkKik/KSQvLFxuXG4gIC8vIHRpbWV6b25lIHRva2Vuc1xuICB0aW1lem9uZTogLyhbWistXS4qKSQvLFxuICB0aW1lem9uZVo6IC9eKFopJC8sXG4gIHRpbWV6b25lSEg6IC9eKFsrLV0pKFxcZHsyfSkkLyxcbiAgdGltZXpvbmVISE1NOiAvXihbKy1dKShcXGR7Mn0pOj8oXFxkezJ9KSQvXG59O1xuXG4vKipcbiAqIEBuYW1lIHRvRGF0ZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgaXRzIGNsb25lLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciwgaXQgaXMgdHJlYXRlZCBhcyBhIHRpbWVzdGFtcC5cbiAqXG4gKiBJZiBhbiBhcmd1bWVudCBpcyBhIHN0cmluZywgdGhlIGZ1bmN0aW9uIHRyaWVzIHRvIHBhcnNlIGl0LlxuICogRnVuY3Rpb24gYWNjZXB0cyBjb21wbGV0ZSBJU08gODYwMSBmb3JtYXRzIGFzIHdlbGwgYXMgcGFydGlhbCBpbXBsZW1lbnRhdGlvbnMuXG4gKiBJU08gODYwMTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMVxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBudWxsLCBpdCBpcyB0cmVhdGVkIGFzIGFuIGludmFsaWQgZGF0ZS5cbiAqXG4gKiBJZiBhbGwgYWJvdmUgZmFpbHMsIHRoZSBmdW5jdGlvbiBwYXNzZXMgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIERhdGUgY29uc3RydWN0b3IuXG4gKlxuICogKipOb3RlKio6ICphbGwqIERhdGUgYXJndW1lbnRzIHBhc3NlZCB0byBhbnkgKmRhdGUtZm5zKiBmdW5jdGlvbiBpcyBwcm9jZXNzZWQgYnkgYHRvRGF0ZWAuXG4gKiBBbGwgKmRhdGUtZm5zKiBmdW5jdGlvbnMgd2lsbCB0aHJvdyBgUmFuZ2VFcnJvcmAgaWYgYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgaXMgbm90IDAsIDEsIDIgb3IgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7Kn0gYXJndW1lbnQgLSB0aGUgdmFsdWUgdG8gY29udmVydFxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XG4gKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gdGhlIGFkZGl0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgZXh0ZW5kZWQgeWVhciBmb3JtYXRcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgcGFyc2VkIGRhdGUgaW4gdGhlIGxvY2FsIHRpbWUgem9uZVxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHN0cmluZyAnMjAxNC0wMi0xMVQxMTozMDozMCcgdG8gZGF0ZTpcbiAqIHZhciByZXN1bHQgPSB0b0RhdGUoJzIwMTQtMDItMTFUMTE6MzA6MzAnKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCBzdHJpbmcgJyswMjAxNDEwMScgdG8gZGF0ZSxcbiAqIC8vIGlmIHRoZSBhZGRpdGlvbmFsIG51bWJlciBvZiBkaWdpdHMgaW4gdGhlIGV4dGVuZGVkIHllYXIgZm9ybWF0IGlzIDE6XG4gKiB2YXIgcmVzdWx0ID0gdG9EYXRlKCcrMDIwMTQxMDEnLCB7YWRkaXRpb25hbERpZ2l0czogMX0pXG4gKiAvLz0+IEZyaSBBcHIgMTEgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiB0b0RhdGUgKGFyZ3VtZW50LCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgaWYgKGFyZ3VtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuXG4gIHZhciBhZGRpdGlvbmFsRGlnaXRzID0gb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzID09PSB1bmRlZmluZWQgPyBERUZBVUxUX0FERElUSU9OQUxfRElHSVRTIDogTnVtYmVyKG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0cyk7XG4gIGlmIChhZGRpdGlvbmFsRGlnaXRzICE9PSAyICYmIGFkZGl0aW9uYWxEaWdpdHMgIT09IDEgJiYgYWRkaXRpb25hbERpZ2l0cyAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhZGRpdGlvbmFsRGlnaXRzIG11c3QgYmUgMCwgMSBvciAyJylcbiAgfVxuXG4gIC8vIENsb25lIHRoZSBkYXRlXG4gIGlmIChhcmd1bWVudCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAvLyBQcmV2ZW50IHRoZSBkYXRlIHRvIGxvc2UgdGhlIG1pbGxpc2Vjb25kcyB3aGVuIHBhc3NlZCB0byBuZXcgRGF0ZSgpIGluIElFMTBcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQuZ2V0VGltZSgpKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQpXG4gIH1cblxuICB2YXIgZGF0ZVN0cmluZ3MgPSBzcGxpdERhdGVTdHJpbmcoYXJndW1lbnQpO1xuXG4gIHZhciBwYXJzZVllYXJSZXN1bHQgPSBwYXJzZVllYXIoZGF0ZVN0cmluZ3MuZGF0ZSwgYWRkaXRpb25hbERpZ2l0cyk7XG4gIHZhciB5ZWFyID0gcGFyc2VZZWFyUmVzdWx0LnllYXI7XG4gIHZhciByZXN0RGF0ZVN0cmluZyA9IHBhcnNlWWVhclJlc3VsdC5yZXN0RGF0ZVN0cmluZztcblxuICB2YXIgZGF0ZSA9IHBhcnNlRGF0ZShyZXN0RGF0ZVN0cmluZywgeWVhcik7XG5cbiAgaWYgKGRhdGUpIHtcbiAgICB2YXIgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgdmFyIHRpbWUgPSAwO1xuICAgIHZhciBvZmZzZXQ7XG5cbiAgICBpZiAoZGF0ZVN0cmluZ3MudGltZSkge1xuICAgICAgdGltZSA9IHBhcnNlVGltZShkYXRlU3RyaW5ncy50aW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0ZVN0cmluZ3MudGltZXpvbmUpIHtcbiAgICAgIG9mZnNldCA9IHBhcnNlVGltZXpvbmUoZGF0ZVN0cmluZ3MudGltZXpvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZXQgb2Zmc2V0IGFjY3VyYXRlIHRvIGhvdXIgaW4gdGltZXpvbmVzIHRoYXQgY2hhbmdlIG9mZnNldFxuICAgICAgb2Zmc2V0ID0gbmV3IERhdGUodGltZXN0YW1wICsgdGltZSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIG9mZnNldCA9IG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUgKyBvZmZzZXQgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXAgKyB0aW1lICsgb2Zmc2V0ICogTUlMTElTRUNPTkRTX0lOX01JTlVURSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gc3BsaXREYXRlU3RyaW5nIChkYXRlU3RyaW5nKSB7XG4gIHZhciBkYXRlU3RyaW5ncyA9IHt9O1xuICB2YXIgYXJyYXkgPSBkYXRlU3RyaW5nLnNwbGl0KHBhdHRlcm5zLmRhdGVUaW1lRGVsaW1ldGVyKTtcbiAgdmFyIHRpbWVTdHJpbmc7XG5cbiAgaWYgKHBhdHRlcm5zLnBsYWluVGltZS50ZXN0KGFycmF5WzBdKSkge1xuICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBudWxsO1xuICAgIHRpbWVTdHJpbmcgPSBhcnJheVswXTtcbiAgfSBlbHNlIHtcbiAgICBkYXRlU3RyaW5ncy5kYXRlID0gYXJyYXlbMF07XG4gICAgdGltZVN0cmluZyA9IGFycmF5WzFdO1xuICB9XG5cbiAgaWYgKHRpbWVTdHJpbmcpIHtcbiAgICB2YXIgdG9rZW4gPSBwYXR0ZXJucy50aW1lem9uZS5leGVjKHRpbWVTdHJpbmcpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmcucmVwbGFjZSh0b2tlblsxXSwgJycpO1xuICAgICAgZGF0ZVN0cmluZ3MudGltZXpvbmUgPSB0b2tlblsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGVTdHJpbmdzXG59XG5cbmZ1bmN0aW9uIHBhcnNlWWVhciAoZGF0ZVN0cmluZywgYWRkaXRpb25hbERpZ2l0cykge1xuICB2YXIgcGF0dGVybllZWSA9IHBhdHRlcm5zLllZWVthZGRpdGlvbmFsRGlnaXRzXTtcbiAgdmFyIHBhdHRlcm5ZWVlZWSA9IHBhdHRlcm5zLllZWVlZW2FkZGl0aW9uYWxEaWdpdHNdO1xuXG4gIHZhciB0b2tlbjtcblxuICAvLyBZWVlZIG9yIMKxWVlZWVlcbiAgdG9rZW4gPSBwYXR0ZXJucy5ZWVlZLmV4ZWMoZGF0ZVN0cmluZykgfHwgcGF0dGVybllZWVlZLmV4ZWMoZGF0ZVN0cmluZyk7XG4gIGlmICh0b2tlbikge1xuICAgIHZhciB5ZWFyU3RyaW5nID0gdG9rZW5bMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXI6IHBhcnNlSW50KHllYXJTdHJpbmcsIDEwKSxcbiAgICAgIHJlc3REYXRlU3RyaW5nOiBkYXRlU3RyaW5nLnNsaWNlKHllYXJTdHJpbmcubGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFlZIG9yIMKxWVlZXG4gIHRva2VuID0gcGF0dGVybnMuWVkuZXhlYyhkYXRlU3RyaW5nKSB8fCBwYXR0ZXJuWVlZLmV4ZWMoZGF0ZVN0cmluZyk7XG4gIGlmICh0b2tlbikge1xuICAgIHZhciBjZW50dXJ5U3RyaW5nID0gdG9rZW5bMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXI6IHBhcnNlSW50KGNlbnR1cnlTdHJpbmcsIDEwKSAqIDEwMCxcbiAgICAgIHJlc3REYXRlU3RyaW5nOiBkYXRlU3RyaW5nLnNsaWNlKGNlbnR1cnlTdHJpbmcubGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXG4gIHJldHVybiB7XG4gICAgeWVhcjogbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZSAoZGF0ZVN0cmluZywgeWVhcikge1xuICAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgeWVhclxuICBpZiAoeWVhciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YXIgdG9rZW47XG4gIHZhciBkYXRlO1xuICB2YXIgbW9udGg7XG4gIHZhciB3ZWVrO1xuXG4gIC8vIFlZWVlcbiAgaWYgKGRhdGVTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKDApO1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhcik7XG4gICAgcmV0dXJuIGRhdGVcbiAgfVxuXG4gIC8vIFlZWVktTU1cbiAgdG9rZW4gPSBwYXR0ZXJucy5NTS5leGVjKGRhdGVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICBkYXRlID0gbmV3IERhdGUoMCk7XG4gICAgbW9udGggPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMTtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoKTtcbiAgICByZXR1cm4gZGF0ZVxuICB9XG5cbiAgLy8gWVlZWS1EREQgb3IgWVlZWURERFxuICB0b2tlbiA9IHBhdHRlcm5zLkRERC5leGVjKGRhdGVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICBkYXRlID0gbmV3IERhdGUoMCk7XG4gICAgdmFyIGRheU9mWWVhciA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCk7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCBkYXlPZlllYXIpO1xuICAgIHJldHVybiBkYXRlXG4gIH1cblxuICAvLyBZWVlZLU1NLUREIG9yIFlZWVlNTUREXG4gIHRva2VuID0gcGF0dGVybnMuTU1ERC5leGVjKGRhdGVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICBkYXRlID0gbmV3IERhdGUoMCk7XG4gICAgbW9udGggPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMTtcbiAgICB2YXIgZGF5ID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKTtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIHJldHVybiBkYXRlXG4gIH1cblxuICAvLyBZWVlZLVd3dyBvciBZWVlZV3d3XG4gIHRva2VuID0gcGF0dGVybnMuV3d3LmV4ZWMoZGF0ZVN0cmluZyk7XG4gIGlmICh0b2tlbikge1xuICAgIHdlZWsgPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMTtcbiAgICByZXR1cm4gZGF5T2ZJU09ZZWFyKHllYXIsIHdlZWspXG4gIH1cblxuICAvLyBZWVlZLVd3dy1EIG9yIFlZWVlXd3dEXG4gIHRva2VuID0gcGF0dGVybnMuV3d3RC5leGVjKGRhdGVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICB3ZWVrID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKSAtIDE7XG4gICAgdmFyIGRheU9mV2VlayA9IHBhcnNlSW50KHRva2VuWzJdLCAxMCkgLSAxO1xuICAgIHJldHVybiBkYXlPZklTT1llYXIoeWVhciwgd2VlaywgZGF5T2ZXZWVrKVxuICB9XG5cbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIGRhdGVcbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lICh0aW1lU3RyaW5nKSB7XG4gIHZhciB0b2tlbjtcbiAgdmFyIGhvdXJzO1xuICB2YXIgbWludXRlcztcblxuICAvLyBoaFxuICB0b2tlbiA9IHBhdHRlcm5zLkhILmV4ZWModGltZVN0cmluZyk7XG4gIGlmICh0b2tlbikge1xuICAgIGhvdXJzID0gcGFyc2VGbG9hdCh0b2tlblsxXS5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgcmV0dXJuIChob3VycyAlIDI0KSAqIE1JTExJU0VDT05EU19JTl9IT1VSXG4gIH1cblxuICAvLyBoaDptbSBvciBoaG1tXG4gIHRva2VuID0gcGF0dGVybnMuSEhNTS5leGVjKHRpbWVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCk7XG4gICAgbWludXRlcyA9IHBhcnNlRmxvYXQodG9rZW5bMl0ucmVwbGFjZSgnLCcsICcuJykpO1xuICAgIHJldHVybiAoaG91cnMgJSAyNCkgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUiArXG4gICAgICBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURVxuICB9XG5cbiAgLy8gaGg6bW06c3Mgb3IgaGhtbXNzXG4gIHRva2VuID0gcGF0dGVybnMuSEhNTVNTLmV4ZWModGltZVN0cmluZyk7XG4gIGlmICh0b2tlbikge1xuICAgIGhvdXJzID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKTtcbiAgICBtaW51dGVzID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKTtcbiAgICB2YXIgc2Vjb25kcyA9IHBhcnNlRmxvYXQodG9rZW5bM10ucmVwbGFjZSgnLCcsICcuJykpO1xuICAgIHJldHVybiAoaG91cnMgJSAyNCkgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUiArXG4gICAgICBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURSArXG4gICAgICBzZWNvbmRzICogMTAwMFxuICB9XG5cbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHRpbWVcbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lem9uZSAodGltZXpvbmVTdHJpbmcpIHtcbiAgdmFyIHRva2VuO1xuICB2YXIgYWJzb2x1dGVPZmZzZXQ7XG5cbiAgLy8gWlxuICB0b2tlbiA9IHBhdHRlcm5zLnRpbWV6b25lWi5leGVjKHRpbWV6b25lU3RyaW5nKTtcbiAgaWYgKHRva2VuKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIMKxaGhcbiAgdG9rZW4gPSBwYXR0ZXJucy50aW1lem9uZUhILmV4ZWModGltZXpvbmVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICBhYnNvbHV0ZU9mZnNldCA9IHBhcnNlSW50KHRva2VuWzJdLCAxMCkgKiA2MDtcbiAgICByZXR1cm4gKHRva2VuWzFdID09PSAnKycpID8gLWFic29sdXRlT2Zmc2V0IDogYWJzb2x1dGVPZmZzZXRcbiAgfVxuXG4gIC8vIMKxaGg6bW0gb3IgwrFoaG1tXG4gIHRva2VuID0gcGF0dGVybnMudGltZXpvbmVISE1NLmV4ZWModGltZXpvbmVTdHJpbmcpO1xuICBpZiAodG9rZW4pIHtcbiAgICBhYnNvbHV0ZU9mZnNldCA9IHBhcnNlSW50KHRva2VuWzJdLCAxMCkgKiA2MCArIHBhcnNlSW50KHRva2VuWzNdLCAxMCk7XG4gICAgcmV0dXJuICh0b2tlblsxXSA9PT0gJysnKSA/IC1hYnNvbHV0ZU9mZnNldCA6IGFic29sdXRlT2Zmc2V0XG4gIH1cblxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBkYXlPZklTT1llYXIgKGlzb1llYXIsIHdlZWssIGRheSkge1xuICB3ZWVrID0gd2VlayB8fCAwO1xuICBkYXkgPSBkYXkgfHwgMDtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihpc29ZZWFyLCAwLCA0KTtcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeURheSA9IGRhdGUuZ2V0VVRDRGF5KCkgfHwgNztcbiAgdmFyIGRpZmYgPSB3ZWVrICogNyArIGRheSArIDEgLSBmb3VydGhPZkphbnVhcnlEYXk7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpO1xuICByZXR1cm4gZGF0ZVxufVxuXG4vKipcbiAqIEBuYW1lIGFkZE1pbGxpc2Vjb25kc1xuICogQGNhdGVnb3J5IE1pbGxpc2Vjb25kIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGJlIGFkZGVkXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgbWlsbGlzZWNvbmRzIGFkZGVkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBZGQgNzUwIG1pbGxpc2Vjb25kcyB0byAxMCBKdWx5IDIwMTQgMTI6NDU6MzAuMDAwOlxuICogdmFyIHJlc3VsdCA9IGFkZE1pbGxpc2Vjb25kcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDQ1LCAzMCwgMCksIDc1MClcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDEyOjQ1OjMwLjc1MFxuICovXG5mdW5jdGlvbiBhZGRNaWxsaXNlY29uZHMgKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgdmFyIHRpbWVzdGFtcCA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykuZ2V0VGltZSgpO1xuICB2YXIgYW1vdW50ID0gTnVtYmVyKGRpcnR5QW1vdW50KTtcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCArIGFtb3VudClcbn1cblxuZnVuY3Rpb24gY2xvbmVPYmplY3QgKGRpcnR5T2JqZWN0KSB7XG4gIGRpcnR5T2JqZWN0ID0gZGlydHlPYmplY3QgfHwge307XG4gIHZhciBvYmplY3QgPSB7fTtcblxuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBkaXJ0eU9iamVjdCkge1xuICAgIGlmIChkaXJ0eU9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSBkaXJ0eU9iamVjdFtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdFxufVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX01JTlVURSQyID0gNjAwMDA7XG5cbi8qKlxuICogQG5hbWUgYWRkTWludXRlc1xuICogQGNhdGVnb3J5IE1pbnV0ZSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWludXRlcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaW51dGVzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbWludXRlcyB0byBiZSBhZGRlZFxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XG4gKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gcGFzc2VkIHRvIGB0b0RhdGVgLiBTZWUgW3RvRGF0ZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy90b0RhdGV9XG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIG1pbnV0ZXMgYWRkZWRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFkZCAzMCBtaW51dGVzIHRvIDEwIEp1bHkgMjAxNCAxMjowMDowMDpcbiAqIHZhciByZXN1bHQgPSBhZGRNaW51dGVzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgMCksIDMwKVxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6MzA6MDBcbiAqL1xuZnVuY3Rpb24gYWRkTWludXRlcyAoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCwgZGlydHlPcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXG4gIH1cblxuICB2YXIgYW1vdW50ID0gTnVtYmVyKGRpcnR5QW1vdW50KTtcbiAgcmV0dXJuIGFkZE1pbGxpc2Vjb25kcyhkaXJ0eURhdGUsIGFtb3VudCAqIE1JTExJU0VDT05EU19JTl9NSU5VVEUkMiwgZGlydHlPcHRpb25zKVxufVxuXG4vKipcbiAqIEBuYW1lIGlzVmFsaWRcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgdmFsaWQ/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm5zIGZhbHNlIGlmIGFyZ3VtZW50IGlzIEludmFsaWQgRGF0ZSBhbmQgdHJ1ZSBvdGhlcndpc2UuXG4gKiBBcmd1bWVudCBpcyBjb252ZXJ0ZWQgdG8gRGF0ZSB1c2luZyBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICogSW52YWxpZCBEYXRlIGlzIGEgRGF0ZSwgd2hvc2UgdGltZSB2YWx1ZSBpcyBOYU4uXG4gKlxuICogVGltZSB2YWx1ZSBvZiBEYXRlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjkuMS4xXG4gKlxuICogQHBhcmFtIHsqfSBkYXRlIC0gdGhlIGRhdGUgdG8gY2hlY2tcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBkYXRlIGlzIHZhbGlkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciB0aGUgdmFsaWQgZGF0ZTpcbiAqIHZhciByZXN1bHQgPSBpc1ZhbGlkKG5ldyBEYXRlKDIwMTQsIDEsIDMxKSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgdGhlIHZhbHVlLCBjb252ZXJ0YWJsZSBpbnRvIGEgZGF0ZTpcbiAqIHZhciByZXN1bHQgPSBpc1ZhbGlkKCcyMDE0LTAyLTMxJylcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgdGhlIGludmFsaWQgZGF0ZTpcbiAqIHZhciByZXN1bHQgPSBpc1ZhbGlkKG5ldyBEYXRlKCcnKSlcbiAqIC8vPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZCAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICByZXR1cm4gIWlzTmFOKGRhdGUpXG59XG5cbnZhciBmb3JtYXREaXN0YW5jZUxvY2FsZSA9IHtcbiAgbGVzc1RoYW5YU2Vjb25kczoge1xuICAgIG9uZTogJ2xlc3MgdGhhbiBhIHNlY29uZCcsXG4gICAgb3RoZXI6ICdsZXNzIHRoYW4ge3tjb3VudH19IHNlY29uZHMnXG4gIH0sXG5cbiAgeFNlY29uZHM6IHtcbiAgICBvbmU6ICcxIHNlY29uZCcsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gc2Vjb25kcydcbiAgfSxcblxuICBoYWxmQU1pbnV0ZTogJ2hhbGYgYSBtaW51dGUnLFxuXG4gIGxlc3NUaGFuWE1pbnV0ZXM6IHtcbiAgICBvbmU6ICdsZXNzIHRoYW4gYSBtaW51dGUnLFxuICAgIG90aGVyOiAnbGVzcyB0aGFuIHt7Y291bnR9fSBtaW51dGVzJ1xuICB9LFxuXG4gIHhNaW51dGVzOiB7XG4gICAgb25lOiAnMSBtaW51dGUnLFxuICAgIG90aGVyOiAne3tjb3VudH19IG1pbnV0ZXMnXG4gIH0sXG5cbiAgYWJvdXRYSG91cnM6IHtcbiAgICBvbmU6ICdhYm91dCAxIGhvdXInLFxuICAgIG90aGVyOiAnYWJvdXQge3tjb3VudH19IGhvdXJzJ1xuICB9LFxuXG4gIHhIb3Vyczoge1xuICAgIG9uZTogJzEgaG91cicsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gaG91cnMnXG4gIH0sXG5cbiAgeERheXM6IHtcbiAgICBvbmU6ICcxIGRheScsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gZGF5cydcbiAgfSxcblxuICBhYm91dFhNb250aHM6IHtcbiAgICBvbmU6ICdhYm91dCAxIG1vbnRoJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSBtb250aHMnXG4gIH0sXG5cbiAgeE1vbnRoczoge1xuICAgIG9uZTogJzEgbW9udGgnLFxuICAgIG90aGVyOiAne3tjb3VudH19IG1vbnRocydcbiAgfSxcblxuICBhYm91dFhZZWFyczoge1xuICAgIG9uZTogJ2Fib3V0IDEgeWVhcicsXG4gICAgb3RoZXI6ICdhYm91dCB7e2NvdW50fX0geWVhcnMnXG4gIH0sXG5cbiAgeFllYXJzOiB7XG4gICAgb25lOiAnMSB5ZWFyJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSB5ZWFycydcbiAgfSxcblxuICBvdmVyWFllYXJzOiB7XG4gICAgb25lOiAnb3ZlciAxIHllYXInLFxuICAgIG90aGVyOiAnb3ZlciB7e2NvdW50fX0geWVhcnMnXG4gIH0sXG5cbiAgYWxtb3N0WFllYXJzOiB7XG4gICAgb25lOiAnYWxtb3N0IDEgeWVhcicsXG4gICAgb3RoZXI6ICdhbG1vc3Qge3tjb3VudH19IHllYXJzJ1xuICB9XG59O1xuXG5mdW5jdGlvbiBmb3JtYXREaXN0YW5jZSAodG9rZW4sIGNvdW50LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciByZXN1bHQ7XG4gIGlmICh0eXBlb2YgZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXTtcbiAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXS5vbmU7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dLm90aGVyLnJlcGxhY2UoJ3t7Y291bnR9fScsIGNvdW50KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFkZFN1ZmZpeCkge1xuICAgIGlmIChvcHRpb25zLmNvbXBhcmlzb24gPiAwKSB7XG4gICAgICByZXR1cm4gJ2luICcgKyByZXN1bHRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdCArICcgYWdvJ1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxudmFyIHRva2Vuc1RvQmVTaG9ydGVkUGF0dGVybiA9IC9NTU1NfE1NfEREfGRkZGQvZztcblxuZnVuY3Rpb24gYnVpbGRTaG9ydExvbmdGb3JtYXQgKGZvcm1hdCkge1xuICByZXR1cm4gZm9ybWF0LnJlcGxhY2UodG9rZW5zVG9CZVNob3J0ZWRQYXR0ZXJuLCBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICByZXR1cm4gdG9rZW4uc2xpY2UoMSlcbiAgfSlcbn1cblxuLyoqXG4gKiBAbmFtZSBidWlsZEZvcm1hdExvbmdGblxuICogQGNhdGVnb3J5IExvY2FsZSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBCdWlsZCBgZm9ybWF0TG9uZ2AgcHJvcGVydHkgZm9yIGxvY2FsZSB1c2VkIGJ5IGBmb3JtYXRgLCBgZm9ybWF0UmVsYXRpdmVgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEJ1aWxkIGBmb3JtYXRMb25nYCBwcm9wZXJ0eSBmb3IgbG9jYWxlIHVzZWQgYnkgYGZvcm1hdGAsIGBmb3JtYXRSZWxhdGl2ZWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zLlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIG9uZSBvZiB0aGUgZm9sbG93aW5nIHRva2VucyBhcyB0aGUgYXJndW1lbnQ6XG4gKiBgJ0xUUydgLCBgJ0xUJ2AsIGAnTCdgLCBgJ0xMJ2AsIGAnTExMJ2AsIGAnbCdgLCBgJ2xsJ2AsIGAnbGxsJ2AsIGAnbGxsbCdgXG4gKiBhbmQgcmV0dXJucyBhIGxvbmcgZm9ybWF0IHN0cmluZyB3cml0dGVuIGFzIGBmb3JtYXRgIHRva2VuIHN0cmluZ3MuXG4gKiBTZWUgW2Zvcm1hdF17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9mb3JtYXR9XG4gKlxuICogYCdsJ2AsIGAnbGwnYCwgYCdsbGwnYCBhbmQgYCdsbGxsJ2AgZm9ybWF0cyBhcmUgYnVpbHQgYXV0b21hdGljYWxseVxuICogYnkgc2hvcnRlbmluZyBzb21lIG9mIHRoZSB0b2tlbnMgZnJvbSBjb3JyZXNwb25kaW5nIHVuc2hvcnRlbmVkIGZvcm1hdHNcbiAqIChlLmcuLCBpZiBgTExgIGlzIGAnTU1NTSBERCBZWVlZJ2AgdGhlbiBgbGxgIHdpbGwgYmUgYE1NTSBEIFlZWVlgKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHdpdGggbG9uZyBmb3JtYXRzIHdyaXR0ZW4gYXMgYGZvcm1hdGAgdG9rZW4gc3RyaW5nc1xuICogQHBhcmFtIHtTdHJpbmd9IG9iai5MVCAtIHRpbWUgZm9ybWF0OiBob3VycyBhbmQgbWludXRlc1xuICogQHBhcmFtIHtTdHJpbmd9IG9iai5MVFMgLSB0aW1lIGZvcm1hdDogaG91cnMsIG1pbnV0ZXMgYW5kIHNlY29uZHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmouTCAtIHNob3J0IGRhdGUgZm9ybWF0OiBudW1lcmljIGRheSwgbW9udGggYW5kIHllYXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb2JqLmxdIC0gc2hvcnQgZGF0ZSBmb3JtYXQ6IG51bWVyaWMgZGF5LCBtb250aCBhbmQgeWVhciAoc2hvcnRlbmVkKVxuICogQHBhcmFtIHtTdHJpbmd9IG9iai5MTCAtIGxvbmcgZGF0ZSBmb3JtYXQ6IGRheSwgbW9udGggaW4gd29yZHMsIGFuZCB5ZWFyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29iai5sbF0gLSBsb25nIGRhdGUgZm9ybWF0OiBkYXksIG1vbnRoIGluIHdvcmRzLCBhbmQgeWVhciAoc2hvcnRlbmVkKVxuICogQHBhcmFtIHtTdHJpbmd9IG9iai5MTEwgLSBsb25nIGRhdGUgYW5kIHRpbWUgZm9ybWF0XG4gKiBAcGFyYW0ge1N0cmluZ30gW29iai5sbGxdIC0gbG9uZyBkYXRlIGFuZCB0aW1lIGZvcm1hdCAoc2hvcnRlbmVkKVxuICogQHBhcmFtIHtTdHJpbmd9IG9iai5MTExMIC0gbG9uZyBkYXRlLCB0aW1lIGFuZCB3ZWVrZGF5IGZvcm1hdFxuICogQHBhcmFtIHtTdHJpbmd9IFtvYmoubGxsbF0gLSBsb25nIGRhdGUsIHRpbWUgYW5kIHdlZWtkYXkgZm9ybWF0IChzaG9ydGVuZWQpXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGBmb3JtYXRMb25nYCBwcm9wZXJ0eSBvZiB0aGUgbG9jYWxlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBgZW4tVVNgIGxvY2FsZTpcbiAqIGxvY2FsZS5mb3JtYXRMb25nID0gYnVpbGRGb3JtYXRMb25nRm4oe1xuICogICBMVDogJ2g6bW0gYWEnLFxuICogICBMVFM6ICdoOm1tOnNzIGFhJyxcbiAqICAgTDogJ01NL0REL1lZWVknLFxuICogICBMTDogJ01NTU0gRCBZWVlZJyxcbiAqICAgTExMOiAnTU1NTSBEIFlZWVkgaDptbSBhYScsXG4gKiAgIExMTEw6ICdkZGRkLCBNTU1NIEQgWVlZWSBoOm1tIGFhJ1xuICogfSlcbiAqL1xuZnVuY3Rpb24gYnVpbGRGb3JtYXRMb25nRm4gKG9iaikge1xuICB2YXIgZm9ybWF0TG9uZ0xvY2FsZSA9IHtcbiAgICBMVFM6IG9iai5MVFMsXG4gICAgTFQ6IG9iai5MVCxcbiAgICBMOiBvYmouTCxcbiAgICBMTDogb2JqLkxMLFxuICAgIExMTDogb2JqLkxMTCxcbiAgICBMTExMOiBvYmouTExMTCxcbiAgICBsOiBvYmoubCB8fCBidWlsZFNob3J0TG9uZ0Zvcm1hdChvYmouTCksXG4gICAgbGw6IG9iai5sbCB8fCBidWlsZFNob3J0TG9uZ0Zvcm1hdChvYmouTEwpLFxuICAgIGxsbDogb2JqLmxsbCB8fCBidWlsZFNob3J0TG9uZ0Zvcm1hdChvYmouTExMKSxcbiAgICBsbGxsOiBvYmoubGxsbCB8fCBidWlsZFNob3J0TG9uZ0Zvcm1hdChvYmouTExMTClcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIGZvcm1hdExvbmdMb2NhbGVbdG9rZW5dXG4gIH1cbn1cblxudmFyIGZvcm1hdExvbmcgPSBidWlsZEZvcm1hdExvbmdGbih7XG4gIExUOiAnaDptbSBhYScsXG4gIExUUzogJ2g6bW06c3MgYWEnLFxuICBMOiAnTU0vREQvWVlZWScsXG4gIExMOiAnTU1NTSBEIFlZWVknLFxuICBMTEw6ICdNTU1NIEQgWVlZWSBoOm1tIGFhJyxcbiAgTExMTDogJ2RkZGQsIE1NTU0gRCBZWVlZIGg6bW0gYWEnXG59KTtcblxudmFyIGZvcm1hdFJlbGF0aXZlTG9jYWxlID0ge1xuICBsYXN0V2VlazogJ1tsYXN0XSBkZGRkIFthdF0gTFQnLFxuICB5ZXN0ZXJkYXk6ICdbeWVzdGVyZGF5IGF0XSBMVCcsXG4gIHRvZGF5OiAnW3RvZGF5IGF0XSBMVCcsXG4gIHRvbW9ycm93OiAnW3RvbW9ycm93IGF0XSBMVCcsXG4gIG5leHRXZWVrOiAnZGRkZCBbYXRdIExUJyxcbiAgb3RoZXI6ICdMJ1xufTtcblxuZnVuY3Rpb24gZm9ybWF0UmVsYXRpdmUgKHRva2VuLCBkYXRlLCBiYXNlRGF0ZSwgb3B0aW9ucykge1xuICByZXR1cm4gZm9ybWF0UmVsYXRpdmVMb2NhbGVbdG9rZW5dXG59XG5cbi8qKlxuICogQG5hbWUgYnVpbGRMb2NhbGl6ZUZuXG4gKiBAY2F0ZWdvcnkgTG9jYWxlIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEJ1aWxkIGBsb2NhbGl6ZS53ZWVrZGF5YCwgYGxvY2FsaXplLm1vbnRoYCBhbmQgYGxvY2FsaXplLnRpbWVPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEJ1aWxkIGBsb2NhbGl6ZS53ZWVrZGF5YCwgYGxvY2FsaXplLm1vbnRoYCBhbmQgYGxvY2FsaXplLnRpbWVPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZVxuICogdXNlZCBieSBgZm9ybWF0YCBmdW5jdGlvbi5cbiAqIElmIG5vIGB0eXBlYCBpcyBzdXBwbGllZCB0byB0aGUgb3B0aW9ucyBvZiB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uLCBgZGVmYXVsdFR5cGVgIHdpbGwgYmUgdXNlZCAoc2VlIGV4YW1wbGUpLlxuICpcbiAqIGBsb2NhbGl6ZS53ZWVrZGF5YCBmdW5jdGlvbiB0YWtlcyB0aGUgd2Vla2RheSBpbmRleCBhcyBhcmd1bWVudCAoMCAtIFN1bmRheSkuXG4gKiBgbG9jYWxpemUubW9udGhgIHRha2VzIHRoZSBtb250aCBpbmRleCAoMCAtIEphbnVhcnkpLlxuICogYGxvY2FsaXplLnRpbWVPZkRheWAgdGFrZXMgdGhlIGhvdXJzLiBVc2UgYGluZGV4Q2FsbGJhY2tgIHRvIGNvbnZlcnQgdGhlbSB0byBhbiBhcnJheSBpbmRleCAoc2VlIGV4YW1wbGUpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgb2JqZWN0IHdpdGggYXJyYXlzIG9mIHZhbHVlc1xuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRUeXBlIC0gdGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhlIGxvY2FsaXplIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5kZXhDYWxsYmFja10gLSB0aGUgY2FsbGJhY2sgd2hpY2ggdGFrZXMgdGhlIHJlc3VsdGluZyBmdW5jdGlvbiBhcmd1bWVudFxuICogICBhbmQgY29udmVydHMgaXQgaW50byB2YWx1ZSBhcnJheSBpbmRleFxuICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciB0aW1lT2ZEYXlWYWx1ZXMgPSB7XG4gKiAgIHVwcGVyY2FzZTogWydBTScsICdQTSddLFxuICogICBsb3dlcmNhc2U6IFsnYW0nLCAncG0nXSxcbiAqICAgbG9uZzogWydhLm0uJywgJ3AubS4nXVxuICogfVxuICogbG9jYWxlLmxvY2FsaXplLnRpbWVPZkRheSA9IGJ1aWxkTG9jYWxpemVGbih0aW1lT2ZEYXlWYWx1ZXMsICdsb25nJywgZnVuY3Rpb24gKGhvdXJzKSB7XG4gKiAgIC8vIDAgaXMgYS5tLiBhcnJheSBpbmRleCwgMSBpcyBwLm0uIGFycmF5IGluZGV4XG4gKiAgIHJldHVybiAoaG91cnMgLyAxMikgPj0gMSA/IDEgOiAwXG4gKiB9KVxuICogbG9jYWxlLmxvY2FsaXplLnRpbWVPZkRheSgxNiwge3R5cGU6ICd1cHBlcmNhc2UnfSkgLy89PiAnUE0nXG4gKiBsb2NhbGUubG9jYWxpemUudGltZU9mRGF5KDUpIC8vPT4gJ2EubS4nXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTG9jYWxpemVGbiAodmFsdWVzLCBkZWZhdWx0VHlwZSwgaW5kZXhDYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGRpcnR5SW5kZXgsIGRpcnR5T3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlID8gU3RyaW5nKG9wdGlvbnMudHlwZSkgOiBkZWZhdWx0VHlwZTtcbiAgICB2YXIgdmFsdWVzQXJyYXkgPSB2YWx1ZXNbdHlwZV0gfHwgdmFsdWVzW2RlZmF1bHRUeXBlXTtcbiAgICB2YXIgaW5kZXggPSBpbmRleENhbGxiYWNrID8gaW5kZXhDYWxsYmFjayhOdW1iZXIoZGlydHlJbmRleCkpIDogTnVtYmVyKGRpcnR5SW5kZXgpO1xuICAgIHJldHVybiB2YWx1ZXNBcnJheVtpbmRleF1cbiAgfVxufVxuXG4vKipcbiAqIEBuYW1lIGJ1aWxkTG9jYWxpemVBcnJheUZuXG4gKiBAY2F0ZWdvcnkgTG9jYWxlIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEJ1aWxkIGBsb2NhbGl6ZS53ZWVrZGF5c2AsIGBsb2NhbGl6ZS5tb250aHNgIGFuZCBgbG9jYWxpemUudGltZXNPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEJ1aWxkIGBsb2NhbGl6ZS53ZWVrZGF5c2AsIGBsb2NhbGl6ZS5tb250aHNgIGFuZCBgbG9jYWxpemUudGltZXNPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZS5cbiAqIElmIG5vIGB0eXBlYCBpcyBzdXBwbGllZCB0byB0aGUgb3B0aW9ucyBvZiB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uLCBgZGVmYXVsdFR5cGVgIHdpbGwgYmUgdXNlZCAoc2VlIGV4YW1wbGUpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgb2JqZWN0IHdpdGggYXJyYXlzIG9mIHZhbHVlc1xuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRUeXBlIC0gdGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhlIGxvY2FsaXplIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSByZXN1bHRpbmcgZnVuY3Rpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHdlZWtkYXlWYWx1ZXMgPSB7XG4gKiAgIG5hcnJvdzogWydTdScsICdNbycsICdUdScsICdXZScsICdUaCcsICdGcicsICdTYSddLFxuICogICBzaG9ydDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAqICAgbG9uZzogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddXG4gKiB9XG4gKiBsb2NhbGUubG9jYWxpemUud2Vla2RheXMgPSBidWlsZExvY2FsaXplQXJyYXlGbih3ZWVrZGF5VmFsdWVzLCAnbG9uZycpXG4gKiBsb2NhbGUubG9jYWxpemUud2Vla2RheXMoe3R5cGU6ICduYXJyb3cnfSkgLy89PiBbJ1N1JywgJ01vJywgLi4uXVxuICogbG9jYWxlLmxvY2FsaXplLndlZWtkYXlzKCkgLy89PiBbJ1N1bmRheScsICdNb25kYXknLCAuLi5dXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTG9jYWxpemVBcnJheUZuICh2YWx1ZXMsIGRlZmF1bHRUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZGlydHlPcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUgPyBTdHJpbmcob3B0aW9ucy50eXBlKSA6IGRlZmF1bHRUeXBlO1xuICAgIHJldHVybiB2YWx1ZXNbdHlwZV0gfHwgdmFsdWVzW2RlZmF1bHRUeXBlXVxuICB9XG59XG5cbi8vIE5vdGU6IGluIEVuZ2xpc2gsIHRoZSBuYW1lcyBvZiBkYXlzIG9mIHRoZSB3ZWVrIGFuZCBtb250aHMgYXJlIGNhcGl0YWxpemVkLlxuLy8gSWYgeW91IGFyZSBtYWtpbmcgYSBuZXcgbG9jYWxlIGJhc2VkIG9uIHRoaXMgb25lLCBjaGVjayBpZiB0aGUgc2FtZSBpcyB0cnVlIGZvciB0aGUgbGFuZ3VhZ2UgeW91J3JlIHdvcmtpbmcgb24uXG4vLyBHZW5lcmFsbHksIGZvcm1hdHRlZCBkYXRlcyBzaG91bGQgbG9vayBsaWtlIHRoZXkgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSBzZW50ZW5jZSxcbi8vIGUuZy4gaW4gU3BhbmlzaCBsYW5ndWFnZSB0aGUgd2Vla2RheXMgYW5kIG1vbnRocyBzaG91bGQgYmUgaW4gdGhlIGxvd2VyY2FzZS5cbnZhciB3ZWVrZGF5VmFsdWVzID0ge1xuICBuYXJyb3c6IFsnU3UnLCAnTW8nLCAnVHUnLCAnV2UnLCAnVGgnLCAnRnInLCAnU2EnXSxcbiAgc2hvcnQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gIGxvbmc6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXVxufTtcblxudmFyIG1vbnRoVmFsdWVzID0ge1xuICBzaG9ydDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICBsb25nOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXVxufTtcblxuLy8gYHRpbWVPZkRheWAgaXMgdXNlZCB0byBkZXNpZ25hdGUgd2hpY2ggcGFydCBvZiB0aGUgZGF5IGl0IGlzLCB3aGVuIHVzZWQgd2l0aCAxMi1ob3VyIGNsb2NrLlxuLy8gVXNlIHRoZSBzeXN0ZW0gd2hpY2ggaXMgdXNlZCB0aGUgbW9zdCBjb21tb25seSBpbiB0aGUgbG9jYWxlLlxuLy8gRm9yIGV4YW1wbGUsIGlmIHRoZSBjb3VudHJ5IGRvZXNuJ3QgdXNlIGEubS4vcC5tLiwgeW91IGNhbiB1c2UgYG5pZ2h0YC9gbW9ybmluZ2AvYGFmdGVybm9vbmAvYGV2ZW5pbmdgOlxuLy9cbi8vICAgdmFyIHRpbWVPZkRheVZhbHVlcyA9IHtcbi8vICAgICBhbnk6IFsnaW4gdGhlIG5pZ2h0JywgJ2luIHRoZSBtb3JuaW5nJywgJ2luIHRoZSBhZnRlcm5vb24nLCAnaW4gdGhlIGV2ZW5pbmcnXVxuLy8gICB9XG4vL1xuLy8gQW5kIGxhdGVyOlxuLy9cbi8vICAgdmFyIGxvY2FsaXplID0ge1xuLy8gICAgIC8vIFRoZSBjYWxsYmFjayB0YWtlcyB0aGUgaG91cnMgYXMgdGhlIGFyZ3VtZW50IGFuZCByZXR1cm5zIHRoZSBhcnJheSBpbmRleFxuLy8gICAgIHRpbWVPZkRheTogYnVpbGRMb2NhbGl6ZUZuKHRpbWVPZkRheVZhbHVlcywgJ2FueScsIGZ1bmN0aW9uIChob3Vycykge1xuLy8gICAgICAgaWYgKGhvdXJzID49IDE3KSB7XG4vLyAgICAgICAgIHJldHVybiAzXG4vLyAgICAgICB9IGVsc2UgaWYgKGhvdXJzID49IDEyKSB7XG4vLyAgICAgICAgIHJldHVybiAyXG4vLyAgICAgICB9IGVsc2UgaWYgKGhvdXJzID49IDQpIHtcbi8vICAgICAgICAgcmV0dXJuIDFcbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIHJldHVybiAwXG4vLyAgICAgICB9XG4vLyAgICAgfSksXG4vLyAgICAgdGltZXNPZkRheTogYnVpbGRMb2NhbGl6ZUFycmF5Rm4odGltZU9mRGF5VmFsdWVzLCAnYW55Jylcbi8vICAgfVxudmFyIHRpbWVPZkRheVZhbHVlcyA9IHtcbiAgdXBwZXJjYXNlOiBbJ0FNJywgJ1BNJ10sXG4gIGxvd2VyY2FzZTogWydhbScsICdwbSddLFxuICBsb25nOiBbJ2EubS4nLCAncC5tLiddXG59O1xuXG5mdW5jdGlvbiBvcmRpbmFsTnVtYmVyIChkaXJ0eU51bWJlciwgZGlydHlPcHRpb25zKSB7XG4gIHZhciBudW1iZXIgPSBOdW1iZXIoZGlydHlOdW1iZXIpO1xuXG4gIC8vIElmIG9yZGluYWwgbnVtYmVycyBkZXBlbmQgb24gY29udGV4dCwgZm9yIGV4YW1wbGUsXG4gIC8vIGlmIHRoZXkgYXJlIGRpZmZlcmVudCBmb3IgZGlmZmVyZW50IGdyYW1tYXRpY2FsIGdlbmRlcnMsXG4gIC8vIHVzZSBgb3B0aW9ucy51bml0YDpcbiAgLy9cbiAgLy8gICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fVxuICAvLyAgIHZhciB1bml0ID0gU3RyaW5nKG9wdGlvbnMudW5pdClcbiAgLy9cbiAgLy8gd2hlcmUgYHVuaXRgIGNhbiBiZSAnbW9udGgnLCAncXVhcnRlcicsICd3ZWVrJywgJ2lzb1dlZWsnLCAnZGF5T2ZZZWFyJyxcbiAgLy8gJ2RheU9mTW9udGgnIG9yICdkYXlPZldlZWsnXG5cbiAgdmFyIHJlbTEwMCA9IG51bWJlciAlIDEwMDtcbiAgaWYgKHJlbTEwMCA+IDIwIHx8IHJlbTEwMCA8IDEwKSB7XG4gICAgc3dpdGNoIChyZW0xMDAgJSAxMCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ3N0J1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ25kJ1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ3JkJ1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVtYmVyICsgJ3RoJ1xufVxuXG52YXIgbG9jYWxpemUgPSB7XG4gIG9yZGluYWxOdW1iZXI6IG9yZGluYWxOdW1iZXIsXG4gIHdlZWtkYXk6IGJ1aWxkTG9jYWxpemVGbih3ZWVrZGF5VmFsdWVzLCAnbG9uZycpLFxuICB3ZWVrZGF5czogYnVpbGRMb2NhbGl6ZUFycmF5Rm4od2Vla2RheVZhbHVlcywgJ2xvbmcnKSxcbiAgbW9udGg6IGJ1aWxkTG9jYWxpemVGbihtb250aFZhbHVlcywgJ2xvbmcnKSxcbiAgbW9udGhzOiBidWlsZExvY2FsaXplQXJyYXlGbihtb250aFZhbHVlcywgJ2xvbmcnKSxcbiAgdGltZU9mRGF5OiBidWlsZExvY2FsaXplRm4odGltZU9mRGF5VmFsdWVzLCAnbG9uZycsIGZ1bmN0aW9uIChob3Vycykge1xuICAgIHJldHVybiAoaG91cnMgLyAxMikgPj0gMSA/IDEgOiAwXG4gIH0pLFxuICB0aW1lc09mRGF5OiBidWlsZExvY2FsaXplQXJyYXlGbih0aW1lT2ZEYXlWYWx1ZXMsICdsb25nJylcbn07XG5cbi8qKlxuICogQG5hbWUgYnVpbGRNYXRjaEZuXG4gKiBAY2F0ZWdvcnkgTG9jYWxlIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEJ1aWxkIGBtYXRjaC53ZWVrZGF5c2AsIGBtYXRjaC5tb250aHNgIGFuZCBgbWF0Y2gudGltZXNPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEJ1aWxkIGBtYXRjaC53ZWVrZGF5c2AsIGBtYXRjaC5tb250aHNgIGFuZCBgbWF0Y2gudGltZXNPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZSB1c2VkIGJ5IGBwYXJzZWAgZnVuY3Rpb24uXG4gKiBJZiBubyBgdHlwZWAgaXMgc3VwcGxpZWQgdG8gdGhlIG9wdGlvbnMgb2YgdGhlIHJlc3VsdGluZyBmdW5jdGlvbiwgYGRlZmF1bHRUeXBlYCB3aWxsIGJlIHVzZWQgKHNlZSBleGFtcGxlKS5cbiAqIFRoZSByZXN1bHQgb2YgdGhlIG1hdGNoIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIGludG8gY29ycmVzcG9uZGluZyBwYXJzZXIgZnVuY3Rpb25cbiAqIChgbWF0Y2gud2Vla2RheWAsIGBtYXRjaC5tb250aGAgb3IgYG1hdGNoLnRpbWVPZkRheWAgcmVzcGVjdGl2ZWx5LiBTZWUgYGJ1aWxkUGFyc2VGbmApLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgb2JqZWN0IHdpdGggUmVnRXhwc1xuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRUeXBlIC0gdGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhlIG1hdGNoIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSByZXN1bHRpbmcgZnVuY3Rpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIG1hdGNoV2Vla2RheXNQYXR0ZXJucyA9IHtcbiAqICAgbmFycm93OiAvXihzdXxtb3x0dXx3ZXx0aHxmcnxzYSkvaSxcbiAqICAgc2hvcnQ6IC9eKHN1bnxtb258dHVlfHdlZHx0aHV8ZnJpfHNhdCkvaSxcbiAqICAgbG9uZzogL14oc3VuZGF5fG1vbmRheXx0dWVzZGF5fHdlZG5lc2RheXx0aHVyc2RheXxmcmlkYXl8c2F0dXJkYXkpL2lcbiAqIH1cbiAqIGxvY2FsZS5tYXRjaC53ZWVrZGF5cyA9IGJ1aWxkTWF0Y2hGbihtYXRjaFdlZWtkYXlzUGF0dGVybnMsICdsb25nJylcbiAqIGxvY2FsZS5tYXRjaC53ZWVrZGF5cygnU3VuZGF5Jywge3R5cGU6ICduYXJyb3cnfSkgLy89PiBbJ1N1JywgJ1N1JywgLi4uXVxuICogbG9jYWxlLm1hdGNoLndlZWtkYXlzKCdTdW5kYXknKSAvLz0+IFsnU3VuZGF5JywgJ1N1bmRheScsIC4uLl1cbiAqL1xuZnVuY3Rpb24gYnVpbGRNYXRjaEZuIChwYXR0ZXJucywgZGVmYXVsdFR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXJ0eVN0cmluZywgZGlydHlPcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUgPyBTdHJpbmcob3B0aW9ucy50eXBlKSA6IGRlZmF1bHRUeXBlO1xuICAgIHZhciBwYXR0ZXJuID0gcGF0dGVybnNbdHlwZV0gfHwgcGF0dGVybnNbZGVmYXVsdFR5cGVdO1xuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcoZGlydHlTdHJpbmcpO1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybilcbiAgfVxufVxuXG4vKipcbiAqIEBuYW1lIGJ1aWxkUGFyc2VGblxuICogQGNhdGVnb3J5IExvY2FsZSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBCdWlsZCBgbWF0Y2gud2Vla2RheWAsIGBtYXRjaC5tb250aGAgYW5kIGBtYXRjaC50aW1lT2ZEYXlgIHByb3BlcnRpZXMgZm9yIHRoZSBsb2NhbGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBCdWlsZCBgbWF0Y2gud2Vla2RheWAsIGBtYXRjaC5tb250aGAgYW5kIGBtYXRjaC50aW1lT2ZEYXlgIHByb3BlcnRpZXMgZm9yIHRoZSBsb2NhbGUgdXNlZCBieSBgcGFyc2VgIGZ1bmN0aW9uLlxuICogVGhlIGFyZ3VtZW50IG9mIHRoZSByZXN1bHRpbmcgZnVuY3Rpb24gaXMgdGhlIHJlc3VsdCBvZiB0aGUgY29ycmVzcG9uZGluZyBtYXRjaCBmdW5jdGlvblxuICogKGBtYXRjaC53ZWVrZGF5c2AsIGBtYXRjaC5tb250aHNgIG9yIGBtYXRjaC50aW1lc09mRGF5YCByZXNwZWN0aXZlbHkuIFNlZSBgYnVpbGRNYXRjaEZuYCkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIHRoZSBvYmplY3Qgd2l0aCBhcnJheXMgb2YgUmVnRXhwc1xuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRUeXBlIC0gdGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhlIHBhcnNlciBmdW5jdGlvblxuICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBwYXJzZVdlZWtkYXlQYXR0ZXJucyA9IHtcbiAqICAgYW55OiBbL15zdS9pLCAvXm0vaSwgL150dS9pLCAvXncvaSwgL150aC9pLCAvXmYvaSwgL15zYS9pXVxuICogfVxuICogbG9jYWxlLm1hdGNoLndlZWtkYXkgPSBidWlsZFBhcnNlRm4obWF0Y2hXZWVrZGF5c1BhdHRlcm5zLCAnbG9uZycpXG4gKiB2YXIgbWF0Y2hSZXN1bHQgPSBsb2NhbGUubWF0Y2gud2Vla2RheXMoJ0ZyaWRheScpXG4gKiBsb2NhbGUubWF0Y2gud2Vla2RheShtYXRjaFJlc3VsdCkgLy89PiA1XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUGFyc2VGbiAocGF0dGVybnMsIGRlZmF1bHRUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIGRpcnR5T3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlID8gU3RyaW5nKG9wdGlvbnMudHlwZSkgOiBkZWZhdWx0VHlwZTtcbiAgICB2YXIgcGF0dGVybnNBcnJheSA9IHBhdHRlcm5zW3R5cGVdIHx8IHBhdHRlcm5zW2RlZmF1bHRUeXBlXTtcbiAgICB2YXIgc3RyaW5nID0gbWF0Y2hSZXN1bHRbMV07XG5cbiAgICByZXR1cm4gcGF0dGVybnNBcnJheS5maW5kSW5kZXgoZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3Qoc3RyaW5nKVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBAbmFtZSBidWlsZE1hdGNoUGF0dGVybkZuXG4gKiBAY2F0ZWdvcnkgTG9jYWxlIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEJ1aWxkIG1hdGNoIGZ1bmN0aW9uIGZyb20gYSBzaW5nbGUgUmVnRXhwLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQnVpbGQgbWF0Y2ggZnVuY3Rpb24gZnJvbSBhIHNpbmdsZSBSZWdFeHAuXG4gKiBVc3VhbGx5IHVzZWQgZm9yIGJ1aWxkaW5nIGBtYXRjaC5vcmRpbmFsTnVtYmVyc2AgcHJvcGVydHkgb2YgdGhlIGxvY2FsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0dGVybiAtIHRoZSBSZWdFeHBcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdGhlIHJlc3VsdGluZyBmdW5jdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKiBsb2NhbGUubWF0Y2gub3JkaW5hbE51bWJlcnMgPSBidWlsZE1hdGNoUGF0dGVybkZuKC9eKFxcZCspKHRofHN0fG5kfHJkKT8vaSlcbiAqIGxvY2FsZS5tYXRjaC5vcmRpbmFsTnVtYmVycygnM3JkJykgLy89PiBbJzNyZCcsICczJywgJ3JkJywgLi4uXVxuICovXG5mdW5jdGlvbiBidWlsZE1hdGNoUGF0dGVybkZuIChwYXR0ZXJuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZGlydHlTdHJpbmcpIHtcbiAgICB2YXIgc3RyaW5nID0gU3RyaW5nKGRpcnR5U3RyaW5nKTtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pXG4gIH1cbn1cblxuLyoqXG4gKiBAbmFtZSBwYXJzZURlY2ltYWxcbiAqIEBjYXRlZ29yeSBMb2NhbGUgSGVscGVyc1xuICogQHN1bW1hcnkgUGFyc2VzIHRoZSBtYXRjaCByZXN1bHQgaW50byBkZWNpbWFsIG51bWJlci5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFBhcnNlcyB0aGUgbWF0Y2ggcmVzdWx0IGludG8gZGVjaW1hbCBudW1iZXIuXG4gKiBVc2VzIHRoZSBzdHJpbmcgbWF0Y2hlZCB3aXRoIHRoZSBmaXJzdCBzZXQgb2YgcGFyZW50aGVzZXMgb2YgbWF0Y2ggUmVnRXhwLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoUmVzdWx0IC0gdGhlIG9iamVjdCByZXR1cm5lZCBieSBtYXRjaGluZyBmdW5jdGlvblxuICogQHJldHVybnMge051bWJlcn0gdGhlIHBhcnNlZCB2YWx1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBsb2NhbGUubWF0Y2ggPSB7XG4gKiAgIG9yZGluYWxOdW1iZXJzOiAoZGlydHlTdHJpbmcpIHtcbiAqICAgICByZXR1cm4gU3RyaW5nKGRpcnR5U3RyaW5nKS5tYXRjaCgvXihcXGQrKSh0aHxzdHxuZHxyZCk/L2kpXG4gKiAgIH0sXG4gKiAgIG9yZGluYWxOdW1iZXI6IHBhcnNlRGVjaW1hbFxuICogfVxuICovXG5mdW5jdGlvbiBwYXJzZURlY2ltYWwgKG1hdGNoUmVzdWx0KSB7XG4gIHJldHVybiBwYXJzZUludChtYXRjaFJlc3VsdFsxXSwgMTApXG59XG5cbnZhciBtYXRjaE9yZGluYWxOdW1iZXJzUGF0dGVybiA9IC9eKFxcZCspKHRofHN0fG5kfHJkKT8vaTtcblxudmFyIG1hdGNoV2Vla2RheXNQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXihzdXxtb3x0dXx3ZXx0aHxmcnxzYSkvaSxcbiAgc2hvcnQ6IC9eKHN1bnxtb258dHVlfHdlZHx0aHV8ZnJpfHNhdCkvaSxcbiAgbG9uZzogL14oc3VuZGF5fG1vbmRheXx0dWVzZGF5fHdlZG5lc2RheXx0aHVyc2RheXxmcmlkYXl8c2F0dXJkYXkpL2lcbn07XG5cbnZhciBwYXJzZVdlZWtkYXlQYXR0ZXJucyA9IHtcbiAgYW55OiBbL15zdS9pLCAvXm0vaSwgL150dS9pLCAvXncvaSwgL150aC9pLCAvXmYvaSwgL15zYS9pXVxufTtcblxudmFyIG1hdGNoTW9udGhzUGF0dGVybnMgPSB7XG4gIHNob3J0OiAvXihqYW58ZmVifG1hcnxhcHJ8bWF5fGp1bnxqdWx8YXVnfHNlcHxvY3R8bm92fGRlYykvaSxcbiAgbG9uZzogL14oamFudWFyeXxmZWJydWFyeXxtYXJjaHxhcHJpbHxtYXl8anVuZXxqdWx5fGF1Z3VzdHxzZXB0ZW1iZXJ8b2N0b2Jlcnxub3ZlbWJlcnxkZWNlbWJlcikvaVxufTtcblxudmFyIHBhcnNlTW9udGhQYXR0ZXJucyA9IHtcbiAgYW55OiBbL15qYS9pLCAvXmYvaSwgL15tYXIvaSwgL15hcC9pLCAvXm1heS9pLCAvXmp1bi9pLCAvXmp1bC9pLCAvXmF1L2ksIC9ecy9pLCAvXm8vaSwgL15uL2ksIC9eZC9pXVxufTtcblxuLy8gYHRpbWVPZkRheWAgaXMgdXNlZCB0byBkZXNpZ25hdGUgd2hpY2ggcGFydCBvZiB0aGUgZGF5IGl0IGlzLCB3aGVuIHVzZWQgd2l0aCAxMi1ob3VyIGNsb2NrLlxuLy8gVXNlIHRoZSBzeXN0ZW0gd2hpY2ggaXMgdXNlZCB0aGUgbW9zdCBjb21tb25seSBpbiB0aGUgbG9jYWxlLlxuLy8gRm9yIGV4YW1wbGUsIGlmIHRoZSBjb3VudHJ5IGRvZXNuJ3QgdXNlIGEubS4vcC5tLiwgeW91IGNhbiB1c2UgYG5pZ2h0YC9gbW9ybmluZ2AvYGFmdGVybm9vbmAvYGV2ZW5pbmdgOlxuLy9cbi8vICAgdmFyIG1hdGNoVGltZXNPZkRheVBhdHRlcm5zID0ge1xuLy8gICAgIGxvbmc6IC9eKChpbiB0aGUpPyAobmlnaHR8bW9ybmluZ3xhZnRlcm5vb258ZXZlbmluZz8pKS9pXG4vLyAgIH1cbi8vXG4vLyAgIHZhciBwYXJzZVRpbWVPZkRheVBhdHRlcm5zID0ge1xuLy8gICAgIGFueTogWy8obmlnaHR8bW9ybmluZykvaSwgLyhhZnRlcm5vb258ZXZlbmluZykvaV1cbi8vICAgfVxudmFyIG1hdGNoVGltZXNPZkRheVBhdHRlcm5zID0ge1xuICBzaG9ydDogL14oYW18cG0pL2ksXG4gIGxvbmc6IC9eKFthcF1cXC4/XFxzP21cXC4/KS9pXG59O1xuXG52YXIgcGFyc2VUaW1lT2ZEYXlQYXR0ZXJucyA9IHtcbiAgYW55OiBbL15hL2ksIC9ecC9pXVxufTtcblxudmFyIG1hdGNoID0ge1xuICBvcmRpbmFsTnVtYmVyczogYnVpbGRNYXRjaFBhdHRlcm5GbihtYXRjaE9yZGluYWxOdW1iZXJzUGF0dGVybiksXG4gIG9yZGluYWxOdW1iZXI6IHBhcnNlRGVjaW1hbCxcbiAgd2Vla2RheXM6IGJ1aWxkTWF0Y2hGbihtYXRjaFdlZWtkYXlzUGF0dGVybnMsICdsb25nJyksXG4gIHdlZWtkYXk6IGJ1aWxkUGFyc2VGbihwYXJzZVdlZWtkYXlQYXR0ZXJucywgJ2FueScpLFxuICBtb250aHM6IGJ1aWxkTWF0Y2hGbihtYXRjaE1vbnRoc1BhdHRlcm5zLCAnbG9uZycpLFxuICBtb250aDogYnVpbGRQYXJzZUZuKHBhcnNlTW9udGhQYXR0ZXJucywgJ2FueScpLFxuICB0aW1lc09mRGF5OiBidWlsZE1hdGNoRm4obWF0Y2hUaW1lc09mRGF5UGF0dGVybnMsICdsb25nJyksXG4gIHRpbWVPZkRheTogYnVpbGRQYXJzZUZuKHBhcnNlVGltZU9mRGF5UGF0dGVybnMsICdhbnknKVxufTtcblxuLyoqXG4gKiBAdHlwZSB7TG9jYWxlfVxuICogQGNhdGVnb3J5IExvY2FsZXNcbiAqIEBzdW1tYXJ5IEVuZ2xpc2ggbG9jYWxlIChVbml0ZWQgU3RhdGVzKS5cbiAqIEBsYW5ndWFnZSBFbmdsaXNoXG4gKiBAaXNvLTYzOS0yIGVuZ1xuICovXG52YXIgbG9jYWxlJDEgPSB7XG4gIGZvcm1hdERpc3RhbmNlOiBmb3JtYXREaXN0YW5jZSxcbiAgZm9ybWF0TG9uZzogZm9ybWF0TG9uZyxcbiAgZm9ybWF0UmVsYXRpdmU6IGZvcm1hdFJlbGF0aXZlLFxuICBsb2NhbGl6ZTogbG9jYWxpemUsXG4gIG1hdGNoOiBtYXRjaCxcbiAgb3B0aW9uczoge1xuICAgIHdlZWtTdGFydHNPbjogMCAvKiBTdW5kYXkgKi8sXG4gICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiAxXG4gIH1cbn07XG5cbnZhciBNSUxMSVNFQ09ORFNfSU5fREFZJDEgPSA4NjQwMDAwMDtcblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5mdW5jdGlvbiBnZXRVVENEYXlPZlllYXIgKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcbiAgdmFyIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB2YXIgc3RhcnRPZlllYXJUaW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgdmFyIGRpZmZlcmVuY2UgPSB0aW1lc3RhbXAgLSBzdGFydE9mWWVhclRpbWVzdGFtcDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZGlmZmVyZW5jZSAvIE1JTExJU0VDT05EU19JTl9EQVkkMSkgKyAxXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuZnVuY3Rpb24gc3RhcnRPZlVUQ0lTT1dlZWsgKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gIHZhciB3ZWVrU3RhcnRzT24gPSAxO1xuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcbiAgdmFyIGRheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gIHZhciBkaWZmID0gKGRheSA8IHdlZWtTdGFydHNPbiA/IDcgOiAwKSArIGRheSAtIHdlZWtTdGFydHNPbjtcblxuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGRhdGVcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5mdW5jdGlvbiBnZXRVVENJU09XZWVrWWVhciAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcblxuICB2YXIgZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhciA9IG5ldyBEYXRlKDApO1xuICBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyLnNldFVUQ0Z1bGxZZWFyKHllYXIgKyAxLCAwLCA0KTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIHN0YXJ0T2ZOZXh0WWVhciA9IHN0YXJ0T2ZVVENJU09XZWVrKGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIsIGRpcnR5T3B0aW9ucyk7XG5cbiAgdmFyIGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIgPSBuZXcgRGF0ZSgwKTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhci5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCA0KTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIHN0YXJ0T2ZUaGlzWWVhciA9IHN0YXJ0T2ZVVENJU09XZWVrKGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIsIGRpcnR5T3B0aW9ucyk7XG5cbiAgaWYgKGRhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZOZXh0WWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhciArIDFcbiAgfSBlbHNlIGlmIChkYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mVGhpc1llYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geWVhciAtIDFcbiAgfVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcbmZ1bmN0aW9uIHN0YXJ0T2ZVVENJU09XZWVrWWVhciAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgdmFyIHllYXIgPSBnZXRVVENJU09XZWVrWWVhcihkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBmb3VydGhPZkphbnVhcnkgPSBuZXcgRGF0ZSgwKTtcbiAgZm91cnRoT2ZKYW51YXJ5LnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnkuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBkYXRlID0gc3RhcnRPZlVUQ0lTT1dlZWsoZm91cnRoT2ZKYW51YXJ5LCBkaXJ0eU9wdGlvbnMpO1xuICByZXR1cm4gZGF0ZVxufVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX1dFRUskMiA9IDYwNDgwMDAwMDtcblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5mdW5jdGlvbiBnZXRVVENJU09XZWVrIChkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBkaWZmID0gc3RhcnRPZlVUQ0lTT1dlZWsoZGF0ZSwgZGlydHlPcHRpb25zKS5nZXRUaW1lKCkgLSBzdGFydE9mVVRDSVNPV2Vla1llYXIoZGF0ZSwgZGlydHlPcHRpb25zKS5nZXRUaW1lKCk7XG5cbiAgLy8gUm91bmQgdGhlIG51bWJlciBvZiBkYXlzIHRvIHRoZSBuZWFyZXN0IGludGVnZXJcbiAgLy8gYmVjYXVzZSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpbiBhIHdlZWsgaXMgbm90IGNvbnN0YW50XG4gIC8vIChlLmcuIGl0J3MgZGlmZmVyZW50IGluIHRoZSB3ZWVrIG9mIHRoZSBkYXlsaWdodCBzYXZpbmcgdGltZSBjbG9jayBzaGlmdClcbiAgcmV0dXJuIE1hdGgucm91bmQoZGlmZiAvIE1JTExJU0VDT05EU19JTl9XRUVLJDIpICsgMVxufVxuXG52YXIgZm9ybWF0dGVycyA9IHtcbiAgLy8gTW9udGg6IDEsIDIsIC4uLiwgMTJcbiAgJ00nOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldFVUQ01vbnRoKCkgKyAxXG4gIH0sXG5cbiAgLy8gTW9udGg6IDFzdCwgMm5kLCAuLi4sIDEydGhcbiAgJ01vJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgbW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCkgKyAxO1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKG1vbnRoLCB7dW5pdDogJ21vbnRoJ30pXG4gIH0sXG5cbiAgLy8gTW9udGg6IDAxLCAwMiwgLi4uLCAxMlxuICAnTU0nOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENNb250aCgpICsgMSwgMilcbiAgfSxcblxuICAvLyBNb250aDogSmFuLCBGZWIsIC4uLiwgRGVjXG4gICdNTU0nOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5tb250aChkYXRlLmdldFVUQ01vbnRoKCksIHt0eXBlOiAnc2hvcnQnfSlcbiAgfSxcblxuICAvLyBNb250aDogSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcbiAgJ01NTU0nOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5tb250aChkYXRlLmdldFVUQ01vbnRoKCksIHt0eXBlOiAnbG9uZyd9KVxuICB9LFxuXG4gIC8vIFF1YXJ0ZXI6IDEsIDIsIDMsIDRcbiAgJ1EnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBNYXRoLmNlaWwoKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpIC8gMylcbiAgfSxcblxuICAvLyBRdWFydGVyOiAxc3QsIDJuZCwgM3JkLCA0dGhcbiAgJ1FvJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcXVhcnRlciA9IE1hdGguY2VpbCgoZGF0ZS5nZXRVVENNb250aCgpICsgMSkgLyAzKTtcbiAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUub3JkaW5hbE51bWJlcihxdWFydGVyLCB7dW5pdDogJ3F1YXJ0ZXInfSlcbiAgfSxcblxuICAvLyBEYXkgb2YgbW9udGg6IDEsIDIsIC4uLiwgMzFcbiAgJ0QnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldFVUQ0RhdGUoKVxuICB9LFxuXG4gIC8vIERheSBvZiBtb250aDogMXN0LCAybmQsIC4uLiwgMzFzdFxuICAnRG8nOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRhdGUuZ2V0VVRDRGF0ZSgpLCB7dW5pdDogJ2RheU9mTW9udGgnfSlcbiAgfSxcblxuICAvLyBEYXkgb2YgbW9udGg6IDAxLCAwMiwgLi4uLCAzMVxuICAnREQnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENEYXRlKCksIDIpXG4gIH0sXG5cbiAgLy8gRGF5IG9mIHllYXI6IDEsIDIsIC4uLiwgMzY2XG4gICdEREQnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBnZXRVVENEYXlPZlllYXIoZGF0ZSlcbiAgfSxcblxuICAvLyBEYXkgb2YgeWVhcjogMXN0LCAybmQsIC4uLiwgMzY2dGhcbiAgJ0RERG8nOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGdldFVUQ0RheU9mWWVhcihkYXRlKSwge3VuaXQ6ICdkYXlPZlllYXInfSlcbiAgfSxcblxuICAvLyBEYXkgb2YgeWVhcjogMDAxLCAwMDIsIC4uLiwgMzY2XG4gICdEREREJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGdldFVUQ0RheU9mWWVhcihkYXRlKSwgMylcbiAgfSxcblxuICAvLyBEYXkgb2Ygd2VlazogU3UsIE1vLCAuLi4sIFNhXG4gICdkZCc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLmxvY2FsaXplLndlZWtkYXkoZGF0ZS5nZXRVVENEYXkoKSwge3R5cGU6ICduYXJyb3cnfSlcbiAgfSxcblxuICAvLyBEYXkgb2Ygd2VlazogU3VuLCBNb24sIC4uLiwgU2F0XG4gICdkZGQnOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS53ZWVrZGF5KGRhdGUuZ2V0VVRDRGF5KCksIHt0eXBlOiAnc2hvcnQnfSlcbiAgfSxcblxuICAvLyBEYXkgb2Ygd2VlazogU3VuZGF5LCBNb25kYXksIC4uLiwgU2F0dXJkYXlcbiAgJ2RkZGQnOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS53ZWVrZGF5KGRhdGUuZ2V0VVRDRGF5KCksIHt0eXBlOiAnbG9uZyd9KVxuICB9LFxuXG4gIC8vIERheSBvZiB3ZWVrOiAwLCAxLCAuLi4sIDZcbiAgJ2QnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldFVUQ0RheSgpXG4gIH0sXG5cbiAgLy8gRGF5IG9mIHdlZWs6IDB0aCwgMXN0LCAybmQsIC4uLiwgNnRoXG4gICdkbyc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLmxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXRVVENEYXkoKSwge3VuaXQ6ICdkYXlPZldlZWsnfSlcbiAgfSxcblxuICAvLyBEYXkgb2YgSVNPIHdlZWs6IDEsIDIsIC4uLiwgN1xuICAnRSc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0VVRDRGF5KCkgfHwgN1xuICB9LFxuXG4gIC8vIElTTyB3ZWVrOiAxLCAyLCAuLi4sIDUzXG4gICdXJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZ2V0VVRDSVNPV2VlayhkYXRlKVxuICB9LFxuXG4gIC8vIElTTyB3ZWVrOiAxc3QsIDJuZCwgLi4uLCA1M3RoXG4gICdXbyc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLmxvY2FsaXplLm9yZGluYWxOdW1iZXIoZ2V0VVRDSVNPV2VlayhkYXRlKSwge3VuaXQ6ICdpc29XZWVrJ30pXG4gIH0sXG5cbiAgLy8gSVNPIHdlZWs6IDAxLCAwMiwgLi4uLCA1M1xuICAnV1cnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZ2V0VVRDSVNPV2VlayhkYXRlKSwgMilcbiAgfSxcblxuICAvLyBZZWFyOiAwMCwgMDEsIC4uLiwgOTlcbiAgJ1lZJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgNCkuc3Vic3RyKDIpXG4gIH0sXG5cbiAgLy8gWWVhcjogMTkwMCwgMTkwMSwgLi4uLCAyMDk5XG4gICdZWVlZJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgNClcbiAgfSxcblxuICAvLyBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogMDAsIDAxLCAuLi4sIDk5XG4gICdHRyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIFN0cmluZyhnZXRVVENJU09XZWVrWWVhcihkYXRlKSkuc3Vic3RyKDIpXG4gIH0sXG5cbiAgLy8gSVNPIHdlZWstbnVtYmVyaW5nIHllYXI6IDE5MDAsIDE5MDEsIC4uLiwgMjA5OVxuICAnR0dHRyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGdldFVUQ0lTT1dlZWtZZWFyKGRhdGUpXG4gIH0sXG5cbiAgLy8gSG91cjogMCwgMSwgLi4uIDIzXG4gICdIJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRVVENIb3VycygpXG4gIH0sXG5cbiAgLy8gSG91cjogMDAsIDAxLCAuLi4sIDIzXG4gICdISCc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ0hvdXJzKCksIDIpXG4gIH0sXG5cbiAgLy8gSG91cjogMSwgMiwgLi4uLCAxMlxuICAnaCc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIGlmIChob3VycyA9PT0gMCkge1xuICAgICAgcmV0dXJuIDEyXG4gICAgfSBlbHNlIGlmIChob3VycyA+IDEyKSB7XG4gICAgICByZXR1cm4gaG91cnMgJSAxMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaG91cnNcbiAgICB9XG4gIH0sXG5cbiAgLy8gSG91cjogMDEsIDAyLCAuLi4sIDEyXG4gICdoaCc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhmb3JtYXR0ZXJzWydoJ10oZGF0ZSksIDIpXG4gIH0sXG5cbiAgLy8gTWludXRlOiAwLCAxLCAuLi4sIDU5XG4gICdtJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRVVENNaW51dGVzKClcbiAgfSxcblxuICAvLyBNaW51dGU6IDAwLCAwMSwgLi4uLCA1OVxuICAnbW0nOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENNaW51dGVzKCksIDIpXG4gIH0sXG5cbiAgLy8gU2Vjb25kOiAwLCAxLCAuLi4sIDU5XG4gICdzJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRVVENTZWNvbmRzKClcbiAgfSxcblxuICAvLyBTZWNvbmQ6IDAwLCAwMSwgLi4uLCA1OVxuICAnc3MnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENTZWNvbmRzKCksIDIpXG4gIH0sXG5cbiAgLy8gMS8xMCBvZiBzZWNvbmQ6IDAsIDEsIC4uLiwgOVxuICAnUyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKSAvIDEwMClcbiAgfSxcblxuICAvLyAxLzEwMCBvZiBzZWNvbmQ6IDAwLCAwMSwgLi4uLCA5OVxuICAnU1MnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoTWF0aC5mbG9vcihkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpIC8gMTApLCAyKVxuICB9LFxuXG4gIC8vIE1pbGxpc2Vjb25kOiAwMDAsIDAwMSwgLi4uLCA5OTlcbiAgJ1NTUyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLCAzKVxuICB9LFxuXG4gIC8vIFRpbWV6b25lOiAtMDE6MDAsICswMDowMCwgLi4uICsxMjowMFxuICAnWic6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHJldHVybiBmb3JtYXRUaW1lem9uZShvcmlnaW5hbERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSwgJzonKVxuICB9LFxuXG4gIC8vIFRpbWV6b25lOiAtMDEwMCwgKzAwMDAsIC4uLiArMTIwMFxuICAnWlonOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICByZXR1cm4gZm9ybWF0VGltZXpvbmUob3JpZ2luYWxEYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkpXG4gIH0sXG5cbiAgLy8gU2Vjb25kcyB0aW1lc3RhbXA6IDUxMjk2OTUyMFxuICAnWCc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHJldHVybiBNYXRoLmZsb29yKG9yaWdpbmFsRGF0ZS5nZXRUaW1lKCkgLyAxMDAwKVxuICB9LFxuXG4gIC8vIE1pbGxpc2Vjb25kcyB0aW1lc3RhbXA6IDUxMjk2OTUyMDkwMFxuICAneCc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHJldHVybiBvcmlnaW5hbERhdGUuZ2V0VGltZSgpXG4gIH0sXG5cbiAgLy8gQU0sIFBNXG4gICdBJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUudGltZU9mRGF5KGRhdGUuZ2V0VVRDSG91cnMoKSwge3R5cGU6ICd1cHBlcmNhc2UnfSlcbiAgfSxcblxuICAvLyBhbSwgcG1cbiAgJ2EnOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS50aW1lT2ZEYXkoZGF0ZS5nZXRVVENIb3VycygpLCB7dHlwZTogJ2xvd2VyY2FzZSd9KVxuICB9LFxuXG4gIC8vIGEubS4sIHAubS5cbiAgJ2FhJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUudGltZU9mRGF5KGRhdGUuZ2V0VVRDSG91cnMoKSwge3R5cGU6ICdsb25nJ30pXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lIChvZmZzZXQsIGRlbGltZXRlcikge1xuICBkZWxpbWV0ZXIgPSBkZWxpbWV0ZXIgfHwgJyc7XG4gIHZhciBzaWduID0gb2Zmc2V0ID4gMCA/ICctJyA6ICcrJztcbiAgdmFyIGFic09mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG4gIHZhciBob3VycyA9IE1hdGguZmxvb3IoYWJzT2Zmc2V0IC8gNjApO1xuICB2YXIgbWludXRlcyA9IGFic09mZnNldCAlIDYwO1xuICByZXR1cm4gc2lnbiArIGFkZExlYWRpbmdaZXJvcyhob3VycywgMikgKyBkZWxpbWV0ZXIgKyBhZGRMZWFkaW5nWmVyb3MobWludXRlcywgMilcbn1cblxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm9zIChudW1iZXIsIHRhcmdldExlbmd0aCkge1xuICB2YXIgb3V0cHV0ID0gTWF0aC5hYnMobnVtYmVyKS50b1N0cmluZygpO1xuICB3aGlsZSAob3V0cHV0Lmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgIG91dHB1dCA9ICcwJyArIG91dHB1dDtcbiAgfVxuICByZXR1cm4gb3V0cHV0XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuZnVuY3Rpb24gYWRkVVRDTWludXRlcyAoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCwgZGlydHlPcHRpb25zKSB7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcbiAgdmFyIGFtb3VudCA9IE51bWJlcihkaXJ0eUFtb3VudCk7XG4gIGRhdGUuc2V0VVRDTWludXRlcyhkYXRlLmdldFVUQ01pbnV0ZXMoKSArIGFtb3VudCk7XG4gIHJldHVybiBkYXRlXG59XG5cbnZhciBsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCA9IC8oXFxbW15bXSpdKXwoXFxcXCk/KExUU3xMVHxMTExMfExMTHxMTHxMfGxsbGx8bGxsfGxsfGwpL2c7XG52YXIgZGVmYXVsdEZvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvKFxcW1teW10qXSl8KFxcXFwpPyh4fHNzfHN8bW18bXxoaHxofGRvfGRkZGR8ZGRkfGRkfGR8YWF8YXxaWnxafFlZWVl8WVl8WHxXb3xXV3xXfFNTU3xTU3xTfFFvfFF8TW98TU1NTXxNTU18TU18TXxISHxIfEdHR0d8R0d8RXxEb3xERERvfERERER8REREfEREfER8QXwuKS9nO1xuXG4vKipcbiAqIEBuYW1lIGZvcm1hdFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBGb3JtYXQgdGhlIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZyBpbiB0aGUgZ2l2ZW4gZm9ybWF0LlxuICpcbiAqIEFjY2VwdGVkIHRva2VuczpcbiAqIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgfCBUb2tlbiB8IFJlc3VsdCBleGFtcGxlcyAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgTW9udGggICAgICAgICAgICAgICAgICAgfCBNICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBNbyAgICB8IDFzdCwgMm5kLCAuLi4sIDEydGggICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTSAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU0gICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU1NICB8IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyIHxcbiAqIHwgUXVhcnRlciAgICAgICAgICAgICAgICAgfCBRICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBRbyAgICB8IDFzdCwgMm5kLCAzcmQsIDR0aCAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgfCBEICAgICB8IDEsIDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBEbyAgICB8IDFzdCwgMm5kLCAuLi4sIDMxc3QgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBERCAgICB8IDAxLCAwMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgfCBEREQgICB8IDEsIDIsIC4uLiwgMzY2ICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBERERvICB8IDFzdCwgMm5kLCAuLi4sIDM2NnRoICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBEREREICB8IDAwMSwgMDAyLCAuLi4sIDM2NiAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIHdlZWsgICAgICAgICAgICAgfCBkICAgICB8IDAsIDEsIC4uLiwgNiAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBkbyAgICB8IDB0aCwgMXN0LCAuLi4sIDZ0aCAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZCAgICB8IFN1LCBNbywgLi4uLCBTYSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZGQgICB8IFN1biwgTW9uLCAuLi4sIFNhdCAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZGRkICB8IFN1bmRheSwgTW9uZGF5LCAuLi4sIFNhdHVyZGF5ICAgIHxcbiAqIHwgRGF5IG9mIElTTyB3ZWVrICAgICAgICAgfCBFICAgICB8IDEsIDIsIC4uLiwgNyAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgSVNPIHdlZWsgICAgICAgICAgICAgICAgfCBXICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBXbyAgICB8IDFzdCwgMm5kLCAuLi4sIDUzcmQgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBXVyAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgIHxcbiAqIHwgWWVhciAgICAgICAgICAgICAgICAgICAgfCBZWSAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWVlZICB8IDE5MDAsIDE5MDEsIC4uLiwgMjA5OSAgICAgICAgICAgIHxcbiAqIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgfCBHRyAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBHR0dHICB8IDE5MDAsIDE5MDEsIC4uLiwgMjA5OSAgICAgICAgICAgIHxcbiAqIHwgQU0vUE0gICAgICAgICAgICAgICAgICAgfCBBICAgICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBhICAgICB8IGFtLCBwbSAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBhYSAgICB8IGEubS4sIHAubS4gICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgSG91ciAgICAgICAgICAgICAgICAgICAgfCBIICAgICB8IDAsIDEsIC4uLiAyMyAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBISCAgICB8IDAwLCAwMSwgLi4uIDIzICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBoICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBoaCAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTWludXRlICAgICAgICAgICAgICAgICAgfCBtICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBtbSAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgfCBzICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBzcyAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMS8xMCBvZiBzZWNvbmQgICAgICAgICAgfCBTICAgICB8IDAsIDEsIC4uLiwgOSAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMS8xMDAgb2Ygc2Vjb25kICAgICAgICAgfCBTUyAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTWlsbGlzZWNvbmQgICAgICAgICAgICAgfCBTU1MgICB8IDAwMCwgMDAxLCAuLi4sIDk5OSAgICAgICAgICAgICAgIHxcbiAqIHwgVGltZXpvbmUgICAgICAgICAgICAgICAgfCBaICAgICB8IC0wMTowMCwgKzAwOjAwLCAuLi4gKzEyOjAwICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBaWiAgICB8IC0wMTAwLCArMDAwMCwgLi4uLCArMTIwMCAgICAgICAgIHxcbiAqIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgfCBYICAgICB8IDUxMjk2OTUyMCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgfCB4ICAgICB8IDUxMjk2OTUyMDkwMCAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTG9uZyBmb3JtYXQgICAgICAgICAgICAgfCBMVCAgICB8IDA1OjMwIGEubS4gICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBMVFMgICB8IDA1OjMwOjE1IGEubS4gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBMICAgICB8IDA3LzAyLzE5OTUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBsICAgICB8IDcvMi8xOTk1ICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTCAgICB8IEp1bHkgMiAxOTk1ICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBsbCAgICB8IEp1bCAyIDE5OTUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTEwgICB8IEp1bHkgMiAxOTk1IDA1OjMwIGEubS4gICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBsbGwgICB8IEp1bCAyIDE5OTUgMDU6MzAgYS5tLiAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTExMICB8IFN1bmRheSwgSnVseSAyIDE5OTUgMDU6MzAgYS5tLiAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBsbGxsICB8IFN1biwgSnVsIDIgMTk5NSAwNTozMCBhLm0uICAgICAgIHxcbiAqXG4gKiBUaGUgY2hhcmFjdGVycyB3cmFwcGVkIGluIHNxdWFyZSBicmFja2V0cyBhcmUgZXNjYXBlZC5cbiAqXG4gKiBUaGUgcmVzdWx0IG1heSB2YXJ5IGJ5IGxvY2FsZS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0IC0gdGhlIHN0cmluZyBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICogQHBhcmFtIHtMb2NhbGV9IFtvcHRpb25zLmxvY2FsZT1kZWZhdWx0TG9jYWxlXSAtIHRoZSBsb2NhbGUgb2JqZWN0LiBTZWUgW0xvY2FsZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9Mb2NhbGV9XG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYGxvY2FsaXplYCBwcm9wZXJ0eVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYGZvcm1hdExvbmdgIHByb3BlcnR5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAxMSBGZWJydWFyeSAyMDE0IGluIG1pZGRsZS1lbmRpYW4gZm9ybWF0OlxuICogdmFyIHJlc3VsdCA9IGZvcm1hdChcbiAqICAgbmV3IERhdGUoMjAxNCwgMSwgMTEpLFxuICogICAnTU0vREQvWVlZWSdcbiAqIClcbiAqIC8vPT4gJzAyLzExLzIwMTQnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAyIEp1bHkgMjAxNCBpbiBFc3BlcmFudG86XG4gKiBpbXBvcnQgeyBlb0xvY2FsZSB9IGZyb20gJ2RhdGUtZm5zL2xvY2FsZS9lbydcbiAqIHZhciByZXN1bHQgPSBmb3JtYXQoXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIpLFxuICogICAnRG8gW2RlXSBNTU1NIFlZWVknLFxuICogICB7bG9jYWxlOiBlb0xvY2FsZX1cbiAqIClcbiAqIC8vPT4gJzItYSBkZSBqdWxpbyAyMDE0J1xuICovXG5mdW5jdGlvbiBmb3JtYXQgKGRpcnR5RGF0ZSwgZGlydHlGb3JtYXRTdHIsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgdmFyIGZvcm1hdFN0ciA9IFN0cmluZyhkaXJ0eUZvcm1hdFN0cik7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuXG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZSB8fCBsb2NhbGUkMTtcblxuICBpZiAoIWxvY2FsZS5sb2NhbGl6ZSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdsb2NhbGUgbXVzdCBjb250YWluIGxvY2FsaXplIHByb3BlcnR5JylcbiAgfVxuXG4gIGlmICghbG9jYWxlLmZvcm1hdExvbmcpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBmb3JtYXRMb25nIHByb3BlcnR5JylcbiAgfVxuXG4gIHZhciBsb2NhbGVGb3JtYXR0ZXJzID0gbG9jYWxlLmZvcm1hdHRlcnMgfHwge307XG4gIHZhciBmb3JtYXR0aW5nVG9rZW5zUmVnRXhwID0gbG9jYWxlLmZvcm1hdHRpbmdUb2tlbnNSZWdFeHAgfHwgZGVmYXVsdEZvcm1hdHRpbmdUb2tlbnNSZWdFeHA7XG4gIHZhciBmb3JtYXRMb25nID0gbG9jYWxlLmZvcm1hdExvbmc7XG5cbiAgdmFyIG9yaWdpbmFsRGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIG9wdGlvbnMpO1xuXG4gIGlmICghaXNWYWxpZChvcmlnaW5hbERhdGUsIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuICdJbnZhbGlkIERhdGUnXG4gIH1cblxuICAvLyBDb252ZXJ0IHRoZSBkYXRlIGluIHN5c3RlbSB0aW1lem9uZSB0byB0aGUgc2FtZSBkYXRlIGluIFVUQyswMDowMCB0aW1lem9uZS5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2hlbiBVVEMgZnVuY3Rpb25zIHdpbGwgYmUgaW1wbGVtZW50ZWQsIGxvY2FsZXMgd2lsbCBiZSBjb21wYXRpYmxlIHdpdGggdGhlbS5cbiAgLy8gU2VlIGFuIGlzc3VlIGFib3V0IFVUQyBmdW5jdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG4gIHZhciB0aW1lem9uZU9mZnNldCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICB2YXIgdXRjRGF0ZSA9IGFkZFVUQ01pbnV0ZXMob3JpZ2luYWxEYXRlLCAtdGltZXpvbmVPZmZzZXQsIG9wdGlvbnMpO1xuXG4gIHZhciBmb3JtYXR0ZXJPcHRpb25zID0gY2xvbmVPYmplY3Qob3B0aW9ucyk7XG4gIGZvcm1hdHRlck9wdGlvbnMubG9jYWxlID0gbG9jYWxlO1xuICBmb3JtYXR0ZXJPcHRpb25zLmZvcm1hdHRlcnMgPSBmb3JtYXR0ZXJzO1xuXG4gIC8vIFdoZW4gVVRDIGZ1bmN0aW9ucyB3aWxsIGJlIGltcGxlbWVudGVkLCBvcHRpb25zLl9vcmlnaW5hbERhdGUgd2lsbCBsaWtlbHkgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkuXG4gIC8vIFJpZ2h0IG5vdywgcGxlYXNlIGRvbid0IHVzZSBpdCBpbiBsb2NhbGVzLiBJZiB5b3UgaGF2ZSB0byB1c2UgYW4gb3JpZ2luYWwgZGF0ZSxcbiAgLy8gcGxlYXNlIHJlc3RvcmUgaXQgZnJvbSBgZGF0ZWAsIGFkZGluZyBhIHRpbWV6b25lIG9mZnNldCB0byBpdC5cbiAgZm9ybWF0dGVyT3B0aW9ucy5fb3JpZ2luYWxEYXRlID0gb3JpZ2luYWxEYXRlO1xuXG4gIHZhciByZXN1bHQgPSBmb3JtYXRTdHJcbiAgICAucmVwbGFjZShsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCwgZnVuY3Rpb24gKHN1YnN0cmluZykge1xuICAgICAgaWYgKHN1YnN0cmluZ1swXSA9PT0gJ1snKSB7XG4gICAgICAgIHJldHVybiBzdWJzdHJpbmdcbiAgICAgIH1cblxuICAgICAgaWYgKHN1YnN0cmluZ1swXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIHJldHVybiBjbGVhbkVzY2FwZWRTdHJpbmcoc3Vic3RyaW5nKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9ybWF0TG9uZyhzdWJzdHJpbmcpXG4gICAgfSlcbiAgICAucmVwbGFjZShmb3JtYXR0aW5nVG9rZW5zUmVnRXhwLCBmdW5jdGlvbiAoc3Vic3RyaW5nKSB7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gbG9jYWxlRm9ybWF0dGVyc1tzdWJzdHJpbmddIHx8IGZvcm1hdHRlcnNbc3Vic3RyaW5nXTtcblxuICAgICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyKHV0Y0RhdGUsIGZvcm1hdHRlck9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2xlYW5Fc2NhcGVkU3RyaW5nKHN1YnN0cmluZylcbiAgICAgIH1cbiAgICB9KTtcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNsZWFuRXNjYXBlZFN0cmluZyAoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XSQvZywgJycpXG4gIH1cbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpXG59XG5cbi8qKlxuICogQG5hbWUgc3ViTWludXRlc1xuICogQGNhdGVnb3J5IE1pbnV0ZSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaW51dGVzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaW51dGVzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBtaW51dGVzIHRvIGJlIHN1YnRyYWN0ZWRcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaW50dWVzIHN1YnRyYWN0ZWRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN1YnRyYWN0IDMwIG1pbnV0ZXMgZnJvbSAxMCBKdWx5IDIwMTQgMTI6MDA6MDA6XG4gKiB2YXIgcmVzdWx0ID0gc3ViTWludXRlcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDApLCAzMClcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDExOjMwOjAwXG4gKi9cbmZ1bmN0aW9uIHN1Yk1pbnV0ZXMgKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgdmFyIGFtb3VudCA9IE51bWJlcihkaXJ0eUFtb3VudCk7XG4gIHJldHVybiBhZGRNaW51dGVzKGRpcnR5RGF0ZSwgLWFtb3VudCwgZGlydHlPcHRpb25zKVxufVxuXG4vKipcbiAqIEBuYW1lIGlzQWZ0ZXJcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGZpcnN0IGRhdGUgYWZ0ZXIgdGhlIHNlY29uZCBvbmU/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZmlyc3QgZGF0ZSBhZnRlciB0aGUgc2Vjb25kIG9uZT9cbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRoYXQgc2hvdWxkIGJlIGFmdGVyIHRoZSBvdGhlciBvbmUgdG8gcmV0dXJuIHRydWVcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlVG9Db21wYXJlIC0gdGhlIGRhdGUgdG8gY29tcGFyZSB3aXRoXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZmlyc3QgZGF0ZSBpcyBhZnRlciB0aGUgc2Vjb25kIGRhdGVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElzIDEwIEp1bHkgMTk4OSBhZnRlciAxMSBGZWJydWFyeSAxOTg3P1xuICogdmFyIHJlc3VsdCA9IGlzQWZ0ZXIobmV3IERhdGUoMTk4OSwgNiwgMTApLCBuZXcgRGF0ZSgxOTg3LCAxLCAxMSkpXG4gKiAvLz0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNBZnRlciAoZGlydHlEYXRlLCBkaXJ0eURhdGVUb0NvbXBhcmUsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgZGF0ZVRvQ29tcGFyZSA9IHRvRGF0ZShkaXJ0eURhdGVUb0NvbXBhcmUsIGRpcnR5T3B0aW9ucyk7XG4gIHJldHVybiBkYXRlLmdldFRpbWUoKSA+IGRhdGVUb0NvbXBhcmUuZ2V0VGltZSgpXG59XG5cbi8qKlxuICogQG5hbWUgaXNCZWZvcmVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGZpcnN0IGRhdGUgYmVmb3JlIHRoZSBzZWNvbmQgb25lP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGZpcnN0IGRhdGUgYmVmb3JlIHRoZSBzZWNvbmQgb25lP1xuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdGhhdCBzaG91bGQgYmUgYmVmb3JlIHRoZSBvdGhlciBvbmUgdG8gcmV0dXJuIHRydWVcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlVG9Db21wYXJlIC0gdGhlIGRhdGUgdG8gY29tcGFyZSB3aXRoXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZmlyc3QgZGF0ZSBpcyBiZWZvcmUgdGhlIHNlY29uZCBkYXRlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJcyAxMCBKdWx5IDE5ODkgYmVmb3JlIDExIEZlYnJ1YXJ5IDE5ODc/XG4gKiB2YXIgcmVzdWx0ID0gaXNCZWZvcmUobmV3IERhdGUoMTk4OSwgNiwgMTApLCBuZXcgRGF0ZSgxOTg3LCAxLCAxMSkpXG4gKiAvLz0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmVmb3JlIChkaXJ0eURhdGUsIGRpcnR5RGF0ZVRvQ29tcGFyZSwgZGlydHlPcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBkYXRlVG9Db21wYXJlID0gdG9EYXRlKGRpcnR5RGF0ZVRvQ29tcGFyZSwgZGlydHlPcHRpb25zKTtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIDwgZGF0ZVRvQ29tcGFyZS5nZXRUaW1lKClcbn1cblxuLyoqXG4gKiBAbmFtZSBpc0VxdWFsXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgZXF1YWw/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBcmUgdGhlIGdpdmVuIGRhdGVzIGVxdWFsP1xuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlTGVmdCAtIHRoZSBmaXJzdCBkYXRlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlUmlnaHQgLSB0aGUgc2Vjb25kIGRhdGUgdG8gY29tcGFyZVxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XG4gKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gcGFzc2VkIHRvIGB0b0RhdGVgLiBTZWUgW3RvRGF0ZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy90b0RhdGV9XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGRhdGVzIGFyZSBlcXVhbFxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgbXVzdCBiZSAwLCAxIG9yIDJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXJlIDIgSnVseSAyMDE0IDA2OjMwOjQ1LjAwMCBhbmQgMiBKdWx5IDIwMTQgMDY6MzA6NDUuNTAwIGVxdWFsP1xuICogdmFyIHJlc3VsdCA9IGlzRXF1YWwoXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDYsIDMwLCA0NSwgMClcbiAqICAgbmV3IERhdGUoMjAxNCwgNiwgMiwgNiwgMzAsIDQ1LCA1MDApXG4gKiApXG4gKiAvLz0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwkMSAoZGlydHlMZWZ0RGF0ZSwgZGlydHlSaWdodERhdGUsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICB9XG5cbiAgdmFyIGRhdGVMZWZ0ID0gdG9EYXRlKGRpcnR5TGVmdERhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBkYXRlUmlnaHQgPSB0b0RhdGUoZGlydHlSaWdodERhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHJldHVybiBkYXRlTGVmdC5nZXRUaW1lKCkgPT09IGRhdGVSaWdodC5nZXRUaW1lKClcbn1cblxudmFyIHBhdHRlcm5zJDEgPSB7XG4gICdNJzogL14oMVswLTJdfDA/XFxkKS8sIC8vIDAgdG8gMTJcbiAgJ0QnOiAvXigzWzAtMV18WzAtMl0/XFxkKS8sIC8vIDAgdG8gMzFcbiAgJ0RERCc6IC9eKDM2WzAtNl18M1swLTVdXFxkfFswLTJdP1xcZD9cXGQpLywgLy8gMCB0byAzNjZcbiAgJ1cnOiAvXig1WzAtM118WzAtNF0/XFxkKS8sIC8vIDAgdG8gNTNcbiAgJ1lZWVknOiAvXihcXGR7MSw0fSkvLCAvLyAwIHRvIDk5OTlcbiAgJ0gnOiAvXigyWzAtM118WzAtMV0/XFxkKS8sIC8vIDAgdG8gMjNcbiAgJ20nOiAvXihbMC01XT9cXGQpLywgLy8gMCB0byA1OVxuICAnWic6IC9eKFsrLV0pKFxcZHsyfSk6KFxcZHsyfSkvLFxuICAnWlonOiAvXihbKy1dKShcXGR7Mn0pKFxcZHsyfSkvLFxuICBzaW5nbGVEaWdpdDogL14oXFxkKS8sXG4gIHR3b0RpZ2l0czogL14oXFxkezJ9KS8sXG4gIHRocmVlRGlnaXRzOiAvXihcXGR7M30pLyxcbiAgZm91ckRpZ2l0czogL14oXFxkezR9KS8sXG4gIGFueURpZ2l0czogL14oXFxkKykvXG59O1xuXG5mdW5jdGlvbiBwYXJzZURlY2ltYWwkMSAobWF0Y2hSZXN1bHQpIHtcbiAgcmV0dXJuIHBhcnNlSW50KG1hdGNoUmVzdWx0WzFdLCAxMClcbn1cblxudmFyIHBhcnNlcnMgPSB7XG4gIC8vIFllYXI6IDAwLCAwMSwgLi4uLCA5OVxuICAnWVknOiB7XG4gICAgdW5pdDogJ3R3b0RpZ2l0WWVhcicsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEudHdvRGlnaXRzLFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQpIHtcbiAgICAgIHJldHVybiBwYXJzZURlY2ltYWwkMShtYXRjaFJlc3VsdClcbiAgICB9XG4gIH0sXG5cbiAgLy8gWWVhcjogMTkwMCwgMTkwMSwgLi4uLCAyMDk5XG4gICdZWVlZJzoge1xuICAgIHVuaXQ6ICd5ZWFyJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5ZWVlZLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiAwMCwgMDEsIC4uLiwgOTlcbiAgJ0dHJzoge1xuICAgIHVuaXQ6ICdpc29ZZWFyJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS50d29EaWdpdHMsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCkge1xuICAgICAgcmV0dXJuIHBhcnNlRGVjaW1hbCQxKG1hdGNoUmVzdWx0KSArIDE5MDBcbiAgICB9XG4gIH0sXG5cbiAgLy8gSVNPIHdlZWstbnVtYmVyaW5nIHllYXI6IDE5MDAsIDE5MDEsIC4uLiwgMjA5OVxuICAnR0dHRyc6IHtcbiAgICB1bml0OiAnaXNvWWVhcicsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEuWVlZWSxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyBRdWFydGVyOiAxLCAyLCAzLCA0XG4gICdRJzoge1xuICAgIHVuaXQ6ICdxdWFydGVyJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5zaW5nbGVEaWdpdCxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyBPcmRpbmFsIHF1YXJ0ZXJcbiAgJ1FvJzoge1xuICAgIHVuaXQ6ICdxdWFydGVyJyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXJzKHN0cmluZywge3VuaXQ6ICdxdWFydGVyJ30pXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gub3JkaW5hbE51bWJlcihtYXRjaFJlc3VsdCwge3VuaXQ6ICdxdWFydGVyJ30pXG4gICAgfVxuICB9LFxuXG4gIC8vIE1vbnRoOiAxLCAyLCAuLi4sIDEyXG4gICdNJzoge1xuICAgIHVuaXQ6ICdtb250aCcsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEuTSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0KSB7XG4gICAgICByZXR1cm4gcGFyc2VEZWNpbWFsJDEobWF0Y2hSZXN1bHQpIC0gMVxuICAgIH1cbiAgfSxcblxuICAvLyBPcmRpbmFsIG1vbnRoXG4gICdNbyc6IHtcbiAgICB1bml0OiAnbW9udGgnLFxuICAgIG1hdGNoOiBmdW5jdGlvbiAoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gub3JkaW5hbE51bWJlcnMoc3RyaW5nLCB7dW5pdDogJ21vbnRoJ30pXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gub3JkaW5hbE51bWJlcihtYXRjaFJlc3VsdCwge3VuaXQ6ICdtb250aCd9KSAtIDFcbiAgICB9XG4gIH0sXG5cbiAgLy8gTW9udGg6IDAxLCAwMiwgLi4uLCAxMlxuICAnTU0nOiB7XG4gICAgdW5pdDogJ21vbnRoJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS50d29EaWdpdHMsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCkge1xuICAgICAgcmV0dXJuIHBhcnNlRGVjaW1hbCQxKG1hdGNoUmVzdWx0KSAtIDFcbiAgICB9XG4gIH0sXG5cbiAgLy8gTW9udGg6IEphbiwgRmViLCAuLi4sIERlY1xuICAnTU1NJzoge1xuICAgIHVuaXQ6ICdtb250aCcsXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIChzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC5tb250aHMoc3RyaW5nLCB7dHlwZTogJ3Nob3J0J30pXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gubW9udGgobWF0Y2hSZXN1bHQsIHt0eXBlOiAnc2hvcnQnfSlcbiAgICB9XG4gIH0sXG5cbiAgLy8gTW9udGg6IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXG4gICdNTU1NJzoge1xuICAgIHVuaXQ6ICdtb250aCcsXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIChzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC5tb250aHMoc3RyaW5nLCB7dHlwZTogJ2xvbmcnfSkgfHxcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUubWF0Y2gubW9udGhzKHN0cmluZywge3R5cGU6ICdzaG9ydCd9KVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gubW9udGgobWF0Y2hSZXN1bHQsIHt0eXBlOiAnbG9uZyd9KTtcblxuICAgICAgaWYgKHBhcnNlUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgcGFyc2VSZXN1bHQgPSBvcHRpb25zLmxvY2FsZS5tYXRjaC5tb250aChtYXRjaFJlc3VsdCwge3R5cGU6ICdzaG9ydCd9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0XG4gICAgfVxuICB9LFxuXG4gIC8vIElTTyB3ZWVrOiAxLCAyLCAuLi4sIDUzXG4gICdXJzoge1xuICAgIHVuaXQ6ICdpc29XZWVrJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5XLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIE9yZGluYWwgSVNPIHdlZWtcbiAgJ1dvJzoge1xuICAgIHVuaXQ6ICdpc29XZWVrJyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXJzKHN0cmluZywge3VuaXQ6ICdpc29XZWVrJ30pXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gub3JkaW5hbE51bWJlcihtYXRjaFJlc3VsdCwge3VuaXQ6ICdpc29XZWVrJ30pXG4gICAgfVxuICB9LFxuXG4gIC8vIElTTyB3ZWVrOiAwMSwgMDIsIC4uLiwgNTNcbiAgJ1dXJzoge1xuICAgIHVuaXQ6ICdpc29XZWVrJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS50d29EaWdpdHMsXG4gICAgcGFyc2U6IHBhcnNlRGVjaW1hbCQxXG4gIH0sXG5cbiAgLy8gRGF5IG9mIHdlZWs6IDAsIDEsIC4uLiwgNlxuICAnZCc6IHtcbiAgICB1bml0OiAnZGF5T2ZXZWVrJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5zaW5nbGVEaWdpdCxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyBPcmRpbmFsIGRheSBvZiB3ZWVrXG4gICdkbyc6IHtcbiAgICB1bml0OiAnZGF5T2ZXZWVrJyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXJzKHN0cmluZywge3VuaXQ6ICdkYXlPZldlZWsnfSlcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC5vcmRpbmFsTnVtYmVyKG1hdGNoUmVzdWx0LCB7dW5pdDogJ2RheU9mV2Vlayd9KVxuICAgIH1cbiAgfSxcblxuICAvLyBEYXkgb2Ygd2VlazogU3UsIE1vLCAuLi4sIFNhXG4gICdkZCc6IHtcbiAgICB1bml0OiAnZGF5T2ZXZWVrJyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLndlZWtkYXlzKHN0cmluZywge3R5cGU6ICduYXJyb3cnfSlcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ25hcnJvdyd9KVxuICAgIH1cbiAgfSxcblxuICAvLyBEYXkgb2Ygd2VlazogU3VuLCBNb24sIC4uLiwgU2F0XG4gICdkZGQnOiB7XG4gICAgdW5pdDogJ2RheU9mV2VlaycsXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIChzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5cyhzdHJpbmcsIHt0eXBlOiAnc2hvcnQnfSkgfHxcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUubWF0Y2gud2Vla2RheXMoc3RyaW5nLCB7dHlwZTogJ25hcnJvdyd9KVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gud2Vla2RheShtYXRjaFJlc3VsdCwge3R5cGU6ICdzaG9ydCd9KTtcblxuICAgICAgaWYgKHBhcnNlUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgcGFyc2VSZXN1bHQgPSBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ25hcnJvdyd9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0XG4gICAgfVxuICB9LFxuXG4gIC8vIERheSBvZiB3ZWVrOiBTdW5kYXksIE1vbmRheSwgLi4uLCBTYXR1cmRheVxuICAnZGRkZCc6IHtcbiAgICB1bml0OiAnZGF5T2ZXZWVrJyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLndlZWtkYXlzKHN0cmluZywge3R5cGU6ICdsb25nJ30pIHx8XG4gICAgICAgIG9wdGlvbnMubG9jYWxlLm1hdGNoLndlZWtkYXlzKHN0cmluZywge3R5cGU6ICdzaG9ydCd9KSB8fFxuICAgICAgICBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5cyhzdHJpbmcsIHt0eXBlOiAnbmFycm93J30pXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgcGFyc2VSZXN1bHQgPSBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ2xvbmcnfSk7XG5cbiAgICAgIGlmIChwYXJzZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gud2Vla2RheShtYXRjaFJlc3VsdCwge3R5cGU6ICdzaG9ydCd9KTtcblxuICAgICAgICBpZiAocGFyc2VSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gud2Vla2RheShtYXRjaFJlc3VsdCwge3R5cGU6ICduYXJyb3cnfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0XG4gICAgfVxuICB9LFxuXG4gIC8vIERheSBvZiBJU08gd2VlazogMSwgMiwgLi4uLCA3XG4gICdFJzoge1xuICAgIHVuaXQ6ICdkYXlPZklTT1dlZWsnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnNpbmdsZURpZ2l0LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQpIHtcbiAgICAgIHJldHVybiBwYXJzZURlY2ltYWwkMShtYXRjaFJlc3VsdClcbiAgICB9XG4gIH0sXG5cbiAgLy8gRGF5IG9mIG1vbnRoOiAxLCAyLCAuLi4sIDMxXG4gICdEJzoge1xuICAgIHVuaXQ6ICdkYXlPZk1vbnRoJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5ELFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIE9yZGluYWwgZGF5IG9mIG1vbnRoXG4gICdEbyc6IHtcbiAgICB1bml0OiAnZGF5T2ZNb250aCcsXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIChzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC5vcmRpbmFsTnVtYmVycyhzdHJpbmcsIHt1bml0OiAnZGF5T2ZNb250aCd9KVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXIobWF0Y2hSZXN1bHQsIHt1bml0OiAnZGF5T2ZNb250aCd9KVxuICAgIH1cbiAgfSxcblxuICAvLyBEYXkgb2YgbW9udGg6IDAxLCAwMiwgLi4uLCAzMVxuICAnREQnOiB7XG4gICAgdW5pdDogJ2RheU9mTW9udGgnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnR3b0RpZ2l0cyxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyBEYXkgb2YgeWVhcjogMSwgMiwgLi4uLCAzNjZcbiAgJ0RERCc6IHtcbiAgICB1bml0OiAnZGF5T2ZZZWFyJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5EREQsXG4gICAgcGFyc2U6IHBhcnNlRGVjaW1hbCQxXG4gIH0sXG5cbiAgLy8gT3JkaW5hbCBkYXkgb2YgeWVhclxuICAnREREbyc6IHtcbiAgICB1bml0OiAnZGF5T2ZZZWFyJyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXJzKHN0cmluZywge3VuaXQ6ICdkYXlPZlllYXInfSlcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC5vcmRpbmFsTnVtYmVyKG1hdGNoUmVzdWx0LCB7dW5pdDogJ2RheU9mWWVhcid9KVxuICAgIH1cbiAgfSxcblxuICAvLyBEYXkgb2YgeWVhcjogMDAxLCAwMDIsIC4uLiwgMzY2XG4gICdEREREJzoge1xuICAgIHVuaXQ6ICdkYXlPZlllYXInLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnRocmVlRGlnaXRzLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIEFNLCBQTVxuICAnQSc6IHtcbiAgICB1bml0OiAndGltZU9mRGF5JyxcbiAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLnRpbWVzT2ZEYXkoc3RyaW5nLCB7dHlwZTogJ3Nob3J0J30pXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gudGltZU9mRGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ3Nob3J0J30pXG4gICAgfVxuICB9LFxuXG4gIC8vIGEubS4sIHAubS5cbiAgJ2FhJzoge1xuICAgIHVuaXQ6ICd0aW1lT2ZEYXknLFxuICAgIG1hdGNoOiBmdW5jdGlvbiAoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gudGltZXNPZkRheShzdHJpbmcsIHt0eXBlOiAnbG9uZyd9KSB8fFxuICAgICAgICBvcHRpb25zLmxvY2FsZS5tYXRjaC50aW1lc09mRGF5KHN0cmluZywge3R5cGU6ICdzaG9ydCd9KVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gudGltZU9mRGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ2xvbmcnfSk7XG5cbiAgICAgIGlmIChwYXJzZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gudGltZU9mRGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ3Nob3J0J30pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHRcbiAgICB9XG4gIH0sXG5cbiAgLy8gSG91cjogMCwgMSwgLi4uIDIzXG4gICdIJzoge1xuICAgIHVuaXQ6ICdob3VycycsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEuSCxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyBIb3VyOiAwMCwgMDEsIC4uLiwgMjNcbiAgJ0hIJzoge1xuICAgIHVuaXQ6ICdob3VycycsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEudHdvRGlnaXRzLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIEhvdXI6IDEsIDIsIC4uLiwgMTJcbiAgJ2gnOiB7XG4gICAgdW5pdDogJ3RpbWVPZkRheUhvdXJzJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5NLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIEhvdXI6IDAxLCAwMiwgLi4uLCAxMlxuICAnaGgnOiB7XG4gICAgdW5pdDogJ3RpbWVPZkRheUhvdXJzJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS50d29EaWdpdHMsXG4gICAgcGFyc2U6IHBhcnNlRGVjaW1hbCQxXG4gIH0sXG5cbiAgLy8gTWludXRlOiAwLCAxLCAuLi4sIDU5XG4gICdtJzoge1xuICAgIHVuaXQ6ICdtaW51dGVzJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5tLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIE1pbnV0ZTogMDAsIDAxLCAuLi4sIDU5XG4gICdtbSc6IHtcbiAgICB1bml0OiAnbWludXRlcycsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEudHdvRGlnaXRzLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIFNlY29uZDogMCwgMSwgLi4uLCA1OVxuICAncyc6IHtcbiAgICB1bml0OiAnc2Vjb25kcycsXG4gICAgbWF0Y2g6IHBhdHRlcm5zJDEubSxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyBTZWNvbmQ6IDAwLCAwMSwgLi4uLCA1OVxuICAnc3MnOiB7XG4gICAgdW5pdDogJ3NlY29uZHMnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnR3b0RpZ2l0cyxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfSxcblxuICAvLyAxLzEwIG9mIHNlY29uZDogMCwgMSwgLi4uLCA5XG4gICdTJzoge1xuICAgIHVuaXQ6ICdtaWxsaXNlY29uZHMnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnNpbmdsZURpZ2l0LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQpIHtcbiAgICAgIHJldHVybiBwYXJzZURlY2ltYWwkMShtYXRjaFJlc3VsdCkgKiAxMDBcbiAgICB9XG4gIH0sXG5cbiAgLy8gMS8xMDAgb2Ygc2Vjb25kOiAwMCwgMDEsIC4uLiwgOTlcbiAgJ1NTJzoge1xuICAgIHVuaXQ6ICdtaWxsaXNlY29uZHMnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnR3b0RpZ2l0cyxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0KSB7XG4gICAgICByZXR1cm4gcGFyc2VEZWNpbWFsJDEobWF0Y2hSZXN1bHQpICogMTBcbiAgICB9XG4gIH0sXG5cbiAgLy8gTWlsbGlzZWNvbmQ6IDAwMCwgMDAxLCAuLi4sIDk5OVxuICAnU1NTJzoge1xuICAgIHVuaXQ6ICdtaWxsaXNlY29uZHMnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLnRocmVlRGlnaXRzLFxuICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICB9LFxuXG4gIC8vIFRpbWV6b25lOiAtMDE6MDAsICswMDowMCwgLi4uICsxMjowMFxuICAnWic6IHtcbiAgICB1bml0OiAndGltZXpvbmUnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLlosXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCkge1xuICAgICAgdmFyIHNpZ24gPSBtYXRjaFJlc3VsdFsxXTtcbiAgICAgIHZhciBob3VycyA9IHBhcnNlSW50KG1hdGNoUmVzdWx0WzJdLCAxMCk7XG4gICAgICB2YXIgbWludXRlcyA9IHBhcnNlSW50KG1hdGNoUmVzdWx0WzNdLCAxMCk7XG4gICAgICB2YXIgYWJzb2x1dGVPZmZzZXQgPSBob3VycyAqIDYwICsgbWludXRlcztcbiAgICAgIHJldHVybiAoc2lnbiA9PT0gJysnKSA/IGFic29sdXRlT2Zmc2V0IDogLWFic29sdXRlT2Zmc2V0XG4gICAgfVxuICB9LFxuXG4gIC8vIFRpbWV6b25lOiAtMDEwMCwgKzAwMDAsIC4uLiArMTIwMFxuICAnWlonOiB7XG4gICAgdW5pdDogJ3RpbWV6b25lJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5aWixcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0KSB7XG4gICAgICB2YXIgc2lnbiA9IG1hdGNoUmVzdWx0WzFdO1xuICAgICAgdmFyIGhvdXJzID0gcGFyc2VJbnQobWF0Y2hSZXN1bHRbMl0sIDEwKTtcbiAgICAgIHZhciBtaW51dGVzID0gcGFyc2VJbnQobWF0Y2hSZXN1bHRbM10sIDEwKTtcbiAgICAgIHZhciBhYnNvbHV0ZU9mZnNldCA9IGhvdXJzICogNjAgKyBtaW51dGVzO1xuICAgICAgcmV0dXJuIChzaWduID09PSAnKycpID8gYWJzb2x1dGVPZmZzZXQgOiAtYWJzb2x1dGVPZmZzZXRcbiAgICB9XG4gIH0sXG5cbiAgLy8gU2Vjb25kcyB0aW1lc3RhbXA6IDUxMjk2OTUyMFxuICAnWCc6IHtcbiAgICB1bml0OiAndGltZXN0YW1wJyxcbiAgICBtYXRjaDogcGF0dGVybnMkMS5hbnlEaWdpdHMsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCkge1xuICAgICAgcmV0dXJuIHBhcnNlRGVjaW1hbCQxKG1hdGNoUmVzdWx0KSAqIDEwMDBcbiAgICB9XG4gIH0sXG5cbiAgLy8gTWlsbGlzZWNvbmRzIHRpbWVzdGFtcDogNTEyOTY5NTIwOTAwXG4gICd4Jzoge1xuICAgIHVuaXQ6ICd0aW1lc3RhbXAnLFxuICAgIG1hdGNoOiBwYXR0ZXJucyQxLmFueURpZ2l0cyxcbiAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgfVxufTtcblxucGFyc2Vyc1snYSddID0gcGFyc2Vyc1snQSddO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcbmZ1bmN0aW9uIHNldFVUQ0RheSAoZGlydHlEYXRlLCBkaXJ0eURheSwgZGlydHlPcHRpb25zKSB7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUgJiYgbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMud2Vla1N0YXJ0c09uO1xuICB2YXIgZGVmYXVsdFdlZWtTdGFydHNPbiA9IGxvY2FsZVdlZWtTdGFydHNPbiA9PT0gdW5kZWZpbmVkID8gMCA6IE51bWJlcihsb2NhbGVXZWVrU3RhcnRzT24pO1xuICB2YXIgd2Vla1N0YXJ0c09uID0gb3B0aW9ucy53ZWVrU3RhcnRzT24gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRXZWVrU3RhcnRzT24gOiBOdW1iZXIob3B0aW9ucy53ZWVrU3RhcnRzT24pO1xuXG4gIC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMCBhbmQgNiBfYW5kXyBpcyBub3QgTmFOXG4gIGlmICghKHdlZWtTdGFydHNPbiA+PSAwICYmIHdlZWtTdGFydHNPbiA8PSA2KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3ZWVrU3RhcnRzT24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYgaW5jbHVzaXZlbHknKVxuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgZGF5ID0gTnVtYmVyKGRpcnR5RGF5KTtcblxuICB2YXIgY3VycmVudERheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG5cbiAgdmFyIHJlbWFpbmRlciA9IGRheSAlIDc7XG4gIHZhciBkYXlJbmRleCA9IChyZW1haW5kZXIgKyA3KSAlIDc7XG5cbiAgdmFyIGRpZmYgPSAoZGF5SW5kZXggPCB3ZWVrU3RhcnRzT24gPyA3IDogMCkgKyBkYXkgLSBjdXJyZW50RGF5O1xuXG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpO1xuICByZXR1cm4gZGF0ZVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcbmZ1bmN0aW9uIHNldFVUQ0lTT0RheSAoZGlydHlEYXRlLCBkaXJ0eURheSwgZGlydHlPcHRpb25zKSB7XG4gIHZhciBkYXkgPSBOdW1iZXIoZGlydHlEYXkpO1xuXG4gIGlmIChkYXkgJSA3ID09PSAwKSB7XG4gICAgZGF5ID0gZGF5IC0gNztcbiAgfVxuXG4gIHZhciB3ZWVrU3RhcnRzT24gPSAxO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBjdXJyZW50RGF5ID0gZGF0ZS5nZXRVVENEYXkoKTtcblxuICB2YXIgcmVtYWluZGVyID0gZGF5ICUgNztcbiAgdmFyIGRheUluZGV4ID0gKHJlbWFpbmRlciArIDcpICUgNztcblxuICB2YXIgZGlmZiA9IChkYXlJbmRleCA8IHdlZWtTdGFydHNPbiA/IDcgOiAwKSArIGRheSAtIGN1cnJlbnREYXk7XG5cbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlmZik7XG4gIHJldHVybiBkYXRlXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuZnVuY3Rpb24gc2V0VVRDSVNPV2VlayAoZGlydHlEYXRlLCBkaXJ0eUlTT1dlZWssIGRpcnR5T3B0aW9ucykge1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBpc29XZWVrID0gTnVtYmVyKGRpcnR5SVNPV2Vlayk7XG4gIHZhciBkaWZmID0gZ2V0VVRDSVNPV2VlayhkYXRlLCBkaXJ0eU9wdGlvbnMpIC0gaXNvV2VlaztcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gZGlmZiAqIDcpO1xuICByZXR1cm4gZGF0ZVxufVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX0RBWSQzID0gODY0MDAwMDA7XG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuZnVuY3Rpb24gc2V0VVRDSVNPV2Vla1llYXIgKGRpcnR5RGF0ZSwgZGlydHlJU09ZZWFyLCBkaXJ0eU9wdGlvbnMpIHtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgaXNvWWVhciA9IE51bWJlcihkaXJ0eUlTT1llYXIpO1xuICB2YXIgZGF0ZVN0YXJ0T2ZZZWFyID0gc3RhcnRPZlVUQ0lTT1dlZWtZZWFyKGRhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBkaWZmID0gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSBkYXRlU3RhcnRPZlllYXIuZ2V0VGltZSgpKSAvIE1JTExJU0VDT05EU19JTl9EQVkkMyk7XG4gIHZhciBmb3VydGhPZkphbnVhcnkgPSBuZXcgRGF0ZSgwKTtcbiAgZm91cnRoT2ZKYW51YXJ5LnNldFVUQ0Z1bGxZZWFyKGlzb1llYXIsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnkuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIGRhdGUgPSBzdGFydE9mVVRDSVNPV2Vla1llYXIoZm91cnRoT2ZKYW51YXJ5LCBkaXJ0eU9wdGlvbnMpO1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaWZmKTtcbiAgcmV0dXJuIGRhdGVcbn1cblxudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUkNiA9IDYwMDAwO1xuXG5mdW5jdGlvbiBzZXRUaW1lT2ZEYXkgKGhvdXJzLCB0aW1lT2ZEYXkpIHtcbiAgdmFyIGlzQU0gPSB0aW1lT2ZEYXkgPT09IDA7XG5cbiAgaWYgKGlzQU0pIHtcbiAgICBpZiAoaG91cnMgPT09IDEyKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaG91cnMgIT09IDEyKSB7XG4gICAgICByZXR1cm4gMTIgKyBob3Vyc1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBob3Vyc1xufVxuXG52YXIgdW5pdHMgPSB7XG4gIHR3b0RpZ2l0WWVhcjoge1xuICAgIHByaW9yaXR5OiAxMCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSkge1xuICAgICAgdmFyIGNlbnR1cnkgPSBNYXRoLmZsb29yKGRhdGVWYWx1ZXMuZGF0ZS5nZXRVVENGdWxsWWVhcigpIC8gMTAwKTtcbiAgICAgIHZhciB5ZWFyID0gY2VudHVyeSAqIDEwMCArIHZhbHVlO1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIDEpO1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgeWVhcjoge1xuICAgIHByaW9yaXR5OiAxMCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSkge1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0Z1bGxZZWFyKHZhbHVlLCAwLCAxKTtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgfVxuICB9LFxuXG4gIGlzb1llYXI6IHtcbiAgICBwcmlvcml0eTogMTAsXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZSA9IHN0YXJ0T2ZVVENJU09XZWVrWWVhcihzZXRVVENJU09XZWVrWWVhcihkYXRlVmFsdWVzLmRhdGUsIHZhbHVlLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgIH1cbiAgfSxcblxuICBxdWFydGVyOiB7XG4gICAgcHJpb3JpdHk6IDIwLFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGVWYWx1ZXMsIHZhbHVlKSB7XG4gICAgICBkYXRlVmFsdWVzLmRhdGUuc2V0VVRDTW9udGgoKHZhbHVlIC0gMSkgKiAzLCAxKTtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgfVxuICB9LFxuXG4gIG1vbnRoOiB7XG4gICAgcHJpb3JpdHk6IDMwLFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGVWYWx1ZXMsIHZhbHVlKSB7XG4gICAgICBkYXRlVmFsdWVzLmRhdGUuc2V0VVRDTW9udGgodmFsdWUsIDEpO1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgaXNvV2Vlazoge1xuICAgIHByaW9yaXR5OiA0MCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlID0gc3RhcnRPZlVUQ0lTT1dlZWsoc2V0VVRDSVNPV2VlayhkYXRlVmFsdWVzLmRhdGUsIHZhbHVlLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgIH1cbiAgfSxcblxuICBkYXlPZldlZWs6IHtcbiAgICBwcmlvcml0eTogNTAsXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZSA9IHNldFVUQ0RheShkYXRlVmFsdWVzLmRhdGUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgfVxuICB9LFxuXG4gIGRheU9mSVNPV2Vlazoge1xuICAgIHByaW9yaXR5OiA1MCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlID0gc2V0VVRDSVNPRGF5KGRhdGVWYWx1ZXMuZGF0ZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgZGF5T2ZNb250aDoge1xuICAgIHByaW9yaXR5OiA1MCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSkge1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0RhdGUodmFsdWUpO1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgZGF5T2ZZZWFyOiB7XG4gICAgcHJpb3JpdHk6IDUwLFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGVWYWx1ZXMsIHZhbHVlKSB7XG4gICAgICBkYXRlVmFsdWVzLmRhdGUuc2V0VVRDTW9udGgoMCwgdmFsdWUpO1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgdGltZU9mRGF5OiB7XG4gICAgcHJpb3JpdHk6IDYwLFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGVWYWx1ZXMsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBkYXRlVmFsdWVzLnRpbWVPZkRheSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgaG91cnM6IHtcbiAgICBwcmlvcml0eTogNzAsXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENIb3Vycyh2YWx1ZSwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgIH1cbiAgfSxcblxuICB0aW1lT2ZEYXlIb3Vyczoge1xuICAgIHByaW9yaXR5OiA3MCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHRpbWVPZkRheSA9IGRhdGVWYWx1ZXMudGltZU9mRGF5O1xuICAgICAgaWYgKHRpbWVPZkRheSAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gc2V0VGltZU9mRGF5KHZhbHVlLCB0aW1lT2ZEYXkpO1xuICAgICAgfVxuICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKHZhbHVlLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgfVxuICB9LFxuXG4gIG1pbnV0ZXM6IHtcbiAgICBwcmlvcml0eTogODAsXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUpIHtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENNaW51dGVzKHZhbHVlLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgfVxuICB9LFxuXG4gIHNlY29uZHM6IHtcbiAgICBwcmlvcml0eTogOTAsXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUpIHtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENTZWNvbmRzKHZhbHVlLCAwKTtcbiAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgfVxuICB9LFxuXG4gIG1pbGxpc2Vjb25kczoge1xuICAgIHByaW9yaXR5OiAxMDAsXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUpIHtcbiAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENNaWxsaXNlY29uZHModmFsdWUpO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgdGltZXpvbmU6IHtcbiAgICBwcmlvcml0eTogMTEwLFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGVWYWx1ZXMsIHZhbHVlKSB7XG4gICAgICBkYXRlVmFsdWVzLmRhdGUgPSBuZXcgRGF0ZShkYXRlVmFsdWVzLmRhdGUuZ2V0VGltZSgpIC0gdmFsdWUgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFJDYpO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH0sXG5cbiAgdGltZXN0YW1wOiB7XG4gICAgcHJpb3JpdHk6IDEyMCxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSkge1xuICAgICAgZGF0ZVZhbHVlcy5kYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICB9XG4gIH1cbn07XG5cbnZhciBUSU1FWk9ORV9VTklUX1BSSU9SSVRZID0gMTEwO1xudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUkNyA9IDYwMDAwO1xuXG52YXIgbG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAkMSA9IC8oXFxbW15bXSpdKXwoXFxcXCk/KExUU3xMVHxMTExMfExMTHxMTHxMfGxsbGx8bGxsfGxsfGwpL2c7XG52YXIgZGVmYXVsdFBhcnNpbmdUb2tlbnNSZWdFeHAgPSAvKFxcW1teW10qXSl8KFxcXFwpPyh4fHNzfHN8bW18bXxoaHxofGRvfGRkZGR8ZGRkfGRkfGR8YWF8YXxaWnxafFlZWVl8WVl8WHxXb3xXV3xXfFNTU3xTU3xTfFFvfFF8TW98TU1NTXxNTU18TU18TXxISHxIfEdHR0d8R0d8RXxEb3xERERvfERERER8REREfEREfER8QXwuKS9nO1xuXG4vKipcbiAqIEBuYW1lIHBhcnNlXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFBhcnNlIHRoZSBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBkYXRlIHBhcnNlZCBmcm9tIHN0cmluZyB1c2luZyB0aGUgZ2l2ZW4gZm9ybWF0LlxuICpcbiAqIEFjY2VwdGVkIGZvcm1hdCB0b2tlbnM6XG4gKiB8IFVuaXQgICAgICAgICAgICAgICAgICAgIHwgUHJpb3JpdHkgfCBUb2tlbiB8IElucHV0IGV4YW1wbGVzICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS18LS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCBZZWFyICAgICAgICAgICAgICAgICAgICB8IDEwICAgICAgIHwgWVkgICAgfCAwMCwgMDEsIC4uLiwgOTkgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBZWVlZICB8IDE5MDAsIDE5MDEsIC4uLiwgMjA5OSAgICAgICAgICAgIHxcbiAqIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgfCAxMCAgICAgICB8IEdHICAgIHwgMDAsIDAxLCAuLi4sIDk5ICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgR0dHRyAgfCAxOTAwLCAxOTAxLCAuLi4sIDIwOTkgICAgICAgICAgICB8XG4gKiB8IFF1YXJ0ZXIgICAgICAgICAgICAgICAgIHwgMjAgICAgICAgfCBRICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IFFvICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgfFxuICogfCBNb250aCAgICAgICAgICAgICAgICAgICB8IDMwICAgICAgIHwgTSAgICAgfCAxLCAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBNbyAgICB8IDFzdCwgMm5kLCAuLi4sIDEydGggICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IE1NICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgTU1NICAgfCBKYW4sIEZlYiwgLi4uLCBEZWMgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBNTU1NICB8IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyIHxcbiAqIHwgSVNPIHdlZWsgICAgICAgICAgICAgICAgfCA0MCAgICAgICB8IFcgICAgIHwgMSwgMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgV28gICAgfCAxc3QsIDJuZCwgLi4uLCA1M3JkICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBXVyAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIHdlZWsgICAgICAgICAgICAgfCA1MCAgICAgICB8IGQgICAgIHwgMCwgMSwgLi4uLCA2ICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgZG8gICAgfCAwdGgsIDFzdCwgLi4uLCA2dGggICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBkZCAgICB8IFN1LCBNbywgLi4uLCBTYSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IGRkZCAgIHwgU3VuLCBNb24sIC4uLiwgU2F0ICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgZGRkZCAgfCBTdW5kYXksIE1vbmRheSwgLi4uLCBTYXR1cmRheSAgICB8XG4gKiB8IERheSBvZiBJU08gd2VlayAgICAgICAgIHwgNTAgICAgICAgfCBFICAgICB8IDEsIDIsIC4uLiwgNyAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgfCA1MCAgICAgICB8IEQgICAgIHwgMSwgMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgRG8gICAgfCAxc3QsIDJuZCwgLi4uLCAzMXN0ICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBERCAgICB8IDAxLCAwMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgfCA1MCAgICAgICB8IERERCAgIHwgMSwgMiwgLi4uLCAzNjYgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgREREbyAgfCAxc3QsIDJuZCwgLi4uLCAzNjZ0aCAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBEREREICB8IDAwMSwgMDAyLCAuLi4sIDM2NiAgICAgICAgICAgICAgIHxcbiAqIHwgVGltZSBvZiBkYXkgICAgICAgICAgICAgfCA2MCAgICAgICB8IEEgICAgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgYSAgICAgfCBhbSwgcG0gICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBhYSAgICB8IGEubS4sIHAubS4gICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgSG91ciAgICAgICAgICAgICAgICAgICAgfCA3MCAgICAgICB8IEggICAgIHwgMCwgMSwgLi4uIDIzICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgSEggICAgfCAwMCwgMDEsIC4uLiAyMyAgICAgICAgICAgICAgICAgICB8XG4gKiB8IFRpbWUgb2YgZGF5IGhvdXIgICAgICAgIHwgNzAgICAgICAgfCBoICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IGhoICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgfFxuICogfCBNaW51dGUgICAgICAgICAgICAgICAgICB8IDgwICAgICAgIHwgbSAgICAgfCAwLCAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBtbSAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgfCA5MCAgICAgICB8IHMgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgc3MgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICB8XG4gKiB8IDEvMTAgb2Ygc2Vjb25kICAgICAgICAgIHwgMTAwICAgICAgfCBTICAgICB8IDAsIDEsIC4uLiwgOSAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMS8xMDAgb2Ygc2Vjb25kICAgICAgICAgfCAxMDAgICAgICB8IFNTICAgIHwgMDAsIDAxLCAuLi4sIDk5ICAgICAgICAgICAgICAgICAgfFxuICogfCBNaWxsaXNlY29uZCAgICAgICAgICAgICB8IDEwMCAgICAgIHwgU1NTICAgfCAwMDAsIDAwMSwgLi4uLCA5OTkgICAgICAgICAgICAgICB8XG4gKiB8IFRpbWV6b25lICAgICAgICAgICAgICAgIHwgMTEwICAgICAgfCBaICAgICB8IC0wMTowMCwgKzAwOjAwLCAuLi4gKzEyOjAwICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IFpaICAgIHwgLTAxMDAsICswMDAwLCAuLi4sICsxMjAwICAgICAgICAgfFxuICogfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICB8IDEyMCAgICAgIHwgWCAgICAgfCA1MTI5Njk1MjAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IE1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgIHwgMTIwICAgICAgfCB4ICAgICB8IDUxMjk2OTUyMDkwMCAgICAgICAgICAgICAgICAgICAgIHxcbiAqXG4gKiBWYWx1ZXMgd2lsbCBiZSBhc3NpZ25lZCB0byB0aGUgZGF0ZSBpbiB0aGUgYXNjZW5kaW5nIG9yZGVyIG9mIGl0cyB1bml0J3MgcHJpb3JpdHkuXG4gKiBVbml0cyBvZiBhbiBlcXVhbCBwcmlvcml0eSBvdmVyd3JpdGUgZWFjaCBvdGhlciBpbiB0aGUgb3JkZXIgb2YgYXBwZWFyYW5jZS5cbiAqXG4gKiBJZiBubyB2YWx1ZXMgb2YgaGlnaGVyIHByaW9yaXR5IGFyZSBwYXJzZWQgKGUuZy4gd2hlbiBwYXJzaW5nIHN0cmluZyAnSmFudWFyeSAxc3QnIHdpdGhvdXQgYSB5ZWFyKSxcbiAqIHRoZSB2YWx1ZXMgd2lsbCBiZSB0YWtlbiBmcm9tIDNyZCBhcmd1bWVudCBgYmFzZURhdGVgIHdoaWNoIHdvcmtzIGFzIGEgY29udGV4dCBvZiBwYXJzaW5nLlxuICpcbiAqIGBiYXNlRGF0ZWAgbXVzdCBiZSBwYXNzZWQgZm9yIGNvcnJlY3Qgd29yayBvZiB0aGUgZnVuY3Rpb24uXG4gKiBJZiB5b3UncmUgbm90IHN1cmUgd2hpY2ggYGJhc2VEYXRlYCB0byBzdXBwbHksIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBEYXRlOlxuICogYHBhcnNlKCcwMi8xMS8yMDE0JywgJ01NL0REL1lZWVknLCBuZXcgRGF0ZSgpKWBcbiAqIEluIHRoaXMgY2FzZSBwYXJzaW5nIHdpbGwgYmUgZG9uZSBpbiB0aGUgY29udGV4dCBvZiB0aGUgY3VycmVudCBkYXRlLlxuICogSWYgYGJhc2VEYXRlYCBpcyBgSW52YWxpZCBEYXRlYCBvciBhIHZhbHVlIG5vdCBjb252ZXJ0aWJsZSB0byB2YWxpZCBgRGF0ZWAsXG4gKiB0aGVuIGBJbnZhbGlkIERhdGVgIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQWxzbywgYHBhcnNlYCB1bmZvbGRzIGxvbmcgZm9ybWF0cyBsaWtlIHRob3NlIGluIFtmb3JtYXRde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvZm9ybWF0fTpcbiAqIHwgVG9rZW4gfCBJbnB1dCBleGFtcGxlcyAgICAgICAgICAgICAgICAgfFxuICogfC0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IExUICAgIHwgMDU6MzAgYS5tLiAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTFRTICAgfCAwNTozMDoxNSBhLm0uICAgICAgICAgICAgICAgICAgfFxuICogfCBMICAgICB8IDA3LzAyLzE5OTUgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IGwgICAgIHwgNy8yLzE5OTUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTEwgICAgfCBKdWx5IDIgMTk5NSAgICAgICAgICAgICAgICAgICAgfFxuICogfCBsbCAgICB8IEp1bCAyIDE5OTUgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IExMTCAgIHwgSnVseSAyIDE5OTUgMDU6MzAgYS5tLiAgICAgICAgIHxcbiAqIHwgbGxsICAgfCBKdWwgMiAxOTk1IDA1OjMwIGEubS4gICAgICAgICAgfFxuICogfCBMTExMICB8IFN1bmRheSwgSnVseSAyIDE5OTUgMDU6MzAgYS5tLiB8XG4gKiB8IGxsbGwgIHwgU3VuLCBKdWwgMiAxOTk1IDA1OjMwIGEubS4gICAgIHxcbiAqXG4gKiBUaGUgY2hhcmFjdGVycyB3cmFwcGVkIGluIHNxdWFyZSBicmFja2V0cyBpbiB0aGUgZm9ybWF0IHN0cmluZyBhcmUgZXNjYXBlZC5cbiAqXG4gKiBUaGUgcmVzdWx0IG1heSB2YXJ5IGJ5IGxvY2FsZS5cbiAqXG4gKiBJZiBgZm9ybWF0U3RyaW5nYCBtYXRjaGVzIHdpdGggYGRhdGVTdHJpbmdgIGJ1dCBkb2VzIG5vdCBwcm92aWRlcyB0b2tlbnMsIGBiYXNlRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBJZiBwYXJzaW5nIGZhaWxlZCwgYEludmFsaWQgRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEludmFsaWQgRGF0ZSBpcyBhIERhdGUsIHdob3NlIHRpbWUgdmFsdWUgaXMgTmFOLlxuICogVGltZSB2YWx1ZSBvZiBEYXRlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjkuMS4xXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGVTdHJpbmcgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0U3RyaW5nIC0gdGhlIHN0cmluZyBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBiYXNlRGF0ZSAtIHRoZSBkYXRlIHRvIHRvb2sgdGhlIG1pc3NpbmcgaGlnaGVyIHByaW9yaXR5IHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cbiAqIEBwYXJhbSB7TG9jYWxlfSBbb3B0aW9ucy5sb2NhbGU9ZGVmYXVsdExvY2FsZV0gLSB0aGUgbG9jYWxlIG9iamVjdC4gU2VlIFtMb2NhbGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvTG9jYWxlfVxuICogQHBhcmFtIHswfDF8MnwzfDR8NXw2fSBbb3B0aW9ucy53ZWVrU3RhcnRzT249MF0gLSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMCAtIFN1bmRheSlcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgcGFyc2VkIGRhdGVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMyBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy53ZWVrU3RhcnRzT25gIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgbWF0Y2hgIHByb3BlcnR5XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgZm9ybWF0TG9uZ2AgcHJvcGVydHlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUGFyc2UgMTEgRmVicnVhcnkgMjAxNCBmcm9tIG1pZGRsZS1lbmRpYW4gZm9ybWF0OlxuICogdmFyIHJlc3VsdCA9IHBhcnNlKFxuICogICAnMDIvMTEvMjAxNCcsXG4gKiAgICdNTS9ERC9ZWVlZJyxcbiAqICAgbmV3IERhdGUoKVxuICogKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMDA6MDA6MDBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUGFyc2UgMjh0aCBvZiBGZWJydWFyeSBpbiBFbmdsaXNoIGxvY2FsZSBpbiB0aGUgY29udGV4dCBvZiAyMDEwIHllYXI6XG4gKiBpbXBvcnQgZW9Mb2NhbGUgZnJvbSAnZGF0ZS1mbnMvbG9jYWxlL2VvJ1xuICogdmFyIHJlc3VsdCA9IHBhcnNlKFxuICogICAnMjgtYSBkZSBmZWJydWFybycsXG4gKiAgICdEbyBbZGVdIE1NTU0nLFxuICogICBuZXcgRGF0ZSgyMDEwLCAwLCAxKVxuICogICB7bG9jYWxlOiBlb0xvY2FsZX1cbiAqIClcbiAqIC8vPT4gU3VuIEZlYiAyOCAyMDEwIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChkaXJ0eURhdGVTdHJpbmcsIGRpcnR5Rm9ybWF0U3RyaW5nLCBkaXJ0eUJhc2VEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMyBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50JylcbiAgfVxuXG4gIHZhciBkYXRlU3RyaW5nID0gU3RyaW5nKGRpcnR5RGF0ZVN0cmluZyk7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuXG4gIHZhciB3ZWVrU3RhcnRzT24gPSBvcHRpb25zLndlZWtTdGFydHNPbiA9PT0gdW5kZWZpbmVkID8gMCA6IE51bWJlcihvcHRpb25zLndlZWtTdGFydHNPbik7XG5cbiAgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAwIGFuZCA2IF9hbmRfIGlzIG5vdCBOYU5cbiAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dlZWtTdGFydHNPbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNiBpbmNsdXNpdmVseScpXG4gIH1cblxuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgfHwgbG9jYWxlJDE7XG4gIHZhciBsb2NhbGVQYXJzZXJzID0gbG9jYWxlLnBhcnNlcnMgfHwge307XG4gIHZhciBsb2NhbGVVbml0cyA9IGxvY2FsZS51bml0cyB8fCB7fTtcblxuICBpZiAoIWxvY2FsZS5tYXRjaCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdsb2NhbGUgbXVzdCBjb250YWluIG1hdGNoIHByb3BlcnR5JylcbiAgfVxuXG4gIGlmICghbG9jYWxlLmZvcm1hdExvbmcpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBmb3JtYXRMb25nIHByb3BlcnR5JylcbiAgfVxuXG4gIHZhciBmb3JtYXRTdHJpbmcgPSBTdHJpbmcoZGlydHlGb3JtYXRTdHJpbmcpXG4gICAgLnJlcGxhY2UobG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAkMSwgZnVuY3Rpb24gKHN1YnN0cmluZykge1xuICAgICAgaWYgKHN1YnN0cmluZ1swXSA9PT0gJ1snKSB7XG4gICAgICAgIHJldHVybiBzdWJzdHJpbmdcbiAgICAgIH1cblxuICAgICAgaWYgKHN1YnN0cmluZ1swXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIHJldHVybiBjbGVhbkVzY2FwZWRTdHJpbmckMShzdWJzdHJpbmcpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2NhbGUuZm9ybWF0TG9uZyhzdWJzdHJpbmcpXG4gICAgfSk7XG5cbiAgaWYgKGZvcm1hdFN0cmluZyA9PT0gJycpIHtcbiAgICBpZiAoZGF0ZVN0cmluZyA9PT0gJycpIHtcbiAgICAgIHJldHVybiB0b0RhdGUoZGlydHlCYXNlRGF0ZSwgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgICB9XG4gIH1cblxuICB2YXIgc3ViRm5PcHRpb25zID0gY2xvbmVPYmplY3Qob3B0aW9ucyk7XG4gIHN1YkZuT3B0aW9ucy5sb2NhbGUgPSBsb2NhbGU7XG5cbiAgdmFyIHRva2VucyA9IGZvcm1hdFN0cmluZy5tYXRjaChsb2NhbGUucGFyc2luZ1Rva2Vuc1JlZ0V4cCB8fCBkZWZhdWx0UGFyc2luZ1Rva2Vuc1JlZ0V4cCk7XG4gIHZhciB0b2tlbnNMZW5ndGggPSB0b2tlbnMubGVuZ3RoO1xuXG4gIC8vIElmIHRpbWV6b25lIGlzbid0IHNwZWNpZmllZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIHN5c3RlbSB0aW1lem9uZVxuICB2YXIgc2V0dGVycyA9IFt7XG4gICAgcHJpb3JpdHk6IFRJTUVaT05FX1VOSVRfUFJJT1JJVFksXG4gICAgc2V0OiBkYXRlVG9TeXN0ZW1UaW1lem9uZSxcbiAgICBpbmRleDogMFxuICB9XTtcblxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRva2Vuc0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgIHZhciBwYXJzZXIgPSBsb2NhbGVQYXJzZXJzW3Rva2VuXSB8fCBwYXJzZXJzW3Rva2VuXTtcbiAgICBpZiAocGFyc2VyKSB7XG4gICAgICB2YXIgbWF0Y2hSZXN1bHQ7XG5cbiAgICAgIGlmIChwYXJzZXIubWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgbWF0Y2hSZXN1bHQgPSBwYXJzZXIubWF0Y2guZXhlYyhkYXRlU3RyaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoUmVzdWx0ID0gcGFyc2VyLm1hdGNoKGRhdGVTdHJpbmcsIHN1YkZuT3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbWF0Y2hSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgICAgIH1cblxuICAgICAgdmFyIHVuaXROYW1lID0gcGFyc2VyLnVuaXQ7XG4gICAgICB2YXIgdW5pdCA9IGxvY2FsZVVuaXRzW3VuaXROYW1lXSB8fCB1bml0c1t1bml0TmFtZV07XG5cbiAgICAgIHNldHRlcnMucHVzaCh7XG4gICAgICAgIHByaW9yaXR5OiB1bml0LnByaW9yaXR5LFxuICAgICAgICBzZXQ6IHVuaXQuc2V0LFxuICAgICAgICB2YWx1ZTogcGFyc2VyLnBhcnNlKG1hdGNoUmVzdWx0LCBzdWJGbk9wdGlvbnMpLFxuICAgICAgICBpbmRleDogc2V0dGVycy5sZW5ndGhcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc3Vic3RyaW5nID0gbWF0Y2hSZXN1bHRbMF07XG4gICAgICBkYXRlU3RyaW5nID0gZGF0ZVN0cmluZy5zbGljZShzdWJzdHJpbmcubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhlYWQgPSB0b2tlbnNbaV0ubWF0Y2goL15cXFsuKl0kLykgPyB0b2tlbnNbaV0ucmVwbGFjZSgvXlxcW3xdJC9nLCAnJykgOiB0b2tlbnNbaV07XG4gICAgICBpZiAoZGF0ZVN0cmluZy5pbmRleE9mKGhlYWQpID09PSAwKSB7XG4gICAgICAgIGRhdGVTdHJpbmcgPSBkYXRlU3RyaW5nLnNsaWNlKGhlYWQubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVuaXF1ZVByaW9yaXR5U2V0dGVycyA9IHNldHRlcnNcbiAgICAubWFwKGZ1bmN0aW9uIChzZXR0ZXIpIHtcbiAgICAgIHJldHVybiBzZXR0ZXIucHJpb3JpdHlcbiAgICB9KVxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGJcbiAgICB9KVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHByaW9yaXR5LCBpbmRleCwgYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHByaW9yaXR5KSA9PT0gaW5kZXhcbiAgICB9KVxuICAgIC5tYXAoZnVuY3Rpb24gKHByaW9yaXR5KSB7XG4gICAgICByZXR1cm4gc2V0dGVyc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzZXR0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyLnByaW9yaXR5ID09PSBwcmlvcml0eVxuICAgICAgICB9KVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgfSlcbiAgICAubWFwKGZ1bmN0aW9uIChzZXR0ZXJBcnJheSkge1xuICAgICAgcmV0dXJuIHNldHRlckFycmF5WzBdXG4gICAgfSk7XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlCYXNlRGF0ZSwgb3B0aW9ucyk7XG5cbiAgaWYgKGlzTmFOKGRhdGUpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgfVxuXG4gIC8vIENvbnZlcnQgdGhlIGRhdGUgaW4gc3lzdGVtIHRpbWV6b25lIHRvIHRoZSBzYW1lIGRhdGUgaW4gVVRDKzAwOjAwIHRpbWV6b25lLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIFVUQyBmdW5jdGlvbnMgd2lsbCBiZSBpbXBsZW1lbnRlZCwgbG9jYWxlcyB3aWxsIGJlIGNvbXBhdGlibGUgd2l0aCB0aGVtLlxuICAvLyBTZWUgYW4gaXNzdWUgYWJvdXQgVVRDIGZ1bmN0aW9uczogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zN1xuICB2YXIgdXRjRGF0ZSA9IHN1Yk1pbnV0ZXMoZGF0ZSwgZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKTtcblxuICB2YXIgZGF0ZVZhbHVlcyA9IHtkYXRlOiB1dGNEYXRlfTtcblxuICB2YXIgc2V0dGVyc0xlbmd0aCA9IHVuaXF1ZVByaW9yaXR5U2V0dGVycy5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBzZXR0ZXJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2V0dGVyID0gdW5pcXVlUHJpb3JpdHlTZXR0ZXJzW2ldO1xuICAgIGRhdGVWYWx1ZXMgPSBzZXR0ZXIuc2V0KGRhdGVWYWx1ZXMsIHNldHRlci52YWx1ZSwgc3ViRm5PcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBkYXRlVmFsdWVzLmRhdGVcbn1cblxuZnVuY3Rpb24gZGF0ZVRvU3lzdGVtVGltZXpvbmUgKGRhdGVWYWx1ZXMpIHtcbiAgdmFyIGRhdGUgPSBkYXRlVmFsdWVzLmRhdGU7XG4gIHZhciB0aW1lID0gZGF0ZS5nZXRUaW1lKCk7XG5cbiAgLy8gR2V0IHRoZSBzeXN0ZW0gdGltZXpvbmUgb2Zmc2V0IGF0IChtb21lbnQgb2YgdGltZSAtIG9mZnNldClcbiAgdmFyIG9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAvLyBHZXQgdGhlIHN5c3RlbSB0aW1lem9uZSBvZmZzZXQgYXQgdGhlIGV4YWN0IG1vbWVudCBvZiB0aW1lXG4gIG9mZnNldCA9IG5ldyBEYXRlKHRpbWUgKyBvZmZzZXQgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFJDcpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgLy8gQ29udmVydCBkYXRlIGluIHRpbWV6b25lIFwiVVRDKzAwOjAwXCIgdG8gdGhlIHN5c3RlbSB0aW1lem9uZVxuICBkYXRlVmFsdWVzLmRhdGUgPSBuZXcgRGF0ZSh0aW1lICsgb2Zmc2V0ICogTUlMTElTRUNPTkRTX0lOX01JTlVURSQ3KTtcblxuICByZXR1cm4gZGF0ZVZhbHVlc1xufVxuXG5mdW5jdGlvbiBjbGVhbkVzY2FwZWRTdHJpbmckMSAoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XSQvZywgJycpXG4gIH1cbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpXG59XG5cbi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYXV0b21hdGljYWxseSBieSBgc2NyaXB0cy9idWlsZC9pbmRpY2VzLmpzYC4gUGxlYXNlLCBkb24ndCBjaGFuZ2UgaXQuXG5cbi8vIFxuXG4vKipcbiAqIEN1c3RvbSBwYXJzZSBiZWhhdmlvciBvbiB0b3Agb2YgZGF0ZS1mbnMgcGFyc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGF0ZSQxIChkYXRlLCBmb3JtYXQkJDEpIHtcbiAgaWYgKHR5cGVvZiBkYXRlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBpc1ZhbGlkKGRhdGUpID8gZGF0ZSA6IG51bGxcbiAgfVxuXG4gIHZhciBwYXJzZWQgPSBwYXJzZShkYXRlLCBmb3JtYXQkJDEsIG5ldyBEYXRlKCkpO1xuXG4gIC8vIGlmIGRhdGUgaXMgbm90IHZhbGlkIG9yIHRoZSBmb3JtYXR0ZWQgb3V0cHV0IGFmdGVyIHBhcnNpbmcgZG9lcyBub3QgbWF0Y2hcbiAgLy8gdGhlIHN0cmluZyB2YWx1ZSBwYXNzZWQgaW4gKGF2b2lkcyBvdmVyZmxvd3MpXG4gIGlmICghaXNWYWxpZChwYXJzZWQpIHx8IGZvcm1hdChwYXJzZWQsIGZvcm1hdCQkMSkgIT09IGRhdGUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHBhcnNlZFxufVxuXG5mdW5jdGlvbiBhZnRlciAodmFsdWUsIHJlZikge1xuICB2YXIgb3RoZXJWYWx1ZSA9IHJlZlswXTtcbiAgdmFyIGluY2x1c2lvbiA9IHJlZlsxXTtcbiAgdmFyIGZvcm1hdCA9IHJlZlsyXTtcblxuICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmb3JtYXQgPSBpbmNsdXNpb247XG4gICAgaW5jbHVzaW9uID0gZmFsc2U7XG4gIH1cbiAgdmFsdWUgPSBwYXJzZURhdGUkMSh2YWx1ZSwgZm9ybWF0KTtcbiAgb3RoZXJWYWx1ZSA9IHBhcnNlRGF0ZSQxKG90aGVyVmFsdWUsIGZvcm1hdCk7XG5cbiAgLy8gaWYgZWl0aGVyIGlzIG5vdCB2YWxpZC5cbiAgaWYgKCF2YWx1ZSB8fCAhb3RoZXJWYWx1ZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGlzQWZ0ZXIodmFsdWUsIG90aGVyVmFsdWUpIHx8IChpbmNsdXNpb24gJiYgaXNFcXVhbCQxKHZhbHVlLCBvdGhlclZhbHVlKSlcbn1cblxuLyoqXG4gKiBTb21lIEFscGhhIFJlZ2V4IGhlbHBlcnMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2hyaXNvL3ZhbGlkYXRvci5qcy9ibG9iL21hc3Rlci9zcmMvbGliL2FscGhhLmpzXG4gKi9cblxudmFyIGFscGhhID0ge1xuICBlbjogL15bQS1aXSokL2ksXG4gIGNzOiAvXltBLVrDgcSMxI7DicSaw43Fh8OTxZjFoMWkw5rFrsOdxb1dKiQvaSxcbiAgZGE6IC9eW0EtWsOGw5jDhV0qJC9pLFxuICBkZTogL15bQS1aw4TDlsOcw59dKiQvaSxcbiAgZXM6IC9eW0EtWsOBw4nDjcORw5PDmsOcXSokL2ksXG4gIGZyOiAvXltBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF0qJC9pLFxuICBsdDogL15bQS1axITEjMSYxJbErsWgxbLFqsW9XSokL2ksXG4gIG5sOiAvXltBLVrDicOLw4/Dk8OWw5xdKiQvaSxcbiAgaHU6IC9eW0EtWsOBw4nDjcOTw5bFkMOaw5zFsF0qJC9pLFxuICBwbDogL15bQS1axITEhsSYxZrFgcWDw5PFu8W5XSokL2ksXG4gIHB0OiAvXltBLVrDg8OBw4DDgsOHw4nDisONw5XDk8OUw5rDnF0qJC9pLFxuICBydTogL15b0JAt0K/QgV0qJC9pLFxuICBzazogL15bQS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1dKiQvaSxcbiAgc3I6IC9eW0EtWsSMxIbFvcWgxJBdKiQvaSxcbiAgdHI6IC9eW0EtWsOHxJ7EsMSxw5bFnsOcXSokL2ksXG4gIHVrOiAvXlvQkC3QqdCs0K7Qr9CE0IbQh9KQXSokL2ksXG4gIGFyOiAvXlvYodii2KPYpNil2KbYp9io2KnYqtir2KzYrdiu2K/YsNix2LLYs9i02LXYtti32LjYudi62YHZgtmD2YTZhdmG2YfZiNmJ2YrZi9mM2Y3ZjtmP2ZDZkdmS2bBdKiQvLFxufTtcblxudmFyIGFscGhhU3BhY2VzID0ge1xuICBlbjogL15bQS1aXFxzXSokL2ksXG4gIGNzOiAvXltBLVrDgcSMxI7DicSaw43Fh8OTxZjFoMWkw5rFrsOdxb1cXHNdKiQvaSxcbiAgZGE6IC9eW0EtWsOGw5jDhVxcc10qJC9pLFxuICBkZTogL15bQS1aw4TDlsOcw59cXHNdKiQvaSxcbiAgZXM6IC9eW0EtWsOBw4nDjcORw5PDmsOcXFxzXSokL2ksXG4gIGZyOiAvXltBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuFxcc10qJC9pLFxuICBsdDogL15bQS1axITEjMSYxJbErsWgxbLFqsW9XFxzXSokL2ksXG4gIG5sOiAvXltBLVrDicOLw4/Dk8OWw5xcXHNdKiQvaSxcbiAgaHU6IC9eW0EtWsOBw4nDjcOTw5bFkMOaw5zFsFxcc10qJC9pLFxuICBwbDogL15bQS1axITEhsSYxZrFgcWDw5PFu8W5XFxzXSokL2ksXG4gIHB0OiAvXltBLVrDg8OBw4DDgsOHw4nDisONw5XDk8OUw5rDnFxcc10qJC9pLFxuICBydTogL15b0JAt0K/QgVxcc10qJC9pLFxuICBzazogL15bQS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1cXHNdKiQvaSxcbiAgc3I6IC9eW0EtWsSMxIbFvcWgxJBcXHNdKiQvaSxcbiAgdHI6IC9eW0EtWsOHxJ7EsMSxw5bFnsOcXFxzXSokL2ksXG4gIHVrOiAvXlvQkC3QqdCs0K7Qr9CE0IbQh9KQXFxzXSokL2ksXG4gIGFyOiAvXlvYodii2KPYpNil2KbYp9io2KnYqtir2KzYrdiu2K/YsNix2LLYs9i02LXYtti32LjYudi62YHZgtmD2YTZhdmG2YfZiNmJ2YrZi9mM2Y3ZjtmP2ZDZkdmS2bBcXHNdKiQvLFxufTtcblxudmFyIGFscGhhbnVtZXJpYyA9IHtcbiAgZW46IC9eWzAtOUEtWl0qJC9pLFxuICBjczogL15bMC05QS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9XSokL2ksXG4gIGRhOiAvXlswLTlBLVrDhsOYw4VdJC9pLFxuICBkZTogL15bMC05QS1aw4TDlsOcw59dKiQvaSxcbiAgZXM6IC9eWzAtOUEtWsOBw4nDjcORw5PDmsOcXSokL2ksXG4gIGZyOiAvXlswLTlBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF0qJC9pLFxuICBsdDogL15bMC05QS1axITEjMSYxJbErsWgxbLFqsW9XSokL2ksXG4gIGh1OiAvXlswLTlBLVrDgcOJw43Dk8OWxZDDmsOcxbBdKiQvaSxcbiAgbmw6IC9eWzAtOUEtWsOJw4vDj8OTw5bDnF0qJC9pLFxuICBwbDogL15bMC05QS1axITEhsSYxZrFgcWDw5PFu8W5XSokL2ksXG4gIHB0OiAvXlswLTlBLVrDg8OBw4DDgsOHw4nDisONw5XDk8OUw5rDnF0qJC9pLFxuICBydTogL15bMC050JAt0K/QgV0qJC9pLFxuICBzazogL15bMC05QS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1dKiQvaSxcbiAgc3I6IC9eWzAtOUEtWsSMxIbFvcWgxJBdKiQvaSxcbiAgdHI6IC9eWzAtOUEtWsOHxJ7EsMSxw5bFnsOcXSokL2ksXG4gIHVrOiAvXlswLTnQkC3QqdCs0K7Qr9CE0IbQh9KQXSokL2ksXG4gIGFyOiAvXlvZoNmh2aLZo9mk2aXZptmn2ajZqTAtOdih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22LfYuNi52LrZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLZsF0qJC8sXG59O1xuXG52YXIgYWxwaGFEYXNoID0ge1xuICBlbjogL15bMC05QS1aXy1dKiQvaSxcbiAgY3M6IC9eWzAtOUEtWsOBxIzEjsOJxJrDjcWHw5PFmMWgxaTDmsWuw53FvV8tXSokL2ksXG4gIGRhOiAvXlswLTlBLVrDhsOYw4VfLV0qJC9pLFxuICBkZTogL15bMC05QS1aw4TDlsOcw59fLV0qJC9pLFxuICBlczogL15bMC05QS1aw4HDicONw5HDk8Oaw5xfLV0qJC9pLFxuICBmcjogL15bMC05QS1aw4DDgsOGw4fDicOIw4rDi8OPw47DlMWSw5nDm8OcxbhfLV0qJC9pLFxuICBsdDogL15bMC05QS1axITEjMSYxJbErsWgxbLFqsW9Xy1dKiQvaSxcbiAgbmw6IC9eWzAtOUEtWsOJw4vDj8OTw5bDnF8tXSokL2ksXG4gIGh1OiAvXlswLTlBLVrDgcOJw43Dk8OWxZDDmsOcxbBfLV0qJC9pLFxuICBwbDogL15bMC05QS1axITEhsSYxZrFgcWDw5PFu8W5Xy1dKiQvaSxcbiAgcHQ6IC9eWzAtOUEtWsODw4HDgMOCw4fDicOKw43DlcOTw5TDmsOcXy1dKiQvaSxcbiAgcnU6IC9eWzAtOdCQLdCv0IFfLV0qJC9pLFxuICBzazogL15bMC05QS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1fLV0qJC9pLFxuICBzcjogL15bMC05QS1axIzEhsW9xaDEkF8tXSokL2ksXG4gIHRyOiAvXlswLTlBLVrDh8SexLDEscOWxZ7DnF8tXSokL2ksXG4gIHVrOiAvXlswLTnQkC3QqdCs0K7Qr9CE0IbQh9KQXy1dKiQvaSxcbiAgYXI6IC9eW9mg2aHZotmj2aTZpdmm2afZqNmpMC052KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXy1dKiQvLFxufTtcblxudmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtudWxsXTtcbiAgdmFyIGxvY2FsZSA9IHJlZlswXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUodmFsLCBbbG9jYWxlXSk7IH0pXG4gIH1cblxuICAvLyBNYXRjaCBhdCBsZWFzdCBvbmUgbG9jYWxlLlxuICBpZiAoISBsb2NhbGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxwaGEpLnNvbWUoZnVuY3Rpb24gKGxvYykgeyByZXR1cm4gYWxwaGFbbG9jXS50ZXN0KHZhbHVlKTsgfSlcbiAgfVxuXG4gIHJldHVybiAoYWxwaGFbbG9jYWxlXSB8fCBhbHBoYS5lbikudGVzdCh2YWx1ZSlcbn07XG5cbnZhciB2YWxpZGF0ZSQxID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtudWxsXTtcbiAgdmFyIGxvY2FsZSA9IHJlZlswXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkMSh2YWwsIFtsb2NhbGVdKTsgfSlcbiAgfVxuXG4gIC8vIE1hdGNoIGF0IGxlYXN0IG9uZSBsb2NhbGUuXG4gIGlmICghIGxvY2FsZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhbHBoYURhc2gpLnNvbWUoZnVuY3Rpb24gKGxvYykgeyByZXR1cm4gYWxwaGFEYXNoW2xvY10udGVzdCh2YWx1ZSk7IH0pXG4gIH1cblxuICByZXR1cm4gKGFscGhhRGFzaFtsb2NhbGVdIHx8IGFscGhhRGFzaC5lbikudGVzdCh2YWx1ZSlcbn07XG5cbnZhciB2YWxpZGF0ZSQyID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtudWxsXTtcbiAgdmFyIGxvY2FsZSA9IHJlZlswXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkMih2YWwsIFtsb2NhbGVdKTsgfSlcbiAgfVxuXG4gIC8vIE1hdGNoIGF0IGxlYXN0IG9uZSBsb2NhbGUuXG4gIGlmICghIGxvY2FsZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhbHBoYW51bWVyaWMpLnNvbWUoZnVuY3Rpb24gKGxvYykgeyByZXR1cm4gYWxwaGFudW1lcmljW2xvY10udGVzdCh2YWx1ZSk7IH0pXG4gIH1cblxuICByZXR1cm4gKGFscGhhbnVtZXJpY1tsb2NhbGVdIHx8IGFscGhhbnVtZXJpYy5lbikudGVzdCh2YWx1ZSlcbn07XG5cbnZhciB2YWxpZGF0ZSQzID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtudWxsXTtcbiAgdmFyIGxvY2FsZSA9IHJlZlswXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkMyh2YWwsIFtsb2NhbGVdKTsgfSlcbiAgfVxuXG4gIC8vIE1hdGNoIGF0IGxlYXN0IG9uZSBsb2NhbGUuXG4gIGlmICghIGxvY2FsZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhbHBoYVNwYWNlcykuc29tZShmdW5jdGlvbiAobG9jKSB7IHJldHVybiBhbHBoYVNwYWNlc1tsb2NdLnRlc3QodmFsdWUpOyB9KVxuICB9XG5cbiAgcmV0dXJuIChhbHBoYVNwYWNlc1tsb2NhbGVdIHx8IGFscGhhU3BhY2VzLmVuKS50ZXN0KHZhbHVlKVxufTtcblxuZnVuY3Rpb24gYmVmb3JlICh2YWx1ZSwgcmVmKSB7XG4gIHZhciBvdGhlclZhbHVlID0gcmVmWzBdO1xuICB2YXIgaW5jbHVzaW9uID0gcmVmWzFdO1xuICB2YXIgZm9ybWF0ID0gcmVmWzJdO1xuXG4gIGlmICh0eXBlb2YgZm9ybWF0ID09PSAndW5kZWZpbmVkJykge1xuICAgIGZvcm1hdCA9IGluY2x1c2lvbjtcbiAgICBpbmNsdXNpb24gPSBmYWxzZTtcbiAgfVxuICB2YWx1ZSA9IHBhcnNlRGF0ZSQxKHZhbHVlLCBmb3JtYXQpO1xuICBvdGhlclZhbHVlID0gcGFyc2VEYXRlJDEob3RoZXJWYWx1ZSwgZm9ybWF0KTtcblxuICAvLyBpZiBlaXRoZXIgaXMgbm90IHZhbGlkLlxuICBpZiAoIXZhbHVlIHx8ICFvdGhlclZhbHVlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gaXNCZWZvcmUodmFsdWUsIG90aGVyVmFsdWUpIHx8IChpbmNsdXNpb24gJiYgaXNFcXVhbCQxKHZhbHVlLCBvdGhlclZhbHVlKSlcbn1cblxudmFyIHZhbGlkYXRlJDQgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICB2YXIgbWluID0gcmVmWzBdO1xuICB2YXIgbWF4ID0gcmVmWzFdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSQ0KHZhbCwgW21pbiwgbWF4XSk7IH0pXG4gIH1cblxuICByZXR1cm4gTnVtYmVyKG1pbikgPD0gdmFsdWUgJiYgTnVtYmVyKG1heCkgPj0gdmFsdWVcbn07XG5cbmZ1bmN0aW9uIGNvbmZpcm1lZCAodmFsdWUsIG90aGVyKSB7IHJldHVybiBTdHJpbmcodmFsdWUpID09PSBTdHJpbmcob3RoZXIpOyB9XG5cbmZ1bmN0aW9uIHVud3JhcEV4cG9ydHMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBhc3NlcnRTdHJpbmdfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnRTdHJpbmc7XG5mdW5jdGlvbiBhc3NlcnRTdHJpbmcoaW5wdXQpIHtcbiAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZztcblxuICBpZiAoIWlzU3RyaW5nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBsaWJyYXJ5ICh2YWxpZGF0b3IuanMpIHZhbGlkYXRlcyBzdHJpbmdzIG9ubHknKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG59KTtcblxudW53cmFwRXhwb3J0cyhhc3NlcnRTdHJpbmdfMSk7XG5cbnZhciBpc0NyZWRpdENhcmRfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0NyZWRpdENhcmQ7XG5cblxuXG52YXIgX2Fzc2VydFN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIGNyZWRpdENhcmQgPSAvXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXwoMjIyWzEtOV18MjJbMy05XVswLTldfDJbMy02XVswLTldezJ9fDI3WzAxXVswLTldfDI3MjApWzAtOV17MTJ9fDYoPzowMTF8NVswLTldWzAtOV0pWzAtOV17MTJ9fDNbNDddWzAtOV17MTN9fDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfXwoPzoyMTMxfDE4MDB8MzVcXGR7M30pXFxkezExfXw2MlswLTldezE0fSkkLztcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBpc0NyZWRpdENhcmQoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nMi5kZWZhdWx0KShzdHIpO1xuICB2YXIgc2FuaXRpemVkID0gc3RyLnJlcGxhY2UoL1stIF0rL2csICcnKTtcbiAgaWYgKCFjcmVkaXRDYXJkLnRlc3Qoc2FuaXRpemVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc3VtID0gMDtcbiAgdmFyIGRpZ2l0ID0gdm9pZCAwO1xuICB2YXIgdG1wTnVtID0gdm9pZCAwO1xuICB2YXIgc2hvdWxkRG91YmxlID0gdm9pZCAwO1xuICBmb3IgKHZhciBpID0gc2FuaXRpemVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgZGlnaXQgPSBzYW5pdGl6ZWQuc3Vic3RyaW5nKGksIGkgKyAxKTtcbiAgICB0bXBOdW0gPSBwYXJzZUludChkaWdpdCwgMTApO1xuICAgIGlmIChzaG91bGREb3VibGUpIHtcbiAgICAgIHRtcE51bSAqPSAyO1xuICAgICAgaWYgKHRtcE51bSA+PSAxMCkge1xuICAgICAgICBzdW0gKz0gdG1wTnVtICUgMTAgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VtICs9IHRtcE51bTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VtICs9IHRtcE51bTtcbiAgICB9XG4gICAgc2hvdWxkRG91YmxlID0gIXNob3VsZERvdWJsZTtcbiAgfVxuICByZXR1cm4gISEoc3VtICUgMTAgPT09IDAgPyBzYW5pdGl6ZWQgOiBmYWxzZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbn0pO1xuXG52YXIgaXNDcmVkaXRDYXJkID0gdW53cmFwRXhwb3J0cyhpc0NyZWRpdENhcmRfMSk7XG5cbmZ1bmN0aW9uIGNyZWRpdF9jYXJkICh2YWx1ZSkgeyByZXR1cm4gaXNDcmVkaXRDYXJkKFN0cmluZyh2YWx1ZSkpOyB9XG5cbnZhciB2YWxpZGF0ZSQ1ID0gZnVuY3Rpb24gKHZhbHVlLCBwYXJhbXMpIHtcbiAgdmFyIGRlY2ltYWxzID0gQXJyYXkuaXNBcnJheShwYXJhbXMpID8gKHBhcmFtc1swXSB8fCAnKicpIDogJyonO1xuICB2YXIgc2VwYXJhdG9yID0gQXJyYXkuaXNBcnJheShwYXJhbXMpID8gKHBhcmFtc1sxXSB8fCAnLicpIDogJy4nO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkNSh2YWwsIHBhcmFtcyk7IH0pXG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gaWYgaXMgMC5cbiAgaWYgKE51bWJlcihkZWNpbWFscykgPT09IDApIHtcbiAgICByZXR1cm4gL14tP1xcZCokLy50ZXN0KHZhbHVlKVxuICB9XG5cbiAgdmFyIHJlZ2V4UGFydCA9IGRlY2ltYWxzID09PSAnKicgPyAnKycgOiAoXCJ7MSxcIiArIGRlY2ltYWxzICsgXCJ9XCIpO1xuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKChcIl4tP1xcXFxkKihcXFxcXCIgKyBzZXBhcmF0b3IgKyBcIlxcXFxkXCIgKyByZWdleFBhcnQgKyBcIik/JFwiKSk7XG5cbiAgaWYgKCEgcmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHZhciBwYXJzZWRWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHJldHVybiBwYXJzZWRWYWx1ZSA9PT0gcGFyc2VkVmFsdWU7XG59O1xuXG5mdW5jdGlvbiBkYXRlX2JldHdlZW4gKHZhbHVlLCBwYXJhbXMpIHtcbiAgdmFyIGFzc2lnbiwgYXNzaWduJDE7XG5cbiAgdmFyIG1pbjtcbiAgdmFyIG1heDtcbiAgdmFyIGZvcm1hdDtcbiAgdmFyIGluY2x1c2l2aXR5ID0gJygpJztcblxuICBpZiAocGFyYW1zLmxlbmd0aCA+IDMpIHtcbiAgICAoYXNzaWduID0gcGFyYW1zLCBtaW4gPSBhc3NpZ25bMF0sIG1heCA9IGFzc2lnblsxXSwgaW5jbHVzaXZpdHkgPSBhc3NpZ25bMl0sIGZvcm1hdCA9IGFzc2lnblszXSk7XG4gIH0gZWxzZSB7XG4gICAgKGFzc2lnbiQxID0gcGFyYW1zLCBtaW4gPSBhc3NpZ24kMVswXSwgbWF4ID0gYXNzaWduJDFbMV0sIGZvcm1hdCA9IGFzc2lnbiQxWzJdKTtcbiAgfVxuXG4gIHZhciBtaW5EYXRlID0gcGFyc2VEYXRlJDEobWluLCBmb3JtYXQpO1xuICB2YXIgbWF4RGF0ZSA9IHBhcnNlRGF0ZSQxKG1heCwgZm9ybWF0KTtcbiAgdmFyIGRhdGVWYWwgPSBwYXJzZURhdGUkMSh2YWx1ZSwgZm9ybWF0KTtcblxuICBpZiAoIW1pbkRhdGUgfHwgIW1heERhdGUgfHwgIWRhdGVWYWwpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChpbmNsdXNpdml0eSA9PT0gJygpJykge1xuICAgIHJldHVybiBpc0FmdGVyKGRhdGVWYWwsIG1pbkRhdGUpICYmIGlzQmVmb3JlKGRhdGVWYWwsIG1heERhdGUpXG4gIH1cblxuICBpZiAoaW5jbHVzaXZpdHkgPT09ICcoXScpIHtcbiAgICByZXR1cm4gaXNBZnRlcihkYXRlVmFsLCBtaW5EYXRlKSAmJiAoaXNFcXVhbCQxKGRhdGVWYWwsIG1heERhdGUpIHx8IGlzQmVmb3JlKGRhdGVWYWwsIG1heERhdGUpKVxuICB9XG5cbiAgaWYgKGluY2x1c2l2aXR5ID09PSAnWyknKSB7XG4gICAgcmV0dXJuIGlzQmVmb3JlKGRhdGVWYWwsIG1heERhdGUpICYmIChpc0VxdWFsJDEoZGF0ZVZhbCwgbWluRGF0ZSkgfHwgaXNBZnRlcihkYXRlVmFsLCBtaW5EYXRlKSlcbiAgfVxuXG4gIHJldHVybiBpc0VxdWFsJDEoZGF0ZVZhbCwgbWF4RGF0ZSkgfHwgaXNFcXVhbCQxKGRhdGVWYWwsIG1pbkRhdGUpIHx8XG4gICAgICAgIChpc0JlZm9yZShkYXRlVmFsLCBtYXhEYXRlKSAmJiBpc0FmdGVyKGRhdGVWYWwsIG1pbkRhdGUpKVxufVxuXG5mdW5jdGlvbiBkYXRlX2Zvcm1hdCAodmFsdWUsIHJlZikge1xuICB2YXIgZm9ybWF0ID0gcmVmWzBdO1xuXG4gIHJldHVybiAhIXBhcnNlRGF0ZSQxKHZhbHVlLCBmb3JtYXQpXG59XG5cbnZhciB2YWxpZGF0ZSQ2ID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgdmFyIGxlbmd0aCA9IHJlZlswXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkNih2YWwsIFtsZW5ndGhdKTsgfSlcbiAgfVxuICB2YXIgc3RyVmFsID0gU3RyaW5nKHZhbHVlKTtcblxuICByZXR1cm4gL15bMC05XSokLy50ZXN0KHN0clZhbCkgJiYgc3RyVmFsLmxlbmd0aCA9PT0gTnVtYmVyKGxlbmd0aClcbn07XG5cbnZhciB2YWxpZGF0ZUltYWdlID0gZnVuY3Rpb24gKGZpbGUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoeyB2YWxpZDogZmFsc2UgfSk7IH07XG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICB2YWxpZDogaW1hZ2Uud2lkdGggPT09IE51bWJlcih3aWR0aCkgJiYgaW1hZ2UuaGVpZ2h0ID09PSBOdW1iZXIoaGVpZ2h0KSxcbiAgICB9KTsgfTtcblxuICAgIGltYWdlLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG4gIH0pXG59O1xuXG5mdW5jdGlvbiBkaW1lbnNpb25zIChmaWxlcywgcmVmKSB7XG4gIHZhciB3aWR0aCA9IHJlZlswXTtcbiAgdmFyIGhlaWdodCA9IHJlZlsxXTtcblxuICB2YXIgbGlzdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gaWYgZmlsZSBpcyBub3QgYW4gaW1hZ2UsIHJlamVjdC5cbiAgICBpZiAoISAvXFwuKGpwZ3xzdmd8anBlZ3xwbmd8Ym1wfGdpZikkL2kudGVzdChmaWxlc1tpXS5uYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgbGlzdC5wdXNoKGZpbGVzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLmFsbChsaXN0Lm1hcChmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gdmFsaWRhdGVJbWFnZShmaWxlLCB3aWR0aCwgaGVpZ2h0KTsgfSkpXG59XG5cbnZhciBtZXJnZV8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1lcmdlO1xuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgZGVmYXVsdHMgPSBhcmd1bWVudHNbMV07XG5cbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9ialtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSk7XG5cbnVud3JhcEV4cG9ydHMobWVyZ2VfMSk7XG5cbnZhciBpc0J5dGVMZW5ndGhfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gaXNCeXRlTGVuZ3RoO1xuXG5cblxudmFyIF9hc3NlcnRTdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuZnVuY3Rpb24gaXNCeXRlTGVuZ3RoKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZzIuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIG1pbiA9IHZvaWQgMDtcbiAgdmFyIG1heCA9IHZvaWQgMDtcbiAgaWYgKCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0aW9ucykpID09PSAnb2JqZWN0Jykge1xuICAgIG1pbiA9IG9wdGlvbnMubWluIHx8IDA7XG4gICAgbWF4ID0gb3B0aW9ucy5tYXg7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGlzQnl0ZUxlbmd0aChzdHIsIG1pbiBbLCBtYXhdKVxuICAgIG1pbiA9IGFyZ3VtZW50c1sxXTtcbiAgICBtYXggPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIGxlbiA9IGVuY29kZVVSSShzdHIpLnNwbGl0KC8lLi58Li8pLmxlbmd0aCAtIDE7XG4gIHJldHVybiBsZW4gPj0gbWluICYmICh0eXBlb2YgbWF4ID09PSAndW5kZWZpbmVkJyB8fCBsZW4gPD0gbWF4KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoaXNCeXRlTGVuZ3RoXzEpO1xuXG52YXIgaXNGUUROXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNGUUROO1xuXG5cblxudmFyIF9hc3NlcnRTdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cblxuXG52YXIgX21lcmdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobWVyZ2VfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0X2ZxZG5fb3B0aW9ucyA9IHtcbiAgcmVxdWlyZV90bGQ6IHRydWUsXG4gIGFsbG93X3VuZGVyc2NvcmVzOiBmYWxzZSxcbiAgYWxsb3dfdHJhaWxpbmdfZG90OiBmYWxzZVxufTtcblxuZnVuY3Rpb24gaXNGUUROKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZzIuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UyLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfZnFkbl9vcHRpb25zKTtcblxuICAvKiBSZW1vdmUgdGhlIG9wdGlvbmFsIHRyYWlsaW5nIGRvdCBiZWZvcmUgY2hlY2tpbmcgdmFsaWRpdHkgKi9cbiAgaWYgKG9wdGlvbnMuYWxsb3dfdHJhaWxpbmdfZG90ICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcuJykge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICB9XG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnLicpO1xuICBpZiAob3B0aW9ucy5yZXF1aXJlX3RsZCkge1xuICAgIHZhciB0bGQgPSBwYXJ0cy5wb3AoKTtcbiAgICBpZiAoIXBhcnRzLmxlbmd0aCB8fCAhL14oW2EtelxcdTAwYTEtXFx1ZmZmZl17Mix9fHhuW2EtejAtOS1dezIsfSkkL2kudGVzdCh0bGQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGRpc2FsbG93IHNwYWNlc1xuICAgIGlmICgvW1xcc1xcdTIwMDItXFx1MjAwQlxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdUZFRkZcXHVEQjQwXFx1REMyMF0vLnRlc3QodGxkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBwYXJ0LCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChvcHRpb25zLmFsbG93X3VuZGVyc2NvcmVzKSB7XG4gICAgICBwYXJ0ID0gcGFydC5yZXBsYWNlKC9fL2csICcnKTtcbiAgICB9XG4gICAgaWYgKCEvXlthLXpcXHUwMGExLVxcdWZmZmYwLTktXSskL2kudGVzdChwYXJ0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBkaXNhbGxvdyBmdWxsLXdpZHRoIGNoYXJzXG4gICAgaWYgKC9bXFx1ZmYwMS1cXHVmZjVlXS8udGVzdChwYXJ0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGFydFswXSA9PT0gJy0nIHx8IHBhcnRbcGFydC5sZW5ndGggLSAxXSA9PT0gJy0nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG59KTtcblxudW53cmFwRXhwb3J0cyhpc0ZRRE5fMSk7XG5cbnZhciBpc0VtYWlsXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNFbWFpbDtcblxuXG5cbnZhciBfYXNzZXJ0U3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG5cblxudmFyIF9tZXJnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG1lcmdlXzEpO1xuXG5cblxudmFyIF9pc0J5dGVMZW5ndGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpc0J5dGVMZW5ndGhfMSk7XG5cblxuXG52YXIgX2lzRlFETjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGlzRlFETl8xKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRfZW1haWxfb3B0aW9ucyA9IHtcbiAgYWxsb3dfZGlzcGxheV9uYW1lOiBmYWxzZSxcbiAgcmVxdWlyZV9kaXNwbGF5X25hbWU6IGZhbHNlLFxuICBhbGxvd191dGY4X2xvY2FsX3BhcnQ6IHRydWUsXG4gIHJlcXVpcmVfdGxkOiB0cnVlXG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG52YXIgZGlzcGxheU5hbWUgPSAvXlthLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcLlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XFwsXFwuXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXFxzXSo8KC4rKT4kL2k7XG52YXIgZW1haWxVc2VyUGFydCA9IC9eW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XSskL2k7XG52YXIgcXVvdGVkRW1haWxVc2VyID0gL14oW1xcc1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2VdfChcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXSkpKiQvaTtcbnZhciBlbWFpbFVzZXJVdGY4UGFydCA9IC9eW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSskL2k7XG52YXIgcXVvdGVkRW1haWxVc2VyVXRmOCA9IC9eKFtcXHNcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdlXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXXwoXFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3ZlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSokL2k7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbi8qIGVzbGludC1lbmFibGUgbm8tY29udHJvbC1yZWdleCAqL1xuXG5mdW5jdGlvbiBpc0VtYWlsKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZzIuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UyLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfZW1haWxfb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMucmVxdWlyZV9kaXNwbGF5X25hbWUgfHwgb3B0aW9ucy5hbGxvd19kaXNwbGF5X25hbWUpIHtcbiAgICB2YXIgZGlzcGxheV9lbWFpbCA9IHN0ci5tYXRjaChkaXNwbGF5TmFtZSk7XG4gICAgaWYgKGRpc3BsYXlfZW1haWwpIHtcbiAgICAgIHN0ciA9IGRpc3BsYXlfZW1haWxbMV07XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnJlcXVpcmVfZGlzcGxheV9uYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCdAJyk7XG4gIHZhciBkb21haW4gPSBwYXJ0cy5wb3AoKTtcbiAgdmFyIHVzZXIgPSBwYXJ0cy5qb2luKCdAJyk7XG5cbiAgdmFyIGxvd2VyX2RvbWFpbiA9IGRvbWFpbi50b0xvd2VyQ2FzZSgpO1xuICBpZiAobG93ZXJfZG9tYWluID09PSAnZ21haWwuY29tJyB8fCBsb3dlcl9kb21haW4gPT09ICdnb29nbGVtYWlsLmNvbScpIHtcbiAgICB1c2VyID0gdXNlci5yZXBsYWNlKC9cXC4vZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICBpZiAoISgwLCBfaXNCeXRlTGVuZ3RoMi5kZWZhdWx0KSh1c2VyLCB7IG1heDogNjQgfSkgfHwgISgwLCBfaXNCeXRlTGVuZ3RoMi5kZWZhdWx0KShkb21haW4sIHsgbWF4OiAyNTQgfSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoISgwLCBfaXNGUUROMi5kZWZhdWx0KShkb21haW4sIHsgcmVxdWlyZV90bGQ6IG9wdGlvbnMucmVxdWlyZV90bGQgfSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodXNlclswXSA9PT0gJ1wiJykge1xuICAgIHVzZXIgPSB1c2VyLnNsaWNlKDEsIHVzZXIubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIG9wdGlvbnMuYWxsb3dfdXRmOF9sb2NhbF9wYXJ0ID8gcXVvdGVkRW1haWxVc2VyVXRmOC50ZXN0KHVzZXIpIDogcXVvdGVkRW1haWxVc2VyLnRlc3QodXNlcik7XG4gIH1cblxuICB2YXIgcGF0dGVybiA9IG9wdGlvbnMuYWxsb3dfdXRmOF9sb2NhbF9wYXJ0ID8gZW1haWxVc2VyVXRmOFBhcnQgOiBlbWFpbFVzZXJQYXJ0O1xuXG4gIHZhciB1c2VyX3BhcnRzID0gdXNlci5zcGxpdCgnLicpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVzZXJfcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXBhdHRlcm4udGVzdCh1c2VyX3BhcnRzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG59KTtcblxudmFyIGlzRW1haWwgPSB1bndyYXBFeHBvcnRzKGlzRW1haWxfMSk7XG5cbnZhciB2YWxpZGF0ZSQ3ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiBpc0VtYWlsKFN0cmluZyh2YWwpKTsgfSlcbiAgfVxuXG4gIHJldHVybiBpc0VtYWlsKFN0cmluZyh2YWx1ZSkpXG59O1xuXG5mdW5jdGlvbiBleHQgKGZpbGVzLCBleHRlbnNpb25zKSB7XG4gIHZhciByZWdleCA9IG5ldyBSZWdFeHAoKFwiLihcIiArIChleHRlbnNpb25zLmpvaW4oJ3wnKSkgKyBcIikkXCIpLCAnaScpO1xuXG4gIHJldHVybiBmaWxlcy5ldmVyeShmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gcmVnZXgudGVzdChmaWxlLm5hbWUpOyB9KVxufVxuXG5mdW5jdGlvbiBpbWFnZSAoZmlsZXMpIHsgcmV0dXJuIGZpbGVzLmV2ZXJ5KGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiAvXFwuKGpwZ3xzdmd8anBlZ3xwbmd8Ym1wfGdpZikkL2kudGVzdChmaWxlLm5hbWUpOyB9XG4pOyB9XG5cbnZhciB2YWxpZGF0ZSQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSQ4KHZhbCwgb3B0aW9ucyk7IH0pXG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgcmV0dXJuICEhIG9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChvcHRpb24pIHsgcmV0dXJuIG9wdGlvbiA9PSB2YWx1ZTsgfSkubGVuZ3RoO1xufTtcblxudmFyIGlzSVBfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0lQO1xuXG5cblxudmFyIF9hc3NlcnRTdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBpcHY0TWF5YmUgPSAvXihcXGR7MSwzfSlcXC4oXFxkezEsM30pXFwuKFxcZHsxLDN9KVxcLihcXGR7MSwzfSkkLztcbnZhciBpcHY2QmxvY2sgPSAvXlswLTlBLUZdezEsNH0kL2k7XG5cbmZ1bmN0aW9uIGlzSVAoc3RyKSB7XG4gIHZhciB2ZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcblxuICAoMCwgX2Fzc2VydFN0cmluZzIuZGVmYXVsdCkoc3RyKTtcbiAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKTtcbiAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIGlzSVAoc3RyLCA0KSB8fCBpc0lQKHN0ciwgNik7XG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gJzQnKSB7XG4gICAgaWYgKCFpcHY0TWF5YmUudGVzdChzdHIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnLicpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFydHNbM10gPD0gMjU1O1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICc2Jykge1xuICAgIHZhciBibG9ja3MgPSBzdHIuc3BsaXQoJzonKTtcbiAgICB2YXIgZm91bmRPbWlzc2lvbkJsb2NrID0gZmFsc2U7IC8vIG1hcmtlciB0byBpbmRpY2F0ZSA6OlxuXG4gICAgLy8gQXQgbGVhc3Qgc29tZSBPUyBhY2NlcHQgdGhlIGxhc3QgMzIgYml0cyBvZiBhbiBJUHY2IGFkZHJlc3NcbiAgICAvLyAoaS5lLiAyIG9mIHRoZSBibG9ja3MpIGluIElQdjQgbm90YXRpb24sIGFuZCBSRkMgMzQ5MyBzYXlzXG4gICAgLy8gdGhhdCAnOjpmZmZmOmEuYi5jLmQnIGlzIHZhbGlkIGZvciBJUHY0LW1hcHBlZCBJUHY2IGFkZHJlc3NlcyxcbiAgICAvLyBhbmQgJzo6YS5iLmMuZCcgaXMgZGVwcmVjYXRlZCwgYnV0IGFsc28gdmFsaWQuXG4gICAgdmFyIGZvdW5kSVB2NFRyYW5zaXRpb25CbG9jayA9IGlzSVAoYmxvY2tzW2Jsb2Nrcy5sZW5ndGggLSAxXSwgNCk7XG4gICAgdmFyIGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3MgPSBmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgPyA3IDogODtcblxuICAgIGlmIChibG9ja3MubGVuZ3RoID4gZXhwZWN0ZWROdW1iZXJPZkJsb2Nrcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBpbml0aWFsIG9yIGZpbmFsIDo6XG4gICAgaWYgKHN0ciA9PT0gJzo6Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChzdHIuc3Vic3RyKDAsIDIpID09PSAnOjonKSB7XG4gICAgICBibG9ja3Muc2hpZnQoKTtcbiAgICAgIGJsb2Nrcy5zaGlmdCgpO1xuICAgICAgZm91bmRPbWlzc2lvbkJsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0ci5zdWJzdHIoc3RyLmxlbmd0aCAtIDIpID09PSAnOjonKSB7XG4gICAgICBibG9ja3MucG9wKCk7XG4gICAgICBibG9ja3MucG9wKCk7XG4gICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyB0ZXN0IGZvciBhIDo6IHdoaWNoIGNhbiBub3QgYmUgYXQgdGhlIHN0cmluZyBzdGFydC9lbmRcbiAgICAgIC8vIHNpbmNlIHRob3NlIGNhc2VzIGhhdmUgYmVlbiBoYW5kbGVkIGFib3ZlXG4gICAgICBpZiAoYmxvY2tzW2ldID09PSAnJyAmJiBpID4gMCAmJiBpIDwgYmxvY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKGZvdW5kT21pc3Npb25CbG9jaykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbXVsdGlwbGUgOjogaW4gYWRkcmVzc1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kSVB2NFRyYW5zaXRpb25CbG9jayAmJiBpID09PSBibG9ja3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAvLyBpdCBoYXMgYmVlbiBjaGVja2VkIGJlZm9yZSB0aGF0IHRoZSBsYXN0XG4gICAgICAgIC8vIGJsb2NrIGlzIGEgdmFsaWQgSVB2NCBhZGRyZXNzXG4gICAgICB9IGVsc2UgaWYgKCFpcHY2QmxvY2sudGVzdChibG9ja3NbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvdW5kT21pc3Npb25CbG9jaykge1xuICAgICAgcmV0dXJuIGJsb2Nrcy5sZW5ndGggPj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2Nrcy5sZW5ndGggPT09IGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3M7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG59KTtcblxudmFyIGlzSVAgPSB1bndyYXBFeHBvcnRzKGlzSVBfMSk7XG5cbmZ1bmN0aW9uIGlwICh2YWx1ZSwgcmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSBbNF07XG4gIHZhciB2ZXJzaW9uID0gcmVmWzBdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiBpc0lQKHZhbCwgW3ZlcnNpb25dKTsgfSlcbiAgfVxuXG4gIHJldHVybiBpc0lQKHZhbHVlLCB2ZXJzaW9uKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuICovXG52YXIgY29tcGFyZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbGVuZ3RoLCBtYXgpIHtcbiAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gbGVuZ3RoXG4gIH1cblxuICAvLyBjYXN0IHRvIG51bWJlci5cbiAgbWF4ID0gTnVtYmVyKG1heCk7XG5cbiAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+PSBsZW5ndGggJiYgdmFsdWUubGVuZ3RoIDw9IG1heFxufTtcblxuZnVuY3Rpb24gbGVuZ3RoICh2YWx1ZSwgcmVmKSB7XG4gIHZhciBsZW5ndGggPSByZWZbMF07XG4gIHZhciBtYXggPSByZWZbMV07IGlmICggbWF4ID09PSB2b2lkIDAgKSBtYXggPSB1bmRlZmluZWQ7XG5cbiAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCk7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgfVxuXG4gIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgdmFsdWUgPSB0b0FycmF5KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBjb21wYXJlKHZhbHVlLCBsZW5ndGgsIG1heClcbn1cblxuZnVuY3Rpb24gaW50ZWdlciAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIC9eLT9bMC05XSskLy50ZXN0KFN0cmluZyh2YWwpKTsgfSlcbiAgfVxuXG4gIHJldHVybiAvXi0/WzAtOV0rJC8udGVzdChTdHJpbmcodmFsdWUpKVxufVxuXG5mdW5jdGlvbiBtYXgkMSAodmFsdWUsIHJlZikge1xuICB2YXIgbGVuZ3RoID0gcmVmWzBdO1xuXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGxlbmd0aCA+PSAwXG4gIH1cblxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5sZW5ndGggPD0gbGVuZ3RoXG59XG5cbmZ1bmN0aW9uIG1heF92YWx1ZSAodmFsdWUsIHJlZikge1xuICB2YXIgbWF4ID0gcmVmWzBdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIE51bWJlcih2YWx1ZSkgPD0gbWF4XG59XG5cbmZ1bmN0aW9uIG1pbWVzIChmaWxlcywgbWltZXMpIHtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgoKG1pbWVzLmpvaW4oJ3wnKS5yZXBsYWNlKCcqJywgJy4rJykpICsgXCIkXCIpLCAnaScpO1xuXG4gIHJldHVybiBmaWxlcy5ldmVyeShmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gcmVnZXgudGVzdChmaWxlLnR5cGUpOyB9KVxufVxuXG5mdW5jdGlvbiBtaW4kMSAodmFsdWUsIHJlZikge1xuICB2YXIgbGVuZ3RoID0gcmVmWzBdO1xuXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkubGVuZ3RoID49IGxlbmd0aFxufVxuXG5mdW5jdGlvbiBtaW5fdmFsdWUgKHZhbHVlLCByZWYpIHtcbiAgdmFyIG1pbiA9IHJlZlswXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBOdW1iZXIodmFsdWUpID49IG1pblxufVxuXG52YXIgdmFsaWRhdGUkOSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkOSh2YWwsIG9wdGlvbnMpOyB9KVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIHJldHVybiAhIG9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChvcHRpb24pIHsgcmV0dXJuIG9wdGlvbiA9PSB2YWx1ZTsgfSkubGVuZ3RoO1xufTtcblxuZnVuY3Rpb24gbnVtZXJpYyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIC9eWzAtOV0rJC8udGVzdChTdHJpbmcodmFsKSk7IH0pXG4gIH1cblxuICByZXR1cm4gL15bMC05XSskLy50ZXN0KFN0cmluZyh2YWx1ZSkpXG59XG5cbmZ1bmN0aW9uIHJlZ2V4ICh2YWx1ZSwgcmVmKSB7XG4gIHZhciByZWdleCA9IHJlZlswXTtcbiAgdmFyIGZsYWdzID0gcmVmLnNsaWNlKDEpO1xuXG4gIGlmIChyZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleC50ZXN0KHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIGZsYWdzKS50ZXN0KFN0cmluZyh2YWx1ZSkpXG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVkICh2YWx1ZSwgcGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSBbZmFsc2VdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiAhISB2YWx1ZS5sZW5ndGhcbiAgfVxuXG4gIC8vIGluY2FzZSBhIGZpZWxkIGNvbnNpZGVycyBgZmFsc2VgIGFzIGFuIGVtcHR5IHZhbHVlIGxpa2UgY2hlY2tib3hlcy5cbiAgdmFyIGludmFsaWRhdGVGYWxzZSA9IHBhcmFtc1swXTtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSAmJiBpbnZhbGlkYXRlRmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gISEgU3RyaW5nKHZhbHVlKS50cmltKCkubGVuZ3RoXG59XG5cbmZ1bmN0aW9uIHNpemUgKGZpbGVzLCByZWYpIHtcbiAgdmFyIHNpemUgPSByZWZbMF07XG5cbiAgaWYgKGlzTmFOKHNpemUpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB2YXIgblNpemUgPSBOdW1iZXIoc2l6ZSkgKiAxMDI0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZpbGVzW2ldLnNpemUgPiBuU2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxudmFyIGlzVVJMXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNVUkw7XG5cblxuXG52YXIgX2Fzc2VydFN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuXG5cbnZhciBfaXNGUUROMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoaXNGUUROXzEpO1xuXG5cblxudmFyIF9pc0lQMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoaXNJUF8xKTtcblxuXG5cbnZhciBfbWVyZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChtZXJnZV8xKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRfdXJsX29wdGlvbnMgPSB7XG4gIHByb3RvY29sczogWydodHRwJywgJ2h0dHBzJywgJ2Z0cCddLFxuICByZXF1aXJlX3RsZDogdHJ1ZSxcbiAgcmVxdWlyZV9wcm90b2NvbDogZmFsc2UsXG4gIHJlcXVpcmVfaG9zdDogdHJ1ZSxcbiAgcmVxdWlyZV92YWxpZF9wcm90b2NvbDogdHJ1ZSxcbiAgYWxsb3dfdW5kZXJzY29yZXM6IGZhbHNlLFxuICBhbGxvd190cmFpbGluZ19kb3Q6IGZhbHNlLFxuICBhbGxvd19wcm90b2NvbF9yZWxhdGl2ZV91cmxzOiBmYWxzZVxufTtcblxudmFyIHdyYXBwZWRfaXB2NiA9IC9eXFxbKFteXFxdXSspXFxdKD86OihbMC05XSspKT8kLztcblxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSG9zdChob3N0LCBtYXRjaGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXRjaCA9IG1hdGNoZXNbaV07XG4gICAgaWYgKGhvc3QgPT09IG1hdGNoIHx8IGlzUmVnRXhwKG1hdGNoKSAmJiBtYXRjaC50ZXN0KGhvc3QpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1VSTCh1cmwsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHVybCk7XG4gIGlmICghdXJsIHx8IHVybC5sZW5ndGggPj0gMjA4MyB8fCAvW1xcczw+XS8udGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh1cmwuaW5kZXhPZignbWFpbHRvOicpID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlMi5kZWZhdWx0KShvcHRpb25zLCBkZWZhdWx0X3VybF9vcHRpb25zKTtcbiAgdmFyIHByb3RvY29sID0gdm9pZCAwLFxuICAgICAgYXV0aCA9IHZvaWQgMCxcbiAgICAgIGhvc3QgPSB2b2lkIDAsXG4gICAgICBob3N0bmFtZSA9IHZvaWQgMCxcbiAgICAgIHBvcnQgPSB2b2lkIDAsXG4gICAgICBwb3J0X3N0ciA9IHZvaWQgMCxcbiAgICAgIHNwbGl0ID0gdm9pZCAwLFxuICAgICAgaXB2NiA9IHZvaWQgMDtcblxuICBzcGxpdCA9IHVybC5zcGxpdCgnIycpO1xuICB1cmwgPSBzcGxpdC5zaGlmdCgpO1xuXG4gIHNwbGl0ID0gdXJsLnNwbGl0KCc/Jyk7XG4gIHVybCA9IHNwbGl0LnNoaWZ0KCk7XG5cbiAgc3BsaXQgPSB1cmwuc3BsaXQoJzovLycpO1xuICBpZiAoc3BsaXQubGVuZ3RoID4gMSkge1xuICAgIHByb3RvY29sID0gc3BsaXQuc2hpZnQoKTtcbiAgICBpZiAob3B0aW9ucy5yZXF1aXJlX3ZhbGlkX3Byb3RvY29sICYmIG9wdGlvbnMucHJvdG9jb2xzLmluZGV4T2YocHJvdG9jb2wpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRpb25zLnJlcXVpcmVfcHJvdG9jb2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5hbGxvd19wcm90b2NvbF9yZWxhdGl2ZV91cmxzICYmIHVybC5zdWJzdHIoMCwgMikgPT09ICcvLycpIHtcbiAgICBzcGxpdFswXSA9IHVybC5zdWJzdHIoMik7XG4gIH1cbiAgdXJsID0gc3BsaXQuam9pbignOi8vJyk7XG5cbiAgaWYgKHVybCA9PT0gJycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzcGxpdCA9IHVybC5zcGxpdCgnLycpO1xuICB1cmwgPSBzcGxpdC5zaGlmdCgpO1xuXG4gIGlmICh1cmwgPT09ICcnICYmICFvcHRpb25zLnJlcXVpcmVfaG9zdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3BsaXQgPSB1cmwuc3BsaXQoJ0AnKTtcbiAgaWYgKHNwbGl0Lmxlbmd0aCA+IDEpIHtcbiAgICBhdXRoID0gc3BsaXQuc2hpZnQoKTtcbiAgICBpZiAoYXV0aC5pbmRleE9mKCc6JykgPj0gMCAmJiBhdXRoLnNwbGl0KCc6JykubGVuZ3RoID4gMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBob3N0bmFtZSA9IHNwbGl0LmpvaW4oJ0AnKTtcblxuICBwb3J0X3N0ciA9IG51bGw7XG4gIGlwdjYgPSBudWxsO1xuICB2YXIgaXB2Nl9tYXRjaCA9IGhvc3RuYW1lLm1hdGNoKHdyYXBwZWRfaXB2Nik7XG4gIGlmIChpcHY2X21hdGNoKSB7XG4gICAgaG9zdCA9ICcnO1xuICAgIGlwdjYgPSBpcHY2X21hdGNoWzFdO1xuICAgIHBvcnRfc3RyID0gaXB2Nl9tYXRjaFsyXSB8fCBudWxsO1xuICB9IGVsc2Uge1xuICAgIHNwbGl0ID0gaG9zdG5hbWUuc3BsaXQoJzonKTtcbiAgICBob3N0ID0gc3BsaXQuc2hpZnQoKTtcbiAgICBpZiAoc3BsaXQubGVuZ3RoKSB7XG4gICAgICBwb3J0X3N0ciA9IHNwbGl0LmpvaW4oJzonKTtcbiAgICB9XG4gIH1cblxuICBpZiAocG9ydF9zdHIgIT09IG51bGwpIHtcbiAgICBwb3J0ID0gcGFyc2VJbnQocG9ydF9zdHIsIDEwKTtcbiAgICBpZiAoIS9eWzAtOV0rJC8udGVzdChwb3J0X3N0cikgfHwgcG9ydCA8PSAwIHx8IHBvcnQgPiA2NTUzNSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKDAsIF9pc0lQMi5kZWZhdWx0KShob3N0KSAmJiAhKDAsIF9pc0ZRRE4yLmRlZmF1bHQpKGhvc3QsIG9wdGlvbnMpICYmICghaXB2NiB8fCAhKDAsIF9pc0lQMi5kZWZhdWx0KShpcHY2LCA2KSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBob3N0ID0gaG9zdCB8fCBpcHY2O1xuXG4gIGlmIChvcHRpb25zLmhvc3Rfd2hpdGVsaXN0ICYmICFjaGVja0hvc3QoaG9zdCwgb3B0aW9ucy5ob3N0X3doaXRlbGlzdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG9wdGlvbnMuaG9zdF9ibGFja2xpc3QgJiYgY2hlY2tIb3N0KGhvc3QsIG9wdGlvbnMuaG9zdF9ibGFja2xpc3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbn0pO1xuXG52YXIgaXNVUkwgPSB1bndyYXBFeHBvcnRzKGlzVVJMXzEpO1xuXG5mdW5jdGlvbiB1cmwgKHZhbHVlLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFt0cnVlXTtcbiAgdmFyIHJlcXVpcmVQcm90b2NvbCA9IHJlZlswXTtcblxuICB2YXIgb3B0aW9ucyA9IHsgcmVxdWlyZV9wcm90b2NvbDogISFyZXF1aXJlUHJvdG9jb2wsIGFsbG93X3VuZGVyc2NvcmVzOiB0cnVlIH07XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiBpc1VSTCh2YWwsIG9wdGlvbnMpOyB9KVxuICB9XG5cbiAgcmV0dXJuIGlzVVJMKHZhbHVlLCBvcHRpb25zKVxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbnZhciBSdWxlcyA9IHtcbiAgYWZ0ZXI6IGFmdGVyLFxuICBhbHBoYV9kYXNoOiB2YWxpZGF0ZSQxLFxuICBhbHBoYV9udW06IHZhbGlkYXRlJDIsXG4gIGFscGhhX3NwYWNlczogdmFsaWRhdGUkMyxcbiAgYWxwaGE6IHZhbGlkYXRlLFxuICBiZWZvcmU6IGJlZm9yZSxcbiAgYmV0d2VlbjogdmFsaWRhdGUkNCxcbiAgY29uZmlybWVkOiBjb25maXJtZWQsXG4gIGNyZWRpdF9jYXJkOiBjcmVkaXRfY2FyZCxcbiAgZGF0ZV9iZXR3ZWVuOiBkYXRlX2JldHdlZW4sXG4gIGRhdGVfZm9ybWF0OiBkYXRlX2Zvcm1hdCxcbiAgZGVjaW1hbDogdmFsaWRhdGUkNSxcbiAgZGlnaXRzOiB2YWxpZGF0ZSQ2LFxuICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICBlbWFpbDogdmFsaWRhdGUkNyxcbiAgZXh0OiBleHQsXG4gIGltYWdlOiBpbWFnZSxcbiAgaW46IHZhbGlkYXRlJDgsXG4gIGludGVnZXI6IGludGVnZXIsXG4gIGxlbmd0aDogbGVuZ3RoLFxuICBpcDogaXAsXG4gIG1heDogbWF4JDEsXG4gIG1heF92YWx1ZTogbWF4X3ZhbHVlLFxuICBtaW1lczogbWltZXMsXG4gIG1pbjogbWluJDEsXG4gIG1pbl92YWx1ZTogbWluX3ZhbHVlLFxuICBub3RfaW46IHZhbGlkYXRlJDksXG4gIG51bWVyaWM6IG51bWVyaWMsXG4gIHJlZ2V4OiByZWdleCxcbiAgcmVxdWlyZWQ6IHJlcXVpcmVkLFxuICBzaXplOiBzaXplLFxuICB1cmw6IHVybCxcbn1cblxuLy8gXG5cbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiAoZmllbGRzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICByZXR1cm4gZmllbGRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xuICAgICAgaWYgKH5jdXJyLmluZGV4T2YoJy4nKSkge1xuICAgICAgICBwcmV2W2N1cnIuc3BsaXQoJy4nKVsxXV0gPSBjdXJyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldltjdXJyXSA9IGN1cnI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2XG4gICAgfSwge30pXG4gIH1cblxuICByZXR1cm4gZmllbGRzXG59O1xuXG4vLyBDb21iaW5lcyB0d28gZmxhZ3MgdXNpbmcgZWl0aGVyIEFORCBvciBPUiBkZXBlbmRpbmcgb24gdGhlIGZsYWcgdHlwZS5cbnZhciBjb21iaW5lID0gZnVuY3Rpb24gKGxocywgcmhzKSB7XG4gIHZhciBtYXBwZXIgPSB7XG4gICAgcHJpc3RpbmU6IGZ1bmN0aW9uIChsaHMsIHJocykgeyByZXR1cm4gbGhzICYmIHJoczsgfSxcbiAgICBkaXJ0eTogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgfHwgcmhzOyB9LFxuICAgIHRvdWNoZWQ6IGZ1bmN0aW9uIChsaHMsIHJocykgeyByZXR1cm4gbGhzIHx8IHJoczsgfSxcbiAgICB1bnRvdWNoZWQ6IGZ1bmN0aW9uIChsaHMsIHJocykgeyByZXR1cm4gbGhzICYmIHJoczsgfSxcbiAgICB2YWxpZDogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgJiYgcmhzOyB9LFxuICAgIGludmFsaWQ6IGZ1bmN0aW9uIChsaHMsIHJocykgeyByZXR1cm4gbGhzIHx8IHJoczsgfSxcbiAgICBwZW5kaW5nOiBmdW5jdGlvbiAobGhzLCByaHMpIHsgcmV0dXJuIGxocyB8fCByaHM7IH0sXG4gICAgcmVxdWlyZWQ6IGZ1bmN0aW9uIChsaHMsIHJocykgeyByZXR1cm4gbGhzIHx8IHJoczsgfSxcbiAgICB2YWxpZGF0ZWQ6IGZ1bmN0aW9uIChsaHMsIHJocykgeyByZXR1cm4gbGhzICYmIHJoczsgfSxcbiAgfTtcblxuICByZXR1cm4gT2JqZWN0LmtleXMobWFwcGVyKS5yZWR1Y2UoZnVuY3Rpb24gKGZsYWdzLCBmbGFnKSB7XG4gICAgZmxhZ3NbZmxhZ10gPSBtYXBwZXJbZmxhZ10obGhzW2ZsYWddLCByaHNbZmxhZ10pO1xuXG4gICAgcmV0dXJuIGZsYWdzXG4gIH0sIHt9KVxufTtcblxudmFyIG1hcFNjb3BlID0gZnVuY3Rpb24gKHNjb3BlLCBkZWVwKSB7XG4gIGlmICggZGVlcCA9PT0gdm9pZCAwICkgZGVlcCA9IHRydWU7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNjb3BlKS5yZWR1Y2UoZnVuY3Rpb24gKGZsYWdzLCBmaWVsZCkge1xuICAgIGlmICghZmxhZ3MpIHtcbiAgICAgIGZsYWdzID0gYXNzaWduKHt9LCBzY29wZVtmaWVsZF0pO1xuICAgICAgcmV0dXJuIGZsYWdzXG4gICAgfVxuXG4gICAgLy8gc2NvcGUuXG4gICAgdmFyIGlzU2NvcGUgPSBmaWVsZC5pbmRleE9mKCckJykgPT09IDA7XG4gICAgaWYgKGRlZXAgJiYgaXNTY29wZSkge1xuICAgICAgcmV0dXJuIGNvbWJpbmUobWFwU2NvcGUoc2NvcGVbZmllbGRdKSwgZmxhZ3MpXG4gICAgfSBlbHNlIGlmICghZGVlcCAmJiBpc1Njb3BlKSB7XG4gICAgICByZXR1cm4gZmxhZ3NcbiAgICB9XG5cbiAgICBmbGFncyA9IGNvbWJpbmUoZmxhZ3MsIHNjb3BlW2ZpZWxkXSk7XG5cbiAgICByZXR1cm4gZmxhZ3NcbiAgfSwgbnVsbClcbn07XG5cbi8qKlxuICogTWFwcyBmaWVsZHMgdG8gY29tcHV0ZWQgZnVuY3Rpb25zLlxuICovXG52YXIgbWFwRmllbGRzID0gZnVuY3Rpb24gKGZpZWxkcykge1xuICBpZiAoIWZpZWxkcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbWFwU2NvcGUodGhpcy4kdmFsaWRhdG9yLmZsYWdzKVxuICAgIH1cbiAgfVxuXG4gIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplKGZpZWxkcyk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhub3JtYWxpemVkKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcbiAgICB2YXIgZmllbGQgPSBub3JtYWxpemVkW2N1cnJdO1xuICAgIHByZXZbY3Vycl0gPSBmdW5jdGlvbiBtYXBwZWRGaWVsZCAoKSB7XG4gICAgICAvLyBpZiBmaWVsZCBleGlzdHNcbiAgICAgIGlmICh0aGlzLiR2YWxpZGF0b3IuZmxhZ3NbZmllbGRdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR2YWxpZGF0b3IuZmxhZ3NbZmllbGRdXG4gICAgICB9XG5cbiAgICAgIC8vIHNjb3BlbGVzcyBmaWVsZHMgd2VyZSBzZWxlY3RlZC5cbiAgICAgIGlmIChub3JtYWxpemVkW2N1cnJdID09PSAnKicpIHtcbiAgICAgICAgcmV0dXJuIG1hcFNjb3BlKHRoaXMuJHZhbGlkYXRvci5mbGFncywgZmFsc2UpXG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGl0IGhhcyBhIHNjb3BlIGRlZmluZWRcbiAgICAgIHZhciBpbmRleCA9IGZpZWxkLmluZGV4T2YoJy4nKTtcbiAgICAgIGlmIChpbmRleCA8PSAwKSB7XG4gICAgICAgIHJldHVybiB7fVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gZmllbGQuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBzY29wZSA9IHJlZlswXTtcbiAgICAgIHZhciBuYW1lID0gcmVmLnNsaWNlKDEpO1xuXG4gICAgICBzY29wZSA9IHRoaXMuJHZhbGlkYXRvci5mbGFnc1soXCIkXCIgKyBzY29wZSldO1xuICAgICAgbmFtZSA9IG5hbWUuam9pbignLicpO1xuXG4gICAgICAvLyBhbiBlbnRpcmUgc2NvcGUgd2FzIHNlbGVjdGVkOiBzY29wZS4qXG4gICAgICBpZiAobmFtZSA9PT0gJyonICYmIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBtYXBTY29wZShzY29wZSlcbiAgICAgIH1cblxuICAgICAgaWYgKHNjb3BlICYmIHNjb3BlW25hbWVdKSB7XG4gICAgICAgIHJldHVybiBzY29wZVtuYW1lXVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge31cbiAgICB9O1xuXG4gICAgcmV0dXJuIHByZXZcbiAgfSwge30pXG59O1xuXG52YXIgdmVyc2lvbiA9ICcyLjAuMyc7XG5cbnZhciBydWxlc1BsdWdpbiA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgdmFyIFZhbGlkYXRvciQkMSA9IHJlZi5WYWxpZGF0b3I7XG5cbiAgT2JqZWN0LmtleXMoUnVsZXMpLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBWYWxpZGF0b3IkJDEuZXh0ZW5kKHJ1bGUsIFJ1bGVzW3J1bGVdKTtcbiAgfSk7XG5cbiAgLy8gTWVyZ2UgdGhlIGVuZ2xpc2ggbWVzc2FnZXMuXG4gIFZhbGlkYXRvciQkMS5sb2NhbGl6ZSgnZW4nLCBsb2NhbGUpO1xufTtcblxudXNlKHJ1bGVzUGx1Z2luKTtcblxuZXhwb3J0IGRlZmF1bHQgVmFsaWRhdG9yO1xuZXhwb3J0IHsgdXNlLCBtYXBGaWVsZHMsIEVycm9yQmFnLCBSdWxlcywgdmVyc2lvbiB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVlLXZhbGlkYXRlL2Rpc3QvcmVlLXZhbGlkYXRlLmVzbS5qc1xuLy8gbW9kdWxlIGlkID0gMzQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDYgNyA4IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRDb250ZW50U3RhdGVGcmFnbWVudFxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9taXplQmxvY2tNYXBLZXlzID0gcmVxdWlyZSgnLi9yYW5kb21pemVCbG9ja01hcEtleXMnKTtcbnZhciByZW1vdmVFbnRpdGllc0F0RWRnZXMgPSByZXF1aXJlKCcuL3JlbW92ZUVudGl0aWVzQXRFZGdlcycpO1xuXG52YXIgZ2V0Q29udGVudFN0YXRlRnJhZ21lbnQgPSBmdW5jdGlvbiBnZXRDb250ZW50U3RhdGVGcmFnbWVudChjb250ZW50U3RhdGUsIHNlbGVjdGlvblN0YXRlKSB7XG4gIHZhciBzdGFydEtleSA9IHNlbGVjdGlvblN0YXRlLmdldFN0YXJ0S2V5KCk7XG4gIHZhciBzdGFydE9mZnNldCA9IHNlbGVjdGlvblN0YXRlLmdldFN0YXJ0T2Zmc2V0KCk7XG4gIHZhciBlbmRLZXkgPSBzZWxlY3Rpb25TdGF0ZS5nZXRFbmRLZXkoKTtcbiAgdmFyIGVuZE9mZnNldCA9IHNlbGVjdGlvblN0YXRlLmdldEVuZE9mZnNldCgpO1xuXG4gIC8vIEVkZ2UgZW50aXRpZXMgc2hvdWxkIGJlIHN0cmlwcGVkIHRvIGVuc3VyZSB0aGF0IHdlIGRvbid0IHByZXNlcnZlXG4gIC8vIGludmFsaWQgcGFydGlhbCBlbnRpdGllcyB3aGVuIHRoZSBmcmFnbWVudCBpcyByZXVzZWQuIFdlIGRvLCBob3dldmVyLFxuICAvLyBwcmVzZXJ2ZSBlbnRpdGllcyB0aGF0IGFyZSBlbnRpcmVseSB3aXRoaW4gdGhlIHNlbGVjdGlvbiByYW5nZS5cbiAgdmFyIGNvbnRlbnRXaXRob3V0RWRnZUVudGl0aWVzID0gcmVtb3ZlRW50aXRpZXNBdEVkZ2VzKGNvbnRlbnRTdGF0ZSwgc2VsZWN0aW9uU3RhdGUpO1xuXG4gIHZhciBibG9ja01hcCA9IGNvbnRlbnRXaXRob3V0RWRnZUVudGl0aWVzLmdldEJsb2NrTWFwKCk7XG4gIHZhciBibG9ja0tleXMgPSBibG9ja01hcC5rZXlTZXEoKTtcbiAgdmFyIHN0YXJ0SW5kZXggPSBibG9ja0tleXMuaW5kZXhPZihzdGFydEtleSk7XG4gIHZhciBlbmRJbmRleCA9IGJsb2NrS2V5cy5pbmRleE9mKGVuZEtleSkgKyAxO1xuXG4gIHJldHVybiByYW5kb21pemVCbG9ja01hcEtleXMoYmxvY2tNYXAuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpLm1hcChmdW5jdGlvbiAoYmxvY2ssIGJsb2NrS2V5KSB7XG4gICAgdmFyIHRleHQgPSBibG9jay5nZXRUZXh0KCk7XG4gICAgdmFyIGNoYXJzID0gYmxvY2suZ2V0Q2hhcmFjdGVyTGlzdCgpO1xuXG4gICAgaWYgKHN0YXJ0S2V5ID09PSBlbmRLZXkpIHtcbiAgICAgIHJldHVybiBibG9jay5tZXJnZSh7XG4gICAgICAgIHRleHQ6IHRleHQuc2xpY2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCksXG4gICAgICAgIGNoYXJhY3Rlckxpc3Q6IGNoYXJzLnNsaWNlKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYmxvY2tLZXkgPT09IHN0YXJ0S2V5KSB7XG4gICAgICByZXR1cm4gYmxvY2subWVyZ2Uoe1xuICAgICAgICB0ZXh0OiB0ZXh0LnNsaWNlKHN0YXJ0T2Zmc2V0KSxcbiAgICAgICAgY2hhcmFjdGVyTGlzdDogY2hhcnMuc2xpY2Uoc3RhcnRPZmZzZXQpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYmxvY2tLZXkgPT09IGVuZEtleSkge1xuICAgICAgcmV0dXJuIGJsb2NrLm1lcmdlKHtcbiAgICAgICAgdGV4dDogdGV4dC5zbGljZSgwLCBlbmRPZmZzZXQpLFxuICAgICAgICBjaGFyYWN0ZXJMaXN0OiBjaGFycy5zbGljZSgwLCBlbmRPZmZzZXQpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2s7XG4gIH0pKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Q29udGVudFN0YXRlRnJhZ21lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2dldENvbnRlbnRTdGF0ZUZyYWdtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX2V4dGVuZHMgPSBfYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERyYWZ0RW50aXR5XG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG52YXIgRHJhZnRFbnRpdHlJbnN0YW5jZSA9IHJlcXVpcmUoJy4vRHJhZnRFbnRpdHlJbnN0YW5jZScpO1xudmFyIEltbXV0YWJsZSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBNYXAgPSBJbW11dGFibGUuTWFwO1xuXG5cbnZhciBpbnN0YW5jZXMgPSBNYXAoKTtcbnZhciBpbnN0YW5jZUtleSA9IDA7XG5cbi8qKlxuICogVGVtcG9yYXJ5IHV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgdGhlIHdhcm5pbmdzXG4gKi9cbmZ1bmN0aW9uIGxvZ1dhcm5pbmcob2xkTWV0aG9kQ2FsbCwgbmV3TWV0aG9kQ2FsbCkge1xuICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6ICcgKyBvbGRNZXRob2RDYWxsICsgJyB3aWxsIGJlIGRlcHJlY2F0ZWQgc29vbiFcXG5QbGVhc2UgdXNlIFwiJyArIG5ld01ldGhvZENhbGwgKyAnXCIgaW5zdGVhZC4nKTtcbn1cblxuLyoqXG4gKiBBIFwiZG9jdW1lbnQgZW50aXR5XCIgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGFcbiAqIHBpZWNlIG9mIHRleHQgaW4gYSBDb250ZW50QmxvY2suXG4gKlxuICogRm9yIGV4YW1wbGUsIGEgYGxpbmtgIGVudGl0eSBtaWdodCBpbmNsdWRlIGEgYHVyaWAgcHJvcGVydHkuIFdoZW4gYVxuICogQ29udGVudEJsb2NrIGlzIHJlbmRlcmVkIGluIHRoZSBicm93c2VyLCB0ZXh0IHRoYXQgcmVmZXJzIHRvIHRoYXQgbGlua1xuICogZW50aXR5IG1heSBiZSByZW5kZXJlZCBhcyBhbiBhbmNob3IsIHdpdGggdGhlIGB1cmlgIGFzIHRoZSBocmVmIHZhbHVlLlxuICpcbiAqIEluIGEgQ29udGVudEJsb2NrLCBldmVyeSBwb3NpdGlvbiBpbiB0aGUgdGV4dCBtYXkgY29ycmVzcG9uZCB0byB6ZXJvXG4gKiBvciBvbmUgZW50aXRpZXMuIFRoaXMgY29ycmVzcG9uZGVuY2UgaXMgdHJhY2tlZCB1c2luZyBhIGtleSBzdHJpbmcsXG4gKiBnZW5lcmF0ZWQgdmlhIERyYWZ0RW50aXR5LmNyZWF0ZSgpIGFuZCB1c2VkIHRvIG9idGFpbiBlbnRpdHkgbWV0YWRhdGFcbiAqIHZpYSBEcmFmdEVudGl0eS5nZXQoKS5cbiAqL1xudmFyIERyYWZ0RW50aXR5ID0ge1xuICAvKipcbiAgICogV0FSTklORzogVGhpcyBtZXRob2Qgd2lsbCBiZSBkZXByZWNhdGVkIHNvb24hXG4gICAqIFBsZWFzZSB1c2UgJ2NvbnRlbnRTdGF0ZS5nZXRMYXN0Q3JlYXRlZEVudGl0eUtleScgaW5zdGVhZC5cbiAgICogLS0tXG4gICAqIEdldCB0aGUgcmFuZG9tIGtleSBzdHJpbmcgZnJvbSB3aGF0ZXZlciBlbnRpdHkgd2FzIGxhc3QgY3JlYXRlZC5cbiAgICogV2UgbmVlZCB0aGlzIHRvIHN1cHBvcnQgdGhlIG5ldyBBUEksIGFzIHBhcnQgb2YgdHJhbnNpdGlvbmluZyB0byBwdXQgRW50aXR5XG4gICAqIHN0b3JhZ2UgaW4gY29udGVudFN0YXRlLlxuICAgKi9cbiAgZ2V0TGFzdENyZWF0ZWRFbnRpdHlLZXk6IGZ1bmN0aW9uIGdldExhc3RDcmVhdGVkRW50aXR5S2V5KCkge1xuICAgIGxvZ1dhcm5pbmcoJ0RyYWZ0RW50aXR5LmdldExhc3RDcmVhdGVkRW50aXR5S2V5JywgJ2NvbnRlbnRTdGF0ZS5nZXRMYXN0Q3JlYXRlZEVudGl0eUtleScpO1xuICAgIHJldHVybiBEcmFmdEVudGl0eS5fX2dldExhc3RDcmVhdGVkRW50aXR5S2V5KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHdpbGwgYmUgZGVwcmVjYXRlZCBzb29uIVxuICAgKiBQbGVhc2UgdXNlICdjb250ZW50U3RhdGUuY3JlYXRlRW50aXR5JyBpbnN0ZWFkLlxuICAgKiAtLS1cbiAgICogQ3JlYXRlIGEgRHJhZnRFbnRpdHlJbnN0YW5jZSBhbmQgc3RvcmUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbC5cbiAgICpcbiAgICogQSByYW5kb20ga2V5IHN0cmluZyB3aWxsIGJlIGdlbmVyYXRlZCBhbmQgcmV0dXJuZWQuIFRoaXMga2V5IG1heVxuICAgKiBiZSB1c2VkIHRvIHRyYWNrIHRoZSBlbnRpdHkncyB1c2FnZSBpbiBhIENvbnRlbnRCbG9jaywgYW5kIGZvclxuICAgKiByZXRyaWV2aW5nIGRhdGEgYWJvdXQgdGhlIGVudGl0eSBhdCByZW5kZXIgdGltZS5cbiAgICovXG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHR5cGUsIG11dGFiaWxpdHksIGRhdGEpIHtcbiAgICBsb2dXYXJuaW5nKCdEcmFmdEVudGl0eS5jcmVhdGUnLCAnY29udGVudFN0YXRlLmNyZWF0ZUVudGl0eScpO1xuICAgIHJldHVybiBEcmFmdEVudGl0eS5fX2NyZWF0ZSh0eXBlLCBtdXRhYmlsaXR5LCBkYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogV0FSTklORzogVGhpcyBtZXRob2Qgd2lsbCBiZSBkZXByZWNhdGVkIHNvb24hXG4gICAqIFBsZWFzZSB1c2UgJ2NvbnRlbnRTdGF0ZS5hZGRFbnRpdHknIGluc3RlYWQuXG4gICAqIC0tLVxuICAgKiBBZGQgYW4gZXhpc3RpbmcgRHJhZnRFbnRpdHlJbnN0YW5jZSB0byB0aGUgRHJhZnRFbnRpdHkgbWFwLiBUaGlzIGlzXG4gICAqIHVzZWZ1bCB3aGVuIHJlc3RvcmluZyBpbnN0YW5jZXMgZnJvbSB0aGUgc2VydmVyLlxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiBhZGQoaW5zdGFuY2UpIHtcbiAgICBsb2dXYXJuaW5nKCdEcmFmdEVudGl0eS5hZGQnLCAnY29udGVudFN0YXRlLmFkZEVudGl0eScpO1xuICAgIHJldHVybiBEcmFmdEVudGl0eS5fX2FkZChpbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHdpbGwgYmUgZGVwcmVjYXRlZCBzb29uIVxuICAgKiBQbGVhc2UgdXNlICdjb250ZW50U3RhdGUuZ2V0RW50aXR5JyBpbnN0ZWFkLlxuICAgKiAtLS1cbiAgICogUmV0cmlldmUgdGhlIGVudGl0eSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdXBwbGllZCBrZXkgc3RyaW5nLlxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgbG9nV2FybmluZygnRHJhZnRFbnRpdHkuZ2V0JywgJ2NvbnRlbnRTdGF0ZS5nZXRFbnRpdHknKTtcbiAgICByZXR1cm4gRHJhZnRFbnRpdHkuX19nZXQoa2V5KTtcbiAgfSxcblxuICAvKipcbiAgICogV0FSTklORzogVGhpcyBtZXRob2Qgd2lsbCBiZSBkZXByZWNhdGVkIHNvb24hXG4gICAqIFBsZWFzZSB1c2UgJ2NvbnRlbnRTdGF0ZS5tZXJnZUVudGl0eURhdGEnIGluc3RlYWQuXG4gICAqIC0tLVxuICAgKiBFbnRpdHkgaW5zdGFuY2VzIGFyZSBpbW11dGFibGUuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aGUgZGF0YSBmb3IgYW5cbiAgICogaW5zdGFuY2UsIHRoaXMgbWV0aG9kIHdpbGwgbWVyZ2UgeW91ciBkYXRhIHVwZGF0ZXMgYW5kIHJldHVybiBhIG5ld1xuICAgKiBpbnN0YW5jZS5cbiAgICovXG4gIG1lcmdlRGF0YTogZnVuY3Rpb24gbWVyZ2VEYXRhKGtleSwgdG9NZXJnZSkge1xuICAgIGxvZ1dhcm5pbmcoJ0RyYWZ0RW50aXR5Lm1lcmdlRGF0YScsICdjb250ZW50U3RhdGUubWVyZ2VFbnRpdHlEYXRhJyk7XG4gICAgcmV0dXJuIERyYWZ0RW50aXR5Ll9fbWVyZ2VEYXRhKGtleSwgdG9NZXJnZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHdpbGwgYmUgZGVwcmVjYXRlZCBzb29uIVxuICAgKiBQbGVhc2UgdXNlICdjb250ZW50U3RhdGUucmVwbGFjZUVudGl0eURhdGEnIGluc3RlYWQuXG4gICAqIC0tLVxuICAgKiBDb21wbGV0ZWx5IHJlcGxhY2UgdGhlIGRhdGEgZm9yIGEgZ2l2ZW4gaW5zdGFuY2UuXG4gICAqL1xuICByZXBsYWNlRGF0YTogZnVuY3Rpb24gcmVwbGFjZURhdGEoa2V5LCBuZXdEYXRhKSB7XG4gICAgbG9nV2FybmluZygnRHJhZnRFbnRpdHkucmVwbGFjZURhdGEnLCAnY29udGVudFN0YXRlLnJlcGxhY2VFbnRpdHlEYXRhJyk7XG4gICAgcmV0dXJuIERyYWZ0RW50aXR5Ll9fcmVwbGFjZURhdGEoa2V5LCBuZXdEYXRhKTtcbiAgfSxcblxuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKldBUk5JTkcqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgLy8gLS0tIHRoZSBhYm92ZSBwdWJsaWMgQVBJIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgbmV4dCB2ZXJzaW9uIG9mIERyYWZ0IVxuICAvLyBUaGUgbWV0aG9kcyBiZWxvdyB0aGlzIGxpbmUgYXJlIHByaXZhdGUgLSBkb24ndCBjYWxsIHRoZW0gZGlyZWN0bHkuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmFuZG9tIGtleSBzdHJpbmcgZnJvbSB3aGF0ZXZlciBlbnRpdHkgd2FzIGxhc3QgY3JlYXRlZC5cbiAgICogV2UgbmVlZCB0aGlzIHRvIHN1cHBvcnQgdGhlIG5ldyBBUEksIGFzIHBhcnQgb2YgdHJhbnNpdGlvbmluZyB0byBwdXQgRW50aXR5XG4gICAqIHN0b3JhZ2UgaW4gY29udGVudFN0YXRlLlxuICAgKi9cbiAgX19nZXRMYXN0Q3JlYXRlZEVudGl0eUtleTogZnVuY3Rpb24gX19nZXRMYXN0Q3JlYXRlZEVudGl0eUtleSgpIHtcbiAgICByZXR1cm4gJycgKyBpbnN0YW5jZUtleTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHJhZnRFbnRpdHlJbnN0YW5jZSBhbmQgc3RvcmUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbC5cbiAgICpcbiAgICogQSByYW5kb20ga2V5IHN0cmluZyB3aWxsIGJlIGdlbmVyYXRlZCBhbmQgcmV0dXJuZWQuIFRoaXMga2V5IG1heVxuICAgKiBiZSB1c2VkIHRvIHRyYWNrIHRoZSBlbnRpdHkncyB1c2FnZSBpbiBhIENvbnRlbnRCbG9jaywgYW5kIGZvclxuICAgKiByZXRyaWV2aW5nIGRhdGEgYWJvdXQgdGhlIGVudGl0eSBhdCByZW5kZXIgdGltZS5cbiAgICovXG4gIF9fY3JlYXRlOiBmdW5jdGlvbiBfX2NyZWF0ZSh0eXBlLCBtdXRhYmlsaXR5LCBkYXRhKSB7XG4gICAgcmV0dXJuIERyYWZ0RW50aXR5Ll9fYWRkKG5ldyBEcmFmdEVudGl0eUluc3RhbmNlKHsgdHlwZTogdHlwZSwgbXV0YWJpbGl0eTogbXV0YWJpbGl0eSwgZGF0YTogZGF0YSB8fCB7fSB9KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBhbiBleGlzdGluZyBEcmFmdEVudGl0eUluc3RhbmNlIHRvIHRoZSBEcmFmdEVudGl0eSBtYXAuIFRoaXMgaXNcbiAgICogdXNlZnVsIHdoZW4gcmVzdG9yaW5nIGluc3RhbmNlcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBfX2FkZDogZnVuY3Rpb24gX19hZGQoaW5zdGFuY2UpIHtcbiAgICB2YXIga2V5ID0gJycgKyArK2luc3RhbmNlS2V5O1xuICAgIGluc3RhbmNlcyA9IGluc3RhbmNlcy5zZXQoa2V5LCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGtleTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGVudGl0eSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdXBwbGllZCBrZXkgc3RyaW5nLlxuICAgKi9cbiAgX19nZXQ6IGZ1bmN0aW9uIF9fZ2V0KGtleSkge1xuICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlcy5nZXQoa2V5KTtcbiAgICAhISFpbnN0YW5jZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIERyYWZ0RW50aXR5IGtleTogJXMuJywga2V5KSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnRpdHkgaW5zdGFuY2VzIGFyZSBpbW11dGFibGUuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aGUgZGF0YSBmb3IgYW5cbiAgICogaW5zdGFuY2UsIHRoaXMgbWV0aG9kIHdpbGwgbWVyZ2UgeW91ciBkYXRhIHVwZGF0ZXMgYW5kIHJldHVybiBhIG5ld1xuICAgKiBpbnN0YW5jZS5cbiAgICovXG4gIF9fbWVyZ2VEYXRhOiBmdW5jdGlvbiBfX21lcmdlRGF0YShrZXksIHRvTWVyZ2UpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBEcmFmdEVudGl0eS5fX2dldChrZXkpO1xuICAgIHZhciBuZXdEYXRhID0gX2V4dGVuZHMoe30sIGluc3RhbmNlLmdldERhdGEoKSwgdG9NZXJnZSk7XG4gICAgdmFyIG5ld0luc3RhbmNlID0gaW5zdGFuY2Uuc2V0KCdkYXRhJywgbmV3RGF0YSk7XG4gICAgaW5zdGFuY2VzID0gaW5zdGFuY2VzLnNldChrZXksIG5ld0luc3RhbmNlKTtcbiAgICByZXR1cm4gbmV3SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXBsZXRlbHkgcmVwbGFjZSB0aGUgZGF0YSBmb3IgYSBnaXZlbiBpbnN0YW5jZS5cbiAgICovXG4gIF9fcmVwbGFjZURhdGE6IGZ1bmN0aW9uIF9fcmVwbGFjZURhdGEoa2V5LCBuZXdEYXRhKSB7XG4gICAgdmFyIGluc3RhbmNlID0gRHJhZnRFbnRpdHkuX19nZXQoa2V5KTtcbiAgICB2YXIgbmV3SW5zdGFuY2UgPSBpbnN0YW5jZS5zZXQoJ2RhdGEnLCBuZXdEYXRhKTtcbiAgICBpbnN0YW5jZXMgPSBpbnN0YW5jZXMuc2V0KGtleSwgbmV3SW5zdGFuY2UpO1xuICAgIHJldHVybiBuZXdJbnN0YW5jZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFmdEVudGl0eTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRHJhZnRFbnRpdHkuanNcbi8vIG1vZHVsZSBpZCA9IDM0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRHJhZnRPZmZzZXRLZXlcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEtFWV9ERUxJTUlURVIgPSAnLSc7XG5cbnZhciBEcmFmdE9mZnNldEtleSA9IHtcbiAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGUoYmxvY2tLZXksIGRlY29yYXRvcktleSwgbGVhZktleSkge1xuICAgIHJldHVybiBibG9ja0tleSArIEtFWV9ERUxJTUlURVIgKyBkZWNvcmF0b3JLZXkgKyBLRVlfREVMSU1JVEVSICsgbGVhZktleTtcbiAgfSxcblxuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZShvZmZzZXRLZXkpIHtcbiAgICB2YXIgX29mZnNldEtleSRzcGxpdCA9IG9mZnNldEtleS5zcGxpdChLRVlfREVMSU1JVEVSKSxcbiAgICAgICAgYmxvY2tLZXkgPSBfb2Zmc2V0S2V5JHNwbGl0WzBdLFxuICAgICAgICBkZWNvcmF0b3JLZXkgPSBfb2Zmc2V0S2V5JHNwbGl0WzFdLFxuICAgICAgICBsZWFmS2V5ID0gX29mZnNldEtleSRzcGxpdFsyXTtcblxuICAgIHJldHVybiB7XG4gICAgICBibG9ja0tleTogYmxvY2tLZXksXG4gICAgICBkZWNvcmF0b3JLZXk6IHBhcnNlSW50KGRlY29yYXRvcktleSwgMTApLFxuICAgICAgbGVhZktleTogcGFyc2VJbnQobGVhZktleSwgMTApXG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFmdE9mZnNldEtleTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRHJhZnRPZmZzZXRLZXkuanNcbi8vIG1vZHVsZSBpZCA9IDM0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ29udGVudFN0YXRlXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEJsb2NrTWFwQnVpbGRlciA9IHJlcXVpcmUoJy4vQmxvY2tNYXBCdWlsZGVyJyk7XG52YXIgQ2hhcmFjdGVyTWV0YWRhdGEgPSByZXF1aXJlKCcuL0NoYXJhY3Rlck1ldGFkYXRhJyk7XG52YXIgQ29udGVudEJsb2NrID0gcmVxdWlyZSgnLi9Db250ZW50QmxvY2snKTtcbnZhciBDb250ZW50QmxvY2tOb2RlID0gcmVxdWlyZSgnLi9Db250ZW50QmxvY2tOb2RlJyk7XG52YXIgRHJhZnRFbnRpdHkgPSByZXF1aXJlKCcuL0RyYWZ0RW50aXR5Jyk7XG52YXIgRHJhZnRGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL0RyYWZ0RmVhdHVyZUZsYWdzJyk7XG52YXIgSW1tdXRhYmxlID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG52YXIgU2VsZWN0aW9uU3RhdGUgPSByZXF1aXJlKCcuL1NlbGVjdGlvblN0YXRlJyk7XG5cbnZhciBnZW5lcmF0ZVJhbmRvbUtleSA9IHJlcXVpcmUoJy4vZ2VuZXJhdGVSYW5kb21LZXknKTtcbnZhciBzYW5pdGl6ZURyYWZ0VGV4dCA9IHJlcXVpcmUoJy4vc2FuaXRpemVEcmFmdFRleHQnKTtcblxudmFyIExpc3QgPSBJbW11dGFibGUuTGlzdCxcbiAgICBSZWNvcmQgPSBJbW11dGFibGUuUmVjb3JkLFxuICAgIFJlcGVhdCA9IEltbXV0YWJsZS5SZXBlYXQ7XG5cblxudmFyIGV4cGVyaW1lbnRhbFRyZWVEYXRhU3VwcG9ydCA9IERyYWZ0RmVhdHVyZUZsYWdzLmRyYWZ0X3RyZWVfZGF0YV9zdXBwb3J0O1xuXG52YXIgZGVmYXVsdFJlY29yZCA9IHtcbiAgZW50aXR5TWFwOiBudWxsLFxuICBibG9ja01hcDogbnVsbCxcbiAgc2VsZWN0aW9uQmVmb3JlOiBudWxsLFxuICBzZWxlY3Rpb25BZnRlcjogbnVsbFxufTtcblxudmFyIENvbnRlbnRCbG9ja05vZGVSZWNvcmQgPSBleHBlcmltZW50YWxUcmVlRGF0YVN1cHBvcnQgPyBDb250ZW50QmxvY2tOb2RlIDogQ29udGVudEJsb2NrO1xuXG52YXIgQ29udGVudFN0YXRlUmVjb3JkID0gUmVjb3JkKGRlZmF1bHRSZWNvcmQpO1xuXG52YXIgQ29udGVudFN0YXRlID0gZnVuY3Rpb24gKF9Db250ZW50U3RhdGVSZWNvcmQpIHtcbiAgX2luaGVyaXRzKENvbnRlbnRTdGF0ZSwgX0NvbnRlbnRTdGF0ZVJlY29yZCk7XG5cbiAgZnVuY3Rpb24gQ29udGVudFN0YXRlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250ZW50U3RhdGUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db250ZW50U3RhdGVSZWNvcmQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBDb250ZW50U3RhdGUucHJvdG90eXBlLmdldEVudGl0eU1hcCA9IGZ1bmN0aW9uIGdldEVudGl0eU1hcCgpIHtcbiAgICAvLyBUT0RPOiB1cGRhdGUgdGhpcyB3aGVuIHdlIGZ1bGx5IHJlbW92ZSBEcmFmdEVudGl0eVxuICAgIHJldHVybiBEcmFmdEVudGl0eTtcbiAgfTtcblxuICBDb250ZW50U3RhdGUucHJvdG90eXBlLmdldEJsb2NrTWFwID0gZnVuY3Rpb24gZ2V0QmxvY2tNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdibG9ja01hcCcpO1xuICB9O1xuXG4gIENvbnRlbnRTdGF0ZS5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uQmVmb3JlID0gZnVuY3Rpb24gZ2V0U2VsZWN0aW9uQmVmb3JlKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnc2VsZWN0aW9uQmVmb3JlJyk7XG4gIH07XG5cbiAgQ29udGVudFN0YXRlLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25BZnRlciA9IGZ1bmN0aW9uIGdldFNlbGVjdGlvbkFmdGVyKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnc2VsZWN0aW9uQWZ0ZXInKTtcbiAgfTtcblxuICBDb250ZW50U3RhdGUucHJvdG90eXBlLmdldEJsb2NrRm9yS2V5ID0gZnVuY3Rpb24gZ2V0QmxvY2tGb3JLZXkoa2V5KSB7XG4gICAgdmFyIGJsb2NrID0gdGhpcy5nZXRCbG9ja01hcCgpLmdldChrZXkpO1xuICAgIHJldHVybiBibG9jaztcbiAgfTtcblxuICBDb250ZW50U3RhdGUucHJvdG90eXBlLmdldEtleUJlZm9yZSA9IGZ1bmN0aW9uIGdldEtleUJlZm9yZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCbG9ja01hcCgpLnJldmVyc2UoKS5rZXlTZXEoKS5za2lwVW50aWwoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ID09PSBrZXk7XG4gICAgfSkuc2tpcCgxKS5maXJzdCgpO1xuICB9O1xuXG4gIENvbnRlbnRTdGF0ZS5wcm90b3R5cGUuZ2V0S2V5QWZ0ZXIgPSBmdW5jdGlvbiBnZXRLZXlBZnRlcihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCbG9ja01hcCgpLmtleVNlcSgpLnNraXBVbnRpbChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYgPT09IGtleTtcbiAgICB9KS5za2lwKDEpLmZpcnN0KCk7XG4gIH07XG5cbiAgQ29udGVudFN0YXRlLnByb3RvdHlwZS5nZXRCbG9ja0FmdGVyID0gZnVuY3Rpb24gZ2V0QmxvY2tBZnRlcihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCbG9ja01hcCgpLnNraXBVbnRpbChmdW5jdGlvbiAoXywgaykge1xuICAgICAgcmV0dXJuIGsgPT09IGtleTtcbiAgICB9KS5za2lwKDEpLmZpcnN0KCk7XG4gIH07XG5cbiAgQ29udGVudFN0YXRlLnByb3RvdHlwZS5nZXRCbG9ja0JlZm9yZSA9IGZ1bmN0aW9uIGdldEJsb2NrQmVmb3JlKGtleSkge1xuICAgIHJldHVybiB0aGlzLmdldEJsb2NrTWFwKCkucmV2ZXJzZSgpLnNraXBVbnRpbChmdW5jdGlvbiAoXywgaykge1xuICAgICAgcmV0dXJuIGsgPT09IGtleTtcbiAgICB9KS5za2lwKDEpLmZpcnN0KCk7XG4gIH07XG5cbiAgQ29udGVudFN0YXRlLnByb3RvdHlwZS5nZXRCbG9ja3NBc0FycmF5ID0gZnVuY3Rpb24gZ2V0QmxvY2tzQXNBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCbG9ja01hcCgpLnRvQXJyYXkoKTtcbiAgfTtcblxuICBDb250ZW50U3RhdGUucHJvdG90eXBlLmdldEZpcnN0QmxvY2sgPSBmdW5jdGlvbiBnZXRGaXJzdEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmdldEJsb2NrTWFwKCkuZmlyc3QoKTtcbiAgfTtcblxuICBDb250ZW50U3RhdGUucHJvdG90eXBlLmdldExhc3RCbG9jayA9IGZ1bmN0aW9uIGdldExhc3RCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCbG9ja01hcCgpLmxhc3QoKTtcbiAgfTtcblxuICBDb250ZW50U3RhdGUucHJvdG90eXBlLmdldFBsYWluVGV4dCA9IGZ1bmN0aW9uIGdldFBsYWluVGV4dChkZWxpbWl0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCbG9ja01hcCgpLm1hcChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgIHJldHVybiBibG9jayA/IGJsb2NrLmdldFRleHQoKSA6ICcnO1xuICAgIH0pLmpvaW4oZGVsaW1pdGVyIHx8ICdcXG4nKTtcbiAgfTtcblxuICBDb250ZW50U3RhdGUucHJvdG90eXBlLmdldExhc3RDcmVhdGVkRW50aXR5S2V5ID0gZnVuY3Rpb24gZ2V0TGFzdENyZWF0ZWRFbnRpdHlLZXkoKSB7XG4gICAgLy8gVE9ETzogdXBkYXRlIHRoaXMgd2hlbiB3ZSBmdWxseSByZW1vdmUgRHJhZnRFbnRpdHlcbiAgICByZXR1cm4gRHJhZnRFbnRpdHkuX19nZXRMYXN0Q3JlYXRlZEVudGl0eUtleSgpO1xuICB9O1xuXG4gIENvbnRlbnRTdGF0ZS5wcm90b3R5cGUuaGFzVGV4dCA9IGZ1bmN0aW9uIGhhc1RleHQoKSB7XG4gICAgdmFyIGJsb2NrTWFwID0gdGhpcy5nZXRCbG9ja01hcCgpO1xuICAgIHJldHVybiBibG9ja01hcC5zaXplID4gMSB8fCBibG9ja01hcC5maXJzdCgpLmdldExlbmd0aCgpID4gMDtcbiAgfTtcblxuICBDb250ZW50U3RhdGUucHJvdG90eXBlLmNyZWF0ZUVudGl0eSA9IGZ1bmN0aW9uIGNyZWF0ZUVudGl0eSh0eXBlLCBtdXRhYmlsaXR5LCBkYXRhKSB7XG4gICAgLy8gVE9ETzogdXBkYXRlIHRoaXMgd2hlbiB3ZSBmdWxseSByZW1vdmUgRHJhZnRFbnRpdHlcbiAgICBEcmFmdEVudGl0eS5fX2NyZWF0ZSh0eXBlLCBtdXRhYmlsaXR5LCBkYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDb250ZW50U3RhdGUucHJvdG90eXBlLm1lcmdlRW50aXR5RGF0YSA9IGZ1bmN0aW9uIG1lcmdlRW50aXR5RGF0YShrZXksIHRvTWVyZ2UpIHtcbiAgICAvLyBUT0RPOiB1cGRhdGUgdGhpcyB3aGVuIHdlIGZ1bGx5IHJlbW92ZSBEcmFmdEVudGl0eVxuICAgIERyYWZ0RW50aXR5Ll9fbWVyZ2VEYXRhKGtleSwgdG9NZXJnZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ29udGVudFN0YXRlLnByb3RvdHlwZS5yZXBsYWNlRW50aXR5RGF0YSA9IGZ1bmN0aW9uIHJlcGxhY2VFbnRpdHlEYXRhKGtleSwgbmV3RGF0YSkge1xuICAgIC8vIFRPRE86IHVwZGF0ZSB0aGlzIHdoZW4gd2UgZnVsbHkgcmVtb3ZlIERyYWZ0RW50aXR5XG4gICAgRHJhZnRFbnRpdHkuX19yZXBsYWNlRGF0YShrZXksIG5ld0RhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENvbnRlbnRTdGF0ZS5wcm90b3R5cGUuYWRkRW50aXR5ID0gZnVuY3Rpb24gYWRkRW50aXR5KGluc3RhbmNlKSB7XG4gICAgLy8gVE9ETzogdXBkYXRlIHRoaXMgd2hlbiB3ZSBmdWxseSByZW1vdmUgRHJhZnRFbnRpdHlcbiAgICBEcmFmdEVudGl0eS5fX2FkZChpbnN0YW5jZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ29udGVudFN0YXRlLnByb3RvdHlwZS5nZXRFbnRpdHkgPSBmdW5jdGlvbiBnZXRFbnRpdHkoa2V5KSB7XG4gICAgLy8gVE9ETzogdXBkYXRlIHRoaXMgd2hlbiB3ZSBmdWxseSByZW1vdmUgRHJhZnRFbnRpdHlcbiAgICByZXR1cm4gRHJhZnRFbnRpdHkuX19nZXQoa2V5KTtcbiAgfTtcblxuICBDb250ZW50U3RhdGUuY3JlYXRlRnJvbUJsb2NrQXJyYXkgPSBmdW5jdGlvbiBjcmVhdGVGcm9tQmxvY2tBcnJheShcbiAgLy8gVE9ETzogdXBkYXRlIGZsb3cgdHlwZSB3aGVuIHdlIGNvbXBsZXRlbHkgZGVwcmVjYXRlIHRoZSBvbGQgZW50aXR5IEFQSVxuICBibG9ja3MsIGVudGl0eU1hcCkge1xuICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIHdoZW4gd2UgY29tcGxldGVseSBkZXByZWNhdGUgdGhlIG9sZCBlbnRpdHkgQVBJXG4gICAgdmFyIHRoZUJsb2NrcyA9IEFycmF5LmlzQXJyYXkoYmxvY2tzKSA/IGJsb2NrcyA6IGJsb2Nrcy5jb250ZW50QmxvY2tzO1xuICAgIHZhciBibG9ja01hcCA9IEJsb2NrTWFwQnVpbGRlci5jcmVhdGVGcm9tQXJyYXkodGhlQmxvY2tzKTtcbiAgICB2YXIgc2VsZWN0aW9uU3RhdGUgPSBibG9ja01hcC5pc0VtcHR5KCkgPyBuZXcgU2VsZWN0aW9uU3RhdGUoKSA6IFNlbGVjdGlvblN0YXRlLmNyZWF0ZUVtcHR5KGJsb2NrTWFwLmZpcnN0KCkuZ2V0S2V5KCkpO1xuICAgIHJldHVybiBuZXcgQ29udGVudFN0YXRlKHtcbiAgICAgIGJsb2NrTWFwOiBibG9ja01hcCxcbiAgICAgIGVudGl0eU1hcDogZW50aXR5TWFwIHx8IERyYWZ0RW50aXR5LFxuICAgICAgc2VsZWN0aW9uQmVmb3JlOiBzZWxlY3Rpb25TdGF0ZSxcbiAgICAgIHNlbGVjdGlvbkFmdGVyOiBzZWxlY3Rpb25TdGF0ZVxuICAgIH0pO1xuICB9O1xuXG4gIENvbnRlbnRTdGF0ZS5jcmVhdGVGcm9tVGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZUZyb21UZXh0KHRleHQpIHtcbiAgICB2YXIgZGVsaW1pdGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAvXFxyXFxuP3xcXG4vZztcblxuICAgIHZhciBzdHJpbmdzID0gdGV4dC5zcGxpdChkZWxpbWl0ZXIpO1xuICAgIHZhciBibG9ja3MgPSBzdHJpbmdzLm1hcChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgIGJsb2NrID0gc2FuaXRpemVEcmFmdFRleHQoYmxvY2spO1xuICAgICAgcmV0dXJuIG5ldyBDb250ZW50QmxvY2tOb2RlUmVjb3JkKHtcbiAgICAgICAga2V5OiBnZW5lcmF0ZVJhbmRvbUtleSgpLFxuICAgICAgICB0ZXh0OiBibG9jayxcbiAgICAgICAgdHlwZTogJ3Vuc3R5bGVkJyxcbiAgICAgICAgY2hhcmFjdGVyTGlzdDogTGlzdChSZXBlYXQoQ2hhcmFjdGVyTWV0YWRhdGEuRU1QVFksIGJsb2NrLmxlbmd0aCkpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gQ29udGVudFN0YXRlLmNyZWF0ZUZyb21CbG9ja0FycmF5KGJsb2Nrcyk7XG4gIH07XG5cbiAgcmV0dXJuIENvbnRlbnRTdGF0ZTtcbn0oQ29udGVudFN0YXRlUmVjb3JkKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250ZW50U3RhdGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0NvbnRlbnRTdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzYW5pdGl6ZURyYWZ0VGV4dFxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUkVHRVhfQkxPQ0tfREVMSU1JVEVSID0gbmV3IFJlZ0V4cCgnXFxyJywgJ2cnKTtcblxuZnVuY3Rpb24gc2FuaXRpemVEcmFmdFRleHQoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoUkVHRVhfQkxPQ0tfREVMSU1JVEVSLCAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FuaXRpemVEcmFmdFRleHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL3Nhbml0aXplRHJhZnRUZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4vKipcbiAqIENvbnN0YW50cyB0byByZXByZXNlbnQgdGV4dCBkaXJlY3Rpb25hbGl0eVxuICpcbiAqIEFsc28gZGVmaW5lcyBhICpnbG9iYWwqIGRpcmVjaXRvbiwgdG8gYmUgdXNlZCBpbiBiaWRpIGFsZ29yaXRobXMgYXMgYVxuICogZGVmYXVsdCBmYWxsYmFjayBkaXJlY2l0b24sIHdoZW4gbm8gYmV0dGVyIGRpcmVjdGlvbiBpcyBmb3VuZCBvciBwcm92aWRlZC5cbiAqXG4gKiBOT1RFOiBVc2UgYHNldEdsb2JhbERpcigpYCwgb3IgdXBkYXRlIGBpbml0R2xvYmFsRGlyKClgLCB0byBzZXQgdGhlIGluaXRpYWxcbiAqICAgICAgIGdsb2JhbCBkaXJlY3Rpb24gdmFsdWUgYmFzZWQgb24gdGhlIGFwcGxpY2F0aW9uLlxuICpcbiAqIFBhcnQgb2YgdGhlIGltcGxlbWVudGF0aW9uIG9mIFVuaWNvZGUgQmlkaXJlY3Rpb25hbCBBbGdvcml0aG0gKFVCQSlcbiAqIFVuaWNvZGUgU3RhbmRhcmQgQW5uZXggIzkgKFVBWDkpXG4gKiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHI5L1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbnZhciBORVVUUkFMID0gJ05FVVRSQUwnOyAvLyBObyBzdHJvbmcgZGlyZWN0aW9uXG52YXIgTFRSID0gJ0xUUic7IC8vIExlZnQtdG8tUmlnaHQgZGlyZWN0aW9uXG52YXIgUlRMID0gJ1JUTCc7IC8vIFJpZ2h0LXRvLUxlZnQgZGlyZWN0aW9uXG5cbnZhciBnbG9iYWxEaXIgPSBudWxsO1xuXG4vLyA9PSBIZWxwZXJzID09XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBkaXJlY3Rpb25hbGl0eSB2YWx1ZSBpcyBhIFN0cm9uZyBvbmVcbiAqL1xuZnVuY3Rpb24gaXNTdHJvbmcoZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IExUUiB8fCBkaXIgPT09IFJUTDtcbn1cblxuLyoqXG4gKiBHZXQgc3RyaW5nIHZhbHVlIHRvIGJlIHVzZWQgZm9yIGBkaXJgIEhUTUwgYXR0cmlidXRlIG9yIGBkaXJlY3Rpb25gIENTU1xuICogcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEhUTUxEaXIoZGlyKSB7XG4gICFpc1N0cm9uZyhkaXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2BkaXJgIG11c3QgYmUgYSBzdHJvbmcgZGlyZWN0aW9uIHRvIGJlIGNvbnZlcnRlZCB0byBIVE1MIERpcmVjdGlvbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRpciA9PT0gTFRSID8gJ2x0cicgOiAncnRsJztcbn1cblxuLyoqXG4gKiBHZXQgc3RyaW5nIHZhbHVlIHRvIGJlIHVzZWQgZm9yIGBkaXJgIEhUTUwgYXR0cmlidXRlIG9yIGBkaXJlY3Rpb25gIENTU1xuICogcHJvcGVydHksIGJ1dCByZXR1cm5zIG51bGwgaWYgYGRpcmAgaGFzIHNhbWUgdmFsdWUgYXMgYG90aGVyRGlyYC5cbiAqIGBudWxsYC5cbiAqL1xuZnVuY3Rpb24gZ2V0SFRNTERpcklmRGlmZmVyZW50KGRpciwgb3RoZXJEaXIpIHtcbiAgIWlzU3Ryb25nKGRpcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYGRpcmAgbXVzdCBiZSBhIHN0cm9uZyBkaXJlY3Rpb24gdG8gYmUgY29udmVydGVkIHRvIEhUTUwgRGlyZWN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhaXNTdHJvbmcob3RoZXJEaXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2BvdGhlckRpcmAgbXVzdCBiZSBhIHN0cm9uZyBkaXJlY3Rpb24gdG8gYmUgY29udmVydGVkIHRvIEhUTUwgRGlyZWN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gZGlyID09PSBvdGhlckRpciA/IG51bGwgOiBnZXRIVE1MRGlyKGRpcik7XG59XG5cbi8vID09IEdsb2JhbCBEaXJlY3Rpb24gPT1cblxuLyoqXG4gKiBTZXQgdGhlIGdsb2JhbCBkaXJlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNldEdsb2JhbERpcihkaXIpIHtcbiAgZ2xvYmFsRGlyID0gZGlyO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGdsb2JhbCBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gaW5pdEdsb2JhbERpcigpIHtcbiAgc2V0R2xvYmFsRGlyKExUUik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBnbG9iYWwgZGlyZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldEdsb2JhbERpcigpIHtcbiAgaWYgKCFnbG9iYWxEaXIpIHtcbiAgICB0aGlzLmluaXRHbG9iYWxEaXIoKTtcbiAgfVxuICAhZ2xvYmFsRGlyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0dsb2JhbCBkaXJlY3Rpb24gbm90IHNldC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBnbG9iYWxEaXI7XG59XG5cbnZhciBVbmljb2RlQmlkaURpcmVjdGlvbiA9IHtcbiAgLy8gVmFsdWVzXG4gIE5FVVRSQUw6IE5FVVRSQUwsXG4gIExUUjogTFRSLFxuICBSVEw6IFJUTCxcbiAgLy8gSGVscGVyc1xuICBpc1N0cm9uZzogaXNTdHJvbmcsXG4gIGdldEhUTUxEaXI6IGdldEhUTUxEaXIsXG4gIGdldEhUTUxEaXJJZkRpZmZlcmVudDogZ2V0SFRNTERpcklmRGlmZmVyZW50LFxuICAvLyBHbG9iYWwgRGlyZWN0aW9uXG4gIHNldEdsb2JhbERpcjogc2V0R2xvYmFsRGlyLFxuICBpbml0R2xvYmFsRGlyOiBpbml0R2xvYmFsRGlyLFxuICBnZXRHbG9iYWxEaXI6IGdldEdsb2JhbERpclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmljb2RlQmlkaURpcmVjdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9Vbmljb2RlQmlkaURpcmVjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEZWZhdWx0RHJhZnRCbG9ja1JlbmRlck1hcFxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdpbW11dGFibGUnKSxcbiAgICBNYXAgPSBfcmVxdWlyZS5NYXA7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBjeCA9IHJlcXVpcmUoJ2ZianMvbGliL2N4Jyk7XG5cbnZhciBVTF9XUkFQID0gUmVhY3QuY3JlYXRlRWxlbWVudCgndWwnLCB7IGNsYXNzTmFtZTogY3goJ3B1YmxpYy9EcmFmdFN0eWxlRGVmYXVsdC91bCcpIH0pO1xudmFyIE9MX1dSQVAgPSBSZWFjdC5jcmVhdGVFbGVtZW50KCdvbCcsIHsgY2xhc3NOYW1lOiBjeCgncHVibGljL0RyYWZ0U3R5bGVEZWZhdWx0L29sJykgfSk7XG52YXIgUFJFX1dSQVAgPSBSZWFjdC5jcmVhdGVFbGVtZW50KCdwcmUnLCB7IGNsYXNzTmFtZTogY3goJ3B1YmxpYy9EcmFmdFN0eWxlRGVmYXVsdC9wcmUnKSB9KTtcblxudmFyIERlZmF1bHREcmFmdEJsb2NrUmVuZGVyTWFwID0gTWFwKHtcbiAgJ2hlYWRlci1vbmUnOiB7XG4gICAgZWxlbWVudDogJ2gxJ1xuICB9LFxuICAnaGVhZGVyLXR3byc6IHtcbiAgICBlbGVtZW50OiAnaDInXG4gIH0sXG4gICdoZWFkZXItdGhyZWUnOiB7XG4gICAgZWxlbWVudDogJ2gzJ1xuICB9LFxuICAnaGVhZGVyLWZvdXInOiB7XG4gICAgZWxlbWVudDogJ2g0J1xuICB9LFxuICAnaGVhZGVyLWZpdmUnOiB7XG4gICAgZWxlbWVudDogJ2g1J1xuICB9LFxuICAnaGVhZGVyLXNpeCc6IHtcbiAgICBlbGVtZW50OiAnaDYnXG4gIH0sXG4gICd1bm9yZGVyZWQtbGlzdC1pdGVtJzoge1xuICAgIGVsZW1lbnQ6ICdsaScsXG4gICAgd3JhcHBlcjogVUxfV1JBUFxuICB9LFxuICAnb3JkZXJlZC1saXN0LWl0ZW0nOiB7XG4gICAgZWxlbWVudDogJ2xpJyxcbiAgICB3cmFwcGVyOiBPTF9XUkFQXG4gIH0sXG4gIGJsb2NrcXVvdGU6IHtcbiAgICBlbGVtZW50OiAnYmxvY2txdW90ZSdcbiAgfSxcbiAgYXRvbWljOiB7XG4gICAgZWxlbWVudDogJ2ZpZ3VyZSdcbiAgfSxcbiAgJ2NvZGUtYmxvY2snOiB7XG4gICAgZWxlbWVudDogJ3ByZScsXG4gICAgd3JhcHBlcjogUFJFX1dSQVBcbiAgfSxcbiAgdW5zdHlsZWQ6IHtcbiAgICBlbGVtZW50OiAnZGl2JyxcbiAgICBhbGlhc2VkRWxlbWVudHM6IFsncCddXG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHREcmFmdEJsb2NrUmVuZGVyTWFwO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EZWZhdWx0RHJhZnRCbG9ja1JlbmRlck1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMzUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCQUNLU1BBQ0U6IDgsXG4gIFRBQjogOSxcbiAgUkVUVVJOOiAxMyxcbiAgQUxUOiAxOCxcbiAgRVNDOiAyNyxcbiAgU1BBQ0U6IDMyLFxuICBQQUdFX1VQOiAzMyxcbiAgUEFHRV9ET1dOOiAzNCxcbiAgRU5EOiAzNSxcbiAgSE9NRTogMzYsXG4gIExFRlQ6IDM3LFxuICBVUDogMzgsXG4gIFJJR0hUOiAzOSxcbiAgRE9XTjogNDAsXG4gIERFTEVURTogNDYsXG4gIENPTU1BOiAxODgsXG4gIFBFUklPRDogMTkwLFxuICBBOiA2NSxcbiAgWjogOTAsXG4gIFpFUk86IDQ4LFxuICBOVU1QQURfMDogOTYsXG4gIE5VTVBBRF85OiAxMDVcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvS2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMzUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFbnRpdHlLZXlGb3JTZWxlY3Rpb25cbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGVudGl0eSBrZXkgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGluc2VydGluZyB0ZXh0IGZvciB0aGVcbiAqIHNwZWNpZmllZCB0YXJnZXQgc2VsZWN0aW9uLCBvbmx5IGlmIHRoZSBlbnRpdHkgaXMgYE1VVEFCTEVgLiBgSU1NVVRBQkxFYFxuICogYW5kIGBTRUdNRU5URURgIGVudGl0aWVzIHNob3VsZCBub3QgYmUgdXNlZCBmb3IgaW5zZXJ0aW9uIGJlaGF2aW9yLlxuICovXG5mdW5jdGlvbiBnZXRFbnRpdHlLZXlGb3JTZWxlY3Rpb24oY29udGVudFN0YXRlLCB0YXJnZXRTZWxlY3Rpb24pIHtcbiAgdmFyIGVudGl0eUtleTtcblxuICBpZiAodGFyZ2V0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICB2YXIga2V5ID0gdGFyZ2V0U2VsZWN0aW9uLmdldEFuY2hvcktleSgpO1xuICAgIHZhciBvZmZzZXQgPSB0YXJnZXRTZWxlY3Rpb24uZ2V0QW5jaG9yT2Zmc2V0KCk7XG4gICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgIGVudGl0eUtleSA9IGNvbnRlbnRTdGF0ZS5nZXRCbG9ja0ZvcktleShrZXkpLmdldEVudGl0eUF0KG9mZnNldCAtIDEpO1xuICAgICAgaWYgKGVudGl0eUtleSAhPT0gY29udGVudFN0YXRlLmdldEJsb2NrRm9yS2V5KGtleSkuZ2V0RW50aXR5QXQob2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWx0ZXJLZXkoY29udGVudFN0YXRlLmdldEVudGl0eU1hcCgpLCBlbnRpdHlLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzdGFydEtleSA9IHRhcmdldFNlbGVjdGlvbi5nZXRTdGFydEtleSgpO1xuICB2YXIgc3RhcnRPZmZzZXQgPSB0YXJnZXRTZWxlY3Rpb24uZ2V0U3RhcnRPZmZzZXQoKTtcbiAgdmFyIHN0YXJ0QmxvY2sgPSBjb250ZW50U3RhdGUuZ2V0QmxvY2tGb3JLZXkoc3RhcnRLZXkpO1xuXG4gIGVudGl0eUtleSA9IHN0YXJ0T2Zmc2V0ID09PSBzdGFydEJsb2NrLmdldExlbmd0aCgpID8gbnVsbCA6IHN0YXJ0QmxvY2suZ2V0RW50aXR5QXQoc3RhcnRPZmZzZXQpO1xuXG4gIHJldHVybiBmaWx0ZXJLZXkoY29udGVudFN0YXRlLmdldEVudGl0eU1hcCgpLCBlbnRpdHlLZXkpO1xufVxuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIGFuIGVudGl0eSBrZXkgY29ycmVzcG9uZHMgdG8gYSBgTVVUQUJMRWAgZW50aXR5LiBJZiBzbyxcbiAqIHJldHVybiBpdC4gSWYgbm90LCByZXR1cm4gbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmlsdGVyS2V5KGVudGl0eU1hcCwgZW50aXR5S2V5KSB7XG4gIGlmIChlbnRpdHlLZXkpIHtcbiAgICB2YXIgZW50aXR5ID0gZW50aXR5TWFwLl9fZ2V0KGVudGl0eUtleSk7XG4gICAgcmV0dXJuIGVudGl0eS5nZXRNdXRhYmlsaXR5KCkgPT09ICdNVVRBQkxFJyA/IGVudGl0eUtleSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RW50aXR5S2V5Rm9yU2VsZWN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXRFbnRpdHlLZXlGb3JTZWxlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDM1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBnZXRTdHlsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9nZXRTdHlsZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogQHBhcmFtIHtET01Ob2RlfSBlbGVtZW50IFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE92ZXJmbG93IHN0eWxlIHByb3BlcnR5IG5hbWUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdXBwbGllZCBuZG9lIGlzIHNjcm9sbGFibGUuXG4gKi9cbmZ1bmN0aW9uIF9pc05vZGVTY3JvbGxhYmxlKGVsZW1lbnQsIG5hbWUpIHtcbiAgdmFyIG92ZXJmbG93ID0gU3R5bGUuZ2V0KGVsZW1lbnQsIG5hbWUpO1xuICByZXR1cm4gb3ZlcmZsb3cgPT09ICdhdXRvJyB8fCBvdmVyZmxvdyA9PT0gJ3Njcm9sbCc7XG59XG5cbi8qKlxuICogVXRpbGl0aWVzIGZvciBxdWVyeWluZyBhbmQgbXV0YXRpbmcgc3R5bGUgcHJvcGVydGllcy5cbiAqL1xudmFyIFN0eWxlID0ge1xuICAvKipcbiAgICogR2V0cyB0aGUgc3R5bGUgcHJvcGVydHkgZm9yIHRoZSBzdXBwbGllZCBub2RlLiBUaGlzIHdpbGwgcmV0dXJuIGVpdGhlciB0aGVcbiAgICogY29tcHV0ZWQgc3R5bGUsIGlmIGF2YWlsYWJsZSwgb3IgdGhlIGRlY2xhcmVkIHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTU5vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU3R5bGUgcHJvcGVydHkgbmFtZS5cbiAgICogQHJldHVybiB7P3N0cmluZ30gU3R5bGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBnZXQ6IGdldFN0eWxlUHJvcGVydHksXG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIG5lYXJlc3QgYW5jZXN0b3Igb2YgYSBub2RlIHRoYXQgaXMgc2Nyb2xsYWJsZS5cbiAgICpcbiAgICogTk9URTogVGhpcyBjYW4gYmUgZXhwZW5zaXZlIGlmIHVzZWQgcmVwZWF0ZWRseSBvciBvbiBhIG5vZGUgbmVzdGVkIGRlZXBseS5cbiAgICpcbiAgICogQHBhcmFtIHs/RE9NTm9kZX0gbm9kZSBOb2RlIGZyb20gd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nLlxuICAgKiBAcmV0dXJuIHs/RE9NV2luZG93fERPTUVsZW1lbnR9IFNjcm9sbCBwYXJlbnQgb2YgdGhlIHN1cHBsaWVkIG5vZGUuXG4gICAqL1xuICBnZXRTY3JvbGxQYXJlbnQ6IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gb3duZXJEb2N1bWVudC5ib2R5KSB7XG4gICAgICBpZiAoX2lzTm9kZVNjcm9sbGFibGUobm9kZSwgJ292ZXJmbG93JykgfHwgX2lzTm9kZVNjcm9sbGFibGUobm9kZSwgJ292ZXJmbG93WScpIHx8IF9pc05vZGVTY3JvbGxhYmxlKG5vZGUsICdvdmVyZmxvd1gnKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IG93bmVyRG9jdW1lbnQucGFyZW50V2luZG93O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDM1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnZXREb2N1bWVudFNjcm9sbEVsZW1lbnQgPSByZXF1aXJlKCcuL2dldERvY3VtZW50U2Nyb2xsRWxlbWVudCcpO1xudmFyIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uID0gcmVxdWlyZSgnLi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbicpO1xuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc3VwcGxpZWQgZWxlbWVudCBvciB3aW5kb3cuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZXMgYXJlIGJvdW5kZWQuIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlzXG4gKiBuZWdhdGl2ZSBvciBleGNlZWRzIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nIGluZXJ0aWFsXG4gKiBzY3JvbGxpbmcpLCB5b3Ugd2lsbCBnZXQgemVybyBvciB0aGUgbWF4aW11bSBzY3JvbGwgcG9zaXRpb24sIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0aGUgdW5ib3VuZCBzY3JvbGwgcG9zaXRpb24sIHVzZSBgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb25gLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZSkge1xuICB2YXIgZG9jdW1lbnRTY3JvbGxFbGVtZW50ID0gZ2V0RG9jdW1lbnRTY3JvbGxFbGVtZW50KHNjcm9sbGFibGUub3duZXJEb2N1bWVudCB8fCBzY3JvbGxhYmxlLmRvY3VtZW50KTtcbiAgaWYgKHNjcm9sbGFibGUuV2luZG93ICYmIHNjcm9sbGFibGUgaW5zdGFuY2VvZiBzY3JvbGxhYmxlLldpbmRvdykge1xuICAgIHNjcm9sbGFibGUgPSBkb2N1bWVudFNjcm9sbEVsZW1lbnQ7XG4gIH1cbiAgdmFyIHNjcm9sbFBvc2l0aW9uID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZSk7XG5cbiAgdmFyIHZpZXdwb3J0ID0gc2Nyb2xsYWJsZSA9PT0gZG9jdW1lbnRTY3JvbGxFbGVtZW50ID8gc2Nyb2xsYWJsZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IHNjcm9sbGFibGU7XG5cbiAgdmFyIHhNYXggPSBzY3JvbGxhYmxlLnNjcm9sbFdpZHRoIC0gdmlld3BvcnQuY2xpZW50V2lkdGg7XG4gIHZhciB5TWF4ID0gc2Nyb2xsYWJsZS5zY3JvbGxIZWlnaHQgLSB2aWV3cG9ydC5jbGllbnRIZWlnaHQ7XG5cbiAgc2Nyb2xsUG9zaXRpb24ueCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbFBvc2l0aW9uLngsIHhNYXgpKTtcbiAgc2Nyb2xsUG9zaXRpb24ueSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbFBvc2l0aW9uLnksIHlNYXgpKTtcblxuICByZXR1cm4gc2Nyb2xsUG9zaXRpb247XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U2Nyb2xsUG9zaXRpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0U2Nyb2xsUG9zaXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDM1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmluZEFuY2VzdG9yT2Zmc2V0S2V5XG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnZXRTZWxlY3Rpb25PZmZzZXRLZXlGb3JOb2RlID0gcmVxdWlyZSgnLi9nZXRTZWxlY3Rpb25PZmZzZXRLZXlGb3JOb2RlJyk7XG5cbi8qKlxuICogR2V0IHRoZSBrZXkgZnJvbSB0aGUgbm9kZSdzIG5lYXJlc3Qgb2Zmc2V0LWF3YXJlIGFuY2VzdG9yLlxuICovXG5mdW5jdGlvbiBmaW5kQW5jZXN0b3JPZmZzZXRLZXkobm9kZSkge1xuICB2YXIgc2VhcmNoTm9kZSA9IG5vZGU7XG4gIHdoaWxlIChzZWFyY2hOb2RlICYmIHNlYXJjaE5vZGUgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHZhciBrZXkgPSBnZXRTZWxlY3Rpb25PZmZzZXRLZXlGb3JOb2RlKHNlYXJjaE5vZGUpO1xuICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgc2VhcmNoTm9kZSA9IHNlYXJjaE5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kQW5jZXN0b3JPZmZzZXRLZXk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2ZpbmRBbmNlc3Rvck9mZnNldEtleS5qc1xuLy8gbW9kdWxlIGlkID0gMzU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBLZXlCaW5kaW5nVXRpbFxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVXNlckFnZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvVXNlckFnZW50Jyk7XG5cbnZhciBpc09TWCA9IFVzZXJBZ2VudC5pc1BsYXRmb3JtKCdNYWMgT1MgWCcpO1xuXG52YXIgS2V5QmluZGluZ1V0aWwgPSB7XG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBjdHJsS2V5IG1vZGlmaWVyIGlzICpub3QqIGJlaW5nIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aFxuICAgKiB0aGUgYWx0S2V5IG1vZGlmaWVyLiBJZiB0aGV5IGFyZSBjb21iaW5lZCwgdGhlIHJlc3VsdCBpcyBhbiBgYWx0R3JhcGhgXG4gICAqIGtleSBtb2RpZmllciwgd2hpY2ggc2hvdWxkIG5vdCBiZSBoYW5kbGVkIGJ5IHRoaXMgc2V0IG9mIGtleSBiaW5kaW5ncy5cbiAgICovXG4gIGlzQ3RybEtleUNvbW1hbmQ6IGZ1bmN0aW9uIGlzQ3RybEtleUNvbW1hbmQoZSkge1xuICAgIHJldHVybiAhIWUuY3RybEtleSAmJiAhZS5hbHRLZXk7XG4gIH0sXG5cbiAgaXNPcHRpb25LZXlDb21tYW5kOiBmdW5jdGlvbiBpc09wdGlvbktleUNvbW1hbmQoZSkge1xuICAgIHJldHVybiBpc09TWCAmJiBlLmFsdEtleTtcbiAgfSxcblxuICBoYXNDb21tYW5kTW9kaWZpZXI6IGZ1bmN0aW9uIGhhc0NvbW1hbmRNb2RpZmllcihlKSB7XG4gICAgcmV0dXJuIGlzT1NYID8gISFlLm1ldGFLZXkgJiYgIWUuYWx0S2V5IDogS2V5QmluZGluZ1V0aWwuaXNDdHJsS2V5Q29tbWFuZChlKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlCaW5kaW5nVXRpbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvS2V5QmluZGluZ1V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDM1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbW92ZVNlbGVjdGlvbkJhY2t3YXJkXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYSBjb2xsYXBzZWQgc2VsZWN0aW9uLCBtb3ZlIHRoZSBmb2N1cyBgbWF4RGlzdGFuY2VgIGJhY2t3YXJkIHdpdGhpblxuICogdGhlIHNlbGVjdGVkIGJsb2NrLiBJZiB0aGUgc2VsZWN0aW9uIHdpbGwgZ28gYmV5b25kIHRoZSBzdGFydCBvZiB0aGUgYmxvY2ssXG4gKiBtb3ZlIGZvY3VzIHRvIHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIGJsb2NrLCBidXQgbm8gZnVydGhlci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBVbmljb2RlLWF3YXJlLCBzbyBzdXJyb2dhdGUgcGFpcnMgd2lsbCBiZSB0cmVhdGVkXG4gKiBhcyBoYXZpbmcgbGVuZ3RoIDIuXG4gKi9cbmZ1bmN0aW9uIG1vdmVTZWxlY3Rpb25CYWNrd2FyZChlZGl0b3JTdGF0ZSwgbWF4RGlzdGFuY2UpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpO1xuICB2YXIgY29udGVudCA9IGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG4gIHZhciBrZXkgPSBzZWxlY3Rpb24uZ2V0U3RhcnRLZXkoKTtcbiAgdmFyIG9mZnNldCA9IHNlbGVjdGlvbi5nZXRTdGFydE9mZnNldCgpO1xuXG4gIHZhciBmb2N1c0tleSA9IGtleTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gMDtcblxuICBpZiAobWF4RGlzdGFuY2UgPiBvZmZzZXQpIHtcbiAgICB2YXIga2V5QmVmb3JlID0gY29udGVudC5nZXRLZXlCZWZvcmUoa2V5KTtcbiAgICBpZiAoa2V5QmVmb3JlID09IG51bGwpIHtcbiAgICAgIGZvY3VzS2V5ID0ga2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBmb2N1c0tleSA9IGtleUJlZm9yZTtcbiAgICAgIHZhciBibG9ja0JlZm9yZSA9IGNvbnRlbnQuZ2V0QmxvY2tGb3JLZXkoa2V5QmVmb3JlKTtcbiAgICAgIGZvY3VzT2Zmc2V0ID0gYmxvY2tCZWZvcmUuZ2V0VGV4dCgpLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9jdXNPZmZzZXQgPSBvZmZzZXQgLSBtYXhEaXN0YW5jZTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24ubWVyZ2Uoe1xuICAgIGZvY3VzS2V5OiBmb2N1c0tleSxcbiAgICBmb2N1c09mZnNldDogZm9jdXNPZmZzZXQsXG4gICAgaXNCYWNrd2FyZDogdHJ1ZVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb3ZlU2VsZWN0aW9uQmFja3dhcmQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL21vdmVTZWxlY3Rpb25CYWNrd2FyZC5qc1xuLy8gbW9kdWxlIGlkID0gMzU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEcmFmdFxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXRvbWljQmxvY2tVdGlscyA9IHJlcXVpcmUoJy4vQXRvbWljQmxvY2tVdGlscycpO1xudmFyIEJsb2NrTWFwQnVpbGRlciA9IHJlcXVpcmUoJy4vQmxvY2tNYXBCdWlsZGVyJyk7XG52YXIgQ2hhcmFjdGVyTWV0YWRhdGEgPSByZXF1aXJlKCcuL0NoYXJhY3Rlck1ldGFkYXRhJyk7XG52YXIgQ29tcG9zaXRlRHJhZnREZWNvcmF0b3IgPSByZXF1aXJlKCcuL0NvbXBvc2l0ZURyYWZ0RGVjb3JhdG9yJyk7XG52YXIgQ29udGVudEJsb2NrID0gcmVxdWlyZSgnLi9Db250ZW50QmxvY2snKTtcbnZhciBDb250ZW50U3RhdGUgPSByZXF1aXJlKCcuL0NvbnRlbnRTdGF0ZScpO1xudmFyIERlZmF1bHREcmFmdEJsb2NrUmVuZGVyTWFwID0gcmVxdWlyZSgnLi9EZWZhdWx0RHJhZnRCbG9ja1JlbmRlck1hcCcpO1xudmFyIERlZmF1bHREcmFmdElubGluZVN0eWxlID0gcmVxdWlyZSgnLi9EZWZhdWx0RHJhZnRJbmxpbmVTdHlsZScpO1xudmFyIERyYWZ0RWRpdG9yID0gcmVxdWlyZSgnLi9EcmFmdEVkaXRvci5yZWFjdCcpO1xudmFyIERyYWZ0RWRpdG9yQmxvY2sgPSByZXF1aXJlKCcuL0RyYWZ0RWRpdG9yQmxvY2sucmVhY3QnKTtcbnZhciBEcmFmdEVudGl0eSA9IHJlcXVpcmUoJy4vRHJhZnRFbnRpdHknKTtcbnZhciBEcmFmdE1vZGlmaWVyID0gcmVxdWlyZSgnLi9EcmFmdE1vZGlmaWVyJyk7XG52YXIgRHJhZnRFbnRpdHlJbnN0YW5jZSA9IHJlcXVpcmUoJy4vRHJhZnRFbnRpdHlJbnN0YW5jZScpO1xudmFyIEVkaXRvclN0YXRlID0gcmVxdWlyZSgnLi9FZGl0b3JTdGF0ZScpO1xudmFyIEtleUJpbmRpbmdVdGlsID0gcmVxdWlyZSgnLi9LZXlCaW5kaW5nVXRpbCcpO1xudmFyIFJpY2hUZXh0RWRpdG9yVXRpbCA9IHJlcXVpcmUoJy4vUmljaFRleHRFZGl0b3JVdGlsJyk7XG52YXIgU2VsZWN0aW9uU3RhdGUgPSByZXF1aXJlKCcuL1NlbGVjdGlvblN0YXRlJyk7XG5cbnZhciBjb252ZXJ0RnJvbURyYWZ0U3RhdGVUb1JhdyA9IHJlcXVpcmUoJy4vY29udmVydEZyb21EcmFmdFN0YXRlVG9SYXcnKTtcbnZhciBjb252ZXJ0RnJvbUhUTUxUb0NvbnRlbnRCbG9ja3MgPSByZXF1aXJlKCcuL2NvbnZlcnRGcm9tSFRNTFRvQ29udGVudEJsb2NrcycpO1xudmFyIGNvbnZlcnRGcm9tUmF3VG9EcmFmdFN0YXRlID0gcmVxdWlyZSgnLi9jb252ZXJ0RnJvbVJhd1RvRHJhZnRTdGF0ZScpO1xudmFyIGdlbmVyYXRlUmFuZG9tS2V5ID0gcmVxdWlyZSgnLi9nZW5lcmF0ZVJhbmRvbUtleScpO1xudmFyIGdldERlZmF1bHRLZXlCaW5kaW5nID0gcmVxdWlyZSgnLi9nZXREZWZhdWx0S2V5QmluZGluZycpO1xudmFyIGdldFZpc2libGVTZWxlY3Rpb25SZWN0ID0gcmVxdWlyZSgnLi9nZXRWaXNpYmxlU2VsZWN0aW9uUmVjdCcpO1xuXG52YXIgRHJhZnRQdWJsaWMgPSB7XG4gIEVkaXRvcjogRHJhZnRFZGl0b3IsXG4gIEVkaXRvckJsb2NrOiBEcmFmdEVkaXRvckJsb2NrLFxuICBFZGl0b3JTdGF0ZTogRWRpdG9yU3RhdGUsXG5cbiAgQ29tcG9zaXRlRGVjb3JhdG9yOiBDb21wb3NpdGVEcmFmdERlY29yYXRvcixcbiAgRW50aXR5OiBEcmFmdEVudGl0eSxcbiAgRW50aXR5SW5zdGFuY2U6IERyYWZ0RW50aXR5SW5zdGFuY2UsXG5cbiAgQmxvY2tNYXBCdWlsZGVyOiBCbG9ja01hcEJ1aWxkZXIsXG4gIENoYXJhY3Rlck1ldGFkYXRhOiBDaGFyYWN0ZXJNZXRhZGF0YSxcbiAgQ29udGVudEJsb2NrOiBDb250ZW50QmxvY2ssXG4gIENvbnRlbnRTdGF0ZTogQ29udGVudFN0YXRlLFxuICBTZWxlY3Rpb25TdGF0ZTogU2VsZWN0aW9uU3RhdGUsXG5cbiAgQXRvbWljQmxvY2tVdGlsczogQXRvbWljQmxvY2tVdGlscyxcbiAgS2V5QmluZGluZ1V0aWw6IEtleUJpbmRpbmdVdGlsLFxuICBNb2RpZmllcjogRHJhZnRNb2RpZmllcixcbiAgUmljaFV0aWxzOiBSaWNoVGV4dEVkaXRvclV0aWwsXG5cbiAgRGVmYXVsdERyYWZ0QmxvY2tSZW5kZXJNYXA6IERlZmF1bHREcmFmdEJsb2NrUmVuZGVyTWFwLFxuICBEZWZhdWx0RHJhZnRJbmxpbmVTdHlsZTogRGVmYXVsdERyYWZ0SW5saW5lU3R5bGUsXG5cbiAgY29udmVydEZyb21IVE1MOiBjb252ZXJ0RnJvbUhUTUxUb0NvbnRlbnRCbG9ja3MsXG4gIGNvbnZlcnRGcm9tUmF3OiBjb252ZXJ0RnJvbVJhd1RvRHJhZnRTdGF0ZSxcbiAgY29udmVydFRvUmF3OiBjb252ZXJ0RnJvbURyYWZ0U3RhdGVUb1JhdyxcbiAgZ2VuS2V5OiBnZW5lcmF0ZVJhbmRvbUtleSxcbiAgZ2V0RGVmYXVsdEtleUJpbmRpbmc6IGdldERlZmF1bHRLZXlCaW5kaW5nLFxuICBnZXRWaXNpYmxlU2VsZWN0aW9uUmVjdDogZ2V0VmlzaWJsZVNlbGVjdGlvblJlY3Rcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZnRQdWJsaWM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHJhbmRvbWl6ZUJsb2NrTWFwS2V5c1xuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29udGVudEJsb2NrTm9kZSA9IHJlcXVpcmUoJy4vQ29udGVudEJsb2NrTm9kZScpO1xudmFyIEltbXV0YWJsZSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xuXG52YXIgZ2VuZXJhdGVSYW5kb21LZXkgPSByZXF1aXJlKCcuL2dlbmVyYXRlUmFuZG9tS2V5Jyk7XG5cbnZhciBPcmRlcmVkTWFwID0gSW1tdXRhYmxlLk9yZGVyZWRNYXA7XG5cblxudmFyIHJhbmRvbWl6ZUNvbnRlbnRCbG9ja05vZGVLZXlzID0gZnVuY3Rpb24gcmFuZG9taXplQ29udGVudEJsb2NrTm9kZUtleXMoYmxvY2tNYXApIHtcbiAgdmFyIG5ld0tleXNSZWYgPSB7fTtcblxuICAvLyB3ZSBrZWVwIHRyYWNrIG9mIHJvb3QgYmxvY2tzIGluIG9yZGVyIHRvIHVwZGF0ZSBzdWJzZXF1ZW50IHNpYmxpbmcgbGlua3NcbiAgdmFyIGxhc3RSb290QmxvY2sgPSB2b2lkIDA7XG5cbiAgcmV0dXJuIE9yZGVyZWRNYXAoYmxvY2tNYXAud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoYmxvY2tNYXBTdGF0ZSkge1xuICAgIGJsb2NrTWFwU3RhdGUuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2ssIGluZGV4KSB7XG4gICAgICB2YXIgb2xkS2V5ID0gYmxvY2suZ2V0S2V5KCk7XG4gICAgICB2YXIgbmV4dEtleSA9IGJsb2NrLmdldE5leHRTaWJsaW5nS2V5KCk7XG4gICAgICB2YXIgcHJldktleSA9IGJsb2NrLmdldFByZXZTaWJsaW5nS2V5KCk7XG4gICAgICB2YXIgY2hpbGRyZW5LZXlzID0gYmxvY2suZ2V0Q2hpbGRLZXlzKCk7XG4gICAgICB2YXIgcGFyZW50S2V5ID0gYmxvY2suZ2V0UGFyZW50S2V5KCk7XG5cbiAgICAgIC8vIG5ldyBrZXkgdGhhdCB3ZSB3aWxsIHVzZSB0byBidWlsZCBsaW5raW5nXG4gICAgICB2YXIga2V5ID0gZ2VuZXJhdGVSYW5kb21LZXkoKTtcblxuICAgICAgLy8gd2Ugd2lsbCBhZGQgaXQgaGVyZSB0byByZS11c2UgaXQgbGF0ZXJcbiAgICAgIG5ld0tleXNSZWZbb2xkS2V5XSA9IGtleTtcblxuICAgICAgaWYgKG5leHRLZXkpIHtcbiAgICAgICAgdmFyIG5leHRCbG9jayA9IGJsb2NrTWFwU3RhdGUuZ2V0KG5leHRLZXkpO1xuICAgICAgICBpZiAobmV4dEJsb2NrKSB7XG4gICAgICAgICAgYmxvY2tNYXBTdGF0ZS5zZXRJbihbbmV4dEtleSwgJ3ByZXZTaWJsaW5nJ10sIGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhpcyBjYW4gaGFwcGVuIHdoZW4gZ2VuZXJhdGluZyByYW5kb20ga2V5cyBmb3IgZnJhZ21lbnRzXG4gICAgICAgICAgYmxvY2tNYXBTdGF0ZS5zZXRJbihbb2xkS2V5LCAnbmV4dFNpYmxpbmcnXSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZLZXkpIHtcbiAgICAgICAgdmFyIHByZXZCbG9jayA9IGJsb2NrTWFwU3RhdGUuZ2V0KHByZXZLZXkpO1xuICAgICAgICBpZiAocHJldkJsb2NrKSB7XG4gICAgICAgICAgYmxvY2tNYXBTdGF0ZS5zZXRJbihbcHJldktleSwgJ25leHRTaWJsaW5nJ10sIGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhpcyBjYW4gaGFwcGVuIHdoZW4gZ2VuZXJhdGluZyByYW5kb20ga2V5cyBmb3IgZnJhZ21lbnRzXG4gICAgICAgICAgYmxvY2tNYXBTdGF0ZS5zZXRJbihbb2xkS2V5LCAncHJldlNpYmxpbmcnXSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudEtleSAmJiBibG9ja01hcFN0YXRlLmdldChwYXJlbnRLZXkpKSB7XG4gICAgICAgIHZhciBwYXJlbnRCbG9jayA9IGJsb2NrTWFwU3RhdGUuZ2V0KHBhcmVudEtleSk7XG4gICAgICAgIHZhciBwYXJlbnRDaGlsZHJlbkxpc3QgPSBwYXJlbnRCbG9jay5nZXRDaGlsZEtleXMoKTtcbiAgICAgICAgYmxvY2tNYXBTdGF0ZS5zZXRJbihbcGFyZW50S2V5LCAnY2hpbGRyZW4nXSwgcGFyZW50Q2hpbGRyZW5MaXN0LnNldChwYXJlbnRDaGlsZHJlbkxpc3QuaW5kZXhPZihibG9jay5nZXRLZXkoKSksIGtleSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYmxvY2tzIHdpbGwgdGhlbiBiZSB0cmVhdGVkIGFzIHJvb3QgYmxvY2sgbm9kZXNcbiAgICAgICAgYmxvY2tNYXBTdGF0ZS5zZXRJbihbb2xkS2V5LCAncGFyZW50J10sIG51bGwpO1xuXG4gICAgICAgIGlmIChsYXN0Um9vdEJsb2NrKSB7XG4gICAgICAgICAgYmxvY2tNYXBTdGF0ZS5zZXRJbihbbGFzdFJvb3RCbG9jay5nZXRLZXkoKSwgJ25leHRTaWJsaW5nJ10sIGtleSk7XG4gICAgICAgICAgYmxvY2tNYXBTdGF0ZS5zZXRJbihbb2xkS2V5LCAncHJldlNpYmxpbmcnXSwgbmV3S2V5c1JlZltsYXN0Um9vdEJsb2NrLmdldEtleSgpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0Um9vdEJsb2NrID0gYmxvY2tNYXBTdGF0ZS5nZXQob2xkS2V5KTtcbiAgICAgIH1cblxuICAgICAgY2hpbGRyZW5LZXlzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkS2V5KSB7XG4gICAgICAgIHZhciBjaGlsZEJsb2NrID0gYmxvY2tNYXBTdGF0ZS5nZXQoY2hpbGRLZXkpO1xuICAgICAgICBpZiAoY2hpbGRCbG9jaykge1xuICAgICAgICAgIGJsb2NrTWFwU3RhdGUuc2V0SW4oW2NoaWxkS2V5LCAncGFyZW50J10sIGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmxvY2tNYXBTdGF0ZS5zZXRJbihbb2xkS2V5LCAnY2hpbGRyZW4nXSwgYmxvY2suZ2V0Q2hpbGRLZXlzKCkuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkICE9PSBjaGlsZEtleTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KS50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChibG9jaykge1xuICAgIHJldHVybiBbbmV3S2V5c1JlZltibG9jay5nZXRLZXkoKV0sIGJsb2NrLnNldCgna2V5JywgbmV3S2V5c1JlZltibG9jay5nZXRLZXkoKV0pXTtcbiAgfSkpO1xufTtcblxudmFyIHJhbmRvbWl6ZUNvbnRlbnRCbG9ja0tleXMgPSBmdW5jdGlvbiByYW5kb21pemVDb250ZW50QmxvY2tLZXlzKGJsb2NrTWFwKSB7XG4gIHJldHVybiBPcmRlcmVkTWFwKGJsb2NrTWFwLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgdmFyIGtleSA9IGdlbmVyYXRlUmFuZG9tS2V5KCk7XG4gICAgcmV0dXJuIFtrZXksIGJsb2NrLnNldCgna2V5Jywga2V5KV07XG4gIH0pKTtcbn07XG5cbnZhciByYW5kb21pemVCbG9ja01hcEtleXMgPSBmdW5jdGlvbiByYW5kb21pemVCbG9ja01hcEtleXMoYmxvY2tNYXApIHtcbiAgdmFyIGlzVHJlZUJhc2VkQmxvY2tNYXAgPSBibG9ja01hcC5maXJzdCgpIGluc3RhbmNlb2YgQ29udGVudEJsb2NrTm9kZTtcblxuICBpZiAoIWlzVHJlZUJhc2VkQmxvY2tNYXApIHtcbiAgICByZXR1cm4gcmFuZG9taXplQ29udGVudEJsb2NrS2V5cyhibG9ja01hcCk7XG4gIH1cblxuICByZXR1cm4gcmFuZG9taXplQ29udGVudEJsb2NrTm9kZUtleXMoYmxvY2tNYXApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSByYW5kb21pemVCbG9ja01hcEtleXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL3JhbmRvbWl6ZUJsb2NrTWFwS2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMzYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSByZW1vdmVFbnRpdGllc0F0RWRnZXNcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJhY3Rlck1ldGFkYXRhID0gcmVxdWlyZSgnLi9DaGFyYWN0ZXJNZXRhZGF0YScpO1xuXG52YXIgZmluZFJhbmdlc0ltbXV0YWJsZSA9IHJlcXVpcmUoJy4vZmluZFJhbmdlc0ltbXV0YWJsZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG5mdW5jdGlvbiByZW1vdmVFbnRpdGllc0F0RWRnZXMoY29udGVudFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSkge1xuICB2YXIgYmxvY2tNYXAgPSBjb250ZW50U3RhdGUuZ2V0QmxvY2tNYXAoKTtcbiAgdmFyIGVudGl0eU1hcCA9IGNvbnRlbnRTdGF0ZS5nZXRFbnRpdHlNYXAoKTtcblxuICB2YXIgdXBkYXRlZEJsb2NrcyA9IHt9O1xuXG4gIHZhciBzdGFydEtleSA9IHNlbGVjdGlvblN0YXRlLmdldFN0YXJ0S2V5KCk7XG4gIHZhciBzdGFydE9mZnNldCA9IHNlbGVjdGlvblN0YXRlLmdldFN0YXJ0T2Zmc2V0KCk7XG4gIHZhciBzdGFydEJsb2NrID0gYmxvY2tNYXAuZ2V0KHN0YXJ0S2V5KTtcbiAgdmFyIHVwZGF0ZWRTdGFydCA9IHJlbW92ZUZvckJsb2NrKGVudGl0eU1hcCwgc3RhcnRCbG9jaywgc3RhcnRPZmZzZXQpO1xuXG4gIGlmICh1cGRhdGVkU3RhcnQgIT09IHN0YXJ0QmxvY2spIHtcbiAgICB1cGRhdGVkQmxvY2tzW3N0YXJ0S2V5XSA9IHVwZGF0ZWRTdGFydDtcbiAgfVxuXG4gIHZhciBlbmRLZXkgPSBzZWxlY3Rpb25TdGF0ZS5nZXRFbmRLZXkoKTtcbiAgdmFyIGVuZE9mZnNldCA9IHNlbGVjdGlvblN0YXRlLmdldEVuZE9mZnNldCgpO1xuICB2YXIgZW5kQmxvY2sgPSBibG9ja01hcC5nZXQoZW5kS2V5KTtcbiAgaWYgKHN0YXJ0S2V5ID09PSBlbmRLZXkpIHtcbiAgICBlbmRCbG9jayA9IHVwZGF0ZWRTdGFydDtcbiAgfVxuXG4gIHZhciB1cGRhdGVkRW5kID0gcmVtb3ZlRm9yQmxvY2soZW50aXR5TWFwLCBlbmRCbG9jaywgZW5kT2Zmc2V0KTtcblxuICBpZiAodXBkYXRlZEVuZCAhPT0gZW5kQmxvY2spIHtcbiAgICB1cGRhdGVkQmxvY2tzW2VuZEtleV0gPSB1cGRhdGVkRW5kO1xuICB9XG5cbiAgaWYgKCFPYmplY3Qua2V5cyh1cGRhdGVkQmxvY2tzKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gY29udGVudFN0YXRlLnNldCgnc2VsZWN0aW9uQWZ0ZXInLCBzZWxlY3Rpb25TdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gY29udGVudFN0YXRlLm1lcmdlKHtcbiAgICBibG9ja01hcDogYmxvY2tNYXAubWVyZ2UodXBkYXRlZEJsb2NrcyksXG4gICAgc2VsZWN0aW9uQWZ0ZXI6IHNlbGVjdGlvblN0YXRlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRSZW1vdmFsUmFuZ2UoY2hhcmFjdGVycywga2V5LCBvZmZzZXQpIHtcbiAgdmFyIHJlbW92YWxSYW5nZTtcbiAgZmluZFJhbmdlc0ltbXV0YWJsZShjaGFyYWN0ZXJzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLmdldEVudGl0eSgpID09PSBiLmdldEVudGl0eSgpO1xuICB9LCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmdldEVudGl0eSgpID09PSBrZXk7XG4gIH0sIGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgaWYgKHN0YXJ0IDw9IG9mZnNldCAmJiBlbmQgPj0gb2Zmc2V0KSB7XG4gICAgICByZW1vdmFsUmFuZ2UgPSB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9XG4gIH0pO1xuICAhKHR5cGVvZiByZW1vdmFsUmFuZ2UgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZW1vdmFsIHJhbmdlIG11c3QgZXhpc3Qgd2l0aGluIGNoYXJhY3RlciBsaXN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHJlbW92YWxSYW5nZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRm9yQmxvY2soZW50aXR5TWFwLCBibG9jaywgb2Zmc2V0KSB7XG4gIHZhciBjaGFycyA9IGJsb2NrLmdldENoYXJhY3Rlckxpc3QoKTtcbiAgdmFyIGNoYXJCZWZvcmUgPSBvZmZzZXQgPiAwID8gY2hhcnMuZ2V0KG9mZnNldCAtIDEpIDogdW5kZWZpbmVkO1xuICB2YXIgY2hhckFmdGVyID0gb2Zmc2V0IDwgY2hhcnMuY291bnQoKSA/IGNoYXJzLmdldChvZmZzZXQpIDogdW5kZWZpbmVkO1xuICB2YXIgZW50aXR5QmVmb3JlQ3Vyc29yID0gY2hhckJlZm9yZSA/IGNoYXJCZWZvcmUuZ2V0RW50aXR5KCkgOiB1bmRlZmluZWQ7XG4gIHZhciBlbnRpdHlBZnRlckN1cnNvciA9IGNoYXJBZnRlciA/IGNoYXJBZnRlci5nZXRFbnRpdHkoKSA6IHVuZGVmaW5lZDtcblxuICBpZiAoZW50aXR5QWZ0ZXJDdXJzb3IgJiYgZW50aXR5QWZ0ZXJDdXJzb3IgPT09IGVudGl0eUJlZm9yZUN1cnNvcikge1xuICAgIHZhciBlbnRpdHkgPSBlbnRpdHlNYXAuX19nZXQoZW50aXR5QWZ0ZXJDdXJzb3IpO1xuICAgIGlmIChlbnRpdHkuZ2V0TXV0YWJpbGl0eSgpICE9PSAnTVVUQUJMRScpIHtcbiAgICAgIHZhciBfZ2V0UmVtb3ZhbFJhbmdlID0gZ2V0UmVtb3ZhbFJhbmdlKGNoYXJzLCBlbnRpdHlBZnRlckN1cnNvciwgb2Zmc2V0KSxcbiAgICAgICAgICBzdGFydCA9IF9nZXRSZW1vdmFsUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgZW5kID0gX2dldFJlbW92YWxSYW5nZS5lbmQ7XG5cbiAgICAgIHZhciBjdXJyZW50O1xuICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIGN1cnJlbnQgPSBjaGFycy5nZXQoc3RhcnQpO1xuICAgICAgICBjaGFycyA9IGNoYXJzLnNldChzdGFydCwgQ2hhcmFjdGVyTWV0YWRhdGEuYXBwbHlFbnRpdHkoY3VycmVudCwgbnVsbCkpO1xuICAgICAgICBzdGFydCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJsb2NrLnNldCgnY2hhcmFjdGVyTGlzdCcsIGNoYXJzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmxvY2s7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVtb3ZlRW50aXRpZXNBdEVkZ2VzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9yZW1vdmVFbnRpdGllc0F0RWRnZXMuanNcbi8vIG1vZHVsZSBpZCA9IDM2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW5zZXJ0SW50b0xpc3RcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNYWludGFpbiBwZXJzaXN0ZW5jZSBmb3IgdGFyZ2V0IGxpc3Qgd2hlbiBhcHBlbmRpbmcgYW5kIHByZXBlbmRpbmcuXG4gKi9cbmZ1bmN0aW9uIGluc2VydEludG9MaXN0KHRhcmdldExpc3QsIHRvSW5zZXJ0LCBvZmZzZXQpIHtcbiAgaWYgKG9mZnNldCA9PT0gdGFyZ2V0TGlzdC5jb3VudCgpKSB7XG4gICAgdG9JbnNlcnQuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgdGFyZ2V0TGlzdCA9IHRhcmdldExpc3QucHVzaChjKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICB0b0luc2VydC5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgdGFyZ2V0TGlzdCA9IHRhcmdldExpc3QudW5zaGlmdChjKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaGVhZCA9IHRhcmdldExpc3Quc2xpY2UoMCwgb2Zmc2V0KTtcbiAgICB2YXIgdGFpbCA9IHRhcmdldExpc3Quc2xpY2Uob2Zmc2V0KTtcbiAgICB0YXJnZXRMaXN0ID0gaGVhZC5jb25jYXQodG9JbnNlcnQsIHRhaWwpLnRvTGlzdCgpO1xuICB9XG4gIHJldHVybiB0YXJnZXRMaXN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEludG9MaXN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9pbnNlcnRJbnRvTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gMzYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldE5leHREZWxpbWl0ZXJCbG9ja0tleVxuICogQGZvcm1hdFxuICogXG4gKlxuICogVGhpcyBpcyB1bnN0YWJsZSBhbmQgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBieVxuICogcHJvZHVjdGlvbiBzeXN0ZW1zLiBUaGlzIGZpbGUgbWF5IGJlIHVwZGF0ZS9yZW1vdmVkIHdpdGhvdXQgbm90aWNlLlxuICovXG5cbnZhciBDb250ZW50QmxvY2tOb2RlID0gcmVxdWlyZSgnLi9Db250ZW50QmxvY2tOb2RlJyk7XG5cbnZhciBnZXROZXh0RGVsaW1pdGVyQmxvY2tLZXkgPSBmdW5jdGlvbiBnZXROZXh0RGVsaW1pdGVyQmxvY2tLZXkoYmxvY2ssIGJsb2NrTWFwKSB7XG4gIHZhciBpc0V4cGVyaW1lbnRhbFRyZWVCbG9jayA9IGJsb2NrIGluc3RhbmNlb2YgQ29udGVudEJsb2NrTm9kZTtcblxuICBpZiAoIWlzRXhwZXJpbWVudGFsVHJlZUJsb2NrKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbmV4dFNpYmxpbmdLZXkgPSBibG9jay5nZXROZXh0U2libGluZ0tleSgpO1xuXG4gIGlmIChuZXh0U2libGluZ0tleSkge1xuICAgIHJldHVybiBuZXh0U2libGluZ0tleTtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSBibG9jay5nZXRQYXJlbnRLZXkoKTtcblxuICBpZiAoIXBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG5leHROb25EZXNjZW5kYW50QmxvY2sgPSBibG9ja01hcC5nZXQocGFyZW50KTtcbiAgd2hpbGUgKG5leHROb25EZXNjZW5kYW50QmxvY2sgJiYgIW5leHROb25EZXNjZW5kYW50QmxvY2suZ2V0TmV4dFNpYmxpbmdLZXkoKSkge1xuICAgIHZhciBwYXJlbnRLZXkgPSBuZXh0Tm9uRGVzY2VuZGFudEJsb2NrLmdldFBhcmVudEtleSgpO1xuICAgIG5leHROb25EZXNjZW5kYW50QmxvY2sgPSBwYXJlbnRLZXkgPyBibG9ja01hcC5nZXQocGFyZW50S2V5KSA6IG51bGw7XG4gIH1cblxuICBpZiAoIW5leHROb25EZXNjZW5kYW50QmxvY2spIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBuZXh0Tm9uRGVzY2VuZGFudEJsb2NrLmdldE5leHRTaWJsaW5nS2V5KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5leHREZWxpbWl0ZXJCbG9ja0tleTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZ2V0TmV4dERlbGltaXRlckJsb2NrS2V5LmpzXG4vLyBtb2R1bGUgaWQgPSAzNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEJsb2NrVHJlZVxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSW1tdXRhYmxlID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGZpbmRSYW5nZXNJbW11dGFibGUgPSByZXF1aXJlKCcuL2ZpbmRSYW5nZXNJbW11dGFibGUnKTtcblxudmFyIExpc3QgPSBJbW11dGFibGUuTGlzdCxcbiAgICBSZXBlYXQgPSBJbW11dGFibGUuUmVwZWF0LFxuICAgIFJlY29yZCA9IEltbXV0YWJsZS5SZWNvcmQ7XG5cblxudmFyIHJldHVyblRydWUgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcblxudmFyIEZJTkdFUlBSSU5UX0RFTElNSVRFUiA9ICctJztcblxudmFyIGRlZmF1bHRMZWFmUmFuZ2UgPSB7XG4gIHN0YXJ0OiBudWxsLFxuICBlbmQ6IG51bGxcbn07XG5cbnZhciBMZWFmUmFuZ2UgPSBSZWNvcmQoZGVmYXVsdExlYWZSYW5nZSk7XG5cbnZhciBkZWZhdWx0RGVjb3JhdG9yUmFuZ2UgPSB7XG4gIHN0YXJ0OiBudWxsLFxuICBlbmQ6IG51bGwsXG4gIGRlY29yYXRvcktleTogbnVsbCxcbiAgbGVhdmVzOiBudWxsXG59O1xuXG52YXIgRGVjb3JhdG9yUmFuZ2UgPSBSZWNvcmQoZGVmYXVsdERlY29yYXRvclJhbmdlKTtcblxudmFyIEJsb2NrVHJlZSA9IHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgYmxvY2sgdHJlZSBmb3IgYSBnaXZlbiBDb250ZW50QmxvY2svZGVjb3JhdG9yIHBhaXIuXG4gICAqL1xuICBnZW5lcmF0ZTogZnVuY3Rpb24gZ2VuZXJhdGUoY29udGVudFN0YXRlLCBibG9jaywgZGVjb3JhdG9yKSB7XG4gICAgdmFyIHRleHRMZW5ndGggPSBibG9jay5nZXRMZW5ndGgoKTtcbiAgICBpZiAoIXRleHRMZW5ndGgpIHtcbiAgICAgIHJldHVybiBMaXN0Lm9mKG5ldyBEZWNvcmF0b3JSYW5nZSh7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IDAsXG4gICAgICAgIGRlY29yYXRvcktleTogbnVsbCxcbiAgICAgICAgbGVhdmVzOiBMaXN0Lm9mKG5ldyBMZWFmUmFuZ2UoeyBzdGFydDogMCwgZW5kOiAwIH0pKVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHZhciBsZWFmU2V0cyA9IFtdO1xuICAgIHZhciBkZWNvcmF0aW9ucyA9IGRlY29yYXRvciA/IGRlY29yYXRvci5nZXREZWNvcmF0aW9ucyhibG9jaywgY29udGVudFN0YXRlKSA6IExpc3QoUmVwZWF0KG51bGwsIHRleHRMZW5ndGgpKTtcblxuICAgIHZhciBjaGFycyA9IGJsb2NrLmdldENoYXJhY3Rlckxpc3QoKTtcblxuICAgIGZpbmRSYW5nZXNJbW11dGFibGUoZGVjb3JhdGlvbnMsIGFyZUVxdWFsLCByZXR1cm5UcnVlLCBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgbGVhZlNldHMucHVzaChuZXcgRGVjb3JhdG9yUmFuZ2Uoe1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kLFxuICAgICAgICBkZWNvcmF0b3JLZXk6IGRlY29yYXRpb25zLmdldChzdGFydCksXG4gICAgICAgIGxlYXZlczogZ2VuZXJhdGVMZWF2ZXMoY2hhcnMuc2xpY2Uoc3RhcnQsIGVuZCkudG9MaXN0KCksIHN0YXJ0KVxuICAgICAgfSkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIExpc3QobGVhZlNldHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHRyZWUgbWFwLiBUaGlzIGFsbG93cyB1c1xuICAgKiB0byByYXBpZGx5IGRldGVybWluZSB3aGV0aGVyIGEgdHJlZSBoYXMgdW5kZXJnb25lIGEgc2lnbmlmaWNhbnRcbiAgICogc3RydWN0dXJhbCBjaGFuZ2UuXG4gICAqL1xuICBnZXRGaW5nZXJwcmludDogZnVuY3Rpb24gZ2V0RmluZ2VycHJpbnQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLm1hcChmdW5jdGlvbiAobGVhZlNldCkge1xuICAgICAgdmFyIGRlY29yYXRvcktleSA9IGxlYWZTZXQuZ2V0KCdkZWNvcmF0b3JLZXknKTtcbiAgICAgIHZhciBmaW5nZXJwcmludFN0cmluZyA9IGRlY29yYXRvcktleSAhPT0gbnVsbCA/IGRlY29yYXRvcktleSArICcuJyArIChsZWFmU2V0LmdldCgnZW5kJykgLSBsZWFmU2V0LmdldCgnc3RhcnQnKSkgOiAnJztcbiAgICAgIHJldHVybiAnJyArIGZpbmdlcnByaW50U3RyaW5nICsgJy4nICsgbGVhZlNldC5nZXQoJ2xlYXZlcycpLnNpemU7XG4gICAgfSkuam9pbihGSU5HRVJQUklOVF9ERUxJTUlURVIpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIExlYWZSYW5nZSByZWNvcmRzIGZvciBhIGdpdmVuIGNoYXJhY3RlciBsaXN0LlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUxlYXZlcyhjaGFyYWN0ZXJzLCBvZmZzZXQpIHtcbiAgdmFyIGxlYXZlcyA9IFtdO1xuICB2YXIgaW5saW5lU3R5bGVzID0gY2hhcmFjdGVycy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYy5nZXRTdHlsZSgpO1xuICB9KS50b0xpc3QoKTtcbiAgZmluZFJhbmdlc0ltbXV0YWJsZShpbmxpbmVTdHlsZXMsIGFyZUVxdWFsLCByZXR1cm5UcnVlLCBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIGxlYXZlcy5wdXNoKG5ldyBMZWFmUmFuZ2Uoe1xuICAgICAgc3RhcnQ6IHN0YXJ0ICsgb2Zmc2V0LFxuICAgICAgZW5kOiBlbmQgKyBvZmZzZXRcbiAgICB9KSk7XG4gIH0pO1xuICByZXR1cm4gTGlzdChsZWF2ZXMpO1xufVxuXG5mdW5jdGlvbiBhcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJsb2NrVHJlZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvQmxvY2tUcmVlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERyYWZ0RW50aXR5SW5zdGFuY2VcbiAqIEBsZWdhY3lTZXJ2ZXJDYWxsYWJsZUluc3RhbmNlXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEltbXV0YWJsZSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xuXG52YXIgUmVjb3JkID0gSW1tdXRhYmxlLlJlY29yZDtcblxuXG52YXIgRHJhZnRFbnRpdHlJbnN0YW5jZVJlY29yZCA9IFJlY29yZCh7XG4gIHR5cGU6ICdUT0tFTicsXG4gIG11dGFiaWxpdHk6ICdJTU1VVEFCTEUnLFxuICBkYXRhOiBPYmplY3Rcbn0pO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIGEgZG9jdW1lbnQgZW50aXR5LCBjb25zaXN0aW5nIG9mIGEgYHR5cGVgIGFuZCByZWxldmFudFxuICogYGRhdGFgLCBtZXRhZGF0YSBhYm91dCB0aGUgZW50aXR5LlxuICpcbiAqIEZvciBpbnN0YW5jZSwgYSBcImxpbmtcIiBlbnRpdHkgbWlnaHQgcHJvdmlkZSBhIFVSSSwgYW5kIGEgXCJtZW50aW9uXCJcbiAqIGVudGl0eSBtaWdodCBwcm92aWRlIHRoZSBtZW50aW9uZWQgdXNlcidzIElELiBUaGVzZSBwaWVjZXMgb2YgZGF0YVxuICogbWF5IGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgdGhlIGVudGl0eSBhcyBwYXJ0IG9mIGEgQ29udGVudEJsb2NrIERPTVxuICogcmVwcmVzZW50YXRpb24uIEZvciBhIGxpbmssIHRoZSBkYXRhIHdvdWxkIGJlIHVzZWQgYXMgYW4gaHJlZiBmb3JcbiAqIHRoZSByZW5kZXJlZCBhbmNob3IuIEZvciBhIG1lbnRpb24sIHRoZSBJRCBjb3VsZCBiZSB1c2VkIHRvIHJldHJpZXZlXG4gKiBhIGhvdmVyY2FyZC5cbiAqL1xuXG52YXIgRHJhZnRFbnRpdHlJbnN0YW5jZSA9IGZ1bmN0aW9uIChfRHJhZnRFbnRpdHlJbnN0YW5jZVIpIHtcbiAgX2luaGVyaXRzKERyYWZ0RW50aXR5SW5zdGFuY2UsIF9EcmFmdEVudGl0eUluc3RhbmNlUik7XG5cbiAgZnVuY3Rpb24gRHJhZnRFbnRpdHlJbnN0YW5jZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhZnRFbnRpdHlJbnN0YW5jZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0RyYWZ0RW50aXR5SW5zdGFuY2VSLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgRHJhZnRFbnRpdHlJbnN0YW5jZS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCd0eXBlJyk7XG4gIH07XG5cbiAgRHJhZnRFbnRpdHlJbnN0YW5jZS5wcm90b3R5cGUuZ2V0TXV0YWJpbGl0eSA9IGZ1bmN0aW9uIGdldE11dGFiaWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdtdXRhYmlsaXR5Jyk7XG4gIH07XG5cbiAgRHJhZnRFbnRpdHlJbnN0YW5jZS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdkYXRhJyk7XG4gIH07XG5cbiAgcmV0dXJuIERyYWZ0RW50aXR5SW5zdGFuY2U7XG59KERyYWZ0RW50aXR5SW5zdGFuY2VSZWNvcmQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWZ0RW50aXR5SW5zdGFuY2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0RW50aXR5SW5zdGFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDM2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qKlxuICogQmFzaWMgKHN0YXRlbGVzcykgQVBJIGZvciB0ZXh0IGRpcmVjdGlvbiBkZXRlY3Rpb25cbiAqXG4gKiBQYXJ0IG9mIG91ciBpbXBsZW1lbnRhdGlvbiBvZiBVbmljb2RlIEJpZGlyZWN0aW9uYWwgQWxnb3JpdGhtIChVQkEpXG4gKiBVbmljb2RlIFN0YW5kYXJkIEFubmV4ICM5IChVQVg5KVxuICogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyOS9cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVbmljb2RlQmlkaURpcmVjdGlvbiA9IHJlcXVpcmUoJy4vVW5pY29kZUJpZGlEaXJlY3Rpb24nKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmVnRXhwIHJhbmdlcyBvZiBjaGFyYWN0ZXJzIHdpdGggYSAqU3Ryb25nKiBCaWRpX0NsYXNzIHZhbHVlLlxuICpcbiAqIERhdGEgaXMgYmFzZWQgb24gRGVyaXZlZEJpZGlDbGFzcy50eHQgaW4gVUNEIHZlcnNpb24gNy4wLjAuXG4gKlxuICogTk9URTogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIG9ubHkgc3VwcG9ydCBVbmljb2RlJ3NcbiAqICAgICAgIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZSAoQk1QKSBmb3Igbm93LlxuICovXG52YXIgUkFOR0VfQllfQklESV9UWVBFID0ge1xuXG4gIEw6ICdBLVphLXpcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDFCQVxcdTAxQkInICsgJ1xcdTAxQkMtXFx1MDFCRlxcdTAxQzAtXFx1MDFDM1xcdTAxQzQtXFx1MDI5M1xcdTAyOTRcXHUwMjk1LVxcdTAyQUZcXHUwMkIwLVxcdTAyQjgnICsgJ1xcdTAyQkItXFx1MDJDMVxcdTAyRDAtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUVcXHUwMzcwLVxcdTAzNzNcXHUwMzc2LVxcdTAzNzcnICsgJ1xcdTAzN0FcXHUwMzdCLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTEnICsgJ1xcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODJcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5JyArICdcXHUwNTVBLVxcdTA1NUZcXHUwNTYxLVxcdTA1ODdcXHUwNTg5XFx1MDkwM1xcdTA5MDQtXFx1MDkzOVxcdTA5M0JcXHUwOTNEJyArICdcXHUwOTNFLVxcdTA5NDBcXHUwOTQ5LVxcdTA5NENcXHUwOTRFLVxcdTA5NEZcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk2NC1cXHUwOTY1JyArICdcXHUwOTY2LVxcdTA5NkZcXHUwOTcwXFx1MDk3MVxcdTA5NzItXFx1MDk4MFxcdTA5ODItXFx1MDk4M1xcdTA5ODUtXFx1MDk4QycgKyAnXFx1MDk4Ri1cXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkQnICsgJ1xcdTA5QkUtXFx1MDlDMFxcdTA5QzctXFx1MDlDOFxcdTA5Q0ItXFx1MDlDQ1xcdTA5Q0VcXHUwOUQ3XFx1MDlEQy1cXHUwOUREJyArICdcXHUwOURGLVxcdTA5RTFcXHUwOUU2LVxcdTA5RUZcXHUwOUYwLVxcdTA5RjFcXHUwOUY0LVxcdTA5RjlcXHUwOUZBXFx1MEEwMycgKyAnXFx1MEEwNS1cXHUwQTBBXFx1MEEwRi1cXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMi1cXHUwQTMzJyArICdcXHUwQTM1LVxcdTBBMzZcXHUwQTM4LVxcdTBBMzlcXHUwQTNFLVxcdTBBNDBcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTZGJyArICdcXHUwQTcyLVxcdTBBNzRcXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwJyArICdcXHUwQUIyLVxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFCRS1cXHUwQUMwXFx1MEFDOVxcdTBBQ0ItXFx1MEFDQ1xcdTBBRDAnICsgJ1xcdTBBRTAtXFx1MEFFMVxcdTBBRTYtXFx1MEFFRlxcdTBBRjBcXHUwQjAyLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGLVxcdTBCMTAnICsgJ1xcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzItXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjNFXFx1MEI0MCcgKyAnXFx1MEI0Ny1cXHUwQjQ4XFx1MEI0Qi1cXHUwQjRDXFx1MEI1N1xcdTBCNUMtXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNjYtXFx1MEI2RicgKyAnXFx1MEI3MFxcdTBCNzFcXHUwQjcyLVxcdTBCNzdcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1JyArICdcXHUwQjk5LVxcdTBCOUFcXHUwQjlDXFx1MEI5RS1cXHUwQjlGXFx1MEJBMy1cXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5JyArICdcXHUwQkJFLVxcdTBCQkZcXHUwQkMxLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0NcXHUwQkQwXFx1MEJENycgKyAnXFx1MEJFNi1cXHUwQkVGXFx1MEJGMC1cXHUwQkYyXFx1MEMwMS1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwJyArICdcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM0MS1cXHUwQzQ0XFx1MEM1OC1cXHUwQzU5XFx1MEM2MC1cXHUwQzYxJyArICdcXHUwQzY2LVxcdTBDNkZcXHUwQzdGXFx1MEM4Mi1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4JyArICdcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENCRVxcdTBDQkZcXHUwQ0MwLVxcdTBDQzRcXHUwQ0M2JyArICdcXHUwQ0M3LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0JcXHUwQ0Q1LVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UxXFx1MENFNi1cXHUwQ0VGJyArICdcXHUwQ0YxLVxcdTBDRjJcXHUwRDAyLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEJyArICdcXHUwRDNFLVxcdTBENDBcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENENcXHUwRDRFXFx1MEQ1N1xcdTBENjAtXFx1MEQ2MScgKyAnXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3MC1cXHUwRDc1XFx1MEQ3OVxcdTBEN0EtXFx1MEQ3RlxcdTBEODItXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NicgKyAnXFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0YtXFx1MEREMVxcdTBERDgtXFx1MERERicgKyAnXFx1MERFNi1cXHUwREVGXFx1MERGMi1cXHUwREYzXFx1MERGNFxcdTBFMDEtXFx1MEUzMFxcdTBFMzItXFx1MEUzM1xcdTBFNDAtXFx1MEU0NScgKyAnXFx1MEU0NlxcdTBFNEZcXHUwRTUwLVxcdTBFNTlcXHUwRTVBLVxcdTBFNUJcXHUwRTgxLVxcdTBFODJcXHUwRTg0XFx1MEU4Ny1cXHUwRTg4JyArICdcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3JyArICdcXHUwRUFBLVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyLVxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNicgKyAnXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMDEtXFx1MEYwM1xcdTBGMDQtXFx1MEYxMlxcdTBGMTNcXHUwRjE0JyArICdcXHUwRjE1LVxcdTBGMTdcXHUwRjFBLVxcdTBGMUZcXHUwRjIwLVxcdTBGMjlcXHUwRjJBLVxcdTBGMzNcXHUwRjM0XFx1MEYzNlxcdTBGMzgnICsgJ1xcdTBGM0UtXFx1MEYzRlxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGN0ZcXHUwRjg1XFx1MEY4OC1cXHUwRjhDJyArICdcXHUwRkJFLVxcdTBGQzVcXHUwRkM3LVxcdTBGQ0NcXHUwRkNFLVxcdTBGQ0ZcXHUwRkQwLVxcdTBGRDRcXHUwRkQ1LVxcdTBGRDgnICsgJ1xcdTBGRDktXFx1MEZEQVxcdTEwMDAtXFx1MTAyQVxcdTEwMkItXFx1MTAyQ1xcdTEwMzFcXHUxMDM4XFx1MTAzQi1cXHUxMDNDXFx1MTAzRicgKyAnXFx1MTA0MC1cXHUxMDQ5XFx1MTA0QS1cXHUxMDRGXFx1MTA1MC1cXHUxMDU1XFx1MTA1Ni1cXHUxMDU3XFx1MTA1QS1cXHUxMDVEXFx1MTA2MScgKyAnXFx1MTA2Mi1cXHUxMDY0XFx1MTA2NS1cXHUxMDY2XFx1MTA2Ny1cXHUxMDZEXFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxJyArICdcXHUxMDgzLVxcdTEwODRcXHUxMDg3LVxcdTEwOENcXHUxMDhFXFx1MTA4RlxcdTEwOTAtXFx1MTA5OVxcdTEwOUEtXFx1MTA5QycgKyAnXFx1MTA5RS1cXHUxMDlGXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZCXFx1MTBGQycgKyAnXFx1MTBGRC1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OCcgKyAnXFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNScgKyAnXFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM2MC1cXHUxMzY4JyArICdcXHUxMzY5LVxcdTEzN0NcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZELVxcdTE2NkUnICsgJ1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUItXFx1MTZFRFxcdTE2RUUtXFx1MTZGMCcgKyAnXFx1MTZGMS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTczNS1cXHUxNzM2JyArICdcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0I2XFx1MTdCRS1cXHUxN0M1JyArICdcXHUxN0M3LVxcdTE3QzhcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q3XFx1MTdEOC1cXHUxN0RBXFx1MTdEQ1xcdTE3RTAtXFx1MTdFOScgKyAnXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODQyXFx1MTg0M1xcdTE4NDQtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUEnICsgJ1xcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjMtXFx1MTkyNlxcdTE5MjktXFx1MTkyQlxcdTE5MzAtXFx1MTkzMScgKyAnXFx1MTkzMy1cXHUxOTM4XFx1MTk0Ni1cXHUxOTRGXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCJyArICdcXHUxOUIwLVxcdTE5QzBcXHUxOUMxLVxcdTE5QzdcXHUxOUM4LVxcdTE5QzlcXHUxOUQwLVxcdTE5RDlcXHUxOURBXFx1MUEwMC1cXHUxQTE2JyArICdcXHUxQTE5LVxcdTFBMUFcXHUxQTFFLVxcdTFBMUZcXHUxQTIwLVxcdTFBNTRcXHUxQTU1XFx1MUE1N1xcdTFBNjFcXHUxQTYzLVxcdTFBNjQnICsgJ1xcdTFBNkQtXFx1MUE3MlxcdTFBODAtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTAtXFx1MUFBNlxcdTFBQTdcXHUxQUE4LVxcdTFBQUQnICsgJ1xcdTFCMDRcXHUxQjA1LVxcdTFCMzNcXHUxQjM1XFx1MUIzQlxcdTFCM0QtXFx1MUI0MVxcdTFCNDMtXFx1MUI0NFxcdTFCNDUtXFx1MUI0QicgKyAnXFx1MUI1MC1cXHUxQjU5XFx1MUI1QS1cXHUxQjYwXFx1MUI2MS1cXHUxQjZBXFx1MUI3NC1cXHUxQjdDXFx1MUI4MlxcdTFCODMtXFx1MUJBMCcgKyAnXFx1MUJBMVxcdTFCQTYtXFx1MUJBN1xcdTFCQUFcXHUxQkFFLVxcdTFCQUZcXHUxQkIwLVxcdTFCQjlcXHUxQkJBLVxcdTFCRTVcXHUxQkU3JyArICdcXHUxQkVBLVxcdTFCRUNcXHUxQkVFXFx1MUJGMi1cXHUxQkYzXFx1MUJGQy1cXHUxQkZGXFx1MUMwMC1cXHUxQzIzXFx1MUMyNC1cXHUxQzJCJyArICdcXHUxQzM0LVxcdTFDMzVcXHUxQzNCLVxcdTFDM0ZcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDNEZcXHUxQzUwLVxcdTFDNTknICsgJ1xcdTFDNUEtXFx1MUM3N1xcdTFDNzgtXFx1MUM3RFxcdTFDN0UtXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUxQ0UxJyArICdcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0YyLVxcdTFDRjNcXHUxQ0Y1LVxcdTFDRjZcXHUxRDAwLVxcdTFEMkInICsgJ1xcdTFEMkMtXFx1MUQ2QVxcdTFENkItXFx1MUQ3N1xcdTFENzhcXHUxRDc5LVxcdTFEOUFcXHUxRDlCLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTUnICsgJ1xcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RCcgKyAnXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQycgKyAnXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwRScgKyAnXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMUQnICsgJ1xcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzNFxcdTIxMzUtXFx1MjEzOFxcdTIxMzknICsgJ1xcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTRGXFx1MjE2MC1cXHUyMTgyXFx1MjE4My1cXHUyMTg0JyArICdcXHUyMTg1LVxcdTIxODhcXHUyMzM2LVxcdTIzN0FcXHUyMzk1XFx1MjQ5Qy1cXHUyNEU5XFx1MjZBQ1xcdTI4MDAtXFx1MjhGRicgKyAnXFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQzdCXFx1MkM3Qy1cXHUyQzdEXFx1MkM3RS1cXHUyQ0U0JyArICdcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkYnICsgJ1xcdTJENzBcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkUnICsgJ1xcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTMwMDVcXHUzMDA2XFx1MzAwNycgKyAnXFx1MzAyMS1cXHUzMDI5XFx1MzAyRS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNBXFx1MzAzQlxcdTMwM0MnICsgJ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkVcXHUzMEZGJyArICdcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMTkwLVxcdTMxOTFcXHUzMTkyLVxcdTMxOTVcXHUzMTk2LVxcdTMxOUYnICsgJ1xcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTMyMDAtXFx1MzIxQ1xcdTMyMjAtXFx1MzIyOVxcdTMyMkEtXFx1MzI0NycgKyAnXFx1MzI0OC1cXHUzMjRGXFx1MzI2MC1cXHUzMjdCXFx1MzI3RlxcdTMyODAtXFx1MzI4OVxcdTMyOEEtXFx1MzJCMFxcdTMyQzAtXFx1MzJDQicgKyAnXFx1MzJEMC1cXHUzMkZFXFx1MzMwMC1cXHUzMzc2XFx1MzM3Qi1cXHUzM0REXFx1MzNFMC1cXHUzM0ZFXFx1MzQwMC1cXHU0REI1JyArICdcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUEwMTRcXHVBMDE1XFx1QTAxNi1cXHVBNDhDXFx1QTREMC1cXHVBNEY3XFx1QTRGOC1cXHVBNEZEJyArICdcXHVBNEZFLVxcdUE0RkZcXHVBNTAwLVxcdUE2MEJcXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyMC1cXHVBNjI5XFx1QTYyQS1cXHVBNjJCJyArICdcXHVBNjQwLVxcdUE2NkRcXHVBNjZFXFx1QTY4MC1cXHVBNjlCXFx1QTY5Qy1cXHVBNjlEXFx1QTZBMC1cXHVBNkU1XFx1QTZFNi1cXHVBNkVGJyArICdcXHVBNkYyLVxcdUE2RjdcXHVBNzIyLVxcdUE3NkZcXHVBNzcwXFx1QTc3MS1cXHVBNzg3XFx1QTc4OS1cXHVBNzhBXFx1QTc4Qi1cXHVBNzhFJyArICdcXHVBNzkwLVxcdUE3QURcXHVBN0IwLVxcdUE3QjFcXHVBN0Y3XFx1QTdGOC1cXHVBN0Y5XFx1QTdGQVxcdUE3RkItXFx1QTgwMScgKyAnXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTgyMy1cXHVBODI0XFx1QTgyN1xcdUE4MzAtXFx1QTgzNScgKyAnXFx1QTgzNi1cXHVBODM3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBODgxXFx1QTg4Mi1cXHVBOEIzXFx1QThCNC1cXHVBOEMzJyArICdcXHVBOENFLVxcdUE4Q0ZcXHVBOEQwLVxcdUE4RDlcXHVBOEYyLVxcdUE4RjdcXHVBOEY4LVxcdUE4RkFcXHVBOEZCXFx1QTkwMC1cXHVBOTA5JyArICdcXHVBOTBBLVxcdUE5MjVcXHVBOTJFLVxcdUE5MkZcXHVBOTMwLVxcdUE5NDZcXHVBOTUyLVxcdUE5NTNcXHVBOTVGXFx1QTk2MC1cXHVBOTdDJyArICdcXHVBOTgzXFx1QTk4NC1cXHVBOUIyXFx1QTlCNC1cXHVBOUI1XFx1QTlCQS1cXHVBOUJCXFx1QTlCRC1cXHVBOUMwXFx1QTlDMS1cXHVBOUNEJyArICdcXHVBOUNGXFx1QTlEMC1cXHVBOUQ5XFx1QTlERS1cXHVBOURGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNlxcdUE5RTctXFx1QTlFRicgKyAnXFx1QTlGMC1cXHVBOUY5XFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUEyRi1cXHVBQTMwXFx1QUEzMy1cXHVBQTM0JyArICdcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE1Qy1cXHVBQTVGXFx1QUE2MC1cXHVBQTZGJyArICdcXHVBQTcwXFx1QUE3MS1cXHVBQTc2XFx1QUE3Ny1cXHVBQTc5XFx1QUE3QVxcdUFBN0JcXHVBQTdEXFx1QUE3RS1cXHVBQUFGXFx1QUFCMScgKyAnXFx1QUFCNS1cXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRENcXHVBQUREXFx1QUFERS1cXHVBQURGJyArICdcXHVBQUUwLVxcdUFBRUFcXHVBQUVCXFx1QUFFRS1cXHVBQUVGXFx1QUFGMC1cXHVBQUYxXFx1QUFGMlxcdUFBRjMtXFx1QUFGNFxcdUFBRjUnICsgJ1xcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRScgKyAnXFx1QUIzMC1cXHVBQjVBXFx1QUI1QlxcdUFCNUMtXFx1QUI1RlxcdUFCNjQtXFx1QUI2NVxcdUFCQzAtXFx1QUJFMlxcdUFCRTMtXFx1QUJFNCcgKyAnXFx1QUJFNi1cXHVBQkU3XFx1QUJFOS1cXHVBQkVBXFx1QUJFQlxcdUFCRUNcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTMnICsgJ1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUUwMDAtXFx1RjhGRlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOScgKyAnXFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRjZGXFx1RkY3MCcgKyAnXFx1RkY3MS1cXHVGRjlEXFx1RkY5RS1cXHVGRjlGXFx1RkZBMC1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGJyArICdcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGREMnLFxuXG4gIFI6ICdcXHUwNTkwXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1QzgtXFx1MDVDRlxcdTA1RDAtXFx1MDVFQVxcdTA1RUItXFx1MDVFRicgKyAnXFx1MDVGMC1cXHUwNUYyXFx1MDVGMy1cXHUwNUY0XFx1MDVGNS1cXHUwNUZGXFx1MDdDMC1cXHUwN0M5XFx1MDdDQS1cXHUwN0VBJyArICdcXHUwN0Y0LVxcdTA3RjVcXHUwN0ZBXFx1MDdGQi1cXHUwN0ZGXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4JyArICdcXHUwODJFLVxcdTA4MkZcXHUwODMwLVxcdTA4M0VcXHUwODNGXFx1MDg0MC1cXHUwODU4XFx1MDg1Qy1cXHUwODVEXFx1MDg1RScgKyAnXFx1MDg1Ri1cXHUwODlGXFx1MjAwRlxcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM3XFx1RkIzOC1cXHVGQjNDJyArICdcXHVGQjNEXFx1RkIzRVxcdUZCM0ZcXHVGQjQwLVxcdUZCNDFcXHVGQjQyXFx1RkI0My1cXHVGQjQ0XFx1RkI0NVxcdUZCNDYtXFx1RkI0RicsXG5cbiAgQUw6ICdcXHUwNjA4XFx1MDYwQlxcdTA2MERcXHUwNjFCXFx1MDYxQ1xcdTA2MURcXHUwNjFFLVxcdTA2MUZcXHUwNjIwLVxcdTA2M0ZcXHUwNjQwJyArICdcXHUwNjQxLVxcdTA2NEFcXHUwNjZEXFx1MDY2RS1cXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENFxcdTA2RDVcXHUwNkU1LVxcdTA2RTYnICsgJ1xcdTA2RUUtXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkQtXFx1MDZGRVxcdTA2RkZcXHUwNzAwLVxcdTA3MERcXHUwNzBFXFx1MDcwRicgKyAnXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEItXFx1MDc0Q1xcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0IyLVxcdTA3QkYnICsgJ1xcdTA4QTAtXFx1MDhCMlxcdTA4QjMtXFx1MDhFM1xcdUZCNTAtXFx1RkJCMVxcdUZCQjItXFx1RkJDMVxcdUZCQzItXFx1RkJEMicgKyAnXFx1RkJEMy1cXHVGRDNEXFx1RkQ0MC1cXHVGRDRGXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5MC1cXHVGRDkxXFx1RkQ5Mi1cXHVGREM3JyArICdcXHVGREM4LVxcdUZEQ0ZcXHVGREYwLVxcdUZERkJcXHVGREZDXFx1RkRGRS1cXHVGREZGXFx1RkU3MC1cXHVGRTc0XFx1RkU3NScgKyAnXFx1RkU3Ni1cXHVGRUZDXFx1RkVGRC1cXHVGRUZFJ1xuXG59O1xuXG52YXIgUkVHRVhfU1RST05HID0gbmV3IFJlZ0V4cCgnWycgKyBSQU5HRV9CWV9CSURJX1RZUEUuTCArIFJBTkdFX0JZX0JJRElfVFlQRS5SICsgUkFOR0VfQllfQklESV9UWVBFLkFMICsgJ10nKTtcblxudmFyIFJFR0VYX1JUTCA9IG5ldyBSZWdFeHAoJ1snICsgUkFOR0VfQllfQklESV9UWVBFLlIgKyBSQU5HRV9CWV9CSURJX1RZUEUuQUwgKyAnXScpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IHN0cm9uZyBjaGFyYWN0ZXIgKGhhcyBCaWRpX0NsYXNzIHZhbHVlIG9mIEwsIFIsIG9yIEFMKS5cbiAqXG4gKiBAcGFyYW0gc3RyICBBIHRleHQgYmxvY2s7IGUuZy4gcGFyYWdyYXBoLCB0YWJsZSBjZWxsLCB0YWdcbiAqIEByZXR1cm4gICAgIEEgY2hhcmFjdGVyIHdpdGggc3Ryb25nIGJpZGkgZGlyZWN0aW9uLCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5mdW5jdGlvbiBmaXJzdFN0cm9uZ0NoYXIoc3RyKSB7XG4gIHZhciBtYXRjaCA9IFJFR0VYX1NUUk9ORy5leGVjKHN0cik7XG4gIHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoWzBdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRpcmVjdGlvbiBvZiBhIGJsb2NrIG9mIHRleHQsIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gb2YgaXRzXG4gKiBmaXJzdCBzdHJvbmcgY2hhcmFjdGVyIChoYXMgQmlkaV9DbGFzcyB2YWx1ZSBvZiBMLCBSLCBvciBBTCkuXG4gKlxuICogQHBhcmFtIHN0ciAgQSB0ZXh0IGJsb2NrOyBlLmcuIHBhcmFncmFwaCwgdGFibGUgY2VsbCwgdGFnXG4gKiBAcmV0dXJuICAgICBUaGUgcmVzb2x2ZWQgZGlyZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZpcnN0U3Ryb25nQ2hhckRpcihzdHIpIHtcbiAgdmFyIHN0cm9uZ0NoYXIgPSBmaXJzdFN0cm9uZ0NoYXIoc3RyKTtcbiAgaWYgKHN0cm9uZ0NoYXIgPT0gbnVsbCkge1xuICAgIHJldHVybiBVbmljb2RlQmlkaURpcmVjdGlvbi5ORVVUUkFMO1xuICB9XG4gIHJldHVybiBSRUdFWF9SVEwuZXhlYyhzdHJvbmdDaGFyKSA/IFVuaWNvZGVCaWRpRGlyZWN0aW9uLlJUTCA6IFVuaWNvZGVCaWRpRGlyZWN0aW9uLkxUUjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaXJlY3Rpb24gb2YgYSBibG9jayBvZiB0ZXh0LCBiYXNlZCBvbiB0aGUgZGlyZWN0aW9uIG9mIGl0c1xuICogZmlyc3Qgc3Ryb25nIGNoYXJhY3RlciAoaGFzIEJpZGlfQ2xhc3MgdmFsdWUgb2YgTCwgUiwgb3IgQUwpLCBvciBhIGZhbGxiYWNrXG4gKiBkaXJlY3Rpb24sIGlmIG5vIHN0cm9uZyBjaGFyYWN0ZXIgaXMgZm91bmQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBzdXBwb3NlZCB0byBiZSB1c2VkIGluIHJlc3BlY3QgdG8gSGlnaGVyLUxldmVsIFByb3RvY29sXG4gKiBydWxlIEhMMS4gKGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjkvI0hMMSlcbiAqXG4gKiBAcGFyYW0gc3RyICAgICAgIEEgdGV4dCBibG9jazsgZS5nLiBwYXJhZ3JhcGgsIHRhYmxlIGNlbGwsIHRhZ1xuICogQHBhcmFtIGZhbGxiYWNrICBGYWxsYmFjayBkaXJlY3Rpb24sIHVzZWQgaWYgbm8gc3Ryb25nIGRpcmVjdGlvbiBkZXRlY3RlZFxuICogICAgICAgICAgICAgICAgICBmb3IgdGhlIGJsb2NrIChkZWZhdWx0ID0gTkVVVFJBTClcbiAqIEByZXR1cm4gICAgICAgICAgVGhlIHJlc29sdmVkIGRpcmVjdGlvblxuICovXG5mdW5jdGlvbiByZXNvbHZlQmxvY2tEaXIoc3RyLCBmYWxsYmFjaykge1xuICBmYWxsYmFjayA9IGZhbGxiYWNrIHx8IFVuaWNvZGVCaWRpRGlyZWN0aW9uLk5FVVRSQUw7XG4gIGlmICghc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxuICB2YXIgYmxvY2tEaXIgPSBmaXJzdFN0cm9uZ0NoYXJEaXIoc3RyKTtcbiAgcmV0dXJuIGJsb2NrRGlyID09PSBVbmljb2RlQmlkaURpcmVjdGlvbi5ORVVUUkFMID8gZmFsbGJhY2sgOiBibG9ja0Rpcjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaXJlY3Rpb24gb2YgYSBibG9jayBvZiB0ZXh0LCBiYXNlZCBvbiB0aGUgZGlyZWN0aW9uIG9mIGl0c1xuICogZmlyc3Qgc3Ryb25nIGNoYXJhY3RlciAoaGFzIEJpZGlfQ2xhc3MgdmFsdWUgb2YgTCwgUiwgb3IgQUwpLCBvciBhIGZhbGxiYWNrXG4gKiBkaXJlY3Rpb24sIGlmIG5vIHN0cm9uZyBjaGFyYWN0ZXIgaXMgZm91bmQuXG4gKlxuICogTk9URTogVGhpcyBmdW5jdGlvbiBpcyBzaW1pbGFyIHRvIHJlc29sdmVCbG9ja0RpcigpLCBidXQgdXNlcyB0aGUgZ2xvYmFsXG4gKiBkaXJlY3Rpb24gYXMgdGhlIGZhbGxiYWNrLCBzbyBpdCAqYWx3YXlzKiByZXR1cm5zIGEgU3Ryb25nIGRpcmVjdGlvbixcbiAqIG1ha2luZyBpdCB1c2VmdWwgZm9yIGludGVncmF0aW9uIGluIHBsYWNlcyB0aGF0IHlvdSBuZWVkIHRvIG1ha2UgdGhlIGZpbmFsXG4gKiBkZWNpc2lvbiwgbGlrZSBzZXR0aW5nIHNvbWUgQ1NTIGNsYXNzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiByZXNwZWN0IHRvIEhpZ2hlci1MZXZlbCBQcm90b2NvbFxuICogcnVsZSBITDEuIChodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHI5LyNITDEpXG4gKlxuICogQHBhcmFtIHN0ciAgICAgICAgICAgICBBIHRleHQgYmxvY2s7IGUuZy4gcGFyYWdyYXBoLCB0YWJsZSBjZWxsXG4gKiBAcGFyYW0gc3Ryb25nRmFsbGJhY2sgIEZhbGxiYWNrIGRpcmVjdGlvbiwgdXNlZCBpZiBubyBzdHJvbmcgZGlyZWN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdGVkIGZvciB0aGUgYmxvY2sgKGRlZmF1bHQgPSBnbG9iYWwgZGlyZWN0aW9uKVxuICogQHJldHVybiAgICAgICAgICAgICAgICBUaGUgcmVzb2x2ZWQgU3Ryb25nIGRpcmVjdGlvblxuICovXG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oc3RyLCBzdHJvbmdGYWxsYmFjaykge1xuICBpZiAoIXN0cm9uZ0ZhbGxiYWNrKSB7XG4gICAgc3Ryb25nRmFsbGJhY2sgPSBVbmljb2RlQmlkaURpcmVjdGlvbi5nZXRHbG9iYWxEaXIoKTtcbiAgfVxuICAhVW5pY29kZUJpZGlEaXJlY3Rpb24uaXNTdHJvbmcoc3Ryb25nRmFsbGJhY2spID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0ZhbGxiYWNrIGRpcmVjdGlvbiBtdXN0IGJlIGEgc3Ryb25nIGRpcmVjdGlvbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHJlc29sdmVCbG9ja0RpcihzdHIsIHN0cm9uZ0ZhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZ2V0RGlyZWN0aW9uKGFyZ3VtZW50cy4uLikgcmV0dXJucyBMVFIuXG4gKlxuICogQHBhcmFtIHN0ciAgICAgICAgICAgICBBIHRleHQgYmxvY2s7IGUuZy4gcGFyYWdyYXBoLCB0YWJsZSBjZWxsXG4gKiBAcGFyYW0gc3Ryb25nRmFsbGJhY2sgIEZhbGxiYWNrIGRpcmVjdGlvbiwgdXNlZCBpZiBubyBzdHJvbmcgZGlyZWN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdGVkIGZvciB0aGUgYmxvY2sgKGRlZmF1bHQgPSBnbG9iYWwgZGlyZWN0aW9uKVxuICogQHJldHVybiAgICAgICAgICAgICAgICBUcnVlIGlmIHRoZSByZXNvbHZlZCBkaXJlY3Rpb24gaXMgTFRSXG4gKi9cbmZ1bmN0aW9uIGlzRGlyZWN0aW9uTFRSKHN0ciwgc3Ryb25nRmFsbGJhY2spIHtcbiAgcmV0dXJuIGdldERpcmVjdGlvbihzdHIsIHN0cm9uZ0ZhbGxiYWNrKSA9PT0gVW5pY29kZUJpZGlEaXJlY3Rpb24uTFRSO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBnZXREaXJlY3Rpb24oYXJndW1lbnRzLi4uKSByZXR1cm5zIFJUTC5cbiAqXG4gKiBAcGFyYW0gc3RyICAgICAgICAgICAgIEEgdGV4dCBibG9jazsgZS5nLiBwYXJhZ3JhcGgsIHRhYmxlIGNlbGxcbiAqIEBwYXJhbSBzdHJvbmdGYWxsYmFjayAgRmFsbGJhY2sgZGlyZWN0aW9uLCB1c2VkIGlmIG5vIHN0cm9uZyBkaXJlY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWQgZm9yIHRoZSBibG9jayAoZGVmYXVsdCA9IGdsb2JhbCBkaXJlY3Rpb24pXG4gKiBAcmV0dXJuICAgICAgICAgICAgICAgIFRydWUgaWYgdGhlIHJlc29sdmVkIGRpcmVjdGlvbiBpcyBSVExcbiAqL1xuZnVuY3Rpb24gaXNEaXJlY3Rpb25SVEwoc3RyLCBzdHJvbmdGYWxsYmFjaykge1xuICByZXR1cm4gZ2V0RGlyZWN0aW9uKHN0ciwgc3Ryb25nRmFsbGJhY2spID09PSBVbmljb2RlQmlkaURpcmVjdGlvbi5SVEw7XG59XG5cbnZhciBVbmljb2RlQmlkaSA9IHtcbiAgZmlyc3RTdHJvbmdDaGFyOiBmaXJzdFN0cm9uZ0NoYXIsXG4gIGZpcnN0U3Ryb25nQ2hhckRpcjogZmlyc3RTdHJvbmdDaGFyRGlyLFxuICByZXNvbHZlQmxvY2tEaXI6IHJlc29sdmVCbG9ja0RpcixcbiAgZ2V0RGlyZWN0aW9uOiBnZXREaXJlY3Rpb24sXG4gIGlzRGlyZWN0aW9uTFRSOiBpc0RpcmVjdGlvbkxUUixcbiAgaXNEaXJlY3Rpb25SVEw6IGlzRGlyZWN0aW9uUlRMXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaWNvZGVCaWRpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL1VuaWNvZGVCaWRpLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERlZmF1bHREcmFmdElubGluZVN0eWxlXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCT0xEOiB7XG4gICAgZm9udFdlaWdodDogJ2JvbGQnXG4gIH0sXG5cbiAgQ09ERToge1xuICAgIGZvbnRGYW1pbHk6ICdtb25vc3BhY2UnLFxuICAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCdcbiAgfSxcblxuICBJVEFMSUM6IHtcbiAgICBmb250U3R5bGU6ICdpdGFsaWMnXG4gIH0sXG5cbiAgU1RSSUtFVEhST1VHSDoge1xuICAgIHRleHREZWNvcmF0aW9uOiAnbGluZS10aHJvdWdoJ1xuICB9LFxuXG4gIFVOREVSTElORToge1xuICAgIHRleHREZWNvcmF0aW9uOiAndW5kZXJsaW5lJ1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EZWZhdWx0RHJhZnRJbmxpbmVTdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1NlbGVjdGlvbkF0TGVhZlN0YXJ0XG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGlzU2VsZWN0aW9uQXRMZWFmU3RhcnQoZWRpdG9yU3RhdGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpO1xuICB2YXIgYW5jaG9yS2V5ID0gc2VsZWN0aW9uLmdldEFuY2hvcktleSgpO1xuICB2YXIgYmxvY2tUcmVlID0gZWRpdG9yU3RhdGUuZ2V0QmxvY2tUcmVlKGFuY2hvcktleSk7XG4gIHZhciBvZmZzZXQgPSBzZWxlY3Rpb24uZ2V0U3RhcnRPZmZzZXQoKTtcblxuICB2YXIgaXNBdFN0YXJ0ID0gZmFsc2U7XG5cbiAgYmxvY2tUcmVlLnNvbWUoZnVuY3Rpb24gKGxlYWZTZXQpIHtcbiAgICBpZiAob2Zmc2V0ID09PSBsZWFmU2V0LmdldCgnc3RhcnQnKSkge1xuICAgICAgaXNBdFN0YXJ0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPCBsZWFmU2V0LmdldCgnZW5kJykpIHtcbiAgICAgIHJldHVybiBsZWFmU2V0LmdldCgnbGVhdmVzJykuc29tZShmdW5jdGlvbiAobGVhZikge1xuICAgICAgICB2YXIgbGVhZlN0YXJ0ID0gbGVhZi5nZXQoJ3N0YXJ0Jyk7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IGxlYWZTdGFydCkge1xuICAgICAgICAgIGlzQXRTdGFydCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuXG4gIHJldHVybiBpc0F0U3RhcnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTZWxlY3Rpb25BdExlYWZTdGFydDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvaXNTZWxlY3Rpb25BdExlYWZTdGFydC5qc1xuLy8gbW9kdWxlIGlkID0gMzY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEcmFmdEVkaXRvckJsb2NrLnJlYWN0XG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX2V4dGVuZHMgPSBfYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBEcmFmdEVkaXRvckxlYWYgPSByZXF1aXJlKCcuL0RyYWZ0RWRpdG9yTGVhZi5yZWFjdCcpO1xudmFyIERyYWZ0T2Zmc2V0S2V5ID0gcmVxdWlyZSgnLi9EcmFmdE9mZnNldEtleScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIFNjcm9sbCA9IHJlcXVpcmUoJ2ZianMvbGliL1Njcm9sbCcpO1xudmFyIFN0eWxlID0gcmVxdWlyZSgnZmJqcy9saWIvU3R5bGUnKTtcbnZhciBVbmljb2RlQmlkaSA9IHJlcXVpcmUoJ2ZianMvbGliL1VuaWNvZGVCaWRpJyk7XG52YXIgVW5pY29kZUJpZGlEaXJlY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9Vbmljb2RlQmlkaURpcmVjdGlvbicpO1xuXG52YXIgY3ggPSByZXF1aXJlKCdmYmpzL2xpYi9jeCcpO1xudmFyIGdldEVsZW1lbnRQb3NpdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEVsZW1lbnRQb3NpdGlvbicpO1xudmFyIGdldFNjcm9sbFBvc2l0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0U2Nyb2xsUG9zaXRpb24nKTtcbnZhciBnZXRWaWV3cG9ydERpbWVuc2lvbnMgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRWaWV3cG9ydERpbWVuc2lvbnMnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBudWxsdGhyb3dzID0gcmVxdWlyZSgnZmJqcy9saWIvbnVsbHRocm93cycpO1xuXG52YXIgU0NST0xMX0JVRkZFUiA9IDEwO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgYmxvY2sgb3ZlcmxhcHMgd2l0aCBlaXRoZXIgZWRnZSBvZiB0aGUgYFNlbGVjdGlvblN0YXRlYC5cbiAqL1xudmFyIGlzQmxvY2tPblNlbGVjdGlvbkVkZ2UgPSBmdW5jdGlvbiBpc0Jsb2NrT25TZWxlY3Rpb25FZGdlKHNlbGVjdGlvbiwga2V5KSB7XG4gIHJldHVybiBzZWxlY3Rpb24uZ2V0QW5jaG9yS2V5KCkgPT09IGtleSB8fCBzZWxlY3Rpb24uZ2V0Rm9jdXNLZXkoKSA9PT0ga2V5O1xufTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBibG9jayByZW5kZXJlciBmb3IgYSBgRHJhZnRFZGl0b3JgIGNvbXBvbmVudC5cbiAqXG4gKiBBIGBEcmFmdEVkaXRvckJsb2NrYCBpcyBhYmxlIHRvIHJlbmRlciBhIGdpdmVuIGBDb250ZW50QmxvY2tgIHRvIGl0c1xuICogYXBwcm9wcmlhdGUgZGVjb3JhdG9yIGFuZCBpbmxpbmUgc3R5bGUgY29tcG9uZW50cy5cbiAqL1xuXG52YXIgRHJhZnRFZGl0b3JCbG9jayA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhEcmFmdEVkaXRvckJsb2NrLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBEcmFmdEVkaXRvckJsb2NrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcmFmdEVkaXRvckJsb2NrKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgRHJhZnRFZGl0b3JCbG9jay5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmJsb2NrICE9PSBuZXh0UHJvcHMuYmxvY2sgfHwgdGhpcy5wcm9wcy50cmVlICE9PSBuZXh0UHJvcHMudHJlZSB8fCB0aGlzLnByb3BzLmRpcmVjdGlvbiAhPT0gbmV4dFByb3BzLmRpcmVjdGlvbiB8fCBpc0Jsb2NrT25TZWxlY3Rpb25FZGdlKG5leHRQcm9wcy5zZWxlY3Rpb24sIG5leHRQcm9wcy5ibG9jay5nZXRLZXkoKSkgJiYgbmV4dFByb3BzLmZvcmNlU2VsZWN0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIGEgYmxvY2sgaXMgbW91bnRlZCBhbmQgb3ZlcmxhcHMgdGhlIHNlbGVjdGlvbiBzdGF0ZSwgd2UgbmVlZCB0byBtYWtlXG4gICAqIHN1cmUgdGhhdCB0aGUgY3Vyc29yIGlzIHZpc2libGUgdG8gbWF0Y2ggbmF0aXZlIGJlaGF2aW9yLiBUaGlzIG1heSBub3RcbiAgICogYmUgdGhlIGNhc2UgaWYgdGhlIHVzZXIgaGFzIHByZXNzZWQgYFJFVFVSTmAgb3IgcGFzdGVkIHNvbWUgY29udGVudCwgc2luY2VcbiAgICogcHJvZ3JhbWF0aWNhbGx5IGNyZWF0aW5nIHRoZXNlIG5ldyBibG9ja3MgYW5kIHNldHRpbmcgdGhlIERPTSBzZWxlY3Rpb25cbiAgICogd2lsbCBtaXNzIG91dCBvbiB0aGUgYnJvd3NlciBuYXRpdmVseSBzY3JvbGxpbmcgdG8gdGhhdCBwb3NpdGlvbi5cbiAgICpcbiAgICogVG8gcmVwbGljYXRlIG5hdGl2ZSBiZWhhdmlvciwgaWYgdGhlIGJsb2NrIG92ZXJsYXBzIHRoZSBzZWxlY3Rpb24gc3RhdGVcbiAgICogb24gbW91bnQsIGZvcmNlIHRoZSBzY3JvbGwgcG9zaXRpb24uIENoZWNrIHRoZSBzY3JvbGwgc3RhdGUgb2YgdGhlIHNjcm9sbFxuICAgKiBwYXJlbnQsIGFuZCBhZGp1c3QgaXQgdG8gYWxpZ24gdGhlIGVudGlyZSBibG9jayB0byB0aGUgYm90dG9tIG9mIHRoZVxuICAgKiBzY3JvbGwgcGFyZW50LlxuICAgKi9cblxuXG4gIERyYWZ0RWRpdG9yQmxvY2sucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMucHJvcHMuc2VsZWN0aW9uO1xuICAgIHZhciBlbmRLZXkgPSBzZWxlY3Rpb24uZ2V0RW5kS2V5KCk7XG4gICAgaWYgKCFzZWxlY3Rpb24uZ2V0SGFzRm9jdXMoKSB8fCBlbmRLZXkgIT09IHRoaXMucHJvcHMuYmxvY2suZ2V0S2V5KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYmxvY2tOb2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG4gICAgdmFyIHNjcm9sbFBhcmVudCA9IFN0eWxlLmdldFNjcm9sbFBhcmVudChibG9ja05vZGUpO1xuICAgIHZhciBzY3JvbGxQb3NpdGlvbiA9IGdldFNjcm9sbFBvc2l0aW9uKHNjcm9sbFBhcmVudCk7XG4gICAgdmFyIHNjcm9sbERlbHRhID0gdm9pZCAwO1xuXG4gICAgaWYgKHNjcm9sbFBhcmVudCA9PT0gd2luZG93KSB7XG4gICAgICB2YXIgbm9kZVBvc2l0aW9uID0gZ2V0RWxlbWVudFBvc2l0aW9uKGJsb2NrTm9kZSk7XG4gICAgICB2YXIgbm9kZUJvdHRvbSA9IG5vZGVQb3NpdGlvbi55ICsgbm9kZVBvc2l0aW9uLmhlaWdodDtcbiAgICAgIHZhciB2aWV3cG9ydEhlaWdodCA9IGdldFZpZXdwb3J0RGltZW5zaW9ucygpLmhlaWdodDtcbiAgICAgIHNjcm9sbERlbHRhID0gbm9kZUJvdHRvbSAtIHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgaWYgKHNjcm9sbERlbHRhID4gMCkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oc2Nyb2xsUG9zaXRpb24ueCwgc2Nyb2xsUG9zaXRpb24ueSArIHNjcm9sbERlbHRhICsgU0NST0xMX0JVRkZFUik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICEoYmxvY2tOb2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Jsb2NrTm9kZSBpcyBub3QgYW4gSFRNTEVsZW1lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgYmxvY2tCb3R0b20gPSBibG9ja05vZGUub2Zmc2V0SGVpZ2h0ICsgYmxvY2tOb2RlLm9mZnNldFRvcDtcbiAgICAgIHZhciBzY3JvbGxCb3R0b20gPSBzY3JvbGxQYXJlbnQub2Zmc2V0SGVpZ2h0ICsgc2Nyb2xsUG9zaXRpb24ueTtcbiAgICAgIHNjcm9sbERlbHRhID0gYmxvY2tCb3R0b20gLSBzY3JvbGxCb3R0b207XG4gICAgICBpZiAoc2Nyb2xsRGVsdGEgPiAwKSB7XG4gICAgICAgIFNjcm9sbC5zZXRUb3Aoc2Nyb2xsUGFyZW50LCBTY3JvbGwuZ2V0VG9wKHNjcm9sbFBhcmVudCkgKyBzY3JvbGxEZWx0YSArIFNDUk9MTF9CVUZGRVIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBEcmFmdEVkaXRvckJsb2NrLnByb3RvdHlwZS5fcmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbiBfcmVuZGVyQ2hpbGRyZW4oKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgYmxvY2sgPSB0aGlzLnByb3BzLmJsb2NrO1xuICAgIHZhciBibG9ja0tleSA9IGJsb2NrLmdldEtleSgpO1xuICAgIHZhciB0ZXh0ID0gYmxvY2suZ2V0VGV4dCgpO1xuICAgIHZhciBsYXN0TGVhZlNldCA9IHRoaXMucHJvcHMudHJlZS5zaXplIC0gMTtcbiAgICB2YXIgaGFzU2VsZWN0aW9uID0gaXNCbG9ja09uU2VsZWN0aW9uRWRnZSh0aGlzLnByb3BzLnNlbGVjdGlvbiwgYmxvY2tLZXkpO1xuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMudHJlZS5tYXAoZnVuY3Rpb24gKGxlYWZTZXQsIGlpKSB7XG4gICAgICB2YXIgbGVhdmVzRm9yTGVhZlNldCA9IGxlYWZTZXQuZ2V0KCdsZWF2ZXMnKTtcbiAgICAgIHZhciBsYXN0TGVhZiA9IGxlYXZlc0ZvckxlYWZTZXQuc2l6ZSAtIDE7XG4gICAgICB2YXIgbGVhdmVzID0gbGVhdmVzRm9yTGVhZlNldC5tYXAoZnVuY3Rpb24gKGxlYWYsIGpqKSB7XG4gICAgICAgIHZhciBvZmZzZXRLZXkgPSBEcmFmdE9mZnNldEtleS5lbmNvZGUoYmxvY2tLZXksIGlpLCBqaik7XG4gICAgICAgIHZhciBzdGFydCA9IGxlYWYuZ2V0KCdzdGFydCcpO1xuICAgICAgICB2YXIgZW5kID0gbGVhZi5nZXQoJ2VuZCcpO1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEcmFmdEVkaXRvckxlYWYsIHtcbiAgICAgICAgICBrZXk6IG9mZnNldEtleSxcbiAgICAgICAgICBvZmZzZXRLZXk6IG9mZnNldEtleSxcbiAgICAgICAgICBibG9jazogYmxvY2ssXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIHNlbGVjdGlvbjogaGFzU2VsZWN0aW9uID8gX3RoaXMyLnByb3BzLnNlbGVjdGlvbiA6IG51bGwsXG4gICAgICAgICAgZm9yY2VTZWxlY3Rpb246IF90aGlzMi5wcm9wcy5mb3JjZVNlbGVjdGlvbixcbiAgICAgICAgICB0ZXh0OiB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgIHN0eWxlU2V0OiBibG9jay5nZXRJbmxpbmVTdHlsZUF0KHN0YXJ0KSxcbiAgICAgICAgICBjdXN0b21TdHlsZU1hcDogX3RoaXMyLnByb3BzLmN1c3RvbVN0eWxlTWFwLFxuICAgICAgICAgIGN1c3RvbVN0eWxlRm46IF90aGlzMi5wcm9wcy5jdXN0b21TdHlsZUZuLFxuICAgICAgICAgIGlzTGFzdDogaWkgPT09IGxhc3RMZWFmU2V0ICYmIGpqID09PSBsYXN0TGVhZlxuICAgICAgICB9KTtcbiAgICAgIH0pLnRvQXJyYXkoKTtcblxuICAgICAgdmFyIGRlY29yYXRvcktleSA9IGxlYWZTZXQuZ2V0KCdkZWNvcmF0b3JLZXknKTtcbiAgICAgIGlmIChkZWNvcmF0b3JLZXkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGVhdmVzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV90aGlzMi5wcm9wcy5kZWNvcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGxlYXZlcztcbiAgICAgIH1cblxuICAgICAgdmFyIGRlY29yYXRvciA9IG51bGx0aHJvd3MoX3RoaXMyLnByb3BzLmRlY29yYXRvcik7XG5cbiAgICAgIHZhciBEZWNvcmF0b3JDb21wb25lbnQgPSBkZWNvcmF0b3IuZ2V0Q29tcG9uZW50Rm9yS2V5KGRlY29yYXRvcktleSk7XG4gICAgICBpZiAoIURlY29yYXRvckNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gbGVhdmVzO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVjb3JhdG9yUHJvcHMgPSBkZWNvcmF0b3IuZ2V0UHJvcHNGb3JLZXkoZGVjb3JhdG9yS2V5KTtcbiAgICAgIHZhciBkZWNvcmF0b3JPZmZzZXRLZXkgPSBEcmFmdE9mZnNldEtleS5lbmNvZGUoYmxvY2tLZXksIGlpLCAwKTtcbiAgICAgIHZhciBkZWNvcmF0ZWRUZXh0ID0gdGV4dC5zbGljZShsZWF2ZXNGb3JMZWFmU2V0LmZpcnN0KCkuZ2V0KCdzdGFydCcpLCBsZWF2ZXNGb3JMZWFmU2V0Lmxhc3QoKS5nZXQoJ2VuZCcpKTtcblxuICAgICAgLy8gUmVzZXR0aW5nIGRpciB0byB0aGUgc2FtZSB2YWx1ZSBvbiBhIGNoaWxkIG5vZGUgbWFrZXMgQ2hyb21lL0ZpcmVmb3hcbiAgICAgIC8vIGNvbmZ1c2VkIG9uIGN1cnNvciBtb3ZlbWVudC4gU2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZDE1N2tMY2svMy9cbiAgICAgIHZhciBkaXIgPSBVbmljb2RlQmlkaURpcmVjdGlvbi5nZXRIVE1MRGlySWZEaWZmZXJlbnQoVW5pY29kZUJpZGkuZ2V0RGlyZWN0aW9uKGRlY29yYXRlZFRleHQpLCBfdGhpczIucHJvcHMuZGlyZWN0aW9uKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIERlY29yYXRvckNvbXBvbmVudCxcbiAgICAgICAgX2V4dGVuZHMoe30sIGRlY29yYXRvclByb3BzLCB7XG4gICAgICAgICAgY29udGVudFN0YXRlOiBfdGhpczIucHJvcHMuY29udGVudFN0YXRlLFxuICAgICAgICAgIGRlY29yYXRlZFRleHQ6IGRlY29yYXRlZFRleHQsXG4gICAgICAgICAgZGlyOiBkaXIsXG4gICAgICAgICAga2V5OiBkZWNvcmF0b3JPZmZzZXRLZXksXG4gICAgICAgICAgZW50aXR5S2V5OiBibG9jay5nZXRFbnRpdHlBdChsZWFmU2V0LmdldCgnc3RhcnQnKSksXG4gICAgICAgICAgb2Zmc2V0S2V5OiBkZWNvcmF0b3JPZmZzZXRLZXkgfSksXG4gICAgICAgIGxlYXZlc1xuICAgICAgKTtcbiAgICB9KS50b0FycmF5KCk7XG4gIH07XG5cbiAgRHJhZnRFZGl0b3JCbG9jay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBkaXJlY3Rpb24gPSBfcHJvcHMuZGlyZWN0aW9uLFxuICAgICAgICBvZmZzZXRLZXkgPSBfcHJvcHMub2Zmc2V0S2V5O1xuXG4gICAgdmFyIGNsYXNzTmFtZSA9IGN4KHtcbiAgICAgICdwdWJsaWMvRHJhZnRTdHlsZURlZmF1bHQvYmxvY2snOiB0cnVlLFxuICAgICAgJ3B1YmxpYy9EcmFmdFN0eWxlRGVmYXVsdC9sdHInOiBkaXJlY3Rpb24gPT09ICdMVFInLFxuICAgICAgJ3B1YmxpYy9EcmFmdFN0eWxlRGVmYXVsdC9ydGwnOiBkaXJlY3Rpb24gPT09ICdSVEwnXG4gICAgfSk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyAnZGF0YS1vZmZzZXQta2V5Jzogb2Zmc2V0S2V5LCBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LFxuICAgICAgdGhpcy5fcmVuZGVyQ2hpbGRyZW4oKVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIERyYWZ0RWRpdG9yQmxvY2s7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZnRFZGl0b3JCbG9jaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRHJhZnRFZGl0b3JCbG9jay5yZWFjdC5qc1xuLy8gbW9kdWxlIGlkID0gMzY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge0RPTURvY3VtZW50fSBkb2NcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIF9pc1ZpZXdwb3J0U2Nyb2xsRWxlbWVudChlbGVtZW50LCBkb2MpIHtcbiAgcmV0dXJuICEhZG9jICYmIChlbGVtZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50IHx8IGVsZW1lbnQgPT09IGRvYy5ib2R5KTtcbn1cblxuLyoqXG4gKiBTY3JvbGwgTW9kdWxlLiBUaGlzIGNsYXNzIGNvbnRhaW5zIDQgc2ltcGxlIHN0YXRpYyBmdW5jdGlvbnNcbiAqIHRvIGJlIHVzZWQgdG8gYWNjZXNzIEVsZW1lbnQuc2Nyb2xsVG9wL3Njcm9sbExlZnQgcHJvcGVydGllcy5cbiAqIFRvIHNvbHZlIHRoZSBpbmNvbnNpc3RlbmNpZXMgYmV0d2VlbiBicm93c2VycyB3aGVuIGVpdGhlclxuICogZG9jdW1lbnQuYm9keSBvciBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgaXMgc3VwcGxpZWQsXG4gKiBiZWxvdyBsb2dpYyB3aWxsIGJlIHVzZWQgdG8gYWxsZXZpYXRlIHRoZSBpc3N1ZTpcbiAqXG4gKiAxLiBJZiAnZWxlbWVudCcgaXMgZWl0aGVyICdkb2N1bWVudC5ib2R5JyBvciAnZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICogICAgZ2V0IHdoaWNoZXZlciBlbGVtZW50J3MgJ3Njcm9sbHtUb3AsTGVmdH0nIGlzIGxhcmdlci5cbiAqIDIuIElmICdlbGVtZW50JyBpcyBlaXRoZXIgJ2RvY3VtZW50LmJvZHknIG9yICdkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQnLFxuICogICAgc2V0IHRoZSAnc2Nyb2xse1RvcCxMZWZ0fScgb24gYm90aCBlbGVtZW50cy5cbiAqL1xuXG52YXIgU2Nyb2xsID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFRvcDogZnVuY3Rpb24gZ2V0VG9wKGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBfaXNWaWV3cG9ydFNjcm9sbEVsZW1lbnQoZWxlbWVudCwgZG9jKSA/XG4gICAgLy8gSW4gcHJhY3RpY2UsIHRoZXkgd2lsbCBlaXRoZXIgYm90aCBoYXZlIHRoZSBzYW1lIHZhbHVlLFxuICAgIC8vIG9yIG9uZSB3aWxsIGJlIHplcm8gYW5kIHRoZSBvdGhlciB3aWxsIGJlIHRoZSBzY3JvbGwgcG9zaXRpb25cbiAgICAvLyBvZiB0aGUgdmlld3BvcnQuIFNvIHdlIGNhbiB1c2UgYFggfHwgWWAgaW5zdGVhZCBvZiBgTWF0aC5tYXgoWCwgWSlgXG4gICAgZG9jLmJvZHkuc2Nyb2xsVG9wIHx8IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIDogZWxlbWVudC5zY3JvbGxUb3A7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VG9wXG4gICAqL1xuICBzZXRUb3A6IGZ1bmN0aW9uIHNldFRvcChlbGVtZW50LCBuZXdUb3ApIHtcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgIGlmIChfaXNWaWV3cG9ydFNjcm9sbEVsZW1lbnQoZWxlbWVudCwgZG9jKSkge1xuICAgICAgZG9jLmJvZHkuc2Nyb2xsVG9wID0gZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgPSBuZXdUb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gbmV3VG9wO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlZnQ6IGZ1bmN0aW9uIGdldExlZnQoZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIF9pc1ZpZXdwb3J0U2Nyb2xsRWxlbWVudChlbGVtZW50LCBkb2MpID8gZG9jLmJvZHkuc2Nyb2xsTGVmdCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgOiBlbGVtZW50LnNjcm9sbExlZnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gbmV3TGVmdFxuICAgKi9cbiAgc2V0TGVmdDogZnVuY3Rpb24gc2V0TGVmdChlbGVtZW50LCBuZXdMZWZ0KSB7XG4gICAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICBpZiAoX2lzVmlld3BvcnRTY3JvbGxFbGVtZW50KGVsZW1lbnQsIGRvYykpIHtcbiAgICAgIGRvYy5ib2R5LnNjcm9sbExlZnQgPSBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgPSBuZXdMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnNjcm9sbExlZnQgPSBuZXdMZWZ0O1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvU2Nyb2xsLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgUGhvdG9zTWltZVR5cGUgPSByZXF1aXJlKCcuL1Bob3Rvc01pbWVUeXBlJyk7XG5cbnZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJy4vY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbnZhciBDUl9MRl9SRUdFWCA9IG5ldyBSZWdFeHAoJ1xcclxcbicsICdnJyk7XG52YXIgTEZfT05MWSA9ICdcXG4nO1xuXG52YXIgUklDSF9URVhUX1RZUEVTID0ge1xuICAndGV4dC9ydGYnOiAxLFxuICAndGV4dC9odG1sJzogMVxufTtcblxuLyoqXG4gKiBJZiBEYXRhVHJhbnNmZXJJdGVtIGlzIGEgZmlsZSB0aGVuIHJldHVybiB0aGUgQmxvYiBvZiBkYXRhLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtXG4gKiBAcmV0dXJuIHs/YmxvYn1cbiAqL1xuZnVuY3Rpb24gZ2V0RmlsZUZyb21EYXRhVHJhbnNmZXIoaXRlbSkge1xuICBpZiAoaXRlbS5raW5kID09ICdmaWxlJykge1xuICAgIHJldHVybiBpdGVtLmdldEFzRmlsZSgpO1xuICB9XG59XG5cbnZhciBEYXRhVHJhbnNmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICAgKi9cbiAgZnVuY3Rpb24gRGF0YVRyYW5zZmVyKGRhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVRyYW5zZmVyKTtcblxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBUeXBlcyBjb3VsZCBiZSBET01TdHJpbmdMaXN0IG9yIGFycmF5XG4gICAgdGhpcy50eXBlcyA9IGRhdGEudHlwZXMgPyBjcmVhdGVBcnJheUZyb21NaXhlZChkYXRhLnR5cGVzKSA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoaXMgbGlrZWx5IHRvIGJlIGEgcmljaCB0ZXh0IGRhdGEgdHJhbnNmZXI/XG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgRGF0YVRyYW5zZmVyLnByb3RvdHlwZS5pc1JpY2hUZXh0ID0gZnVuY3Rpb24gaXNSaWNoVGV4dCgpIHtcbiAgICAvLyBJZiBIVE1MIGlzIGF2YWlsYWJsZSwgdHJlYXQgdGhpcyBkYXRhIGFzIHJpY2ggdGV4dC4gVGhpcyB3YXksIHdlIGF2b2lkXG4gICAgLy8gdXNpbmcgYSBwYXN0ZWQgaW1hZ2UgaWYgaXQgaXMgcGFja2FnZWQgd2l0aCBIVE1MIC0tIHRoaXMgbWF5IG9jY3VyIHdpdGhcbiAgICAvLyBwYXN0ZXMgZnJvbSBNUyBXb3JkLCBmb3IgZXhhbXBsZS4gIEhvd2V2ZXIgdGhpcyBpcyBvbmx5IHJpY2ggdGV4dCBpZlxuICAgIC8vIHRoZXJlJ3MgYWNjb21wYW55aW5nIHRleHQuXG4gICAgaWYgKHRoaXMuZ2V0SFRNTCgpICYmIHRoaXMuZ2V0VGV4dCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGFuIGltYWdlIGlzIGNvcGllZCBmcm9tIGEgcHJldmlldyB3aW5kb3csIHlvdSBlbmQgdXAgd2l0aCB0d29cbiAgICAvLyBEYXRhVHJhbnNmZXJJdGVtcyBvbmUgb2Ygd2hpY2ggaXMgYSBmaWxlJ3MgbWV0YWRhdGEgYXMgdGV4dC4gIFNraXAgdGhvc2UuXG4gICAgaWYgKHRoaXMuaXNJbWFnZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudHlwZXMuc29tZShmdW5jdGlvbiAodHlwZSkge1xuICAgICAgcmV0dXJuIFJJQ0hfVEVYVF9UWVBFU1t0eXBlXTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHJhdyB0ZXh0LlxuICAgKlxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cblxuXG4gIERhdGFUcmFuc2Zlci5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIGdldFRleHQoKSB7XG4gICAgdmFyIHRleHQ7XG4gICAgaWYgKHRoaXMuZGF0YS5nZXREYXRhKSB7XG4gICAgICBpZiAoIXRoaXMudHlwZXMubGVuZ3RoKSB7XG4gICAgICAgIHRleHQgPSB0aGlzLmRhdGEuZ2V0RGF0YSgnVGV4dCcpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGVzLmluZGV4T2YoJ3RleHQvcGxhaW4nKSAhPSAtMSkge1xuICAgICAgICB0ZXh0ID0gdGhpcy5kYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQgPyB0ZXh0LnJlcGxhY2UoQ1JfTEZfUkVHRVgsIExGX09OTFkpIDogbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IEhUTUwgcGFzdGUgZGF0YVxuICAgKlxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cblxuXG4gIERhdGFUcmFuc2Zlci5wcm90b3R5cGUuZ2V0SFRNTCA9IGZ1bmN0aW9uIGdldEhUTUwoKSB7XG4gICAgaWYgKHRoaXMuZGF0YS5nZXREYXRhKSB7XG4gICAgICBpZiAoIXRoaXMudHlwZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuZ2V0RGF0YSgnVGV4dCcpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGVzLmluZGV4T2YoJ3RleHQvaHRtbCcpICE9IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJcyB0aGlzIGEgbGluayBkYXRhIHRyYW5zZmVyP1xuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXG4gIERhdGFUcmFuc2Zlci5wcm90b3R5cGUuaXNMaW5rID0gZnVuY3Rpb24gaXNMaW5rKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGVzLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiB0eXBlLmluZGV4T2YoJ1VybCcpICE9IC0xIHx8IHR5cGUuaW5kZXhPZigndGV4dC91cmktbGlzdCcpICE9IC0xIHx8IHR5cGUuaW5kZXhPZigndGV4dC94LW1vei11cmwnKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgbGluayB1cmwuXG4gICAqXG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuXG5cbiAgRGF0YVRyYW5zZmVyLnByb3RvdHlwZS5nZXRMaW5rID0gZnVuY3Rpb24gZ2V0TGluaygpIHtcbiAgICBpZiAodGhpcy5kYXRhLmdldERhdGEpIHtcbiAgICAgIGlmICh0aGlzLnR5cGVzLmluZGV4T2YoJ3RleHQveC1tb3otdXJsJykgIT0gLTEpIHtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMuZGF0YS5nZXREYXRhKCd0ZXh0L3gtbW96LXVybCcpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgcmV0dXJuIHVybFswXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnR5cGVzLmluZGV4T2YoJ3RleHQvdXJpLWxpc3QnKSAhPSAtMSA/IHRoaXMuZGF0YS5nZXREYXRhKCd0ZXh0L3VyaS1saXN0JykgOiB0aGlzLmRhdGEuZ2V0RGF0YSgndXJsJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHRoaXMgYW4gaW1hZ2UgZGF0YSB0cmFuc2Zlcj9cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBEYXRhVHJhbnNmZXIucHJvdG90eXBlLmlzSW1hZ2UgPSBmdW5jdGlvbiBpc0ltYWdlKCkge1xuICAgIHZhciBpc0ltYWdlID0gdGhpcy50eXBlcy5zb21lKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAvLyBGaXJlZm94IHdpbGwgaGF2ZSBhIHR5cGUgb2YgYXBwbGljYXRpb24veC1tb3otZmlsZSBmb3IgaW1hZ2VzIGR1cmluZ1xuICAgICAgLy8gZHJhZ2dpbmdcbiAgICAgIHJldHVybiB0eXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtbW96LWZpbGUnKSAhPSAtMTtcbiAgICB9KTtcblxuICAgIGlmIChpc0ltYWdlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXRlbXMgPSB0aGlzLmdldEZpbGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHR5cGUgPSBpdGVtc1tpXS50eXBlO1xuICAgICAgaWYgKCFQaG90b3NNaW1lVHlwZS5pc0ltYWdlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBEYXRhVHJhbnNmZXIucHJvdG90eXBlLmdldENvdW50ID0gZnVuY3Rpb24gZ2V0Q291bnQoKSB7XG4gICAgaWYgKHRoaXMuZGF0YS5oYXNPd25Qcm9wZXJ0eSgnaXRlbXMnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YS5pdGVtcy5sZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGEuaGFzT3duUHJvcGVydHkoJ21vekl0ZW1Db3VudCcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLm1vekl0ZW1Db3VudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5maWxlcykge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YS5maWxlcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgZmlsZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge2FycmF5fVxuICAgKi9cblxuXG4gIERhdGFUcmFuc2Zlci5wcm90b3R5cGUuZ2V0RmlsZXMgPSBmdW5jdGlvbiBnZXRGaWxlcygpIHtcbiAgICBpZiAodGhpcy5kYXRhLml0ZW1zKSB7XG4gICAgICAvLyBjcmVhdGVBcnJheUZyb21NaXhlZCBkb2Vzbid0IHByb3Blcmx5IGhhbmRsZSBEYXRhVHJhbnNmZXJJdGVtTGlzdHMuXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5kYXRhLml0ZW1zKS5tYXAoZ2V0RmlsZUZyb21EYXRhVHJhbnNmZXIpLmZpbHRlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmZpbGVzKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5kYXRhLmZpbGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQXJlIHRoZXJlIGFueSBmaWxlcyB0byBmZXRjaD9cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBEYXRhVHJhbnNmZXIucHJvdG90eXBlLmhhc0ZpbGVzID0gZnVuY3Rpb24gaGFzRmlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmlsZXMoKS5sZW5ndGggPiAwO1xuICB9O1xuXG4gIHJldHVybiBEYXRhVHJhbnNmZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVRyYW5zZmVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0RhdGFUcmFuc2Zlci5qc1xuLy8gbW9kdWxlIGlkID0gMzcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRTZWxlY3Rpb25PZmZzZXRLZXlGb3JOb2RlXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0IG9mZnNldCBrZXkgZnJvbSBhIG5vZGUgb3IgaXQncyBjaGlsZCBub2Rlcy4gUmV0dXJuIHRoZSBmaXJzdCBvZmZzZXQga2V5XG4gKiBmb3VuZCBvbiB0aGUgRE9NIHRyZWUgb2YgZ2l2ZW4gbm9kZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25PZmZzZXRLZXlGb3JOb2RlKG5vZGUpIHtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgdmFyIG9mZnNldEtleSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW9mZnNldC1rZXknKTtcbiAgICBpZiAob2Zmc2V0S2V5KSB7XG4gICAgICByZXR1cm4gb2Zmc2V0S2V5O1xuICAgIH1cbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgdmFyIGNoaWxkT2Zmc2V0S2V5ID0gZ2V0U2VsZWN0aW9uT2Zmc2V0S2V5Rm9yTm9kZShub2RlLmNoaWxkTm9kZXNbaWldKTtcbiAgICAgIGlmIChjaGlsZE9mZnNldEtleSkge1xuICAgICAgICByZXR1cm4gY2hpbGRPZmZzZXRLZXk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFNlbGVjdGlvbk9mZnNldEtleUZvck5vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2dldFNlbGVjdGlvbk9mZnNldEtleUZvck5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDM3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0VGV4dENvbnRlbnRGcm9tRmlsZXNcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgVEVYVF9DTElQUElOR19SRUdFWCA9IC9cXC50ZXh0Q2xpcHBpbmckLztcblxudmFyIFRFWFRfVFlQRVMgPSB7XG4gICd0ZXh0L3BsYWluJzogdHJ1ZSxcbiAgJ3RleHQvaHRtbCc6IHRydWUsXG4gICd0ZXh0L3J0Zic6IHRydWVcbn07XG5cbi8vIFNvbWV3aGF0IGFyYml0cmFyeSB1cHBlciBib3VuZCBvbiB0ZXh0IHNpemUuIExldCdzIG5vdCBsb2NrIHVwIHRoZSBicm93c2VyLlxudmFyIFRFWFRfU0laRV9VUFBFUl9CT1VORCA9IDUwMDA7XG5cbi8qKlxuICogRXh0cmFjdCB0aGUgdGV4dCBjb250ZW50IGZyb20gYSBmaWxlIGxpc3QuXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50RnJvbUZpbGVzKGZpbGVzLCBjYWxsYmFjaykge1xuICB2YXIgcmVhZENvdW50ID0gMDtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoIC8qYmxvYiovZmlsZSkge1xuICAgIHJlYWRGaWxlKGZpbGUsIGZ1bmN0aW9uICggLypzdHJpbmcqL3RleHQpIHtcbiAgICAgIHJlYWRDb3VudCsrO1xuICAgICAgdGV4dCAmJiByZXN1bHRzLnB1c2godGV4dC5zbGljZSgwLCBURVhUX1NJWkVfVVBQRVJfQk9VTkQpKTtcbiAgICAgIGlmIChyZWFkQ291bnQgPT0gZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdHMuam9pbignXFxyJykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiB0b2RvIGlzYWFjOiBEbyB3b3JrIHRvIHR1cm4gaHRtbC9ydGYgaW50byBhIGNvbnRlbnQgZnJhZ21lbnQuXG4gKi9cbmZ1bmN0aW9uIHJlYWRGaWxlKGZpbGUsIGNhbGxiYWNrKSB7XG4gIGlmICghZ2xvYmFsLkZpbGVSZWFkZXIgfHwgZmlsZS50eXBlICYmICEoZmlsZS50eXBlIGluIFRFWFRfVFlQRVMpKSB7XG4gICAgY2FsbGJhY2soJycpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmaWxlLnR5cGUgPT09ICcnKSB7XG4gICAgdmFyIGNvbnRlbnRzID0gJyc7XG4gICAgLy8gU3BlY2lhbC1jYXNlIHRleHQgY2xpcHBpbmdzLCB3aGljaCBoYXZlIGFuIGVtcHR5IHR5cGUgYnV0IGluY2x1ZGVcbiAgICAvLyBgLnRleHRDbGlwcGluZ2AgaW4gdGhlIGZpbGUgbmFtZS4gYHJlYWRBc1RleHRgIHJlc3VsdHMgaW4gYW4gZW1wdHlcbiAgICAvLyBzdHJpbmcgZm9yIHRleHQgY2xpcHBpbmdzLCBzbyB3ZSBmb3JjZSB0aGUgZmlsZSBuYW1lIHRvIHNlcnZlXG4gICAgLy8gYXMgdGhlIHRleHQgdmFsdWUgZm9yIHRoZSBmaWxlLlxuICAgIGlmIChURVhUX0NMSVBQSU5HX1JFR0VYLnRlc3QoZmlsZS5uYW1lKSkge1xuICAgICAgY29udGVudHMgPSBmaWxlLm5hbWUucmVwbGFjZShURVhUX0NMSVBQSU5HX1JFR0VYLCAnJyk7XG4gICAgfVxuICAgIGNhbGxiYWNrKGNvbnRlbnRzKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVhZGVyLnJlc3VsdDtcbiAgICAhKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYmUgY2FsbGluZyBcIkZpbGVSZWFkZXIucmVhZEFzVGV4dFwiIHdoaWNoIHJldHVybnMgYSBzdHJpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY2FsbGJhY2socmVzdWx0KTtcbiAgfTtcbiAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2soJycpO1xuICB9O1xuICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUZXh0Q29udGVudEZyb21GaWxlcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZ2V0VGV4dENvbnRlbnRGcm9tRmlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDM3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0VXBkYXRlZFNlbGVjdGlvblN0YXRlXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEcmFmdE9mZnNldEtleSA9IHJlcXVpcmUoJy4vRHJhZnRPZmZzZXRLZXknKTtcblxudmFyIG51bGx0aHJvd3MgPSByZXF1aXJlKCdmYmpzL2xpYi9udWxsdGhyb3dzJyk7XG5cbmZ1bmN0aW9uIGdldFVwZGF0ZWRTZWxlY3Rpb25TdGF0ZShlZGl0b3JTdGF0ZSwgYW5jaG9yS2V5LCBhbmNob3JPZmZzZXQsIGZvY3VzS2V5LCBmb2N1c09mZnNldCkge1xuICB2YXIgc2VsZWN0aW9uID0gbnVsbHRocm93cyhlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCFhbmNob3JLZXkgfHwgIWZvY3VzS2V5KSB7XG4gICAgICAvKmVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBzZWxlY3Rpb24gc3RhdGUuJywgYXJndW1lbnRzLCBlZGl0b3JTdGF0ZS50b0pTKCkpO1xuICAgICAgLyplc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgfVxuICB9XG5cbiAgdmFyIGFuY2hvclBhdGggPSBEcmFmdE9mZnNldEtleS5kZWNvZGUoYW5jaG9yS2V5KTtcbiAgdmFyIGFuY2hvckJsb2NrS2V5ID0gYW5jaG9yUGF0aC5ibG9ja0tleTtcbiAgdmFyIGFuY2hvckxlYWYgPSBlZGl0b3JTdGF0ZS5nZXRCbG9ja1RyZWUoYW5jaG9yQmxvY2tLZXkpLmdldEluKFthbmNob3JQYXRoLmRlY29yYXRvcktleSwgJ2xlYXZlcycsIGFuY2hvclBhdGgubGVhZktleV0pO1xuXG4gIHZhciBmb2N1c1BhdGggPSBEcmFmdE9mZnNldEtleS5kZWNvZGUoZm9jdXNLZXkpO1xuICB2YXIgZm9jdXNCbG9ja0tleSA9IGZvY3VzUGF0aC5ibG9ja0tleTtcbiAgdmFyIGZvY3VzTGVhZiA9IGVkaXRvclN0YXRlLmdldEJsb2NrVHJlZShmb2N1c0Jsb2NrS2V5KS5nZXRJbihbZm9jdXNQYXRoLmRlY29yYXRvcktleSwgJ2xlYXZlcycsIGZvY3VzUGF0aC5sZWFmS2V5XSk7XG5cbiAgdmFyIGFuY2hvckxlYWZTdGFydCA9IGFuY2hvckxlYWYuZ2V0KCdzdGFydCcpO1xuICB2YXIgZm9jdXNMZWFmU3RhcnQgPSBmb2N1c0xlYWYuZ2V0KCdzdGFydCcpO1xuXG4gIHZhciBhbmNob3JCbG9ja09mZnNldCA9IGFuY2hvckxlYWYgPyBhbmNob3JMZWFmU3RhcnQgKyBhbmNob3JPZmZzZXQgOiBudWxsO1xuICB2YXIgZm9jdXNCbG9ja09mZnNldCA9IGZvY3VzTGVhZiA/IGZvY3VzTGVhZlN0YXJ0ICsgZm9jdXNPZmZzZXQgOiBudWxsO1xuXG4gIHZhciBhcmVFcXVhbCA9IHNlbGVjdGlvbi5nZXRBbmNob3JLZXkoKSA9PT0gYW5jaG9yQmxvY2tLZXkgJiYgc2VsZWN0aW9uLmdldEFuY2hvck9mZnNldCgpID09PSBhbmNob3JCbG9ja09mZnNldCAmJiBzZWxlY3Rpb24uZ2V0Rm9jdXNLZXkoKSA9PT0gZm9jdXNCbG9ja0tleSAmJiBzZWxlY3Rpb24uZ2V0Rm9jdXNPZmZzZXQoKSA9PT0gZm9jdXNCbG9ja09mZnNldDtcblxuICBpZiAoYXJlRXF1YWwpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uO1xuICB9XG5cbiAgdmFyIGlzQmFja3dhcmQgPSBmYWxzZTtcbiAgaWYgKGFuY2hvckJsb2NrS2V5ID09PSBmb2N1c0Jsb2NrS2V5KSB7XG4gICAgdmFyIGFuY2hvckxlYWZFbmQgPSBhbmNob3JMZWFmLmdldCgnZW5kJyk7XG4gICAgdmFyIGZvY3VzTGVhZkVuZCA9IGZvY3VzTGVhZi5nZXQoJ2VuZCcpO1xuICAgIGlmIChmb2N1c0xlYWZTdGFydCA9PT0gYW5jaG9yTGVhZlN0YXJ0ICYmIGZvY3VzTGVhZkVuZCA9PT0gYW5jaG9yTGVhZkVuZCkge1xuICAgICAgaXNCYWNrd2FyZCA9IGZvY3VzT2Zmc2V0IDwgYW5jaG9yT2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0JhY2t3YXJkID0gZm9jdXNMZWFmU3RhcnQgPCBhbmNob3JMZWFmU3RhcnQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzdGFydEtleSA9IGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCkuZ2V0QmxvY2tNYXAoKS5rZXlTZXEoKS5za2lwVW50aWwoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ID09PSBhbmNob3JCbG9ja0tleSB8fCB2ID09PSBmb2N1c0Jsb2NrS2V5O1xuICAgIH0pLmZpcnN0KCk7XG4gICAgaXNCYWNrd2FyZCA9IHN0YXJ0S2V5ID09PSBmb2N1c0Jsb2NrS2V5O1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbi5tZXJnZSh7XG4gICAgYW5jaG9yS2V5OiBhbmNob3JCbG9ja0tleSxcbiAgICBhbmNob3JPZmZzZXQ6IGFuY2hvckJsb2NrT2Zmc2V0LFxuICAgIGZvY3VzS2V5OiBmb2N1c0Jsb2NrS2V5LFxuICAgIGZvY3VzT2Zmc2V0OiBmb2N1c0Jsb2NrT2Zmc2V0LFxuICAgIGlzQmFja3dhcmQ6IGlzQmFja3dhcmRcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VXBkYXRlZFNlbGVjdGlvblN0YXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXRVcGRhdGVkU2VsZWN0aW9uU3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDM3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnZXRDb250ZW50U3RhdGVGcmFnbWVudCA9IHJlcXVpcmUoJy4vZ2V0Q29udGVudFN0YXRlRnJhZ21lbnQnKTtcblxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uKGVkaXRvclN0YXRlKSB7XG4gIHZhciBzZWxlY3Rpb25TdGF0ZSA9IGVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpO1xuXG4gIGlmIChzZWxlY3Rpb25TdGF0ZS5pc0NvbGxhcHNlZCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0Q29udGVudFN0YXRlRnJhZ21lbnQoZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKSwgc2VsZWN0aW9uU3RhdGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEZyYWdtZW50RnJvbVNlbGVjdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldFJhbmdlQ2xpZW50UmVjdHNcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVzZXJBZ2VudCA9IHJlcXVpcmUoJ2ZianMvbGliL1VzZXJBZ2VudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpc0Nocm9tZSA9IFVzZXJBZ2VudC5pc0Jyb3dzZXIoJ0Nocm9tZScpO1xuXG4vLyBJbiBDaHJvbWUsIHRoZSBjbGllbnQgcmVjdHMgd2lsbCBpbmNsdWRlIHRoZSBlbnRpcmUgYm91bmRzIG9mIGFsbCBub2RlcyB0aGF0XG4vLyBiZWdpbiAoaGF2ZSBhIHN0YXJ0IHRhZykgd2l0aGluIHRoZSBzZWxlY3Rpb24sIGV2ZW4gaWYgdGhlIHNlbGVjdGlvbiBkb2VzXG4vLyBub3Qgb3ZlcmxhcCB0aGUgZW50aXJlIG5vZGUuIFRvIHJlc29sdmUgdGhpcywgd2Ugc3BsaXQgdGhlIHJhbmdlIGF0IGVhY2hcbi8vIHN0YXJ0IHRhZyBhbmQgam9pbiB0aGUgY2xpZW50IHJlY3RzIHRvZ2V0aGVyLlxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTMyNDQzN1xuLyogZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbmZ1bmN0aW9uIGdldFJhbmdlQ2xpZW50UmVjdHNDaHJvbWUocmFuZ2UpIHtcbiAgdmFyIHRlbXBSYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgdmFyIGNsaWVudFJlY3RzID0gW107XG5cbiAgZm9yICh2YXIgYW5jZXN0b3IgPSByYW5nZS5lbmRDb250YWluZXI7IGFuY2VzdG9yICE9IG51bGw7IGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgIC8vIElmIHdlJ3ZlIGNsaW1iZWQgdXAgdG8gdGhlIGNvbW1vbiBhbmNlc3Rvciwgd2UgY2FuIG5vdyB1c2UgdGhlXG4gICAgLy8gb3JpZ2luYWwgc3RhcnQgcG9pbnQgYW5kIHN0b3AgY2xpbWJpbmcgdGhlIHRyZWUuXG4gICAgdmFyIGF0Q29tbW9uQW5jZXN0b3IgPSBhbmNlc3RvciA9PT0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgaWYgKGF0Q29tbW9uQW5jZXN0b3IpIHtcbiAgICAgIHRlbXBSYW5nZS5zZXRTdGFydChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wUmFuZ2Uuc2V0U3RhcnQodGVtcFJhbmdlLmVuZENvbnRhaW5lciwgMCk7XG4gICAgfVxuICAgIHZhciByZWN0cyA9IEFycmF5LmZyb20odGVtcFJhbmdlLmdldENsaWVudFJlY3RzKCkpO1xuICAgIGNsaWVudFJlY3RzLnB1c2gocmVjdHMpO1xuICAgIGlmIChhdENvbW1vbkFuY2VzdG9yKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgY2xpZW50UmVjdHMucmV2ZXJzZSgpO1xuICAgICAgcmV0dXJuIChfcmVmID0gW10pLmNvbmNhdC5hcHBseShfcmVmLCBjbGllbnRSZWN0cyk7XG4gICAgfVxuICAgIHRlbXBSYW5nZS5zZXRFbmRCZWZvcmUoYW5jZXN0b3IpO1xuICB9XG5cbiAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0ZvdW5kIGFuIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSB3aGVuIGdldHRpbmcgcmFuZ2UgY2xpZW50IHJlY3RzLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn1cbi8qIGVzbGludC1lbmFibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cblxuLyoqXG4gKiBMaWtlIHJhbmdlLmdldENsaWVudFJlY3RzKCkgYnV0IG5vcm1hbGl6ZXMgZm9yIGJyb3dzZXIgYnVncy5cbiAqL1xudmFyIGdldFJhbmdlQ2xpZW50UmVjdHMgPSBpc0Nocm9tZSA/IGdldFJhbmdlQ2xpZW50UmVjdHNDaHJvbWUgOiBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20ocmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhbmdlQ2xpZW50UmVjdHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2dldFJhbmdlQ2xpZW50UmVjdHMuanNcbi8vIG1vZHVsZSBpZCA9IDM3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RHJhZnRFZGl0b3JTZWxlY3Rpb25XaXRoTm9kZXNcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGZpbmRBbmNlc3Rvck9mZnNldEtleSA9IHJlcXVpcmUoJy4vZmluZEFuY2VzdG9yT2Zmc2V0S2V5Jyk7XG52YXIgZ2V0U2VsZWN0aW9uT2Zmc2V0S2V5Rm9yTm9kZSA9IHJlcXVpcmUoJy4vZ2V0U2VsZWN0aW9uT2Zmc2V0S2V5Rm9yTm9kZScpO1xudmFyIGdldFVwZGF0ZWRTZWxlY3Rpb25TdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0VXBkYXRlZFNlbGVjdGlvblN0YXRlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgbnVsbHRocm93cyA9IHJlcXVpcmUoJ2ZianMvbGliL251bGx0aHJvd3MnKTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBjdXJyZW50IHNlbGVjdGlvbiByYW5nZSB0byBhbiBhbmNob3IvZm9jdXMgcGFpciBvZiBvZmZzZXQga2V5c1xuICogYW5kIHZhbHVlcyB0aGF0IGNhbiBiZSBpbnRlcnByZXRlZCBieSBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiBnZXREcmFmdEVkaXRvclNlbGVjdGlvbldpdGhOb2RlcyhlZGl0b3JTdGF0ZSwgcm9vdCwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gIHZhciBhbmNob3JJc1RleHROb2RlID0gYW5jaG9yTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREU7XG4gIHZhciBmb2N1c0lzVGV4dE5vZGUgPSBmb2N1c05vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFO1xuXG4gIC8vIElmIHRoZSBzZWxlY3Rpb24gcmFuZ2UgbGllcyBvbmx5IG9uIHRleHQgbm9kZXMsIHRoZSB0YXNrIGlzIHNpbXBsZS5cbiAgLy8gRmluZCB0aGUgbmVhcmVzdCBvZmZzZXQtYXdhcmUgZWxlbWVudHMgYW5kIHVzZSB0aGVcbiAgLy8gb2Zmc2V0IHZhbHVlcyBzdXBwbGllZCBieSB0aGUgc2VsZWN0aW9uIHJhbmdlLlxuICBpZiAoYW5jaG9ySXNUZXh0Tm9kZSAmJiBmb2N1c0lzVGV4dE5vZGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0aW9uU3RhdGU6IGdldFVwZGF0ZWRTZWxlY3Rpb25TdGF0ZShlZGl0b3JTdGF0ZSwgbnVsbHRocm93cyhmaW5kQW5jZXN0b3JPZmZzZXRLZXkoYW5jaG9yTm9kZSkpLCBhbmNob3JPZmZzZXQsIG51bGx0aHJvd3MoZmluZEFuY2VzdG9yT2Zmc2V0S2V5KGZvY3VzTm9kZSkpLCBmb2N1c09mZnNldCksXG4gICAgICBuZWVkc1JlY292ZXJ5OiBmYWxzZVxuICAgIH07XG4gIH1cblxuICB2YXIgYW5jaG9yUG9pbnQgPSBudWxsO1xuICB2YXIgZm9jdXNQb2ludCA9IG51bGw7XG4gIHZhciBuZWVkc1JlY292ZXJ5ID0gdHJ1ZTtcblxuICAvLyBBbiBlbGVtZW50IGlzIHNlbGVjdGVkLiBDb252ZXJ0IHRoaXMgc2VsZWN0aW9uIHJhbmdlIGludG8gbGVhZiBvZmZzZXRcbiAgLy8ga2V5cyBhbmQgb2Zmc2V0IHZhbHVlcyBmb3IgY29uc3VtcHRpb24gYXQgdGhlIGNvbXBvbmVudCBsZXZlbC4gVGhpc1xuICAvLyBpcyBjb21tb24gaW4gRmlyZWZveCwgd2hlcmUgc2VsZWN0LWFsbCBhbmQgdHJpcGxlIGNsaWNrIGJlaGF2aW9yIGxlYWRzXG4gIC8vIHRvIGVudGlyZSBlbGVtZW50cyBiZWluZyBzZWxlY3RlZC5cbiAgLy9cbiAgLy8gTm90ZSB0aGF0IHdlIHVzZSB0aGUgYG5lZWRzUmVjb3ZlcnlgIHBhcmFtZXRlciBpbiB0aGUgY2FsbGJhY2sgaGVyZS4gVGhpc1xuICAvLyBpcyBiZWNhdXNlIHdoZW4gY2VydGFpbiBlbGVtZW50cyBhcmUgc2VsZWN0ZWQsIHRoZSBiZWhhdmlvciBmb3Igc3Vic2VxdWVudFxuICAvLyBjdXJzb3IgbW92ZW1lbnQgKGUuZy4gdmlhIGFycm93IGtleXMpIGlzIHVuY2VydGFpbiBhbmQgbWF5IG5vdCBtYXRjaFxuICAvLyBleHBlY3RhdGlvbnMgYXQgdGhlIGNvbXBvbmVudCBsZXZlbC4gRm9yIGV4YW1wbGUsIGlmIGFuIGVudGlyZSA8ZGl2PiBpc1xuICAvLyBzZWxlY3RlZCBhbmQgdGhlIHVzZXIgcHJlc3NlcyB0aGUgcmlnaHQgYXJyb3csIEZpcmVmb3gga2VlcHMgdGhlIHNlbGVjdGlvblxuICAvLyBvbiB0aGUgPGRpdj4uIElmIHdlIGFsbG93IHN1YnNlcXVlbnQga2V5cHJlc3NlcyB0byBpbnNlcnQgY2hhcmFjdGVyc1xuICAvLyBuYXRpdmVseSwgdGhleSB3aWxsIGJlIGluc2VydGVkIGludG8gYSBicm93c2VyLWNyZWF0ZWQgdGV4dCBub2RlIHRvIHRoZVxuICAvLyByaWdodCBvZiB0aGF0IDxkaXY+LiBUaGlzIGlzIG9idmlvdXNseSB1bmRlc2lyYWJsZS5cbiAgLy9cbiAgLy8gV2l0aCB0aGUgYG5lZWRzUmVjb3ZlcnlgIGZsYWcsIHdlIGluZm9ybSB0aGUgY2FsbGVyIHRoYXQgaXQgaXMgcmVzcG9uc2libGVcbiAgLy8gZm9yIG1hbnVhbGx5IHNldHRpbmcgdGhlIHNlbGVjdGlvbiBzdGF0ZSBvbiB0aGUgcmVuZGVyZWQgZG9jdW1lbnQgdG9cbiAgLy8gZW5zdXJlIHByb3BlciBzZWxlY3Rpb24gc3RhdGUgbWFpbnRlbmFuY2UuXG5cbiAgaWYgKGFuY2hvcklzVGV4dE5vZGUpIHtcbiAgICBhbmNob3JQb2ludCA9IHtcbiAgICAgIGtleTogbnVsbHRocm93cyhmaW5kQW5jZXN0b3JPZmZzZXRLZXkoYW5jaG9yTm9kZSkpLFxuICAgICAgb2Zmc2V0OiBhbmNob3JPZmZzZXRcbiAgICB9O1xuICAgIGZvY3VzUG9pbnQgPSBnZXRQb2ludEZvck5vblRleHROb2RlKHJvb3QsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xuICB9IGVsc2UgaWYgKGZvY3VzSXNUZXh0Tm9kZSkge1xuICAgIGZvY3VzUG9pbnQgPSB7XG4gICAgICBrZXk6IG51bGx0aHJvd3MoZmluZEFuY2VzdG9yT2Zmc2V0S2V5KGZvY3VzTm9kZSkpLFxuICAgICAgb2Zmc2V0OiBmb2N1c09mZnNldFxuICAgIH07XG4gICAgYW5jaG9yUG9pbnQgPSBnZXRQb2ludEZvck5vblRleHROb2RlKHJvb3QsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgYW5jaG9yUG9pbnQgPSBnZXRQb2ludEZvck5vblRleHROb2RlKHJvb3QsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgZm9jdXNQb2ludCA9IGdldFBvaW50Rm9yTm9uVGV4dE5vZGUocm9vdCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG5cbiAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZCBvbiBhbiBlbXB0eSBibG9jaywgZG9uJ3QgZm9yY2UgcmVjb3ZlcnkuXG4gICAgLy8gVGhpcyB3YXksIG9uIGFycm93IGtleSBzZWxlY3Rpb24gY2hhbmdlcywgdGhlIGJyb3dzZXIgY2FuIG1vdmUgdGhlXG4gICAgLy8gY3Vyc29yIGZyb20gYSBub24temVybyBvZmZzZXQgb24gb25lIGJsb2NrLCB0aHJvdWdoIGVtcHR5IGJsb2NrcyxcbiAgICAvLyB0byBhIG1hdGNoaW5nIG5vbi16ZXJvIG9mZnNldCBvbiBvdGhlciB0ZXh0IGJsb2Nrcy5cbiAgICBpZiAoYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvck9mZnNldCA9PT0gZm9jdXNPZmZzZXQpIHtcbiAgICAgIG5lZWRzUmVjb3ZlcnkgPSAhIWFuY2hvck5vZGUuZmlyc3RDaGlsZCAmJiBhbmNob3JOb2RlLmZpcnN0Q2hpbGQubm9kZU5hbWUgIT09ICdCUic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzZWxlY3Rpb25TdGF0ZTogZ2V0VXBkYXRlZFNlbGVjdGlvblN0YXRlKGVkaXRvclN0YXRlLCBhbmNob3JQb2ludC5rZXksIGFuY2hvclBvaW50Lm9mZnNldCwgZm9jdXNQb2ludC5rZXksIGZvY3VzUG9pbnQub2Zmc2V0KSxcbiAgICBuZWVkc1JlY292ZXJ5OiBuZWVkc1JlY292ZXJ5XG4gIH07XG59XG5cbi8qKlxuICogSWRlbnRpZnkgdGhlIGZpcnN0IGxlYWYgZGVzY2VuZGFudCBmb3IgdGhlIGdpdmVuIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldEZpcnN0TGVhZihub2RlKSB7XG4gIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQgJiYgKFxuICAvLyBkYXRhLWJsb2NrcyBoYXMgbm8gb2Zmc2V0XG4gIG5vZGUuZmlyc3RDaGlsZCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgbm9kZS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSgnZGF0YS1ibG9ja3MnKSA9PT0gJ3RydWUnIHx8IGdldFNlbGVjdGlvbk9mZnNldEtleUZvck5vZGUobm9kZS5maXJzdENoaWxkKSkpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIElkZW50aWZ5IHRoZSBsYXN0IGxlYWYgZGVzY2VuZGFudCBmb3IgdGhlIGdpdmVuIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldExhc3RMZWFmKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkICYmIChcbiAgLy8gZGF0YS1ibG9ja3MgaGFzIG5vIG9mZnNldFxuICBub2RlLmxhc3RDaGlsZCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgbm9kZS5sYXN0Q2hpbGQuZ2V0QXR0cmlidXRlKCdkYXRhLWJsb2NrcycpID09PSAndHJ1ZScgfHwgZ2V0U2VsZWN0aW9uT2Zmc2V0S2V5Rm9yTm9kZShub2RlLmxhc3RDaGlsZCkpKSB7XG4gICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBnZXRQb2ludEZvck5vblRleHROb2RlKGVkaXRvclJvb3QsIHN0YXJ0Tm9kZSwgY2hpbGRPZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBzdGFydE5vZGU7XG4gIHZhciBvZmZzZXRLZXkgPSBmaW5kQW5jZXN0b3JPZmZzZXRLZXkobm9kZSk7XG5cbiAgIShvZmZzZXRLZXkgIT0gbnVsbCB8fCBlZGl0b3JSb290ICYmIChlZGl0b3JSb290ID09PSBub2RlIHx8IGVkaXRvclJvb3QuZmlyc3RDaGlsZCA9PT0gbm9kZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1Vua25vd24gbm9kZSBpbiBzZWxlY3Rpb24gcmFuZ2UuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIC8vIElmIHRoZSBlZGl0b3JSb290IGlzIHRoZSBzZWxlY3Rpb24sIHN0ZXAgZG93bndhcmQgaW50byB0aGUgY29udGVudFxuICAvLyB3cmFwcGVyLlxuICBpZiAoZWRpdG9yUm9vdCA9PT0gbm9kZSkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgIShub2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1jb250ZW50cycpID09PSAndHJ1ZScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgRHJhZnRFZGl0b3JDb250ZW50cyBzdHJ1Y3R1cmUuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGlmIChjaGlsZE9mZnNldCA+IDApIHtcbiAgICAgIGNoaWxkT2Zmc2V0ID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgY2hpbGQgb2Zmc2V0IGlzIHplcm8gYW5kIHdlIGhhdmUgYW4gb2Zmc2V0IGtleSwgd2UncmUgZG9uZS5cbiAgLy8gSWYgdGhlcmUncyBubyBvZmZzZXQga2V5IGJlY2F1c2UgdGhlIGVudGlyZSBlZGl0b3IgaXMgc2VsZWN0ZWQsXG4gIC8vIGZpbmQgdGhlIGxlZnRtb3N0IChcImZpcnN0XCIpIGxlYWYgaW4gdGhlIHRyZWUgYW5kIHVzZSB0aGF0IGFzIHRoZSBvZmZzZXRcbiAgLy8ga2V5LlxuICBpZiAoY2hpbGRPZmZzZXQgPT09IDApIHtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICBpZiAob2Zmc2V0S2V5ICE9IG51bGwpIHtcbiAgICAgIGtleSA9IG9mZnNldEtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0TGVhZiA9IGdldEZpcnN0TGVhZihub2RlKTtcbiAgICAgIGtleSA9IG51bGx0aHJvd3MoZ2V0U2VsZWN0aW9uT2Zmc2V0S2V5Rm9yTm9kZShmaXJzdExlYWYpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsga2V5OiBrZXksIG9mZnNldDogMCB9O1xuICB9XG5cbiAgdmFyIG5vZGVCZWZvcmVDdXJzb3IgPSBub2RlLmNoaWxkTm9kZXNbY2hpbGRPZmZzZXQgLSAxXTtcbiAgdmFyIGxlYWZLZXkgPSBudWxsO1xuICB2YXIgdGV4dExlbmd0aCA9IG51bGw7XG5cbiAgaWYgKCFnZXRTZWxlY3Rpb25PZmZzZXRLZXlGb3JOb2RlKG5vZGVCZWZvcmVDdXJzb3IpKSB7XG4gICAgLy8gT3VyIHRhcmdldCBub2RlIG1heSBiZSBhIGxlYWYgb3IgYSB0ZXh0IG5vZGUsIGluIHdoaWNoIGNhc2Ugd2UncmVcbiAgICAvLyBhbHJlYWR5IHdoZXJlIHdlIHdhbnQgdG8gYmUgYW5kIGNhbiBqdXN0IHVzZSB0aGUgY2hpbGQncyBsZW5ndGggYXNcbiAgICAvLyBvdXIgb2Zmc2V0LlxuICAgIGxlYWZLZXkgPSBudWxsdGhyb3dzKG9mZnNldEtleSk7XG4gICAgdGV4dExlbmd0aCA9IGdldFRleHRDb250ZW50TGVuZ3RoKG5vZGVCZWZvcmVDdXJzb3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgd2UnbGwgbG9vayBhdCB0aGUgY2hpbGQgdG8gdGhlIGxlZnQgb2YgdGhlIGN1cnNvciBhbmQgZmluZFxuICAgIC8vIHRoZSBsYXN0IGxlYWYgbm9kZSBpbiBpdHMgc3VidHJlZS5cbiAgICB2YXIgbGFzdExlYWYgPSBnZXRMYXN0TGVhZihub2RlQmVmb3JlQ3Vyc29yKTtcbiAgICBsZWFmS2V5ID0gbnVsbHRocm93cyhnZXRTZWxlY3Rpb25PZmZzZXRLZXlGb3JOb2RlKGxhc3RMZWFmKSk7XG4gICAgdGV4dExlbmd0aCA9IGdldFRleHRDb250ZW50TGVuZ3RoKGxhc3RMZWFmKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAga2V5OiBsZWFmS2V5LFxuICAgIG9mZnNldDogdGV4dExlbmd0aFxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbGVuZ3RoIG9mIGEgbm9kZSdzIHRleHRDb250ZW50LCByZWdhcmRpbmcgc2luZ2xlIG5ld2xpbmVcbiAqIGNoYXJhY3RlcnMgYXMgemVyby1sZW5ndGguIFRoaXMgYWxsb3dzIHVzIHRvIGF2b2lkIHByb2JsZW1zIHdpdGggaWRlbnRpZnlpbmdcbiAqIHRoZSBjb3JyZWN0IHNlbGVjdGlvbiBvZmZzZXQgZm9yIGVtcHR5IGJsb2NrcyBpbiBJRSwgaW4gd2hpY2ggd2VcbiAqIHJlbmRlciBuZXdsaW5lcyBpbnN0ZWFkIG9mIGJyZWFrIHRhZ3MuXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50TGVuZ3RoKG5vZGUpIHtcbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcbiAgcmV0dXJuIHRleHRDb250ZW50ID09PSAnXFxuJyA/IDAgOiB0ZXh0Q29udGVudC5sZW5ndGg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RHJhZnRFZGl0b3JTZWxlY3Rpb25XaXRoTm9kZXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2dldERyYWZ0RWRpdG9yU2VsZWN0aW9uV2l0aE5vZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERyYWZ0UmVtb3ZhYmxlV29yZFxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9rZW5pemVVdGlsID0gcmVxdWlyZSgnZmJqcy9saWIvVG9rZW5pemVVdGlsJyk7XG5cbnZhciBwdW5jdHVhdGlvbiA9IFRva2VuaXplVXRpbC5nZXRQdW5jdHVhdGlvbigpO1xuXG4vLyBUaGUgYXBvc3Ryb3BoZSBhbmQgY3VybHkgc2luZ2xlIHF1b3RlcyBiZWhhdmUgaW4gYSBjdXJpb3VzIHdheTogd2hlblxuLy8gc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IHdvcmQgY2hhcmFjdGVycywgdGhleSBiZWhhdmUgYXMgd29yZCBjaGFyczsgd2hlblxuLy8gZWl0aGVyIG5laWdoYm9yIGlzIHB1bmN0dWF0aW9uIG9yIGFuIGVuZCBvZiB0aGUgc3RyaW5nLCB0aGV5IGJlaGF2ZSBhc1xuLy8gcHVuY3R1YXRpb24uXG52YXIgQ0hBTUVMRU9OX0NIQVJTID0gJ1tcXCdcXHUyMDE4XFx1MjAxOV0nO1xuXG4vLyBSZW1vdmUgdGhlIHVuZGVyc2NvcmUsIHdoaWNoIHNob3VsZCBjb3VudCBhcyBwYXJ0IG9mIHRoZSByZW1vdmFibGUgd29yZC4gVGhlXG4vLyBcImNoYW1lbGVvbiBjaGFyc1wiIGFsc28gY291bnQgYXMgcHVuY3R1YXRpb24gaW4gdGhpcyByZWdleC5cbnZhciBXSElURVNQQUNFX0FORF9QVU5DVFVBVElPTiA9ICdcXFxcc3woPyFbX10pJyArIHB1bmN0dWF0aW9uO1xuXG52YXIgREVMRVRFX1NUUklORyA9ICdeJyArICcoPzonICsgV0hJVEVTUEFDRV9BTkRfUFVOQ1RVQVRJT04gKyAnKSonICsgJyg/OicgKyBDSEFNRUxFT05fQ0hBUlMgKyAnfCg/IScgKyBXSElURVNQQUNFX0FORF9QVU5DVFVBVElPTiArICcpLikqJyArICcoPzooPyEnICsgV0hJVEVTUEFDRV9BTkRfUFVOQ1RVQVRJT04gKyAnKS4pJztcbnZhciBERUxFVEVfUkVHRVggPSBuZXcgUmVnRXhwKERFTEVURV9TVFJJTkcpO1xuXG52YXIgQkFDS1NQQUNFX1NUUklORyA9ICcoPzooPyEnICsgV0hJVEVTUEFDRV9BTkRfUFVOQ1RVQVRJT04gKyAnKS4pJyArICcoPzonICsgQ0hBTUVMRU9OX0NIQVJTICsgJ3woPyEnICsgV0hJVEVTUEFDRV9BTkRfUFVOQ1RVQVRJT04gKyAnKS4pKicgKyAnKD86JyArIFdISVRFU1BBQ0VfQU5EX1BVTkNUVUFUSU9OICsgJykqJyArICckJztcbnZhciBCQUNLU1BBQ0VfUkVHRVggPSBuZXcgUmVnRXhwKEJBQ0tTUEFDRV9TVFJJTkcpO1xuXG5mdW5jdGlvbiBnZXRSZW1vdmFibGVXb3JkKHRleHQsIGlzQmFja3dhcmQpIHtcbiAgdmFyIG1hdGNoZXMgPSBpc0JhY2t3YXJkID8gQkFDS1NQQUNFX1JFR0VYLmV4ZWModGV4dCkgOiBERUxFVEVfUkVHRVguZXhlYyh0ZXh0KTtcbiAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogdGV4dDtcbn1cblxudmFyIERyYWZ0UmVtb3ZhYmxlV29yZCA9IHtcbiAgZ2V0QmFja3dhcmQ6IGZ1bmN0aW9uIGdldEJhY2t3YXJkKHRleHQpIHtcbiAgICByZXR1cm4gZ2V0UmVtb3ZhYmxlV29yZCh0ZXh0LCB0cnVlKTtcbiAgfSxcblxuICBnZXRGb3J3YXJkOiBmdW5jdGlvbiBnZXRGb3J3YXJkKHRleHQpIHtcbiAgICByZXR1cm4gZ2V0UmVtb3ZhYmxlV29yZCh0ZXh0LCBmYWxzZSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZnRSZW1vdmFibGVXb3JkO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdFJlbW92YWJsZVdvcmQuanNcbi8vIG1vZHVsZSBpZCA9IDM3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbW92ZVNlbGVjdGlvbkZvcndhcmRcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhIGNvbGxhcHNlZCBzZWxlY3Rpb24sIG1vdmUgdGhlIGZvY3VzIGBtYXhEaXN0YW5jZWAgZm9yd2FyZCB3aXRoaW5cbiAqIHRoZSBzZWxlY3RlZCBibG9jay4gSWYgdGhlIHNlbGVjdGlvbiB3aWxsIGdvIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBibG9jayxcbiAqIG1vdmUgZm9jdXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IGJsb2NrLCBidXQgbm8gZnVydGhlci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBVbmljb2RlLWF3YXJlLCBzbyBzdXJyb2dhdGUgcGFpcnMgd2lsbCBiZSB0cmVhdGVkXG4gKiBhcyBoYXZpbmcgbGVuZ3RoIDIuXG4gKi9cbmZ1bmN0aW9uIG1vdmVTZWxlY3Rpb25Gb3J3YXJkKGVkaXRvclN0YXRlLCBtYXhEaXN0YW5jZSkge1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBrZXkgPSBzZWxlY3Rpb24uZ2V0U3RhcnRLZXkoKTtcbiAgdmFyIG9mZnNldCA9IHNlbGVjdGlvbi5nZXRTdGFydE9mZnNldCgpO1xuICB2YXIgY29udGVudCA9IGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG5cbiAgdmFyIGZvY3VzS2V5ID0ga2V5O1xuICB2YXIgZm9jdXNPZmZzZXQ7XG5cbiAgdmFyIGJsb2NrID0gY29udGVudC5nZXRCbG9ja0ZvcktleShrZXkpO1xuXG4gIGlmIChtYXhEaXN0YW5jZSA+IGJsb2NrLmdldFRleHQoKS5sZW5ndGggLSBvZmZzZXQpIHtcbiAgICBmb2N1c0tleSA9IGNvbnRlbnQuZ2V0S2V5QWZ0ZXIoa2V5KTtcbiAgICBmb2N1c09mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZm9jdXNPZmZzZXQgPSBvZmZzZXQgKyBtYXhEaXN0YW5jZTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24ubWVyZ2UoeyBmb2N1c0tleTogZm9jdXNLZXksIGZvY3VzT2Zmc2V0OiBmb2N1c09mZnNldCB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb3ZlU2VsZWN0aW9uRm9yd2FyZDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvbW92ZVNlbGVjdGlvbkZvcndhcmQuanNcbi8vIG1vZHVsZSBpZCA9IDM3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY29udmVydEZyb21IVE1MVG9Db250ZW50QmxvY2tzXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfZXh0ZW5kcyA9IF9hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfa25vd25MaXN0SXRlbURlcHRoQ2wsXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIENoYXJhY3Rlck1ldGFkYXRhID0gcmVxdWlyZSgnLi9DaGFyYWN0ZXJNZXRhZGF0YScpO1xudmFyIENvbnRlbnRCbG9jayA9IHJlcXVpcmUoJy4vQ29udGVudEJsb2NrJyk7XG52YXIgQ29udGVudEJsb2NrTm9kZSA9IHJlcXVpcmUoJy4vQ29udGVudEJsb2NrTm9kZScpO1xudmFyIERlZmF1bHREcmFmdEJsb2NrUmVuZGVyTWFwID0gcmVxdWlyZSgnLi9EZWZhdWx0RHJhZnRCbG9ja1JlbmRlck1hcCcpO1xudmFyIERyYWZ0RW50aXR5ID0gcmVxdWlyZSgnLi9EcmFmdEVudGl0eScpO1xudmFyIERyYWZ0RmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9EcmFmdEZlYXR1cmVGbGFncycpO1xudmFyIEltbXV0YWJsZSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdpbW11dGFibGUnKSxcbiAgICBTZXQgPSBfcmVxdWlyZS5TZXQ7XG5cbnZhciBVUkkgPSByZXF1aXJlKCdmYmpzL2xpYi9VUkknKTtcblxudmFyIGN4ID0gcmVxdWlyZSgnZmJqcy9saWIvY3gnKTtcbnZhciBnZW5lcmF0ZVJhbmRvbUtleSA9IHJlcXVpcmUoJy4vZ2VuZXJhdGVSYW5kb21LZXknKTtcbnZhciBnZXRTYWZlQm9keUZyb21IVE1MID0gcmVxdWlyZSgnLi9nZXRTYWZlQm9keUZyb21IVE1MJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2FuaXRpemVEcmFmdFRleHQgPSByZXF1aXJlKCcuL3Nhbml0aXplRHJhZnRUZXh0Jyk7XG5cbnZhciBleHBlcmltZW50YWxUcmVlRGF0YVN1cHBvcnQgPSBEcmFmdEZlYXR1cmVGbGFncy5kcmFmdF90cmVlX2RhdGFfc3VwcG9ydDtcblxudmFyIExpc3QgPSBJbW11dGFibGUuTGlzdCxcbiAgICBPcmRlcmVkU2V0ID0gSW1tdXRhYmxlLk9yZGVyZWRTZXQ7XG5cblxudmFyIE5CU1AgPSAnJm5ic3A7JztcbnZhciBTUEFDRSA9ICcgJztcblxuLy8gQXJiaXRyYXJ5IG1heCBpbmRlbnRcbnZhciBNQVhfREVQVEggPSA0O1xuXG4vLyB1c2VkIGZvciByZXBsYWNpbmcgY2hhcmFjdGVycyBpbiBIVE1MXG52YXIgUkVHRVhfQ1IgPSBuZXcgUmVnRXhwKCdcXHInLCAnZycpO1xudmFyIFJFR0VYX0xGID0gbmV3IFJlZ0V4cCgnXFxuJywgJ2cnKTtcbnZhciBSRUdFWF9OQlNQID0gbmV3IFJlZ0V4cChOQlNQLCAnZycpO1xudmFyIFJFR0VYX0NBUlJJQUdFID0gbmV3IFJlZ0V4cCgnJiMxMzs/JywgJ2cnKTtcbnZhciBSRUdFWF9aV1MgPSBuZXcgUmVnRXhwKCcmIzgyMDM7PycsICdnJyk7XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250LXdlaWdodFxudmFyIGJvbGRWYWx1ZXMgPSBbJ2JvbGQnLCAnYm9sZGVyJywgJzUwMCcsICc2MDAnLCAnNzAwJywgJzgwMCcsICc5MDAnXTtcbnZhciBub3RCb2xkVmFsdWVzID0gWydsaWdodCcsICdsaWdodGVyJywgJzEwMCcsICcyMDAnLCAnMzAwJywgJzQwMCddO1xuXG4vLyBCbG9jayB0YWcgZmxvdyBpcyBkaWZmZXJlbnQgYmVjYXVzZSBMSXMgZG8gbm90IGhhdmVcbi8vIGEgZGV0ZXJtaW5pc3RpYyBzdHlsZSA7XztcbnZhciBpbmxpbmVUYWdzID0ge1xuICBiOiAnQk9MRCcsXG4gIGNvZGU6ICdDT0RFJyxcbiAgZGVsOiAnU1RSSUtFVEhST1VHSCcsXG4gIGVtOiAnSVRBTElDJyxcbiAgaTogJ0lUQUxJQycsXG4gIHM6ICdTVFJJS0VUSFJPVUdIJyxcbiAgc3RyaWtlOiAnU1RSSUtFVEhST1VHSCcsXG4gIHN0cm9uZzogJ0JPTEQnLFxuICB1OiAnVU5ERVJMSU5FJ1xufTtcblxudmFyIGtub3duTGlzdEl0ZW1EZXB0aENsYXNzZXMgPSAoX2tub3duTGlzdEl0ZW1EZXB0aENsID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfa25vd25MaXN0SXRlbURlcHRoQ2wsIGN4KCdwdWJsaWMvRHJhZnRTdHlsZURlZmF1bHQvZGVwdGgwJyksIDApLCBfZGVmaW5lUHJvcGVydHkoX2tub3duTGlzdEl0ZW1EZXB0aENsLCBjeCgncHVibGljL0RyYWZ0U3R5bGVEZWZhdWx0L2RlcHRoMScpLCAxKSwgX2RlZmluZVByb3BlcnR5KF9rbm93bkxpc3RJdGVtRGVwdGhDbCwgY3goJ3B1YmxpYy9EcmFmdFN0eWxlRGVmYXVsdC9kZXB0aDInKSwgMiksIF9kZWZpbmVQcm9wZXJ0eShfa25vd25MaXN0SXRlbURlcHRoQ2wsIGN4KCdwdWJsaWMvRHJhZnRTdHlsZURlZmF1bHQvZGVwdGgzJyksIDMpLCBfZGVmaW5lUHJvcGVydHkoX2tub3duTGlzdEl0ZW1EZXB0aENsLCBjeCgncHVibGljL0RyYWZ0U3R5bGVEZWZhdWx0L2RlcHRoNCcpLCA0KSwgX2tub3duTGlzdEl0ZW1EZXB0aENsKTtcblxudmFyIGFuY2hvckF0dHIgPSBbJ2NsYXNzTmFtZScsICdocmVmJywgJ3JlbCcsICd0YXJnZXQnLCAndGl0bGUnXTtcblxudmFyIGltZ0F0dHIgPSBbJ2FsdCcsICdjbGFzc05hbWUnLCAnaGVpZ2h0JywgJ3NyYycsICd3aWR0aCddO1xuXG52YXIgbGFzdEJsb2NrID0gdm9pZCAwO1xuXG52YXIgRU1QVFlfQ0hVTksgPSB7XG4gIHRleHQ6ICcnLFxuICBpbmxpbmVzOiBbXSxcbiAgZW50aXRpZXM6IFtdLFxuICBibG9ja3M6IFtdXG59O1xuXG52YXIgRU1QVFlfQkxPQ0sgPSB7XG4gIGNoaWxkcmVuOiBMaXN0KCksXG4gIGRlcHRoOiAwLFxuICBrZXk6ICcnLFxuICB0eXBlOiAnJ1xufTtcblxudmFyIGdldExpc3RCbG9ja1R5cGUgPSBmdW5jdGlvbiBnZXRMaXN0QmxvY2tUeXBlKHRhZywgbGFzdExpc3QpIHtcbiAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgIHJldHVybiBsYXN0TGlzdCA9PT0gJ29sJyA/ICdvcmRlcmVkLWxpc3QtaXRlbScgOiAndW5vcmRlcmVkLWxpc3QtaXRlbSc7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgZ2V0QmxvY2tNYXBTdXBwb3J0ZWRUYWdzID0gZnVuY3Rpb24gZ2V0QmxvY2tNYXBTdXBwb3J0ZWRUYWdzKGJsb2NrUmVuZGVyTWFwKSB7XG4gIHZhciB1bnN0eWxlZEVsZW1lbnQgPSBibG9ja1JlbmRlck1hcC5nZXQoJ3Vuc3R5bGVkJykuZWxlbWVudDtcbiAgdmFyIHRhZ3MgPSBTZXQoW10pO1xuXG4gIGJsb2NrUmVuZGVyTWFwLmZvckVhY2goZnVuY3Rpb24gKGRyYWZ0QmxvY2spIHtcbiAgICBpZiAoZHJhZnRCbG9jay5hbGlhc2VkRWxlbWVudHMpIHtcbiAgICAgIGRyYWZ0QmxvY2suYWxpYXNlZEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhZykge1xuICAgICAgICB0YWdzID0gdGFncy5hZGQodGFnKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRhZ3MgPSB0YWdzLmFkZChkcmFmdEJsb2NrLmVsZW1lbnQpO1xuICB9KTtcblxuICByZXR1cm4gdGFncy5maWx0ZXIoZnVuY3Rpb24gKHRhZykge1xuICAgIHJldHVybiB0YWcgJiYgdGFnICE9PSB1bnN0eWxlZEVsZW1lbnQ7XG4gIH0pLnRvQXJyYXkoKS5zb3J0KCk7XG59O1xuXG4vLyBjdXN0b20gZWxlbWVudCBjb252ZXJzaW9uc1xudmFyIGdldE11bHRpTWF0Y2hlZFR5cGUgPSBmdW5jdGlvbiBnZXRNdWx0aU1hdGNoZWRUeXBlKHRhZywgbGFzdExpc3QsIG11bHRpTWF0Y2hFeHRyYWN0b3IpIHtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG11bHRpTWF0Y2hFeHRyYWN0b3IubGVuZ3RoOyBpaSsrKSB7XG4gICAgdmFyIG1hdGNoVHlwZSA9IG11bHRpTWF0Y2hFeHRyYWN0b3JbaWldKHRhZywgbGFzdExpc3QpO1xuICAgIGlmIChtYXRjaFR5cGUpIHtcbiAgICAgIHJldHVybiBtYXRjaFR5cGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIGdldEJsb2NrVHlwZUZvclRhZyA9IGZ1bmN0aW9uIGdldEJsb2NrVHlwZUZvclRhZyh0YWcsIGxhc3RMaXN0LCBibG9ja1JlbmRlck1hcCkge1xuICB2YXIgbWF0Y2hlZFR5cGVzID0gYmxvY2tSZW5kZXJNYXAuZmlsdGVyKGZ1bmN0aW9uIChkcmFmdEJsb2NrKSB7XG4gICAgcmV0dXJuIGRyYWZ0QmxvY2suZWxlbWVudCA9PT0gdGFnIHx8IGRyYWZ0QmxvY2sud3JhcHBlciA9PT0gdGFnIHx8IGRyYWZ0QmxvY2suYWxpYXNlZEVsZW1lbnRzICYmIGRyYWZ0QmxvY2suYWxpYXNlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICByZXR1cm4gYWxpYXMgPT09IHRhZztcbiAgICB9KTtcbiAgfSkua2V5U2VxKCkudG9TZXQoKS50b0FycmF5KCkuc29ydCgpO1xuXG4gIC8vIGlmIHdlIGRvbnQgaGF2ZSBhbnkgbWF0Y2hlZCB0eXBlLCByZXR1cm4gdW5zdHlsZWRcbiAgLy8gaWYgd2UgaGF2ZSBvbmUgbWF0Y2hlZCB0eXBlIHJldHVybiBpdFxuICAvLyBpZiB3ZSBoYXZlIG11bHRpIG1hdGNoZWQgdHlwZXMgdXNlIHRoZSBtdWx0aS1tYXRjaCBmdW5jdGlvbiB0byBnYXRoZXIgdHlwZVxuICBzd2l0Y2ggKG1hdGNoZWRUeXBlcy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gJ3Vuc3R5bGVkJztcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gbWF0Y2hlZFR5cGVzWzBdO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZ2V0TXVsdGlNYXRjaGVkVHlwZSh0YWcsIGxhc3RMaXN0LCBbZ2V0TGlzdEJsb2NrVHlwZV0pIHx8ICd1bnN0eWxlZCc7XG4gIH1cbn07XG5cbnZhciBwcm9jZXNzSW5saW5lVGFnID0gZnVuY3Rpb24gcHJvY2Vzc0lubGluZVRhZyh0YWcsIG5vZGUsIGN1cnJlbnRTdHlsZSkge1xuICB2YXIgc3R5bGVUb0NoZWNrID0gaW5saW5lVGFnc1t0YWddO1xuICBpZiAoc3R5bGVUb0NoZWNrKSB7XG4gICAgY3VycmVudFN0eWxlID0gY3VycmVudFN0eWxlLmFkZChzdHlsZVRvQ2hlY2spLnRvT3JkZXJlZFNldCgpO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHZhciBodG1sRWxlbWVudCA9IG5vZGU7XG4gICAgY3VycmVudFN0eWxlID0gY3VycmVudFN0eWxlLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICB2YXIgZm9udFdlaWdodCA9IGh0bWxFbGVtZW50LnN0eWxlLmZvbnRXZWlnaHQ7XG4gICAgICB2YXIgZm9udFN0eWxlID0gaHRtbEVsZW1lbnQuc3R5bGUuZm9udFN0eWxlO1xuICAgICAgdmFyIHRleHREZWNvcmF0aW9uID0gaHRtbEVsZW1lbnQuc3R5bGUudGV4dERlY29yYXRpb247XG5cbiAgICAgIGlmIChib2xkVmFsdWVzLmluZGV4T2YoZm9udFdlaWdodCkgPj0gMCkge1xuICAgICAgICBzdHlsZS5hZGQoJ0JPTEQnKTtcbiAgICAgIH0gZWxzZSBpZiAobm90Qm9sZFZhbHVlcy5pbmRleE9mKGZvbnRXZWlnaHQpID49IDApIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlKCdCT0xEJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb250U3R5bGUgPT09ICdpdGFsaWMnKSB7XG4gICAgICAgIHN0eWxlLmFkZCgnSVRBTElDJyk7XG4gICAgICB9IGVsc2UgaWYgKGZvbnRTdHlsZSA9PT0gJ25vcm1hbCcpIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlKCdJVEFMSUMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHREZWNvcmF0aW9uID09PSAndW5kZXJsaW5lJykge1xuICAgICAgICBzdHlsZS5hZGQoJ1VOREVSTElORScpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHREZWNvcmF0aW9uID09PSAnbGluZS10aHJvdWdoJykge1xuICAgICAgICBzdHlsZS5hZGQoJ1NUUklLRVRIUk9VR0gnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHN0eWxlLnJlbW92ZSgnVU5ERVJMSU5FJyk7XG4gICAgICAgIHN0eWxlLnJlbW92ZSgnU1RSSUtFVEhST1VHSCcpO1xuICAgICAgfVxuICAgIH0pLnRvT3JkZXJlZFNldCgpO1xuICB9XG4gIHJldHVybiBjdXJyZW50U3R5bGU7XG59O1xuXG52YXIgam9pbkNodW5rcyA9IGZ1bmN0aW9uIGpvaW5DaHVua3MoQSwgQiwgZXhwZXJpbWVudGFsSGFzTmVzdGVkQmxvY2tzKSB7XG4gIC8vIFNvbWV0aW1lcyB0d28gYmxvY2tzIHdpbGwgdG91Y2ggaW4gdGhlIERPTSBhbmQgd2UgbmVlZCB0byBzdHJpcCB0aGVcbiAgLy8gZXh0cmEgZGVsaW1pdGVyIHRvIHByZXNlcnZlIG5pY2VuZXNzLlxuICB2YXIgbGFzdEluQSA9IEEudGV4dC5zbGljZSgtMSk7XG4gIHZhciBmaXJzdEluQiA9IEIudGV4dC5zbGljZSgwLCAxKTtcblxuICBpZiAobGFzdEluQSA9PT0gJ1xccicgJiYgZmlyc3RJbkIgPT09ICdcXHInICYmICFleHBlcmltZW50YWxIYXNOZXN0ZWRCbG9ja3MpIHtcbiAgICBBLnRleHQgPSBBLnRleHQuc2xpY2UoMCwgLTEpO1xuICAgIEEuaW5saW5lcy5wb3AoKTtcbiAgICBBLmVudGl0aWVzLnBvcCgpO1xuICAgIEEuYmxvY2tzLnBvcCgpO1xuICB9XG5cbiAgLy8gS2lsbCB3aGl0ZXNwYWNlIGFmdGVyIGJsb2Nrc1xuICBpZiAobGFzdEluQSA9PT0gJ1xccicpIHtcbiAgICBpZiAoQi50ZXh0ID09PSBTUEFDRSB8fCBCLnRleHQgPT09ICdcXG4nKSB7XG4gICAgICByZXR1cm4gQTtcbiAgICB9IGVsc2UgaWYgKGZpcnN0SW5CID09PSBTUEFDRSB8fCBmaXJzdEluQiA9PT0gJ1xcbicpIHtcbiAgICAgIEIudGV4dCA9IEIudGV4dC5zbGljZSgxKTtcbiAgICAgIEIuaW5saW5lcy5zaGlmdCgpO1xuICAgICAgQi5lbnRpdGllcy5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGV4dDogQS50ZXh0ICsgQi50ZXh0LFxuICAgIGlubGluZXM6IEEuaW5saW5lcy5jb25jYXQoQi5pbmxpbmVzKSxcbiAgICBlbnRpdGllczogQS5lbnRpdGllcy5jb25jYXQoQi5lbnRpdGllcyksXG4gICAgYmxvY2tzOiBBLmJsb2Nrcy5jb25jYXQoQi5ibG9ja3MpXG4gIH07XG59O1xuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGFueXRoaW5nIGxpa2UgPHA+IDxibG9ja3F1b3RlPiA8aDE+Li4uIHRvIGNyZWF0ZVxuICogYmxvY2sgdGFncyBmcm9tLiBJZiB3ZSBkbywgd2UgY2FuIHVzZSB0aG9zZSBhbmQgaWdub3JlIDxkaXY+IHRhZ3MuIElmIHdlXG4gKiBkb24ndCwgd2UgY2FuIHRyZWF0IDxkaXY+IHRhZ3MgYXMgbWVhbmluZ2Z1bCAodW5zdHlsZWQpIGJsb2Nrcy5cbiAqL1xudmFyIGNvbnRhaW5zU2VtYW50aWNCbG9ja01hcmt1cCA9IGZ1bmN0aW9uIGNvbnRhaW5zU2VtYW50aWNCbG9ja01hcmt1cChodG1sLCBibG9ja1RhZ3MpIHtcbiAgcmV0dXJuIGJsb2NrVGFncy5zb21lKGZ1bmN0aW9uICh0YWcpIHtcbiAgICByZXR1cm4gaHRtbC5pbmRleE9mKCc8JyArIHRhZykgIT09IC0xO1xuICB9KTtcbn07XG5cbnZhciBoYXNWYWxpZExpbmtUZXh0ID0gZnVuY3Rpb24gaGFzVmFsaWRMaW5rVGV4dChsaW5rKSB7XG4gICEobGluayBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdMaW5rIG11c3QgYmUgYW4gSFRNTEFuY2hvckVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgcHJvdG9jb2wgPSBsaW5rLnByb3RvY29sO1xuICByZXR1cm4gcHJvdG9jb2wgPT09ICdodHRwOicgfHwgcHJvdG9jb2wgPT09ICdodHRwczonIHx8IHByb3RvY29sID09PSAnbWFpbHRvOic7XG59O1xuXG52YXIgZ2V0V2hpdGVzcGFjZUNodW5rID0gZnVuY3Rpb24gZ2V0V2hpdGVzcGFjZUNodW5rKGluRW50aXR5KSB7XG4gIHZhciBlbnRpdGllcyA9IG5ldyBBcnJheSgxKTtcbiAgaWYgKGluRW50aXR5KSB7XG4gICAgZW50aXRpZXNbMF0gPSBpbkVudGl0eTtcbiAgfVxuICByZXR1cm4gX2V4dGVuZHMoe30sIEVNUFRZX0NIVU5LLCB7XG4gICAgdGV4dDogU1BBQ0UsXG4gICAgaW5saW5lczogW09yZGVyZWRTZXQoKV0sXG4gICAgZW50aXRpZXM6IGVudGl0aWVzXG4gIH0pO1xufTtcblxudmFyIGdldFNvZnROZXdsaW5lQ2h1bmsgPSBmdW5jdGlvbiBnZXRTb2Z0TmV3bGluZUNodW5rKCkge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIEVNUFRZX0NIVU5LLCB7XG4gICAgdGV4dDogJ1xcbicsXG4gICAgaW5saW5lczogW09yZGVyZWRTZXQoKV0sXG4gICAgZW50aXRpZXM6IG5ldyBBcnJheSgxKVxuICB9KTtcbn07XG5cbnZhciBnZXRDaHVua2VkQmxvY2sgPSBmdW5jdGlvbiBnZXRDaHVua2VkQmxvY2soKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBFTVBUWV9CTE9DSywgcHJvcHMpO1xufTtcblxudmFyIGdldEJsb2NrRGl2aWRlckNodW5rID0gZnVuY3Rpb24gZ2V0QmxvY2tEaXZpZGVyQ2h1bmsoYmxvY2ssIGRlcHRoKSB7XG4gIHZhciBwYXJlbnRLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICB0ZXh0OiAnXFxyJyxcbiAgICBpbmxpbmVzOiBbT3JkZXJlZFNldCgpXSxcbiAgICBlbnRpdGllczogbmV3IEFycmF5KDEpLFxuICAgIGJsb2NrczogW2dldENodW5rZWRCbG9jayh7XG4gICAgICBwYXJlbnQ6IHBhcmVudEtleSxcbiAgICAgIGtleTogZ2VuZXJhdGVSYW5kb21LZXkoKSxcbiAgICAgIHR5cGU6IGJsb2NrLFxuICAgICAgZGVwdGg6IE1hdGgubWF4KDAsIE1hdGgubWluKE1BWF9ERVBUSCwgZGVwdGgpKVxuICAgIH0pXVxuICB9O1xufTtcblxuLyoqXG4gKiAgSWYgd2UncmUgcGFzdGluZyBmcm9tIG9uZSBEcmFmdEVkaXRvciB0byBhbm90aGVyIHdlIGNhbiBjaGVjayB0byBzZWUgaWZcbiAqICBleGlzdGluZyBsaXN0IGl0ZW0gZGVwdGggY2xhc3NlcyBhcmUgYmVpbmcgdXNlZCBhbmQgcHJlc2VydmUgdGhpcyBzdHlsZVxuICovXG52YXIgZ2V0TGlzdEl0ZW1EZXB0aCA9IGZ1bmN0aW9uIGdldExpc3RJdGVtRGVwdGgobm9kZSkge1xuICB2YXIgZGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgT2JqZWN0LmtleXMoa25vd25MaXN0SXRlbURlcHRoQ2xhc3Nlcykuc29tZShmdW5jdGlvbiAoZGVwdGhDbGFzcykge1xuICAgIGlmIChub2RlLmNsYXNzTGlzdC5jb250YWlucyhkZXB0aENsYXNzKSkge1xuICAgICAgZGVwdGggPSBrbm93bkxpc3RJdGVtRGVwdGhDbGFzc2VzW2RlcHRoQ2xhc3NdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkZXB0aDtcbn07XG5cbnZhciBnZW5GcmFnbWVudCA9IGZ1bmN0aW9uIGdlbkZyYWdtZW50KGVudGl0eU1hcCwgbm9kZSwgaW5saW5lU3R5bGUsIGxhc3RMaXN0LCBpbkJsb2NrLCBibG9ja1RhZ3MsIGRlcHRoLCBibG9ja1JlbmRlck1hcCwgaW5FbnRpdHksIHBhcmVudEtleSkge1xuICB2YXIgbGFzdExhc3RCbG9jayA9IGxhc3RCbG9jaztcbiAgdmFyIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgbmV3RW50aXR5TWFwID0gZW50aXR5TWFwO1xuICB2YXIgbmV4dEJsb2NrVHlwZSA9ICd1bnN0eWxlZCc7XG4gIHZhciBuZXdCbG9jayA9IGZhbHNlO1xuICB2YXIgaW5CbG9ja1R5cGUgPSBpbkJsb2NrICYmIGdldEJsb2NrVHlwZUZvclRhZyhpbkJsb2NrLCBsYXN0TGlzdCwgYmxvY2tSZW5kZXJNYXApO1xuICB2YXIgY2h1bmsgPSBfZXh0ZW5kcyh7fSwgRU1QVFlfQ0hVTkspO1xuICB2YXIgbmV3Q2h1bmsgPSBudWxsO1xuICB2YXIgYmxvY2tLZXkgPSB2b2lkIDA7XG5cbiAgLy8gQmFzZSBDYXNlXG4gIGlmIChub2RlTmFtZSA9PT0gJyN0ZXh0Jykge1xuICAgIHZhciBfdGV4dCA9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgdmFyIG5vZGVUZXh0Q29udGVudCA9IF90ZXh0LnRyaW0oKTtcblxuICAgIC8vIFdlIHNob3VsZCBub3QgY3JlYXRlIGJsb2NrcyBmb3IgbGVhZGluZyBzcGFjZXMgdGhhdCBhcmVcbiAgICAvLyBleGlzdGluZyBhcm91bmQgb2wvdWwgYW5kIHRoZWlyIGNoaWxkcmVuIGxpc3QgaXRlbXNcbiAgICBpZiAobGFzdExpc3QgJiYgbm9kZVRleHRDb250ZW50ID09PSAnJyAmJiBub2RlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHZhciBwYXJlbnROb2RlTmFtZSA9IG5vZGUucGFyZW50RWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHBhcmVudE5vZGVOYW1lID09PSAnb2wnIHx8IHBhcmVudE5vZGVOYW1lID09PSAndWwnKSB7XG4gICAgICAgIHJldHVybiB7IGNodW5rOiBfZXh0ZW5kcyh7fSwgRU1QVFlfQ0hVTkspLCBlbnRpdHlNYXA6IGVudGl0eU1hcCB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlVGV4dENvbnRlbnQgPT09ICcnICYmIGluQmxvY2sgIT09ICdwcmUnKSB7XG4gICAgICByZXR1cm4geyBjaHVuazogZ2V0V2hpdGVzcGFjZUNodW5rKGluRW50aXR5KSwgZW50aXR5TWFwOiBlbnRpdHlNYXAgfTtcbiAgICB9XG4gICAgaWYgKGluQmxvY2sgIT09ICdwcmUnKSB7XG4gICAgICAvLyBDYW4ndCB1c2UgZW1wdHkgc3RyaW5nIGJlY2F1c2UgTVNXb3JkXG4gICAgICBfdGV4dCA9IF90ZXh0LnJlcGxhY2UoUkVHRVhfTEYsIFNQQUNFKTtcbiAgICB9XG5cbiAgICAvLyBzYXZlIHRoZSBsYXN0IGJsb2NrIHNvIHdlIGNhbiB1c2UgaXQgbGF0ZXJcbiAgICBsYXN0QmxvY2sgPSBub2RlTmFtZTtcblxuICAgIHJldHVybiB7XG4gICAgICBjaHVuazoge1xuICAgICAgICB0ZXh0OiBfdGV4dCxcbiAgICAgICAgaW5saW5lczogQXJyYXkoX3RleHQubGVuZ3RoKS5maWxsKGlubGluZVN0eWxlKSxcbiAgICAgICAgZW50aXRpZXM6IEFycmF5KF90ZXh0Lmxlbmd0aCkuZmlsbChpbkVudGl0eSksXG4gICAgICAgIGJsb2NrczogW11cbiAgICAgIH0sXG4gICAgICBlbnRpdHlNYXA6IGVudGl0eU1hcFxuICAgIH07XG4gIH1cblxuICAvLyBzYXZlIHRoZSBsYXN0IGJsb2NrIHNvIHdlIGNhbiB1c2UgaXQgbGF0ZXJcbiAgbGFzdEJsb2NrID0gbm9kZU5hbWU7XG5cbiAgLy8gQlIgdGFnc1xuICBpZiAobm9kZU5hbWUgPT09ICdicicpIHtcbiAgICBpZiAobGFzdExhc3RCbG9jayA9PT0gJ2JyJyAmJiAoIWluQmxvY2sgfHwgaW5CbG9ja1R5cGUgPT09ICd1bnN0eWxlZCcpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaHVuazogZ2V0QmxvY2tEaXZpZGVyQ2h1bmsoJ3Vuc3R5bGVkJywgZGVwdGgsIHBhcmVudEtleSksXG4gICAgICAgIGVudGl0eU1hcDogZW50aXR5TWFwXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjaHVuazogZ2V0U29mdE5ld2xpbmVDaHVuaygpLCBlbnRpdHlNYXA6IGVudGl0eU1hcCB9O1xuICB9XG5cbiAgLy8gSU1HIHRhZ3NcbiAgaWYgKG5vZGVOYW1lID09PSAnaW1nJyAmJiBub2RlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCAmJiBub2RlLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdzcmMnKSAmJiBub2RlLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdzcmMnKS52YWx1ZSkge1xuICAgIHZhciBpbWFnZSA9IG5vZGU7XG4gICAgdmFyIGVudGl0eUNvbmZpZyA9IHt9O1xuXG4gICAgaW1nQXR0ci5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICB2YXIgaW1hZ2VBdHRyaWJ1dGUgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICBpZiAoaW1hZ2VBdHRyaWJ1dGUpIHtcbiAgICAgICAgZW50aXR5Q29uZmlnW2F0dHJdID0gaW1hZ2VBdHRyaWJ1dGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gRm9yY2luZyB0aGlzIG5vZGUgdG8gaGF2ZSBjaGlsZHJlbiBiZWNhdXNlIG90aGVyd2lzZSBubyBlbnRpdHkgd2lsbCBiZVxuICAgIC8vIGNyZWF0ZWQgZm9yIHRoaXMgbm9kZS5cbiAgICAvLyBUaGUgY2hpbGQgdGV4dCBub2RlIGNhbm5vdCBqdXN0IGhhdmUgYSBzcGFjZSBvciByZXR1cm4gYXMgY29udGVudCAtXG4gICAgLy8gd2Ugc3RyaXAgdGhvc2Ugb3V0LlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZHJhZnQtanMvaXNzdWVzLzIzMSBmb3Igc29tZSBjb250ZXh0LlxuICAgIG5vZGUudGV4dENvbnRlbnQgPSAnXFx1RDgzRFxcdURDRjcnO1xuXG4gICAgLy8gVE9ETzogdXBkYXRlIHRoaXMgd2hlbiB3ZSByZW1vdmUgRHJhZnRFbnRpdHkgZW50aXJlbHlcbiAgICBpbkVudGl0eSA9IERyYWZ0RW50aXR5Ll9fY3JlYXRlKCdJTUFHRScsICdNVVRBQkxFJywgZW50aXR5Q29uZmlnIHx8IHt9KTtcbiAgfVxuXG4gIC8vIElubGluZSB0YWdzXG4gIGlubGluZVN0eWxlID0gcHJvY2Vzc0lubGluZVRhZyhub2RlTmFtZSwgbm9kZSwgaW5saW5lU3R5bGUpO1xuXG4gIC8vIEhhbmRsZSBsaXN0c1xuICBpZiAobm9kZU5hbWUgPT09ICd1bCcgfHwgbm9kZU5hbWUgPT09ICdvbCcpIHtcbiAgICBpZiAobGFzdExpc3QpIHtcbiAgICAgIGRlcHRoICs9IDE7XG4gICAgfVxuICAgIGxhc3RMaXN0ID0gbm9kZU5hbWU7XG4gIH1cblxuICBpZiAoIWV4cGVyaW1lbnRhbFRyZWVEYXRhU3VwcG9ydCAmJiBub2RlTmFtZSA9PT0gJ2xpJyAmJiBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICBkZXB0aCA9IGdldExpc3RJdGVtRGVwdGgobm9kZSwgZGVwdGgpO1xuICB9XG5cbiAgdmFyIGJsb2NrVHlwZSA9IGdldEJsb2NrVHlwZUZvclRhZyhub2RlTmFtZSwgbGFzdExpc3QsIGJsb2NrUmVuZGVyTWFwKTtcbiAgdmFyIGluTGlzdEJsb2NrID0gbGFzdExpc3QgJiYgaW5CbG9jayA9PT0gJ2xpJyAmJiBub2RlTmFtZSA9PT0gJ2xpJztcbiAgdmFyIGluQmxvY2tPckhhc05lc3RlZEJsb2NrcyA9ICghaW5CbG9jayB8fCBleHBlcmltZW50YWxUcmVlRGF0YVN1cHBvcnQpICYmIGJsb2NrVGFncy5pbmRleE9mKG5vZGVOYW1lKSAhPT0gLTE7XG5cbiAgLy8gQmxvY2sgVGFnc1xuICBpZiAoaW5MaXN0QmxvY2sgfHwgaW5CbG9ja09ySGFzTmVzdGVkQmxvY2tzKSB7XG4gICAgY2h1bmsgPSBnZXRCbG9ja0RpdmlkZXJDaHVuayhibG9ja1R5cGUsIGRlcHRoLCBwYXJlbnRLZXkpO1xuICAgIGJsb2NrS2V5ID0gY2h1bmsuYmxvY2tzWzBdLmtleTtcbiAgICBpbkJsb2NrID0gbm9kZU5hbWU7XG4gICAgbmV3QmxvY2sgPSAhZXhwZXJpbWVudGFsVHJlZURhdGFTdXBwb3J0O1xuICB9XG5cbiAgLy8gdGhpcyBpcyByZXF1aXJlZCBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgJ3VsJyBhbmQgJ29sJ1xuICBpZiAoaW5MaXN0QmxvY2spIHtcbiAgICBuZXh0QmxvY2tUeXBlID0gbGFzdExpc3QgPT09ICd1bCcgPyAndW5vcmRlcmVkLWxpc3QtaXRlbScgOiAnb3JkZXJlZC1saXN0LWl0ZW0nO1xuICB9XG5cbiAgLy8gUmVjdXJzZSB0aHJvdWdoIGNoaWxkcmVuXG4gIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgaWYgKGNoaWxkICE9IG51bGwpIHtcbiAgICBub2RlTmFtZSA9IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB2YXIgZW50aXR5SWQgPSBudWxsO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50ICYmIGNoaWxkLmhyZWYgJiYgaGFzVmFsaWRMaW5rVGV4dChjaGlsZCkpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbmNob3IgPSBjaGlsZDtcbiAgICAgICAgdmFyIGVudGl0eUNvbmZpZyA9IHt9O1xuXG4gICAgICAgIGFuY2hvckF0dHIuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHZhciBhbmNob3JBdHRyaWJ1dGUgPSBhbmNob3IuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgIGlmIChhbmNob3JBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGVudGl0eUNvbmZpZ1thdHRyXSA9IGFuY2hvckF0dHJpYnV0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVudGl0eUNvbmZpZy51cmwgPSBuZXcgVVJJKGFuY2hvci5ocmVmKS50b1N0cmluZygpO1xuICAgICAgICAvLyBUT0RPOiB1cGRhdGUgdGhpcyB3aGVuIHdlIHJlbW92ZSBEcmFmdEVudGl0eSBjb21wbGV0ZWx5XG4gICAgICAgIGVudGl0eUlkID0gRHJhZnRFbnRpdHkuX19jcmVhdGUoJ0xJTksnLCAnTVVUQUJMRScsIGVudGl0eUNvbmZpZyB8fCB7fSk7XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRpdHlJZCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgX2dlbkZyYWdtZW50ID0gZ2VuRnJhZ21lbnQobmV3RW50aXR5TWFwLCBjaGlsZCwgaW5saW5lU3R5bGUsIGxhc3RMaXN0LCBpbkJsb2NrLCBibG9ja1RhZ3MsIGRlcHRoLCBibG9ja1JlbmRlck1hcCwgZW50aXR5SWQgfHwgaW5FbnRpdHksIGV4cGVyaW1lbnRhbFRyZWVEYXRhU3VwcG9ydCA/IGJsb2NrS2V5IDogbnVsbCksXG4gICAgICAgIGdlbmVyYXRlZENodW5rID0gX2dlbkZyYWdtZW50LmNodW5rLFxuICAgICAgICBtYXliZVVwZGF0ZWRFbnRpdHlNYXAgPSBfZ2VuRnJhZ21lbnQuZW50aXR5TWFwO1xuXG4gICAgbmV3Q2h1bmsgPSBnZW5lcmF0ZWRDaHVuaztcbiAgICBuZXdFbnRpdHlNYXAgPSBtYXliZVVwZGF0ZWRFbnRpdHlNYXA7XG5cbiAgICBjaHVuayA9IGpvaW5DaHVua3MoY2h1bmssIG5ld0NodW5rLCBleHBlcmltZW50YWxUcmVlRGF0YVN1cHBvcnQpO1xuICAgIHZhciBzaWJsaW5nID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAvLyBQdXQgaW4gYSBuZXdsaW5lIHRvIGJyZWFrIHVwIGJsb2NrcyBpbnNpZGUgYmxvY2tzXG4gICAgaWYgKCFwYXJlbnRLZXkgJiYgc2libGluZyAmJiBibG9ja1RhZ3MuaW5kZXhPZihub2RlTmFtZSkgPj0gMCAmJiBpbkJsb2NrKSB7XG4gICAgICBjaHVuayA9IGpvaW5DaHVua3MoY2h1bmssIGdldFNvZnROZXdsaW5lQ2h1bmsoKSk7XG4gICAgfVxuICAgIGlmIChzaWJsaW5nKSB7XG4gICAgICBub2RlTmFtZSA9IHNpYmxpbmcubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgY2hpbGQgPSBzaWJsaW5nO1xuICB9XG5cbiAgaWYgKG5ld0Jsb2NrKSB7XG4gICAgY2h1bmsgPSBqb2luQ2h1bmtzKGNodW5rLCBnZXRCbG9ja0RpdmlkZXJDaHVuayhuZXh0QmxvY2tUeXBlLCBkZXB0aCwgcGFyZW50S2V5KSk7XG4gIH1cblxuICByZXR1cm4geyBjaHVuazogY2h1bmssIGVudGl0eU1hcDogbmV3RW50aXR5TWFwIH07XG59O1xuXG52YXIgZ2V0Q2h1bmtGb3JIVE1MID0gZnVuY3Rpb24gZ2V0Q2h1bmtGb3JIVE1MKGh0bWwsIERPTUJ1aWxkZXIsIGJsb2NrUmVuZGVyTWFwLCBlbnRpdHlNYXApIHtcbiAgaHRtbCA9IGh0bWwudHJpbSgpLnJlcGxhY2UoUkVHRVhfQ1IsICcnKS5yZXBsYWNlKFJFR0VYX05CU1AsIFNQQUNFKS5yZXBsYWNlKFJFR0VYX0NBUlJJQUdFLCAnJykucmVwbGFjZShSRUdFWF9aV1MsICcnKTtcblxuICB2YXIgc3VwcG9ydGVkQmxvY2tUYWdzID0gZ2V0QmxvY2tNYXBTdXBwb3J0ZWRUYWdzKGJsb2NrUmVuZGVyTWFwKTtcblxuICB2YXIgc2FmZUJvZHkgPSBET01CdWlsZGVyKGh0bWwpO1xuICBpZiAoIXNhZmVCb2R5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGFzdEJsb2NrID0gbnVsbDtcblxuICAvLyBTb21ldGltZXMgd2UgYXJlbid0IGRlYWxpbmcgd2l0aCBjb250ZW50IHRoYXQgY29udGFpbnMgbmljZSBzZW1hbnRpY1xuICAvLyB0YWdzLiBJbiB0aGlzIGNhc2UsIHVzZSBkaXZzIHRvIHNlcGFyYXRlIGV2ZXJ5dGhpbmcgb3V0IGludG8gcGFyYWdyYXBoc1xuICAvLyBhbmQgaG9wZSBmb3IgdGhlIGJlc3QuXG4gIHZhciB3b3JraW5nQmxvY2tzID0gY29udGFpbnNTZW1hbnRpY0Jsb2NrTWFya3VwKGh0bWwsIHN1cHBvcnRlZEJsb2NrVGFncykgPyBzdXBwb3J0ZWRCbG9ja1RhZ3MgOiBbJ2RpdiddO1xuXG4gIC8vIFN0YXJ0IHdpdGggLTEgYmxvY2sgZGVwdGggdG8gb2Zmc2V0IHRoZSBmYWN0IHRoYXQgd2UgYXJlIHBhc3NpbmcgaW4gYSBmYWtlXG4gIC8vIFVMIGJsb2NrIHRvIHN0YXJ0IHdpdGguXG4gIHZhciBmcmFnbWVudCA9IGdlbkZyYWdtZW50KGVudGl0eU1hcCwgc2FmZUJvZHksIE9yZGVyZWRTZXQoKSwgJ3VsJywgbnVsbCwgd29ya2luZ0Jsb2NrcywgLTEsIGJsb2NrUmVuZGVyTWFwKTtcblxuICB2YXIgY2h1bmsgPSBmcmFnbWVudC5jaHVuaztcbiAgdmFyIG5ld0VudGl0eU1hcCA9IGZyYWdtZW50LmVudGl0eU1hcDtcblxuICAvLyBqb2luIHdpdGggcHJldmlvdXMgYmxvY2sgdG8gcHJldmVudCB3ZWlyZG5lc3Mgb24gcGFzdGVcbiAgaWYgKGNodW5rLnRleHQuaW5kZXhPZignXFxyJykgPT09IDApIHtcbiAgICBjaHVuayA9IHtcbiAgICAgIHRleHQ6IGNodW5rLnRleHQuc2xpY2UoMSksXG4gICAgICBpbmxpbmVzOiBjaHVuay5pbmxpbmVzLnNsaWNlKDEpLFxuICAgICAgZW50aXRpZXM6IGNodW5rLmVudGl0aWVzLnNsaWNlKDEpLFxuICAgICAgYmxvY2tzOiBjaHVuay5ibG9ja3NcbiAgICB9O1xuICB9XG5cbiAgLy8gS2lsbCBibG9jayBkZWxpbWl0ZXIgYXQgdGhlIGVuZFxuICBpZiAoY2h1bmsudGV4dC5zbGljZSgtMSkgPT09ICdcXHInKSB7XG4gICAgY2h1bmsudGV4dCA9IGNodW5rLnRleHQuc2xpY2UoMCwgLTEpO1xuICAgIGNodW5rLmlubGluZXMgPSBjaHVuay5pbmxpbmVzLnNsaWNlKDAsIC0xKTtcbiAgICBjaHVuay5lbnRpdGllcyA9IGNodW5rLmVudGl0aWVzLnNsaWNlKDAsIC0xKTtcbiAgICBjaHVuay5ibG9ja3MucG9wKCk7XG4gIH1cblxuICAvLyBJZiB3ZSBzYXcgbm8gYmxvY2sgdGFncywgcHV0IGFuIHVuc3R5bGVkIG9uZSBpblxuICBpZiAoY2h1bmsuYmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNodW5rLmJsb2Nrcy5wdXNoKF9leHRlbmRzKHt9LCBFTVBUWV9DSFVOSywge1xuICAgICAgdHlwZTogJ3Vuc3R5bGVkJyxcbiAgICAgIGRlcHRoOiAwXG4gICAgfSkpO1xuICB9XG5cbiAgLy8gU29tZXRpbWVzIHdlIHN0YXJ0IHdpdGggdGV4dCB0aGF0IGlzbid0IGluIGEgYmxvY2ssIHdoaWNoIGlzIHRoZW5cbiAgLy8gZm9sbG93ZWQgYnkgYmxvY2tzLiBOZWVkIHRvIGZpeCB1cCB0aGUgYmxvY2tzIHRvIGFkZCBpblxuICAvLyBhbiB1bnN0eWxlZCBibG9jayBmb3IgdGhpcyBjb250ZW50XG4gIGlmIChjaHVuay50ZXh0LnNwbGl0KCdcXHInKS5sZW5ndGggPT09IGNodW5rLmJsb2Nrcy5sZW5ndGggKyAxKSB7XG4gICAgY2h1bmsuYmxvY2tzLnVuc2hpZnQoeyB0eXBlOiAndW5zdHlsZWQnLCBkZXB0aDogMCB9KTtcbiAgfVxuXG4gIHJldHVybiB7IGNodW5rOiBjaHVuaywgZW50aXR5TWFwOiBuZXdFbnRpdHlNYXAgfTtcbn07XG5cbnZhciBjb252ZXJ0Q2h1bmtUb0NvbnRlbnRCbG9ja3MgPSBmdW5jdGlvbiBjb252ZXJ0Q2h1bmtUb0NvbnRlbnRCbG9ja3MoY2h1bmspIHtcbiAgaWYgKCFjaHVuayB8fCAhY2h1bmsudGV4dCB8fCAhQXJyYXkuaXNBcnJheShjaHVuay5ibG9ja3MpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaW5pdGlhbFN0YXRlID0ge1xuICAgIGNhY2hlUmVmOiB7fSxcbiAgICBjb250ZW50QmxvY2tzOiBbXVxuICB9O1xuXG4gIHZhciBzdGFydCA9IDA7XG5cbiAgdmFyIHJhd0Jsb2NrcyA9IGNodW5rLmJsb2NrcyxcbiAgICAgIHJhd0lubGluZXMgPSBjaHVuay5pbmxpbmVzLFxuICAgICAgcmF3RW50aXRpZXMgPSBjaHVuay5lbnRpdGllcztcblxuXG4gIHZhciBCbG9ja05vZGVSZWNvcmQgPSBleHBlcmltZW50YWxUcmVlRGF0YVN1cHBvcnQgPyBDb250ZW50QmxvY2tOb2RlIDogQ29udGVudEJsb2NrO1xuXG4gIHJldHVybiBjaHVuay50ZXh0LnNwbGl0KCdcXHInKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdGV4dEJsb2NrLCBpbmRleCkge1xuICAgIC8vIE1ha2UgYWJzb2x1dGVseSBjZXJ0YWluIHRoYXQgb3VyIHRleHQgaXMgYWNjZXB0YWJsZS5cbiAgICB0ZXh0QmxvY2sgPSBzYW5pdGl6ZURyYWZ0VGV4dCh0ZXh0QmxvY2spO1xuXG4gICAgdmFyIGJsb2NrID0gcmF3QmxvY2tzW2luZGV4XTtcbiAgICB2YXIgZW5kID0gc3RhcnQgKyB0ZXh0QmxvY2subGVuZ3RoO1xuICAgIHZhciBpbmxpbmVzID0gcmF3SW5saW5lcy5zbGljZShzdGFydCwgZW5kKTtcbiAgICB2YXIgZW50aXRpZXMgPSByYXdFbnRpdGllcy5zbGljZShzdGFydCwgZW5kKTtcbiAgICB2YXIgY2hhcmFjdGVyTGlzdCA9IExpc3QoaW5saW5lcy5tYXAoZnVuY3Rpb24gKHN0eWxlLCBpbmRleCkge1xuICAgICAgdmFyIGRhdGEgPSB7IHN0eWxlOiBzdHlsZSwgZW50aXR5OiBudWxsIH07XG4gICAgICBpZiAoZW50aXRpZXNbaW5kZXhdKSB7XG4gICAgICAgIGRhdGEuZW50aXR5ID0gZW50aXRpZXNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENoYXJhY3Rlck1ldGFkYXRhLmNyZWF0ZShkYXRhKTtcbiAgICB9KSk7XG4gICAgc3RhcnQgPSBlbmQgKyAxO1xuXG4gICAgdmFyIGRlcHRoID0gYmxvY2suZGVwdGgsXG4gICAgICAgIHR5cGUgPSBibG9jay50eXBlLFxuICAgICAgICBwYXJlbnQgPSBibG9jay5wYXJlbnQ7XG5cblxuICAgIHZhciBrZXkgPSBibG9jay5rZXkgfHwgZ2VuZXJhdGVSYW5kb21LZXkoKTtcbiAgICB2YXIgcGFyZW50VGV4dE5vZGVLZXkgPSBudWxsOyAvLyB3aWxsIGJlIHVzZWQgdG8gc3RvcmUgY29udGFpbmVyIHRleHQgbm9kZXNcblxuICAgIC8vIGNoaWxkcmVucyBhZGQgdGhlbXNlbHZlcyB0byB0aGVpciBwYXJlbnRzIHNpbmNlIHdlIGFyZSBpdGVyYXRpbmcgaW4gb3JkZXJcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB2YXIgcGFyZW50SW5kZXggPSBhY2MuY2FjaGVSZWZbcGFyZW50XTtcbiAgICAgIHZhciBwYXJlbnRSZWNvcmQgPSBhY2MuY29udGVudEJsb2Nrc1twYXJlbnRJbmRleF07XG5cbiAgICAgIC8vIGlmIHBhcmVudCBoYXMgdGV4dCB3ZSBuZWVkIHRvIHNwbGl0IGl0IGludG8gYSBzZXBhcmF0ZSB1bnN0eWxlZCBlbGVtZW50XG4gICAgICBpZiAocGFyZW50UmVjb3JkLmdldENoaWxkS2V5cygpLmlzRW1wdHkoKSAmJiBwYXJlbnRSZWNvcmQuZ2V0VGV4dCgpKSB7XG4gICAgICAgIHZhciBwYXJlbnRDaGFyYWN0ZXJMaXN0ID0gcGFyZW50UmVjb3JkLmdldENoYXJhY3Rlckxpc3QoKTtcbiAgICAgICAgdmFyIHBhcmVudFRleHQgPSBwYXJlbnRSZWNvcmQuZ2V0VGV4dCgpO1xuICAgICAgICBwYXJlbnRUZXh0Tm9kZUtleSA9IGdlbmVyYXRlUmFuZG9tS2V5KCk7XG5cbiAgICAgICAgdmFyIHRleHROb2RlID0gbmV3IENvbnRlbnRCbG9ja05vZGUoe1xuICAgICAgICAgIGtleTogcGFyZW50VGV4dE5vZGVLZXksXG4gICAgICAgICAgdGV4dDogcGFyZW50VGV4dCxcbiAgICAgICAgICBjaGFyYWN0ZXJMaXN0OiBwYXJlbnRDaGFyYWN0ZXJMaXN0LFxuICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgIG5leHRTaWJsaW5nOiBrZXlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWNjLmNvbnRlbnRCbG9ja3MucHVzaCh0ZXh0Tm9kZSk7XG5cbiAgICAgICAgcGFyZW50UmVjb3JkID0gcGFyZW50UmVjb3JkLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgYmxvY2suc2V0KCdjaGFyYWN0ZXJMaXN0JywgTGlzdCgpKS5zZXQoJ3RleHQnLCAnJykuc2V0KCdjaGlsZHJlbicsIHBhcmVudFJlY29yZC5jaGlsZHJlbi5wdXNoKHRleHROb2RlLmdldEtleSgpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBhY2MuY29udGVudEJsb2Nrc1twYXJlbnRJbmRleF0gPSBwYXJlbnRSZWNvcmQuc2V0KCdjaGlsZHJlbicsIHBhcmVudFJlY29yZC5jaGlsZHJlbi5wdXNoKGtleSkpO1xuICAgIH1cblxuICAgIHZhciBibG9ja05vZGUgPSBuZXcgQmxvY2tOb2RlUmVjb3JkKHtcbiAgICAgIGtleToga2V5LFxuICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgdGV4dDogdGV4dEJsb2NrLFxuICAgICAgY2hhcmFjdGVyTGlzdDogY2hhcmFjdGVyTGlzdCxcbiAgICAgIHByZXZTaWJsaW5nOiBwYXJlbnRUZXh0Tm9kZUtleSB8fCAoaW5kZXggPT09IDAgfHwgcmF3QmxvY2tzW2luZGV4IC0gMV0ucGFyZW50ICE9PSBwYXJlbnQgPyBudWxsIDogcmF3QmxvY2tzW2luZGV4IC0gMV0ua2V5KSxcbiAgICAgIG5leHRTaWJsaW5nOiBpbmRleCA9PT0gcmF3QmxvY2tzLmxlbmd0aCAtIDEgfHwgcmF3QmxvY2tzW2luZGV4ICsgMV0ucGFyZW50ICE9PSBwYXJlbnQgPyBudWxsIDogcmF3QmxvY2tzW2luZGV4ICsgMV0ua2V5XG4gICAgfSk7XG5cbiAgICAvLyBpbnNlcnQgbm9kZVxuICAgIGFjYy5jb250ZW50QmxvY2tzLnB1c2goYmxvY2tOb2RlKTtcblxuICAgIC8vIGNhY2hlIHJlZiBmb3IgYnVpbGRpbmcgbGlua3NcbiAgICBhY2MuY2FjaGVSZWZbYmxvY2tOb2RlLmtleV0gPSBpbmRleDtcblxuICAgIHJldHVybiBhY2M7XG4gIH0sIGluaXRpYWxTdGF0ZSkuY29udGVudEJsb2Nrcztcbn07XG5cbnZhciBjb252ZXJ0RnJvbUhUTUx0b0NvbnRlbnRCbG9ja3MgPSBmdW5jdGlvbiBjb252ZXJ0RnJvbUhUTUx0b0NvbnRlbnRCbG9ja3MoaHRtbCkge1xuICB2YXIgRE9NQnVpbGRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZ2V0U2FmZUJvZHlGcm9tSFRNTDtcbiAgdmFyIGJsb2NrUmVuZGVyTWFwID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBEZWZhdWx0RHJhZnRCbG9ja1JlbmRlck1hcDtcblxuICAvLyBCZSBBQlNPTFVURUxZIFNVUkUgdGhhdCB0aGUgZG9tIGJ1aWxkZXIgeW91IHBhc3MgaGVyZSB3b24ndCBleGVjdXRlXG4gIC8vIGFyYml0cmFyeSBjb2RlIGluIHdoYXRldmVyIGVudmlyb25tZW50IHlvdSdyZSBydW5uaW5nIHRoaXMgaW4uIEZvciBhblxuICAvLyBleGFtcGxlIG9mIGhvdyB3ZSB0cnkgdG8gZG8gdGhpcyBpbi1icm93c2VyLCBzZWUgZ2V0U2FmZUJvZHlGcm9tSFRNTC5cblxuICAvLyBUT0RPOiByZXBsYWNlIERyYWZ0RW50aXR5IHdpdGggYW4gT3JkZXJlZE1hcCBoZXJlXG4gIHZhciBjaHVua0RhdGEgPSBnZXRDaHVua0ZvckhUTUwoaHRtbCwgRE9NQnVpbGRlciwgYmxvY2tSZW5kZXJNYXAsIERyYWZ0RW50aXR5KTtcblxuICBpZiAoY2h1bmtEYXRhID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjaHVuayA9IGNodW5rRGF0YS5jaHVuayxcbiAgICAgIGVudGl0eU1hcCA9IGNodW5rRGF0YS5lbnRpdHlNYXA7XG5cbiAgdmFyIGNvbnRlbnRCbG9ja3MgPSBjb252ZXJ0Q2h1bmtUb0NvbnRlbnRCbG9ja3MoY2h1bmspO1xuXG4gIHJldHVybiB7XG4gICAgY29udGVudEJsb2NrczogY29udGVudEJsb2NrcyxcbiAgICBlbnRpdHlNYXA6IGVudGl0eU1hcFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJ0RnJvbUhUTUx0b0NvbnRlbnRCbG9ja3M7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2NvbnZlcnRGcm9tSFRNTFRvQ29udGVudEJsb2Nrcy5qc1xuLy8gbW9kdWxlIGlkID0gMzgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRTYWZlQm9keUZyb21IVE1MXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVc2VyQWdlbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9Vc2VyQWdlbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgaXNPbGRJRSA9IFVzZXJBZ2VudC5pc0Jyb3dzZXIoJ0lFIDw9IDknKTtcblxuLy8gUHJvdmlkZXMgYSBkb20gbm9kZSB0aGF0IHdpbGwgbm90IGV4ZWN1dGUgc2NyaXB0c1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RPTUltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvQWRkLW9ucy9Db2RlX3NuaXBwZXRzL0hUTUxfdG9fRE9NXG5cbmZ1bmN0aW9uIGdldFNhZmVCb2R5RnJvbUhUTUwoaHRtbCkge1xuICB2YXIgZG9jO1xuICB2YXIgcm9vdCA9IG51bGw7XG4gIC8vIFByb3ZpZGVzIGEgc2FmZSBjb250ZXh0XG4gIGlmICghaXNPbGRJRSAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQpIHtcbiAgICBkb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ2ZvbycpO1xuICAgICFkb2MuZG9jdW1lbnRFbGVtZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc3NpbmcgZG9jLmRvY3VtZW50RWxlbWVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBkb2MuZG9jdW1lbnRFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcm9vdCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdO1xuICB9XG4gIHJldHVybiByb290O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFNhZmVCb2R5RnJvbUhUTUw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2dldFNhZmVCb2R5RnJvbUhUTUwuanNcbi8vIG1vZHVsZSBpZCA9IDM4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmljaFRleHRFZGl0b3JVdGlsXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEcmFmdE1vZGlmaWVyID0gcmVxdWlyZSgnLi9EcmFmdE1vZGlmaWVyJyk7XG52YXIgRWRpdG9yU3RhdGUgPSByZXF1aXJlKCcuL0VkaXRvclN0YXRlJyk7XG52YXIgU2VsZWN0aW9uU3RhdGUgPSByZXF1aXJlKCcuL1NlbGVjdGlvblN0YXRlJyk7XG5cbnZhciBhZGp1c3RCbG9ja0RlcHRoRm9yQ29udGVudFN0YXRlID0gcmVxdWlyZSgnLi9hZGp1c3RCbG9ja0RlcHRoRm9yQ29udGVudFN0YXRlJyk7XG52YXIgbnVsbHRocm93cyA9IHJlcXVpcmUoJ2ZianMvbGliL251bGx0aHJvd3MnKTtcblxudmFyIFJpY2hUZXh0RWRpdG9yVXRpbCA9IHtcbiAgY3VycmVudEJsb2NrQ29udGFpbnNMaW5rOiBmdW5jdGlvbiBjdXJyZW50QmxvY2tDb250YWluc0xpbmsoZWRpdG9yU3RhdGUpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG4gICAgdmFyIGNvbnRlbnRTdGF0ZSA9IGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG4gICAgdmFyIGVudGl0eU1hcCA9IGNvbnRlbnRTdGF0ZS5nZXRFbnRpdHlNYXAoKTtcbiAgICByZXR1cm4gY29udGVudFN0YXRlLmdldEJsb2NrRm9yS2V5KHNlbGVjdGlvbi5nZXRBbmNob3JLZXkoKSkuZ2V0Q2hhcmFjdGVyTGlzdCgpLnNsaWNlKHNlbGVjdGlvbi5nZXRTdGFydE9mZnNldCgpLCBzZWxlY3Rpb24uZ2V0RW5kT2Zmc2V0KCkpLnNvbWUoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHZhciBlbnRpdHkgPSB2LmdldEVudGl0eSgpO1xuICAgICAgcmV0dXJuICEhZW50aXR5ICYmIGVudGl0eU1hcC5fX2dldChlbnRpdHkpLmdldFR5cGUoKSA9PT0gJ0xJTksnO1xuICAgIH0pO1xuICB9LFxuXG4gIGdldEN1cnJlbnRCbG9ja1R5cGU6IGZ1bmN0aW9uIGdldEN1cnJlbnRCbG9ja1R5cGUoZWRpdG9yU3RhdGUpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCkuZ2V0QmxvY2tGb3JLZXkoc2VsZWN0aW9uLmdldFN0YXJ0S2V5KCkpLmdldFR5cGUoKTtcbiAgfSxcblxuICBnZXREYXRhT2JqZWN0Rm9yTGlua1VSTDogZnVuY3Rpb24gZ2V0RGF0YU9iamVjdEZvckxpbmtVUkwodXJpKSB7XG4gICAgcmV0dXJuIHsgdXJsOiB1cmkudG9TdHJpbmcoKSB9O1xuICB9LFxuXG4gIGhhbmRsZUtleUNvbW1hbmQ6IGZ1bmN0aW9uIGhhbmRsZUtleUNvbW1hbmQoZWRpdG9yU3RhdGUsIGNvbW1hbmQpIHtcbiAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgIGNhc2UgJ2JvbGQnOlxuICAgICAgICByZXR1cm4gUmljaFRleHRFZGl0b3JVdGlsLnRvZ2dsZUlubGluZVN0eWxlKGVkaXRvclN0YXRlLCAnQk9MRCcpO1xuICAgICAgY2FzZSAnaXRhbGljJzpcbiAgICAgICAgcmV0dXJuIFJpY2hUZXh0RWRpdG9yVXRpbC50b2dnbGVJbmxpbmVTdHlsZShlZGl0b3JTdGF0ZSwgJ0lUQUxJQycpO1xuICAgICAgY2FzZSAndW5kZXJsaW5lJzpcbiAgICAgICAgcmV0dXJuIFJpY2hUZXh0RWRpdG9yVXRpbC50b2dnbGVJbmxpbmVTdHlsZShlZGl0b3JTdGF0ZSwgJ1VOREVSTElORScpO1xuICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgIHJldHVybiBSaWNoVGV4dEVkaXRvclV0aWwudG9nZ2xlQ29kZShlZGl0b3JTdGF0ZSk7XG4gICAgICBjYXNlICdiYWNrc3BhY2UnOlxuICAgICAgY2FzZSAnYmFja3NwYWNlLXdvcmQnOlxuICAgICAgY2FzZSAnYmFja3NwYWNlLXRvLXN0YXJ0LW9mLWxpbmUnOlxuICAgICAgICByZXR1cm4gUmljaFRleHRFZGl0b3JVdGlsLm9uQmFja3NwYWNlKGVkaXRvclN0YXRlKTtcbiAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICBjYXNlICdkZWxldGUtd29yZCc6XG4gICAgICBjYXNlICdkZWxldGUtdG8tZW5kLW9mLWJsb2NrJzpcbiAgICAgICAgcmV0dXJuIFJpY2hUZXh0RWRpdG9yVXRpbC5vbkRlbGV0ZShlZGl0b3JTdGF0ZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyB0aGV5IG1heSBoYXZlIGN1c3RvbSBlZGl0b3IgY29tbWFuZHM7IGlnbm9yZSB0aG9zZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgaW5zZXJ0U29mdE5ld2xpbmU6IGZ1bmN0aW9uIGluc2VydFNvZnROZXdsaW5lKGVkaXRvclN0YXRlKSB7XG4gICAgdmFyIGNvbnRlbnRTdGF0ZSA9IERyYWZ0TW9kaWZpZXIuaW5zZXJ0VGV4dChlZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpLCBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKSwgJ1xcbicsIGVkaXRvclN0YXRlLmdldEN1cnJlbnRJbmxpbmVTdHlsZSgpLCBudWxsKTtcblxuICAgIHZhciBuZXdFZGl0b3JTdGF0ZSA9IEVkaXRvclN0YXRlLnB1c2goZWRpdG9yU3RhdGUsIGNvbnRlbnRTdGF0ZSwgJ2luc2VydC1jaGFyYWN0ZXJzJyk7XG5cbiAgICByZXR1cm4gRWRpdG9yU3RhdGUuZm9yY2VTZWxlY3Rpb24obmV3RWRpdG9yU3RhdGUsIGNvbnRlbnRTdGF0ZS5nZXRTZWxlY3Rpb25BZnRlcigpKTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yIGNvbGxhcHNlZCBzZWxlY3Rpb25zIGF0IHRoZSBzdGFydCBvZiBzdHlsZWQgYmxvY2tzLCBiYWNrc3BhY2Ugc2hvdWxkXG4gICAqIGp1c3QgcmVtb3ZlIHRoZSBleGlzdGluZyBzdHlsZS5cbiAgICovXG4gIG9uQmFja3NwYWNlOiBmdW5jdGlvbiBvbkJhY2tzcGFjZShlZGl0b3JTdGF0ZSkge1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IHNlbGVjdGlvbi5nZXRBbmNob3JPZmZzZXQoKSB8fCBzZWxlY3Rpb24uZ2V0Rm9jdXNPZmZzZXQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gRmlyc3QsIHRyeSB0byByZW1vdmUgYSBwcmVjZWRpbmcgYXRvbWljIGJsb2NrLlxuICAgIHZhciBjb250ZW50ID0gZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKTtcbiAgICB2YXIgc3RhcnRLZXkgPSBzZWxlY3Rpb24uZ2V0U3RhcnRLZXkoKTtcbiAgICB2YXIgYmxvY2tCZWZvcmUgPSBjb250ZW50LmdldEJsb2NrQmVmb3JlKHN0YXJ0S2V5KTtcblxuICAgIGlmIChibG9ja0JlZm9yZSAmJiBibG9ja0JlZm9yZS5nZXRUeXBlKCkgPT09ICdhdG9taWMnKSB7XG4gICAgICB2YXIgYmxvY2tNYXAgPSBjb250ZW50LmdldEJsb2NrTWFwKClbJ2RlbGV0ZSddKGJsb2NrQmVmb3JlLmdldEtleSgpKTtcbiAgICAgIHZhciB3aXRob3V0QXRvbWljQmxvY2sgPSBjb250ZW50Lm1lcmdlKHtcbiAgICAgICAgYmxvY2tNYXA6IGJsb2NrTWFwLFxuICAgICAgICBzZWxlY3Rpb25BZnRlcjogc2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGlmICh3aXRob3V0QXRvbWljQmxvY2sgIT09IGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIEVkaXRvclN0YXRlLnB1c2goZWRpdG9yU3RhdGUsIHdpdGhvdXRBdG9taWNCbG9jaywgJ3JlbW92ZS1yYW5nZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoYXQgZG9lc24ndCBzdWNjZWVkLCB0cnkgdG8gcmVtb3ZlIHRoZSBjdXJyZW50IGJsb2NrIHN0eWxlLlxuICAgIHZhciB3aXRob3V0QmxvY2tTdHlsZSA9IFJpY2hUZXh0RWRpdG9yVXRpbC50cnlUb1JlbW92ZUJsb2NrU3R5bGUoZWRpdG9yU3RhdGUpO1xuXG4gICAgaWYgKHdpdGhvdXRCbG9ja1N0eWxlKSB7XG4gICAgICByZXR1cm4gRWRpdG9yU3RhdGUucHVzaChlZGl0b3JTdGF0ZSwgd2l0aG91dEJsb2NrU3R5bGUsICdjaGFuZ2UtYmxvY2stdHlwZScpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIG9uRGVsZXRlOiBmdW5jdGlvbiBvbkRlbGV0ZShlZGl0b3JTdGF0ZSkge1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9IGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG4gICAgdmFyIHN0YXJ0S2V5ID0gc2VsZWN0aW9uLmdldFN0YXJ0S2V5KCk7XG4gICAgdmFyIGJsb2NrID0gY29udGVudC5nZXRCbG9ja0ZvcktleShzdGFydEtleSk7XG4gICAgdmFyIGxlbmd0aCA9IGJsb2NrLmdldExlbmd0aCgpO1xuXG4gICAgLy8gVGhlIGN1cnNvciBpcyBzb21ld2hlcmUgd2l0aGluIHRoZSB0ZXh0LiBCZWhhdmUgbm9ybWFsbHkuXG4gICAgaWYgKHNlbGVjdGlvbi5nZXRTdGFydE9mZnNldCgpIDwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYmxvY2tBZnRlciA9IGNvbnRlbnQuZ2V0QmxvY2tBZnRlcihzdGFydEtleSk7XG5cbiAgICBpZiAoIWJsb2NrQWZ0ZXIgfHwgYmxvY2tBZnRlci5nZXRUeXBlKCkgIT09ICdhdG9taWMnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYXRvbWljQmxvY2tUYXJnZXQgPSBzZWxlY3Rpb24ubWVyZ2Uoe1xuICAgICAgZm9jdXNLZXk6IGJsb2NrQWZ0ZXIuZ2V0S2V5KCksXG4gICAgICBmb2N1c09mZnNldDogYmxvY2tBZnRlci5nZXRMZW5ndGgoKVxuICAgIH0pO1xuXG4gICAgdmFyIHdpdGhvdXRBdG9taWNCbG9jayA9IERyYWZ0TW9kaWZpZXIucmVtb3ZlUmFuZ2UoY29udGVudCwgYXRvbWljQmxvY2tUYXJnZXQsICdmb3J3YXJkJyk7XG5cbiAgICBpZiAod2l0aG91dEF0b21pY0Jsb2NrICE9PSBjb250ZW50KSB7XG4gICAgICByZXR1cm4gRWRpdG9yU3RhdGUucHVzaChlZGl0b3JTdGF0ZSwgd2l0aG91dEF0b21pY0Jsb2NrLCAncmVtb3ZlLXJhbmdlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgb25UYWI6IGZ1bmN0aW9uIG9uVGFiKGV2ZW50LCBlZGl0b3JTdGF0ZSwgbWF4RGVwdGgpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG4gICAgdmFyIGtleSA9IHNlbGVjdGlvbi5nZXRBbmNob3JLZXkoKTtcbiAgICBpZiAoa2V5ICE9PSBzZWxlY3Rpb24uZ2V0Rm9jdXNLZXkoKSkge1xuICAgICAgcmV0dXJuIGVkaXRvclN0YXRlO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50ID0gZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKTtcbiAgICB2YXIgYmxvY2sgPSBjb250ZW50LmdldEJsb2NrRm9yS2V5KGtleSk7XG4gICAgdmFyIHR5cGUgPSBibG9jay5nZXRUeXBlKCk7XG4gICAgaWYgKHR5cGUgIT09ICd1bm9yZGVyZWQtbGlzdC1pdGVtJyAmJiB0eXBlICE9PSAnb3JkZXJlZC1saXN0LWl0ZW0nKSB7XG4gICAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gICAgfVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIE9ubHkgYWxsb3cgaW5kZW50aW5nIG9uZSBsZXZlbCBiZXlvbmQgdGhlIGJsb2NrIGFib3ZlLCBhbmQgb25seSBpZlxuICAgIC8vIHRoZSBibG9jayBhYm92ZSBpcyBhIGxpc3QgaXRlbSBhcyB3ZWxsLlxuICAgIHZhciBibG9ja0Fib3ZlID0gY29udGVudC5nZXRCbG9ja0JlZm9yZShrZXkpO1xuICAgIGlmICghYmxvY2tBYm92ZSkge1xuICAgICAgcmV0dXJuIGVkaXRvclN0YXRlO1xuICAgIH1cblxuICAgIHZhciB0eXBlQWJvdmUgPSBibG9ja0Fib3ZlLmdldFR5cGUoKTtcbiAgICBpZiAodHlwZUFib3ZlICE9PSAndW5vcmRlcmVkLWxpc3QtaXRlbScgJiYgdHlwZUFib3ZlICE9PSAnb3JkZXJlZC1saXN0LWl0ZW0nKSB7XG4gICAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlcHRoID0gYmxvY2suZ2V0RGVwdGgoKTtcbiAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmIGRlcHRoID09PSBtYXhEZXB0aCkge1xuICAgICAgcmV0dXJuIGVkaXRvclN0YXRlO1xuICAgIH1cblxuICAgIG1heERlcHRoID0gTWF0aC5taW4oYmxvY2tBYm92ZS5nZXREZXB0aCgpICsgMSwgbWF4RGVwdGgpO1xuXG4gICAgdmFyIHdpdGhBZGp1c3RtZW50ID0gYWRqdXN0QmxvY2tEZXB0aEZvckNvbnRlbnRTdGF0ZShjb250ZW50LCBzZWxlY3Rpb24sIGV2ZW50LnNoaWZ0S2V5ID8gLTEgOiAxLCBtYXhEZXB0aCk7XG5cbiAgICByZXR1cm4gRWRpdG9yU3RhdGUucHVzaChlZGl0b3JTdGF0ZSwgd2l0aEFkanVzdG1lbnQsICdhZGp1c3QtZGVwdGgnKTtcbiAgfSxcblxuICB0b2dnbGVCbG9ja1R5cGU6IGZ1bmN0aW9uIHRvZ2dsZUJsb2NrVHlwZShlZGl0b3JTdGF0ZSwgYmxvY2tUeXBlKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpO1xuICAgIHZhciBzdGFydEtleSA9IHNlbGVjdGlvbi5nZXRTdGFydEtleSgpO1xuICAgIHZhciBlbmRLZXkgPSBzZWxlY3Rpb24uZ2V0RW5kS2V5KCk7XG4gICAgdmFyIGNvbnRlbnQgPSBlZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpO1xuICAgIHZhciB0YXJnZXQgPSBzZWxlY3Rpb247XG5cbiAgICAvLyBUcmlwbGUtY2xpY2sgY2FuIGxlYWQgdG8gYSBzZWxlY3Rpb24gdGhhdCBpbmNsdWRlcyBvZmZzZXQgMCBvZiB0aGVcbiAgICAvLyBmb2xsb3dpbmcgYmxvY2suIFRoZSBgU2VsZWN0aW9uU3RhdGVgIGZvciB0aGlzIGNhc2UgaXMgYWNjdXJhdGUsIGJ1dFxuICAgIC8vIHdlIHNob3VsZCBhdm9pZCB0b2dnbGluZyBibG9jayB0eXBlIGZvciB0aGUgdHJhaWxpbmcgYmxvY2sgYmVjYXVzZSBpdFxuICAgIC8vIGlzIGEgY29uZnVzaW5nIGludGVyYWN0aW9uLlxuICAgIGlmIChzdGFydEtleSAhPT0gZW5kS2V5ICYmIHNlbGVjdGlvbi5nZXRFbmRPZmZzZXQoKSA9PT0gMCkge1xuICAgICAgdmFyIGJsb2NrQmVmb3JlID0gbnVsbHRocm93cyhjb250ZW50LmdldEJsb2NrQmVmb3JlKGVuZEtleSkpO1xuICAgICAgZW5kS2V5ID0gYmxvY2tCZWZvcmUuZ2V0S2V5KCk7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQubWVyZ2Uoe1xuICAgICAgICBhbmNob3JLZXk6IHN0YXJ0S2V5LFxuICAgICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5nZXRTdGFydE9mZnNldCgpLFxuICAgICAgICBmb2N1c0tleTogZW5kS2V5LFxuICAgICAgICBmb2N1c09mZnNldDogYmxvY2tCZWZvcmUuZ2V0TGVuZ3RoKCksXG4gICAgICAgIGlzQmFja3dhcmQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaGFzQXRvbWljQmxvY2sgPSBjb250ZW50LmdldEJsb2NrTWFwKCkuc2tpcFdoaWxlKGZ1bmN0aW9uIChfLCBrKSB7XG4gICAgICByZXR1cm4gayAhPT0gc3RhcnRLZXk7XG4gICAgfSkucmV2ZXJzZSgpLnNraXBXaGlsZShmdW5jdGlvbiAoXywgaykge1xuICAgICAgcmV0dXJuIGsgIT09IGVuZEtleTtcbiAgICB9KS5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdi5nZXRUeXBlKCkgPT09ICdhdG9taWMnO1xuICAgIH0pO1xuXG4gICAgaWYgKGhhc0F0b21pY0Jsb2NrKSB7XG4gICAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVUb1NldCA9IGNvbnRlbnQuZ2V0QmxvY2tGb3JLZXkoc3RhcnRLZXkpLmdldFR5cGUoKSA9PT0gYmxvY2tUeXBlID8gJ3Vuc3R5bGVkJyA6IGJsb2NrVHlwZTtcblxuICAgIHJldHVybiBFZGl0b3JTdGF0ZS5wdXNoKGVkaXRvclN0YXRlLCBEcmFmdE1vZGlmaWVyLnNldEJsb2NrVHlwZShjb250ZW50LCB0YXJnZXQsIHR5cGVUb1NldCksICdjaGFuZ2UtYmxvY2stdHlwZScpO1xuICB9LFxuXG4gIHRvZ2dsZUNvZGU6IGZ1bmN0aW9uIHRvZ2dsZUNvZGUoZWRpdG9yU3RhdGUpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG4gICAgdmFyIGFuY2hvcktleSA9IHNlbGVjdGlvbi5nZXRBbmNob3JLZXkoKTtcbiAgICB2YXIgZm9jdXNLZXkgPSBzZWxlY3Rpb24uZ2V0Rm9jdXNLZXkoKTtcblxuICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCBhbmNob3JLZXkgIT09IGZvY3VzS2V5KSB7XG4gICAgICByZXR1cm4gUmljaFRleHRFZGl0b3JVdGlsLnRvZ2dsZUJsb2NrVHlwZShlZGl0b3JTdGF0ZSwgJ2NvZGUtYmxvY2snKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmljaFRleHRFZGl0b3JVdGlsLnRvZ2dsZUlubGluZVN0eWxlKGVkaXRvclN0YXRlLCAnQ09ERScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIHNwZWNpZmllZCBpbmxpbmUgc3R5bGUgZm9yIHRoZSBzZWxlY3Rpb24uIElmIHRoZVxuICAgKiB1c2VyJ3Mgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZCwgYXBwbHkgb3IgcmVtb3ZlIHRoZSBzdHlsZSBmb3IgdGhlXG4gICAqIGludGVybmFsIHN0YXRlLiBJZiBpdCBpcyBub3QgY29sbGFwc2VkLCBhcHBseSB0aGUgY2hhbmdlIGRpcmVjdGx5XG4gICAqIHRvIHRoZSBkb2N1bWVudCBzdGF0ZS5cbiAgICovXG4gIHRvZ2dsZUlubGluZVN0eWxlOiBmdW5jdGlvbiB0b2dnbGVJbmxpbmVTdHlsZShlZGl0b3JTdGF0ZSwgaW5saW5lU3R5bGUpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG4gICAgdmFyIGN1cnJlbnRTdHlsZSA9IGVkaXRvclN0YXRlLmdldEN1cnJlbnRJbmxpbmVTdHlsZSgpO1xuXG4gICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQsIHRvZ2dsZSB0aGUgc3BlY2lmaWVkIHN0eWxlIG9uIG9yIG9mZiBhbmRcbiAgICAvLyBzZXQgdGhlIHJlc3VsdCBhcyB0aGUgbmV3IGlubGluZSBzdHlsZSBvdmVycmlkZS4gVGhpcyB3aWxsIHRoZW4gYmVcbiAgICAvLyB1c2VkIGFzIHRoZSBpbmxpbmUgc3R5bGUgZm9yIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBpbnNlcnRlZC5cbiAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIHJldHVybiBFZGl0b3JTdGF0ZS5zZXRJbmxpbmVTdHlsZU92ZXJyaWRlKGVkaXRvclN0YXRlLCBjdXJyZW50U3R5bGUuaGFzKGlubGluZVN0eWxlKSA/IGN1cnJlbnRTdHlsZS5yZW1vdmUoaW5saW5lU3R5bGUpIDogY3VycmVudFN0eWxlLmFkZChpbmxpbmVTdHlsZSkpO1xuICAgIH1cblxuICAgIC8vIElmIGNoYXJhY3RlcnMgYXJlIHNlbGVjdGVkLCBpbW1lZGlhdGVseSBhcHBseSBvciByZW1vdmUgdGhlXG4gICAgLy8gaW5saW5lIHN0eWxlIG9uIHRoZSBkb2N1bWVudCBzdGF0ZSBpdHNlbGYuXG4gICAgdmFyIGNvbnRlbnQgPSBlZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpO1xuICAgIHZhciBuZXdDb250ZW50O1xuXG4gICAgLy8gSWYgdGhlIHN0eWxlIGlzIGFscmVhZHkgcHJlc2VudCBmb3IgdGhlIHNlbGVjdGlvbiByYW5nZSwgcmVtb3ZlIGl0LlxuICAgIC8vIE90aGVyd2lzZSwgYXBwbHkgaXQuXG4gICAgaWYgKGN1cnJlbnRTdHlsZS5oYXMoaW5saW5lU3R5bGUpKSB7XG4gICAgICBuZXdDb250ZW50ID0gRHJhZnRNb2RpZmllci5yZW1vdmVJbmxpbmVTdHlsZShjb250ZW50LCBzZWxlY3Rpb24sIGlubGluZVN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Q29udGVudCA9IERyYWZ0TW9kaWZpZXIuYXBwbHlJbmxpbmVTdHlsZShjb250ZW50LCBzZWxlY3Rpb24sIGlubGluZVN0eWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRWRpdG9yU3RhdGUucHVzaChlZGl0b3JTdGF0ZSwgbmV3Q29udGVudCwgJ2NoYW5nZS1pbmxpbmUtc3R5bGUnKTtcbiAgfSxcblxuICB0b2dnbGVMaW5rOiBmdW5jdGlvbiB0b2dnbGVMaW5rKGVkaXRvclN0YXRlLCB0YXJnZXRTZWxlY3Rpb24sIGVudGl0eUtleSkge1xuICAgIHZhciB3aXRob3V0TGluayA9IERyYWZ0TW9kaWZpZXIuYXBwbHlFbnRpdHkoZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKSwgdGFyZ2V0U2VsZWN0aW9uLCBlbnRpdHlLZXkpO1xuXG4gICAgcmV0dXJuIEVkaXRvclN0YXRlLnB1c2goZWRpdG9yU3RhdGUsIHdpdGhvdXRMaW5rLCAnYXBwbHktZW50aXR5Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gYSBjb2xsYXBzZWQgY3Vyc29yIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgZmlyc3Qgc3R5bGVkIGJsb2NrLCBvclxuICAgKiBhbiBlbXB0eSBzdHlsZWQgYmxvY2ssIGNoYW5nZXMgYmxvY2sgdG8gJ3Vuc3R5bGVkJy4gUmV0dXJucyBudWxsIGlmXG4gICAqIGJsb2NrIG9yIHNlbGVjdGlvbiBkb2VzIG5vdCBtZWV0IHRoYXQgY3JpdGVyaWEuXG4gICAqL1xuICB0cnlUb1JlbW92ZUJsb2NrU3R5bGU6IGZ1bmN0aW9uIHRyeVRvUmVtb3ZlQmxvY2tTdHlsZShlZGl0b3JTdGF0ZSkge1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKTtcbiAgICB2YXIgb2Zmc2V0ID0gc2VsZWN0aW9uLmdldEFuY2hvck9mZnNldCgpO1xuICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBvZmZzZXQgPT09IDApIHtcbiAgICAgIHZhciBrZXkgPSBzZWxlY3Rpb24uZ2V0QW5jaG9yS2V5KCk7XG4gICAgICB2YXIgY29udGVudCA9IGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG4gICAgICB2YXIgYmxvY2sgPSBjb250ZW50LmdldEJsb2NrRm9yS2V5KGtleSk7XG5cbiAgICAgIHZhciBmaXJzdEJsb2NrID0gY29udGVudC5nZXRGaXJzdEJsb2NrKCk7XG4gICAgICBpZiAoYmxvY2suZ2V0TGVuZ3RoKCkgPiAwICYmIGJsb2NrICE9PSBmaXJzdEJsb2NrKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZSA9IGJsb2NrLmdldFR5cGUoKTtcbiAgICAgIHZhciBibG9ja0JlZm9yZSA9IGNvbnRlbnQuZ2V0QmxvY2tCZWZvcmUoa2V5KTtcbiAgICAgIGlmICh0eXBlID09PSAnY29kZS1ibG9jaycgJiYgYmxvY2tCZWZvcmUgJiYgYmxvY2tCZWZvcmUuZ2V0VHlwZSgpID09PSAnY29kZS1ibG9jaycgJiYgYmxvY2tCZWZvcmUuZ2V0TGVuZ3RoKCkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlICE9PSAndW5zdHlsZWQnKSB7XG4gICAgICAgIHJldHVybiBEcmFmdE1vZGlmaWVyLnNldEJsb2NrVHlwZShjb250ZW50LCBzZWxlY3Rpb24sICd1bnN0eWxlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSaWNoVGV4dEVkaXRvclV0aWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL1JpY2hUZXh0RWRpdG9yVXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMzgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXREZWZhdWx0S2V5QmluZGluZ1xuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgS2V5QmluZGluZ1V0aWwgPSByZXF1aXJlKCcuL0tleUJpbmRpbmdVdGlsJyk7XG52YXIgS2V5cyA9IHJlcXVpcmUoJ2ZianMvbGliL0tleXMnKTtcbnZhciBVc2VyQWdlbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9Vc2VyQWdlbnQnKTtcblxudmFyIGlzT1NYID0gVXNlckFnZW50LmlzUGxhdGZvcm0oJ01hYyBPUyBYJyk7XG52YXIgaXNXaW5kb3dzID0gVXNlckFnZW50LmlzUGxhdGZvcm0oJ1dpbmRvd3MnKTtcblxuLy8gRmlyZWZveCBvbiBPU1ggaGFkIGEgYnVnIHJlc3VsdGluZyBpbiBuYXZpZ2F0aW9uIGluc3RlYWQgb2YgY3Vyc29yIG1vdmVtZW50LlxuLy8gVGhpcyBidWcgd2FzIGZpeGVkIGluIEZpcmVmb3ggMjkuIEZlYXR1cmUgZGV0ZWN0aW9uIGlzIHZpcnR1YWxseSBpbXBvc3NpYmxlXG4vLyBzbyB3ZSBqdXN0IGNoZWNrIHRoZSB2ZXJzaW9uIG51bWJlci4gU2VlICMzNDI3NjUuXG52YXIgc2hvdWxkRml4RmlyZWZveE1vdmVtZW50ID0gaXNPU1ggJiYgVXNlckFnZW50LmlzQnJvd3NlcignRmlyZWZveCA8IDI5Jyk7XG5cbnZhciBoYXNDb21tYW5kTW9kaWZpZXIgPSBLZXlCaW5kaW5nVXRpbC5oYXNDb21tYW5kTW9kaWZpZXIsXG4gICAgaXNDdHJsS2V5Q29tbWFuZCA9IEtleUJpbmRpbmdVdGlsLmlzQ3RybEtleUNvbW1hbmQ7XG5cblxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlV29yZChlKSB7XG4gIHJldHVybiBpc09TWCAmJiBlLmFsdEtleSB8fCBpc0N0cmxLZXlDb21tYW5kKGUpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXBwcm9wcmlhdGUgdW5kby9yZWRvIGNvbW1hbmQgZm9yIGEgWiBrZXkgY29tbWFuZC5cbiAqL1xuZnVuY3Rpb24gZ2V0WkNvbW1hbmQoZSkge1xuICBpZiAoIWhhc0NvbW1hbmRNb2RpZmllcihlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBlLnNoaWZ0S2V5ID8gJ3JlZG8nIDogJ3VuZG8nO1xufVxuXG5mdW5jdGlvbiBnZXREZWxldGVDb21tYW5kKGUpIHtcbiAgLy8gQWxsb3cgZGVmYXVsdCBcImN1dFwiIGJlaGF2aW9yIGZvciBXaW5kb3dzIG9uIFNoaWZ0ICsgRGVsZXRlLlxuICBpZiAoaXNXaW5kb3dzICYmIGUuc2hpZnRLZXkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gc2hvdWxkUmVtb3ZlV29yZChlKSA/ICdkZWxldGUtd29yZCcgOiAnZGVsZXRlJztcbn1cblxuZnVuY3Rpb24gZ2V0QmFja3NwYWNlQ29tbWFuZChlKSB7XG4gIGlmIChoYXNDb21tYW5kTW9kaWZpZXIoZSkgJiYgaXNPU1gpIHtcbiAgICByZXR1cm4gJ2JhY2tzcGFjZS10by1zdGFydC1vZi1saW5lJztcbiAgfVxuICByZXR1cm4gc2hvdWxkUmVtb3ZlV29yZChlKSA/ICdiYWNrc3BhY2Utd29yZCcgOiAnYmFja3NwYWNlJztcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSBhIGJvdW5kIGtleSBjb21tYW5kIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRLZXlCaW5kaW5nKGUpIHtcbiAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICBjYXNlIDY2OlxuICAgICAgLy8gQlxuICAgICAgcmV0dXJuIGhhc0NvbW1hbmRNb2RpZmllcihlKSA/ICdib2xkJyA6IG51bGw7XG4gICAgY2FzZSA2ODpcbiAgICAgIC8vIERcbiAgICAgIHJldHVybiBpc0N0cmxLZXlDb21tYW5kKGUpID8gJ2RlbGV0ZScgOiBudWxsO1xuICAgIGNhc2UgNzI6XG4gICAgICAvLyBIXG4gICAgICByZXR1cm4gaXNDdHJsS2V5Q29tbWFuZChlKSA/ICdiYWNrc3BhY2UnIDogbnVsbDtcbiAgICBjYXNlIDczOlxuICAgICAgLy8gSVxuICAgICAgcmV0dXJuIGhhc0NvbW1hbmRNb2RpZmllcihlKSA/ICdpdGFsaWMnIDogbnVsbDtcbiAgICBjYXNlIDc0OlxuICAgICAgLy8gSlxuICAgICAgcmV0dXJuIGhhc0NvbW1hbmRNb2RpZmllcihlKSA/ICdjb2RlJyA6IG51bGw7XG4gICAgY2FzZSA3NTpcbiAgICAgIC8vIEtcbiAgICAgIHJldHVybiAhaXNXaW5kb3dzICYmIGlzQ3RybEtleUNvbW1hbmQoZSkgPyAnc2Vjb25kYXJ5LWN1dCcgOiBudWxsO1xuICAgIGNhc2UgNzc6XG4gICAgICAvLyBNXG4gICAgICByZXR1cm4gaXNDdHJsS2V5Q29tbWFuZChlKSA/ICdzcGxpdC1ibG9jaycgOiBudWxsO1xuICAgIGNhc2UgNzk6XG4gICAgICAvLyBPXG4gICAgICByZXR1cm4gaXNDdHJsS2V5Q29tbWFuZChlKSA/ICdzcGxpdC1ibG9jaycgOiBudWxsO1xuICAgIGNhc2UgODQ6XG4gICAgICAvLyBUXG4gICAgICByZXR1cm4gaXNPU1ggJiYgaXNDdHJsS2V5Q29tbWFuZChlKSA/ICd0cmFuc3Bvc2UtY2hhcmFjdGVycycgOiBudWxsO1xuICAgIGNhc2UgODU6XG4gICAgICAvLyBVXG4gICAgICByZXR1cm4gaGFzQ29tbWFuZE1vZGlmaWVyKGUpID8gJ3VuZGVybGluZScgOiBudWxsO1xuICAgIGNhc2UgODc6XG4gICAgICAvLyBXXG4gICAgICByZXR1cm4gaXNPU1ggJiYgaXNDdHJsS2V5Q29tbWFuZChlKSA/ICdiYWNrc3BhY2Utd29yZCcgOiBudWxsO1xuICAgIGNhc2UgODk6XG4gICAgICAvLyBZXG4gICAgICBpZiAoaXNDdHJsS2V5Q29tbWFuZChlKSkge1xuICAgICAgICByZXR1cm4gaXNXaW5kb3dzID8gJ3JlZG8nIDogJ3NlY29uZGFyeS1wYXN0ZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIDkwOlxuICAgICAgLy8gWlxuICAgICAgcmV0dXJuIGdldFpDb21tYW5kKGUpIHx8IG51bGw7XG4gICAgY2FzZSBLZXlzLlJFVFVSTjpcbiAgICAgIHJldHVybiAnc3BsaXQtYmxvY2snO1xuICAgIGNhc2UgS2V5cy5ERUxFVEU6XG4gICAgICByZXR1cm4gZ2V0RGVsZXRlQ29tbWFuZChlKTtcbiAgICBjYXNlIEtleXMuQkFDS1NQQUNFOlxuICAgICAgcmV0dXJuIGdldEJhY2tzcGFjZUNvbW1hbmQoZSk7XG4gICAgLy8gTEVGVC9SSUdIVCBoYW5kbGVycyBzZXJ2ZSBhcyBhIHdvcmthcm91bmQgZm9yIGEgRmlyZWZveCBidWcuXG4gICAgY2FzZSBLZXlzLkxFRlQ6XG4gICAgICByZXR1cm4gc2hvdWxkRml4RmlyZWZveE1vdmVtZW50ICYmIGhhc0NvbW1hbmRNb2RpZmllcihlKSA/ICdtb3ZlLXNlbGVjdGlvbi10by1zdGFydC1vZi1ibG9jaycgOiBudWxsO1xuICAgIGNhc2UgS2V5cy5SSUdIVDpcbiAgICAgIHJldHVybiBzaG91bGRGaXhGaXJlZm94TW92ZW1lbnQgJiYgaGFzQ29tbWFuZE1vZGlmaWVyKGUpID8gJ21vdmUtc2VsZWN0aW9uLXRvLWVuZC1vZi1ibG9jaycgOiBudWxsO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldERlZmF1bHRLZXlCaW5kaW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXREZWZhdWx0S2V5QmluZGluZy5qc1xuLy8gbW9kdWxlIGlkID0gMzgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEcmFmdFN0cmluZ0tleVxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRHJhZnRTdHJpbmdLZXkgPSB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGtleSkge1xuICAgIHJldHVybiAnXycgKyBTdHJpbmcoa2V5KTtcbiAgfSxcblxuICB1bnN0cmluZ2lmeTogZnVuY3Rpb24gdW5zdHJpbmdpZnkoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5zbGljZSgxKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFmdFN0cmluZ0tleTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRHJhZnRTdHJpbmdLZXkuanNcbi8vIG1vZHVsZSBpZCA9IDM4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCB7IEVkaXRvclN0YXRlLCBjb252ZXJ0VG9SYXcsIENvbnRlbnRTdGF0ZSwgY29udmVydEZyb21IVE1MIH0gZnJvbSAnZHJhZnQtanMnXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICdyZWFjdC1kcmFmdC13eXNpd3lnJ1xuaW1wb3J0IGRyYWZ0VG9IdG1sIGZyb20gJ2RyYWZ0anMtdG8taHRtbCdcblxuaW1wb3J0ICdyZWFjdC1kcmFmdC13eXNpd3lnL2Rpc3QvcmVhY3QtZHJhZnQtd3lzaXd5Zy5jc3MnXG5cbmNsYXNzIFdZU0lXWUcgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVkaXRvclN0YXRlOiB0aGlzLmNvbnZlcnRIdG1sVG9FZGl0b3JTdGF0ZSh0aGlzLnByb3BzLnZhbHVlKSxcbiAgICB9XG5cbiAgICB0aGlzLm9uRWRpdG9yU3RhdGVDaGFuZ2UgPSB0aGlzLm9uRWRpdG9yU3RhdGVDaGFuZ2UuYmluZCh0aGlzKVxuICB9XG5cbiAgY29udmVydEh0bWxUb0VkaXRvclN0YXRlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKXtcbiAgICAgIGNvbnN0IGJsb2Nrc0Zyb21IVE1MID0gY29udmVydEZyb21IVE1MKHZhbHVlKVxuICAgICAgY29uc3Qgc3RhdGUgPSBDb250ZW50U3RhdGUuY3JlYXRlRnJvbUJsb2NrQXJyYXkoXG4gICAgICAgIGJsb2Nrc0Zyb21IVE1MLmNvbnRlbnRCbG9ja3MsXG4gICAgICAgIGJsb2Nrc0Zyb21IVE1MLmVudGl0eU1hcFxuICAgICAgKVxuXG4gICAgICByZXR1cm4gRWRpdG9yU3RhdGUuY3JlYXRlV2l0aENvbnRlbnQoc3RhdGUpXG4gICAgfVxuICB9XG5cbiAgb25FZGl0b3JTdGF0ZUNoYW5nZShlZGl0b3JTdGF0ZSkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZWRpdG9yU3RhdGUsXG4gICAgfSlcblxuICAgIHRoaXMucHJvcHMub25DaGFuZ2UoZHJhZnRUb0h0bWwoY29udmVydFRvUmF3KGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCkpKSlcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGVkaXRvclN0YXRlIH0gPSB0aGlzLnN0YXRlXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIDxFZGl0b3JcbiAgICAgICAgICBlZGl0b3JTdGF0ZT17ZWRpdG9yU3RhdGV9XG4gICAgICAgICAgd3JhcHBlckNsYXNzTmFtZT1cImRlbW8td3JhcHBlclwiXG4gICAgICAgICAgZWRpdG9yQ2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICBvbkVkaXRvclN0YXRlQ2hhbmdlPXt0aGlzLm9uRWRpdG9yU3RhdGVDaGFuZ2V9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgV1lTSVdZR1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21tb24vd3lzaXd5Zy1lZGl0b3IvaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEF0b21pY0Jsb2NrVXRpbHNcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfZXh0ZW5kcyA9IF9hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBCbG9ja01hcEJ1aWxkZXIgPSByZXF1aXJlKCcuL0Jsb2NrTWFwQnVpbGRlcicpO1xudmFyIENoYXJhY3Rlck1ldGFkYXRhID0gcmVxdWlyZSgnLi9DaGFyYWN0ZXJNZXRhZGF0YScpO1xudmFyIENvbnRlbnRCbG9jayA9IHJlcXVpcmUoJy4vQ29udGVudEJsb2NrJyk7XG52YXIgQ29udGVudEJsb2NrTm9kZSA9IHJlcXVpcmUoJy4vQ29udGVudEJsb2NrTm9kZScpO1xudmFyIERyYWZ0RmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9EcmFmdEZlYXR1cmVGbGFncycpO1xudmFyIERyYWZ0TW9kaWZpZXIgPSByZXF1aXJlKCcuL0RyYWZ0TW9kaWZpZXInKTtcbnZhciBFZGl0b3JTdGF0ZSA9IHJlcXVpcmUoJy4vRWRpdG9yU3RhdGUnKTtcbnZhciBJbW11dGFibGUgPSByZXF1aXJlKCdpbW11dGFibGUnKTtcbnZhciBTZWxlY3Rpb25TdGF0ZSA9IHJlcXVpcmUoJy4vU2VsZWN0aW9uU3RhdGUnKTtcblxudmFyIGdlbmVyYXRlUmFuZG9tS2V5ID0gcmVxdWlyZSgnLi9nZW5lcmF0ZVJhbmRvbUtleScpO1xudmFyIG1vdmVCbG9ja0luQ29udGVudFN0YXRlID0gcmVxdWlyZSgnLi9tb3ZlQmxvY2tJbkNvbnRlbnRTdGF0ZScpO1xuXG52YXIgZXhwZXJpbWVudGFsVHJlZURhdGFTdXBwb3J0ID0gRHJhZnRGZWF0dXJlRmxhZ3MuZHJhZnRfdHJlZV9kYXRhX3N1cHBvcnQ7XG52YXIgQ29udGVudEJsb2NrUmVjb3JkID0gZXhwZXJpbWVudGFsVHJlZURhdGFTdXBwb3J0ID8gQ29udGVudEJsb2NrTm9kZSA6IENvbnRlbnRCbG9jaztcblxudmFyIExpc3QgPSBJbW11dGFibGUuTGlzdCxcbiAgICBSZXBlYXQgPSBJbW11dGFibGUuUmVwZWF0O1xuXG5cbnZhciBBdG9taWNCbG9ja1V0aWxzID0ge1xuICBpbnNlcnRBdG9taWNCbG9jazogZnVuY3Rpb24gaW5zZXJ0QXRvbWljQmxvY2soZWRpdG9yU3RhdGUsIGVudGl0eUtleSwgY2hhcmFjdGVyKSB7XG4gICAgdmFyIGNvbnRlbnRTdGF0ZSA9IGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG4gICAgdmFyIHNlbGVjdGlvblN0YXRlID0gZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICB2YXIgYWZ0ZXJSZW1vdmFsID0gRHJhZnRNb2RpZmllci5yZW1vdmVSYW5nZShjb250ZW50U3RhdGUsIHNlbGVjdGlvblN0YXRlLCAnYmFja3dhcmQnKTtcblxuICAgIHZhciB0YXJnZXRTZWxlY3Rpb24gPSBhZnRlclJlbW92YWwuZ2V0U2VsZWN0aW9uQWZ0ZXIoKTtcbiAgICB2YXIgYWZ0ZXJTcGxpdCA9IERyYWZ0TW9kaWZpZXIuc3BsaXRCbG9jayhhZnRlclJlbW92YWwsIHRhcmdldFNlbGVjdGlvbik7XG4gICAgdmFyIGluc2VydGlvblRhcmdldCA9IGFmdGVyU3BsaXQuZ2V0U2VsZWN0aW9uQWZ0ZXIoKTtcblxuICAgIHZhciBhc0F0b21pY0Jsb2NrID0gRHJhZnRNb2RpZmllci5zZXRCbG9ja1R5cGUoYWZ0ZXJTcGxpdCwgaW5zZXJ0aW9uVGFyZ2V0LCAnYXRvbWljJyk7XG5cbiAgICB2YXIgY2hhckRhdGEgPSBDaGFyYWN0ZXJNZXRhZGF0YS5jcmVhdGUoeyBlbnRpdHk6IGVudGl0eUtleSB9KTtcblxuICAgIHZhciBhdG9taWNCbG9ja0NvbmZpZyA9IHtcbiAgICAgIGtleTogZ2VuZXJhdGVSYW5kb21LZXkoKSxcbiAgICAgIHR5cGU6ICdhdG9taWMnLFxuICAgICAgdGV4dDogY2hhcmFjdGVyLFxuICAgICAgY2hhcmFjdGVyTGlzdDogTGlzdChSZXBlYXQoY2hhckRhdGEsIGNoYXJhY3Rlci5sZW5ndGgpKVxuICAgIH07XG5cbiAgICB2YXIgYXRvbWljRGl2aWRlckJsb2NrQ29uZmlnID0ge1xuICAgICAga2V5OiBnZW5lcmF0ZVJhbmRvbUtleSgpLFxuICAgICAgdHlwZTogJ3Vuc3R5bGVkJ1xuICAgIH07XG5cbiAgICBpZiAoZXhwZXJpbWVudGFsVHJlZURhdGFTdXBwb3J0KSB7XG4gICAgICBhdG9taWNCbG9ja0NvbmZpZyA9IF9leHRlbmRzKHt9LCBhdG9taWNCbG9ja0NvbmZpZywge1xuICAgICAgICBuZXh0U2libGluZzogYXRvbWljRGl2aWRlckJsb2NrQ29uZmlnLmtleVxuICAgICAgfSk7XG4gICAgICBhdG9taWNEaXZpZGVyQmxvY2tDb25maWcgPSBfZXh0ZW5kcyh7fSwgYXRvbWljRGl2aWRlckJsb2NrQ29uZmlnLCB7XG4gICAgICAgIHByZXZTaWJsaW5nOiBhdG9taWNCbG9ja0NvbmZpZy5rZXlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudEFycmF5ID0gW25ldyBDb250ZW50QmxvY2tSZWNvcmQoYXRvbWljQmxvY2tDb25maWcpLCBuZXcgQ29udGVudEJsb2NrUmVjb3JkKGF0b21pY0RpdmlkZXJCbG9ja0NvbmZpZyldO1xuXG4gICAgdmFyIGZyYWdtZW50ID0gQmxvY2tNYXBCdWlsZGVyLmNyZWF0ZUZyb21BcnJheShmcmFnbWVudEFycmF5KTtcblxuICAgIHZhciB3aXRoQXRvbWljQmxvY2sgPSBEcmFmdE1vZGlmaWVyLnJlcGxhY2VXaXRoRnJhZ21lbnQoYXNBdG9taWNCbG9jaywgaW5zZXJ0aW9uVGFyZ2V0LCBmcmFnbWVudCk7XG5cbiAgICB2YXIgbmV3Q29udGVudCA9IHdpdGhBdG9taWNCbG9jay5tZXJnZSh7XG4gICAgICBzZWxlY3Rpb25CZWZvcmU6IHNlbGVjdGlvblN0YXRlLFxuICAgICAgc2VsZWN0aW9uQWZ0ZXI6IHdpdGhBdG9taWNCbG9jay5nZXRTZWxlY3Rpb25BZnRlcigpLnNldCgnaGFzRm9jdXMnLCB0cnVlKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEVkaXRvclN0YXRlLnB1c2goZWRpdG9yU3RhdGUsIG5ld0NvbnRlbnQsICdpbnNlcnQtZnJhZ21lbnQnKTtcbiAgfSxcblxuICBtb3ZlQXRvbWljQmxvY2s6IGZ1bmN0aW9uIG1vdmVBdG9taWNCbG9jayhlZGl0b3JTdGF0ZSwgYXRvbWljQmxvY2ssIHRhcmdldFJhbmdlLCBpbnNlcnRpb25Nb2RlKSB7XG4gICAgdmFyIGNvbnRlbnRTdGF0ZSA9IGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG4gICAgdmFyIHNlbGVjdGlvblN0YXRlID0gZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICB2YXIgd2l0aE1vdmVkQXRvbWljQmxvY2sgPSB2b2lkIDA7XG5cbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSA9PT0gJ2JlZm9yZScgfHwgaW5zZXJ0aW9uTW9kZSA9PT0gJ2FmdGVyJykge1xuICAgICAgdmFyIHRhcmdldEJsb2NrID0gY29udGVudFN0YXRlLmdldEJsb2NrRm9yS2V5KGluc2VydGlvbk1vZGUgPT09ICdiZWZvcmUnID8gdGFyZ2V0UmFuZ2UuZ2V0U3RhcnRLZXkoKSA6IHRhcmdldFJhbmdlLmdldEVuZEtleSgpKTtcblxuICAgICAgd2l0aE1vdmVkQXRvbWljQmxvY2sgPSBtb3ZlQmxvY2tJbkNvbnRlbnRTdGF0ZShjb250ZW50U3RhdGUsIGF0b21pY0Jsb2NrLCB0YXJnZXRCbG9jaywgaW5zZXJ0aW9uTW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhZnRlclJlbW92YWwgPSBEcmFmdE1vZGlmaWVyLnJlbW92ZVJhbmdlKGNvbnRlbnRTdGF0ZSwgdGFyZ2V0UmFuZ2UsICdiYWNrd2FyZCcpO1xuXG4gICAgICB2YXIgc2VsZWN0aW9uQWZ0ZXJSZW1vdmFsID0gYWZ0ZXJSZW1vdmFsLmdldFNlbGVjdGlvbkFmdGVyKCk7XG4gICAgICB2YXIgX3RhcmdldEJsb2NrID0gYWZ0ZXJSZW1vdmFsLmdldEJsb2NrRm9yS2V5KHNlbGVjdGlvbkFmdGVyUmVtb3ZhbC5nZXRGb2N1c0tleSgpKTtcblxuICAgICAgaWYgKHNlbGVjdGlvbkFmdGVyUmVtb3ZhbC5nZXRTdGFydE9mZnNldCgpID09PSAwKSB7XG4gICAgICAgIHdpdGhNb3ZlZEF0b21pY0Jsb2NrID0gbW92ZUJsb2NrSW5Db250ZW50U3RhdGUoYWZ0ZXJSZW1vdmFsLCBhdG9taWNCbG9jaywgX3RhcmdldEJsb2NrLCAnYmVmb3JlJyk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGlvbkFmdGVyUmVtb3ZhbC5nZXRFbmRPZmZzZXQoKSA9PT0gX3RhcmdldEJsb2NrLmdldExlbmd0aCgpKSB7XG4gICAgICAgIHdpdGhNb3ZlZEF0b21pY0Jsb2NrID0gbW92ZUJsb2NrSW5Db250ZW50U3RhdGUoYWZ0ZXJSZW1vdmFsLCBhdG9taWNCbG9jaywgX3RhcmdldEJsb2NrLCAnYWZ0ZXInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhZnRlclNwbGl0ID0gRHJhZnRNb2RpZmllci5zcGxpdEJsb2NrKGFmdGVyUmVtb3ZhbCwgc2VsZWN0aW9uQWZ0ZXJSZW1vdmFsKTtcblxuICAgICAgICB2YXIgc2VsZWN0aW9uQWZ0ZXJTcGxpdCA9IGFmdGVyU3BsaXQuZ2V0U2VsZWN0aW9uQWZ0ZXIoKTtcbiAgICAgICAgdmFyIF90YXJnZXRCbG9jazIgPSBhZnRlclNwbGl0LmdldEJsb2NrRm9yS2V5KHNlbGVjdGlvbkFmdGVyU3BsaXQuZ2V0Rm9jdXNLZXkoKSk7XG5cbiAgICAgICAgd2l0aE1vdmVkQXRvbWljQmxvY2sgPSBtb3ZlQmxvY2tJbkNvbnRlbnRTdGF0ZShhZnRlclNwbGl0LCBhdG9taWNCbG9jaywgX3RhcmdldEJsb2NrMiwgJ2JlZm9yZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDb250ZW50ID0gd2l0aE1vdmVkQXRvbWljQmxvY2subWVyZ2Uoe1xuICAgICAgc2VsZWN0aW9uQmVmb3JlOiBzZWxlY3Rpb25TdGF0ZSxcbiAgICAgIHNlbGVjdGlvbkFmdGVyOiB3aXRoTW92ZWRBdG9taWNCbG9jay5nZXRTZWxlY3Rpb25BZnRlcigpLnNldCgnaGFzRm9jdXMnLCB0cnVlKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEVkaXRvclN0YXRlLnB1c2goZWRpdG9yU3RhdGUsIG5ld0NvbnRlbnQsICdtb3ZlLWJsb2NrJyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXRvbWljQmxvY2tVdGlscztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvQXRvbWljQmxvY2tVdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMzg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERyYWZ0RmVhdHVyZUZsYWdzLWNvcmVcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERyYWZ0RmVhdHVyZUZsYWdzID0ge1xuICBkcmFmdF9raWxsc3dpdGNoX2FsbG93X25vbnRleHRub2RlczogZmFsc2UsXG4gIGRyYWZ0X3NlZ21lbnRlZF9lbnRpdGllc19iZWhhdmlvcjogZmFsc2UsXG4gIGRyYWZ0X2hhbmRsZWJlZm9yZWlucHV0X2NvbXBvc2VkX3RleHQ6IGZhbHNlLFxuICBkcmFmdF90cmVlX2RhdGFfc3VwcG9ydDogZmFsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZnRGZWF0dXJlRmxhZ3M7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0RmVhdHVyZUZsYWdzLWNvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDM5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ29udGVudFN0YXRlSW5saW5lU3R5bGVcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJhY3Rlck1ldGFkYXRhID0gcmVxdWlyZSgnLi9DaGFyYWN0ZXJNZXRhZGF0YScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdpbW11dGFibGUnKSxcbiAgICBNYXAgPSBfcmVxdWlyZS5NYXA7XG5cbnZhciBDb250ZW50U3RhdGVJbmxpbmVTdHlsZSA9IHtcbiAgYWRkOiBmdW5jdGlvbiBhZGQoY29udGVudFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSwgaW5saW5lU3R5bGUpIHtcbiAgICByZXR1cm4gbW9kaWZ5SW5saW5lU3R5bGUoY29udGVudFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSwgaW5saW5lU3R5bGUsIHRydWUpO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNvbnRlbnRTdGF0ZSwgc2VsZWN0aW9uU3RhdGUsIGlubGluZVN0eWxlKSB7XG4gICAgcmV0dXJuIG1vZGlmeUlubGluZVN0eWxlKGNvbnRlbnRTdGF0ZSwgc2VsZWN0aW9uU3RhdGUsIGlubGluZVN0eWxlLCBmYWxzZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1vZGlmeUlubGluZVN0eWxlKGNvbnRlbnRTdGF0ZSwgc2VsZWN0aW9uU3RhdGUsIGlubGluZVN0eWxlLCBhZGRPclJlbW92ZSkge1xuICB2YXIgYmxvY2tNYXAgPSBjb250ZW50U3RhdGUuZ2V0QmxvY2tNYXAoKTtcbiAgdmFyIHN0YXJ0S2V5ID0gc2VsZWN0aW9uU3RhdGUuZ2V0U3RhcnRLZXkoKTtcbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gc2VsZWN0aW9uU3RhdGUuZ2V0U3RhcnRPZmZzZXQoKTtcbiAgdmFyIGVuZEtleSA9IHNlbGVjdGlvblN0YXRlLmdldEVuZEtleSgpO1xuICB2YXIgZW5kT2Zmc2V0ID0gc2VsZWN0aW9uU3RhdGUuZ2V0RW5kT2Zmc2V0KCk7XG5cbiAgdmFyIG5ld0Jsb2NrcyA9IGJsb2NrTWFwLnNraXBVbnRpbChmdW5jdGlvbiAoXywgaykge1xuICAgIHJldHVybiBrID09PSBzdGFydEtleTtcbiAgfSkudGFrZVVudGlsKGZ1bmN0aW9uIChfLCBrKSB7XG4gICAgcmV0dXJuIGsgPT09IGVuZEtleTtcbiAgfSkuY29uY2F0KE1hcChbW2VuZEtleSwgYmxvY2tNYXAuZ2V0KGVuZEtleSldXSkpLm1hcChmdW5jdGlvbiAoYmxvY2ssIGJsb2NrS2V5KSB7XG4gICAgdmFyIHNsaWNlU3RhcnQ7XG4gICAgdmFyIHNsaWNlRW5kO1xuXG4gICAgaWYgKHN0YXJ0S2V5ID09PSBlbmRLZXkpIHtcbiAgICAgIHNsaWNlU3RhcnQgPSBzdGFydE9mZnNldDtcbiAgICAgIHNsaWNlRW5kID0gZW5kT2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGljZVN0YXJ0ID0gYmxvY2tLZXkgPT09IHN0YXJ0S2V5ID8gc3RhcnRPZmZzZXQgOiAwO1xuICAgICAgc2xpY2VFbmQgPSBibG9ja0tleSA9PT0gZW5kS2V5ID8gZW5kT2Zmc2V0IDogYmxvY2suZ2V0TGVuZ3RoKCk7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJzID0gYmxvY2suZ2V0Q2hhcmFjdGVyTGlzdCgpO1xuICAgIHZhciBjdXJyZW50O1xuICAgIHdoaWxlIChzbGljZVN0YXJ0IDwgc2xpY2VFbmQpIHtcbiAgICAgIGN1cnJlbnQgPSBjaGFycy5nZXQoc2xpY2VTdGFydCk7XG4gICAgICBjaGFycyA9IGNoYXJzLnNldChzbGljZVN0YXJ0LCBhZGRPclJlbW92ZSA/IENoYXJhY3Rlck1ldGFkYXRhLmFwcGx5U3R5bGUoY3VycmVudCwgaW5saW5lU3R5bGUpIDogQ2hhcmFjdGVyTWV0YWRhdGEucmVtb3ZlU3R5bGUoY3VycmVudCwgaW5saW5lU3R5bGUpKTtcbiAgICAgIHNsaWNlU3RhcnQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2suc2V0KCdjaGFyYWN0ZXJMaXN0JywgY2hhcnMpO1xuICB9KTtcblxuICByZXR1cm4gY29udGVudFN0YXRlLm1lcmdlKHtcbiAgICBibG9ja01hcDogYmxvY2tNYXAubWVyZ2UobmV3QmxvY2tzKSxcbiAgICBzZWxlY3Rpb25CZWZvcmU6IHNlbGVjdGlvblN0YXRlLFxuICAgIHNlbGVjdGlvbkFmdGVyOiBzZWxlY3Rpb25TdGF0ZVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb250ZW50U3RhdGVJbmxpbmVTdHlsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvQ29udGVudFN0YXRlSW5saW5lU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDM5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgYXBwbHlFbnRpdHlUb0NvbnRlbnRTdGF0ZVxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSW1tdXRhYmxlID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG5cbnZhciBhcHBseUVudGl0eVRvQ29udGVudEJsb2NrID0gcmVxdWlyZSgnLi9hcHBseUVudGl0eVRvQ29udGVudEJsb2NrJyk7XG5cbmZ1bmN0aW9uIGFwcGx5RW50aXR5VG9Db250ZW50U3RhdGUoY29udGVudFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSwgZW50aXR5S2V5KSB7XG4gIHZhciBibG9ja01hcCA9IGNvbnRlbnRTdGF0ZS5nZXRCbG9ja01hcCgpO1xuICB2YXIgc3RhcnRLZXkgPSBzZWxlY3Rpb25TdGF0ZS5nZXRTdGFydEtleSgpO1xuICB2YXIgc3RhcnRPZmZzZXQgPSBzZWxlY3Rpb25TdGF0ZS5nZXRTdGFydE9mZnNldCgpO1xuICB2YXIgZW5kS2V5ID0gc2VsZWN0aW9uU3RhdGUuZ2V0RW5kS2V5KCk7XG4gIHZhciBlbmRPZmZzZXQgPSBzZWxlY3Rpb25TdGF0ZS5nZXRFbmRPZmZzZXQoKTtcblxuICB2YXIgbmV3QmxvY2tzID0gYmxvY2tNYXAuc2tpcFVudGlsKGZ1bmN0aW9uIChfLCBrKSB7XG4gICAgcmV0dXJuIGsgPT09IHN0YXJ0S2V5O1xuICB9KS50YWtlVW50aWwoZnVuY3Rpb24gKF8sIGspIHtcbiAgICByZXR1cm4gayA9PT0gZW5kS2V5O1xuICB9KS50b09yZGVyZWRNYXAoKS5tZXJnZShJbW11dGFibGUuT3JkZXJlZE1hcChbW2VuZEtleSwgYmxvY2tNYXAuZ2V0KGVuZEtleSldXSkpLm1hcChmdW5jdGlvbiAoYmxvY2ssIGJsb2NrS2V5KSB7XG4gICAgdmFyIHNsaWNlU3RhcnQgPSBibG9ja0tleSA9PT0gc3RhcnRLZXkgPyBzdGFydE9mZnNldCA6IDA7XG4gICAgdmFyIHNsaWNlRW5kID0gYmxvY2tLZXkgPT09IGVuZEtleSA/IGVuZE9mZnNldCA6IGJsb2NrLmdldExlbmd0aCgpO1xuICAgIHJldHVybiBhcHBseUVudGl0eVRvQ29udGVudEJsb2NrKGJsb2NrLCBzbGljZVN0YXJ0LCBzbGljZUVuZCwgZW50aXR5S2V5KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnRTdGF0ZS5tZXJnZSh7XG4gICAgYmxvY2tNYXA6IGJsb2NrTWFwLm1lcmdlKG5ld0Jsb2NrcyksXG4gICAgc2VsZWN0aW9uQmVmb3JlOiBzZWxlY3Rpb25TdGF0ZSxcbiAgICBzZWxlY3Rpb25BZnRlcjogc2VsZWN0aW9uU3RhdGVcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHlFbnRpdHlUb0NvbnRlbnRTdGF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvYXBwbHlFbnRpdHlUb0NvbnRlbnRTdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhcHBseUVudGl0eVRvQ29udGVudEJsb2NrXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFyYWN0ZXJNZXRhZGF0YSA9IHJlcXVpcmUoJy4vQ2hhcmFjdGVyTWV0YWRhdGEnKTtcblxuZnVuY3Rpb24gYXBwbHlFbnRpdHlUb0NvbnRlbnRCbG9jayhjb250ZW50QmxvY2ssIHN0YXJ0LCBlbmQsIGVudGl0eUtleSkge1xuICB2YXIgY2hhcmFjdGVyTGlzdCA9IGNvbnRlbnRCbG9jay5nZXRDaGFyYWN0ZXJMaXN0KCk7XG4gIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgIGNoYXJhY3Rlckxpc3QgPSBjaGFyYWN0ZXJMaXN0LnNldChzdGFydCwgQ2hhcmFjdGVyTWV0YWRhdGEuYXBwbHlFbnRpdHkoY2hhcmFjdGVyTGlzdC5nZXQoc3RhcnQpLCBlbnRpdHlLZXkpKTtcbiAgICBzdGFydCsrO1xuICB9XG4gIHJldHVybiBjb250ZW50QmxvY2suc2V0KCdjaGFyYWN0ZXJMaXN0JywgY2hhcmFjdGVyTGlzdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHlFbnRpdHlUb0NvbnRlbnRCbG9jaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvYXBwbHlFbnRpdHlUb0NvbnRlbnRCbG9jay5qc1xuLy8gbW9kdWxlIGlkID0gMzkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRDaGFyYWN0ZXJSZW1vdmFsUmFuZ2VcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERyYWZ0RW50aXR5U2VnbWVudHMgPSByZXF1aXJlKCcuL0RyYWZ0RW50aXR5U2VnbWVudHMnKTtcblxudmFyIGdldFJhbmdlc0ZvckRyYWZ0RW50aXR5ID0gcmVxdWlyZSgnLi9nZXRSYW5nZXNGb3JEcmFmdEVudGl0eScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEdpdmVuIGEgU2VsZWN0aW9uU3RhdGUgYW5kIGEgcmVtb3ZhbCBkaXJlY3Rpb24sIGRldGVybWluZSB0aGUgZW50aXJlIHJhbmdlXG4gKiB0aGF0IHNob3VsZCBiZSByZW1vdmVkIGZyb20gYSBDb250ZW50U3RhdGUuIFRoaXMgaXMgYmFzZWQgb24gYW55IGVudGl0aWVzXG4gKiB3aXRoaW4gdGhlIHRhcmdldCwgd2l0aCB0aGVpciBgbXV0YWJpbGl0eWAgdmFsdWVzIHRha2VuIGludG8gYWNjb3VudC5cbiAqXG4gKiBGb3IgaW5zdGFuY2UsIGlmIHdlIGFyZSBhdHRlbXB0aW5nIHRvIHJlbW92ZSBwYXJ0IG9mIGFuIFwiaW1tdXRhYmxlXCIgZW50aXR5XG4gKiByYW5nZSwgdGhlIGVudGlyZSBlbnRpdHkgbXVzdCBiZSByZW1vdmVkLiBUaGUgcmV0dXJuZWQgYFNlbGVjdGlvblN0YXRlYFxuICogd2lsbCBiZSBhZGp1c3RlZCBhY2NvcmRpbmdseS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyUmVtb3ZhbFJhbmdlKGVudGl0eU1hcCwgc3RhcnRCbG9jaywgZW5kQmxvY2ssIHNlbGVjdGlvblN0YXRlLCBkaXJlY3Rpb24pIHtcbiAgdmFyIHN0YXJ0ID0gc2VsZWN0aW9uU3RhdGUuZ2V0U3RhcnRPZmZzZXQoKTtcbiAgdmFyIGVuZCA9IHNlbGVjdGlvblN0YXRlLmdldEVuZE9mZnNldCgpO1xuICB2YXIgc3RhcnRFbnRpdHlLZXkgPSBzdGFydEJsb2NrLmdldEVudGl0eUF0KHN0YXJ0KTtcbiAgdmFyIGVuZEVudGl0eUtleSA9IGVuZEJsb2NrLmdldEVudGl0eUF0KGVuZCAtIDEpO1xuICBpZiAoIXN0YXJ0RW50aXR5S2V5ICYmICFlbmRFbnRpdHlLZXkpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uU3RhdGU7XG4gIH1cbiAgdmFyIG5ld1NlbGVjdGlvblN0YXRlID0gc2VsZWN0aW9uU3RhdGU7XG4gIGlmIChzdGFydEVudGl0eUtleSAmJiBzdGFydEVudGl0eUtleSA9PT0gZW5kRW50aXR5S2V5KSB7XG4gICAgbmV3U2VsZWN0aW9uU3RhdGUgPSBnZXRFbnRpdHlSZW1vdmFsUmFuZ2UoZW50aXR5TWFwLCBzdGFydEJsb2NrLCBuZXdTZWxlY3Rpb25TdGF0ZSwgZGlyZWN0aW9uLCBzdGFydEVudGl0eUtleSwgdHJ1ZSwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAoc3RhcnRFbnRpdHlLZXkgJiYgZW5kRW50aXR5S2V5KSB7XG4gICAgdmFyIHN0YXJ0U2VsZWN0aW9uU3RhdGUgPSBnZXRFbnRpdHlSZW1vdmFsUmFuZ2UoZW50aXR5TWFwLCBzdGFydEJsb2NrLCBuZXdTZWxlY3Rpb25TdGF0ZSwgZGlyZWN0aW9uLCBzdGFydEVudGl0eUtleSwgZmFsc2UsIHRydWUpO1xuICAgIHZhciBlbmRTZWxlY3Rpb25TdGF0ZSA9IGdldEVudGl0eVJlbW92YWxSYW5nZShlbnRpdHlNYXAsIGVuZEJsb2NrLCBuZXdTZWxlY3Rpb25TdGF0ZSwgZGlyZWN0aW9uLCBlbmRFbnRpdHlLZXksIGZhbHNlLCBmYWxzZSk7XG4gICAgbmV3U2VsZWN0aW9uU3RhdGUgPSBuZXdTZWxlY3Rpb25TdGF0ZS5tZXJnZSh7XG4gICAgICBhbmNob3JPZmZzZXQ6IHN0YXJ0U2VsZWN0aW9uU3RhdGUuZ2V0QW5jaG9yT2Zmc2V0KCksXG4gICAgICBmb2N1c09mZnNldDogZW5kU2VsZWN0aW9uU3RhdGUuZ2V0Rm9jdXNPZmZzZXQoKSxcbiAgICAgIGlzQmFja3dhcmQ6IGZhbHNlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc3RhcnRFbnRpdHlLZXkpIHtcbiAgICB2YXIgX3N0YXJ0U2VsZWN0aW9uU3RhdGUgPSBnZXRFbnRpdHlSZW1vdmFsUmFuZ2UoZW50aXR5TWFwLCBzdGFydEJsb2NrLCBuZXdTZWxlY3Rpb25TdGF0ZSwgZGlyZWN0aW9uLCBzdGFydEVudGl0eUtleSwgZmFsc2UsIHRydWUpO1xuICAgIG5ld1NlbGVjdGlvblN0YXRlID0gbmV3U2VsZWN0aW9uU3RhdGUubWVyZ2Uoe1xuICAgICAgYW5jaG9yT2Zmc2V0OiBfc3RhcnRTZWxlY3Rpb25TdGF0ZS5nZXRTdGFydE9mZnNldCgpLFxuICAgICAgaXNCYWNrd2FyZDogZmFsc2VcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChlbmRFbnRpdHlLZXkpIHtcbiAgICB2YXIgX2VuZFNlbGVjdGlvblN0YXRlID0gZ2V0RW50aXR5UmVtb3ZhbFJhbmdlKGVudGl0eU1hcCwgZW5kQmxvY2ssIG5ld1NlbGVjdGlvblN0YXRlLCBkaXJlY3Rpb24sIGVuZEVudGl0eUtleSwgZmFsc2UsIGZhbHNlKTtcbiAgICBuZXdTZWxlY3Rpb25TdGF0ZSA9IG5ld1NlbGVjdGlvblN0YXRlLm1lcmdlKHtcbiAgICAgIGZvY3VzT2Zmc2V0OiBfZW5kU2VsZWN0aW9uU3RhdGUuZ2V0RW5kT2Zmc2V0KCksXG4gICAgICBpc0JhY2t3YXJkOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXdTZWxlY3Rpb25TdGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RW50aXR5UmVtb3ZhbFJhbmdlKGVudGl0eU1hcCwgYmxvY2ssIHNlbGVjdGlvblN0YXRlLCBkaXJlY3Rpb24sIGVudGl0eUtleSwgaXNFbnRpcmVTZWxlY3Rpb25XaXRoaW5FbnRpdHksIGlzRW50aXR5QXRTdGFydCkge1xuICB2YXIgc3RhcnQgPSBzZWxlY3Rpb25TdGF0ZS5nZXRTdGFydE9mZnNldCgpO1xuICB2YXIgZW5kID0gc2VsZWN0aW9uU3RhdGUuZ2V0RW5kT2Zmc2V0KCk7XG4gIHZhciBlbnRpdHkgPSBlbnRpdHlNYXAuX19nZXQoZW50aXR5S2V5KTtcbiAgdmFyIG11dGFiaWxpdHkgPSBlbnRpdHkuZ2V0TXV0YWJpbGl0eSgpO1xuICB2YXIgc2lkZVRvQ29uc2lkZXIgPSBpc0VudGl0eUF0U3RhcnQgPyBzdGFydCA6IGVuZDtcblxuICAvLyBgTVVUQUJMRWAgZW50aXRpZXMgY2FuIGp1c3QgaGF2ZSB0aGUgc3BlY2lmaWVkIHJhbmdlIG9mIHRleHQgcmVtb3ZlZFxuICAvLyBkaXJlY3RseS4gTm8gYWRqdXN0bWVudHMgYXJlIG5lZWRlZC5cbiAgaWYgKG11dGFiaWxpdHkgPT09ICdNVVRBQkxFJykge1xuICAgIHJldHVybiBzZWxlY3Rpb25TdGF0ZTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGVudGl0eSByYW5nZSB0aGF0IG92ZXJsYXBzIHdpdGggb3VyIHJlbW92YWwgcmFuZ2UuXG4gIHZhciBlbnRpdHlSYW5nZXMgPSBnZXRSYW5nZXNGb3JEcmFmdEVudGl0eShibG9jaywgZW50aXR5S2V5KS5maWx0ZXIoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgcmV0dXJuIHNpZGVUb0NvbnNpZGVyIDw9IHJhbmdlLmVuZCAmJiBzaWRlVG9Db25zaWRlciA+PSByYW5nZS5zdGFydDtcbiAgfSk7XG5cbiAgIShlbnRpdHlSYW5nZXMubGVuZ3RoID09IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBlbnRpdHkgcmFuZ2Ugd2l0aGluIHRoaXMgcmVtb3ZhbCByYW5nZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgdmFyIGVudGl0eVJhbmdlID0gZW50aXR5UmFuZ2VzWzBdO1xuXG4gIC8vIEZvciBgSU1NVVRBQkxFYCBlbnRpdHkgdHlwZXMsIHdlIHdpbGwgcmVtb3ZlIHRoZSBlbnRpcmUgZW50aXR5IHJhbmdlLlxuICBpZiAobXV0YWJpbGl0eSA9PT0gJ0lNTVVUQUJMRScpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uU3RhdGUubWVyZ2Uoe1xuICAgICAgYW5jaG9yT2Zmc2V0OiBlbnRpdHlSYW5nZS5zdGFydCxcbiAgICAgIGZvY3VzT2Zmc2V0OiBlbnRpdHlSYW5nZS5lbmQsXG4gICAgICBpc0JhY2t3YXJkOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gRm9yIGBTRUdNRU5URURgIGVudGl0eSB0eXBlcywgZGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBzZWdtZW50IHRvXG4gIC8vIHJlbW92ZS5cbiAgaWYgKCFpc0VudGlyZVNlbGVjdGlvbldpdGhpbkVudGl0eSkge1xuICAgIGlmIChpc0VudGl0eUF0U3RhcnQpIHtcbiAgICAgIGVuZCA9IGVudGl0eVJhbmdlLmVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBlbnRpdHlSYW5nZS5zdGFydDtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVtb3ZhbFJhbmdlID0gRHJhZnRFbnRpdHlTZWdtZW50cy5nZXRSZW1vdmFsUmFuZ2Uoc3RhcnQsIGVuZCwgYmxvY2suZ2V0VGV4dCgpLnNsaWNlKGVudGl0eVJhbmdlLnN0YXJ0LCBlbnRpdHlSYW5nZS5lbmQpLCBlbnRpdHlSYW5nZS5zdGFydCwgZGlyZWN0aW9uKTtcblxuICByZXR1cm4gc2VsZWN0aW9uU3RhdGUubWVyZ2Uoe1xuICAgIGFuY2hvck9mZnNldDogcmVtb3ZhbFJhbmdlLnN0YXJ0LFxuICAgIGZvY3VzT2Zmc2V0OiByZW1vdmFsUmFuZ2UuZW5kLFxuICAgIGlzQmFja3dhcmQ6IGZhbHNlXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldENoYXJhY3RlclJlbW92YWxSYW5nZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZ2V0Q2hhcmFjdGVyUmVtb3ZhbFJhbmdlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERyYWZ0RW50aXR5U2VnbWVudHNcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBJZGVudGlmeSB0aGUgcmFuZ2UgdG8gZGVsZXRlIGZyb20gYSBzZWdtZW50ZWQgZW50aXR5LlxuICpcbiAqIFJ1bGVzOlxuICpcbiAqICBFeGFtcGxlOiAnSm9obiBGLiBLZW5uZWR5J1xuICpcbiAqICAgLSBEZWxldGlvbiBmcm9tIHdpdGhpbiBhbnkgbm9uLXdoaXRlc3BhY2UgKGkuZS4gWydKb2huJywgJ0YuJywgJ0tlbm5lZHknXSlcbiAqICAgICB3aWxsIHJldHVybiB0aGUgcmFuZ2Ugb2YgdGhhdCB0ZXh0LlxuICpcbiAqICAgICAgICdKb2huIEYuIEtlbm5lZHknIC0+ICdKb2huIEYuJ1xuICogICAgICAgICAgICAgICAgICBeXG4gKlxuICogICAtIEZvcndhcmQgZGVsZXRpb24gb2Ygd2hpdGVzcGFjZSB3aWxsIHJlbW92ZSB0aGUgZm9sbG93aW5nIHNlY3Rpb246XG4gKlxuICogICAgICAgJ0pvaG4gRi4gS2VubmVkeScgLT4gJ0pvaG4gS2VubmVkeSdcbiAqICAgICAgICAgICAgXlxuICpcbiAqICAgLSBCYWNrd2FyZCBkZWxldGlvbiBvZiB3aGl0ZXNwYWNlIHdpbGwgcmVtb3ZlIHRoZSBwcmV2aW91cyBzZWN0aW9uOlxuICpcbiAqICAgICAgICdKb2huIEYuIEtlbm5lZHknIC0+ICdGLiBLZW5uZWR5J1xuICogICAgICAgICAgICBeXG4gKi9cbnZhciBEcmFmdEVudGl0eVNlZ21lbnRzID0ge1xuICBnZXRSZW1vdmFsUmFuZ2U6IGZ1bmN0aW9uIGdldFJlbW92YWxSYW5nZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kLCB0ZXh0LCBlbnRpdHlTdGFydCwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gdGV4dC5zcGxpdCgnICcpO1xuICAgIHNlZ21lbnRzID0gc2VnbWVudHMubWFwKGZ1bmN0aW9uICggLypzdHJpbmcqL3NlZ21lbnQsIC8qbnVtYmVyKi9paSkge1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgIGlmIChpaSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gJyAnICsgc2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpaSA8IHNlZ21lbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnQgKyAnICc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VnbWVudDtcbiAgICB9KTtcblxuICAgIHZhciBzZWdtZW50U3RhcnQgPSBlbnRpdHlTdGFydDtcbiAgICB2YXIgc2VnbWVudEVuZDtcbiAgICB2YXIgc2VnbWVudDtcbiAgICB2YXIgcmVtb3ZhbFN0YXJ0ID0gbnVsbDtcbiAgICB2YXIgcmVtb3ZhbEVuZCA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBqaiA9IDA7IGpqIDwgc2VnbWVudHMubGVuZ3RoOyBqaisrKSB7XG4gICAgICBzZWdtZW50ID0gc2VnbWVudHNbampdO1xuICAgICAgc2VnbWVudEVuZCA9IHNlZ21lbnRTdGFydCArIHNlZ21lbnQubGVuZ3RoO1xuXG4gICAgICAvLyBPdXIgc2VsZWN0aW9uIG92ZXJsYXBzIHRoaXMgc2VnbWVudC5cbiAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA8IHNlZ21lbnRFbmQgJiYgc2VnbWVudFN0YXJ0IDwgc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIGlmIChyZW1vdmFsU3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICByZW1vdmFsRW5kID0gc2VnbWVudEVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmFsU3RhcnQgPSBzZWdtZW50U3RhcnQ7XG4gICAgICAgICAgcmVtb3ZhbEVuZCA9IHNlZ21lbnRFbmQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVtb3ZhbFN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzZWdtZW50U3RhcnQgPSBzZWdtZW50RW5kO1xuICAgIH1cblxuICAgIHZhciBlbnRpdHlFbmQgPSBlbnRpdHlTdGFydCArIHRleHQubGVuZ3RoO1xuICAgIHZhciBhdFN0YXJ0ID0gcmVtb3ZhbFN0YXJ0ID09PSBlbnRpdHlTdGFydDtcbiAgICB2YXIgYXRFbmQgPSByZW1vdmFsRW5kID09PSBlbnRpdHlFbmQ7XG5cbiAgICBpZiAoIWF0U3RhcnQgJiYgYXRFbmQgfHwgYXRTdGFydCAmJiAhYXRFbmQpIHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgICBpZiAocmVtb3ZhbEVuZCAhPT0gZW50aXR5RW5kKSB7XG4gICAgICAgICAgcmVtb3ZhbEVuZCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlbW92YWxTdGFydCAhPT0gZW50aXR5U3RhcnQpIHtcbiAgICAgICAgcmVtb3ZhbFN0YXJ0LS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiByZW1vdmFsU3RhcnQsXG4gICAgICBlbmQ6IHJlbW92YWxFbmRcbiAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWZ0RW50aXR5U2VnbWVudHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0RW50aXR5U2VnbWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDM5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0UmFuZ2VzRm9yRHJhZnRFbnRpdHlcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIE9idGFpbiB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgb2YgdGhlIHJhbmdlIHRoYXQgaGFzIHRoZVxuICogc3BlY2lmaWVkIGVudGl0eSBhcHBsaWVkIHRvIGl0LlxuICpcbiAqIEVudGl0eSBrZXlzIGFyZSBhcHBsaWVkIG9ubHkgdG8gY29udGlndW91cyBzdHJldGNoZXMgb2YgdGV4dCwgc28gdGhpc1xuICogbWV0aG9kIHNlYXJjaGVzIGZvciB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhlIGVudGl0eSBrZXkgYW5kIHJldHVybnNcbiAqIHRoZSBzdWJzZXF1ZW50IHJhbmdlLlxuICovXG5mdW5jdGlvbiBnZXRSYW5nZXNGb3JEcmFmdEVudGl0eShibG9jaywga2V5KSB7XG4gIHZhciByYW5nZXMgPSBbXTtcbiAgYmxvY2suZmluZEVudGl0eVJhbmdlcyhmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiBjLmdldEVudGl0eSgpID09PSBrZXk7XG4gIH0sIGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgcmFuZ2VzLnB1c2goeyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH0pO1xuICB9KTtcblxuICAhISFyYW5nZXMubGVuZ3RoID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VudGl0eSBrZXkgbm90IGZvdW5kIGluIHRoaXMgcmFuZ2UuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIHJldHVybiByYW5nZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmFuZ2VzRm9yRHJhZnRFbnRpdHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2dldFJhbmdlc0ZvckRyYWZ0RW50aXR5LmpzXG4vLyBtb2R1bGUgaWQgPSAzOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGluc2VydEZyYWdtZW50SW50b0NvbnRlbnRTdGF0ZVxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmxvY2tNYXBCdWlsZGVyID0gcmVxdWlyZSgnLi9CbG9ja01hcEJ1aWxkZXInKTtcbnZhciBDb250ZW50QmxvY2tOb2RlID0gcmVxdWlyZSgnLi9Db250ZW50QmxvY2tOb2RlJyk7XG52YXIgSW1tdXRhYmxlID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG5cbnZhciBpbnNlcnRJbnRvTGlzdCA9IHJlcXVpcmUoJy4vaW5zZXJ0SW50b0xpc3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciByYW5kb21pemVCbG9ja01hcEtleXMgPSByZXF1aXJlKCcuL3JhbmRvbWl6ZUJsb2NrTWFwS2V5cycpO1xuXG52YXIgTGlzdCA9IEltbXV0YWJsZS5MaXN0O1xuXG5cbnZhciB1cGRhdGVFeGlzdGluZ0Jsb2NrID0gZnVuY3Rpb24gdXBkYXRlRXhpc3RpbmdCbG9jayhjb250ZW50U3RhdGUsIHNlbGVjdGlvblN0YXRlLCBibG9ja01hcCwgZnJhZ21lbnRCbG9jaywgdGFyZ2V0S2V5LCB0YXJnZXRPZmZzZXQpIHtcbiAgdmFyIHRhcmdldEJsb2NrID0gYmxvY2tNYXAuZ2V0KHRhcmdldEtleSk7XG4gIHZhciB0ZXh0ID0gdGFyZ2V0QmxvY2suZ2V0VGV4dCgpO1xuICB2YXIgY2hhcnMgPSB0YXJnZXRCbG9jay5nZXRDaGFyYWN0ZXJMaXN0KCk7XG4gIHZhciBmaW5hbEtleSA9IHRhcmdldEtleTtcbiAgdmFyIGZpbmFsT2Zmc2V0ID0gdGFyZ2V0T2Zmc2V0ICsgZnJhZ21lbnRCbG9jay5nZXRUZXh0KCkubGVuZ3RoO1xuXG4gIHZhciBuZXdCbG9jayA9IHRhcmdldEJsb2NrLm1lcmdlKHtcbiAgICB0ZXh0OiB0ZXh0LnNsaWNlKDAsIHRhcmdldE9mZnNldCkgKyBmcmFnbWVudEJsb2NrLmdldFRleHQoKSArIHRleHQuc2xpY2UodGFyZ2V0T2Zmc2V0KSxcbiAgICBjaGFyYWN0ZXJMaXN0OiBpbnNlcnRJbnRvTGlzdChjaGFycywgZnJhZ21lbnRCbG9jay5nZXRDaGFyYWN0ZXJMaXN0KCksIHRhcmdldE9mZnNldCksXG4gICAgZGF0YTogZnJhZ21lbnRCbG9jay5nZXREYXRhKClcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnRTdGF0ZS5tZXJnZSh7XG4gICAgYmxvY2tNYXA6IGJsb2NrTWFwLnNldCh0YXJnZXRLZXksIG5ld0Jsb2NrKSxcbiAgICBzZWxlY3Rpb25CZWZvcmU6IHNlbGVjdGlvblN0YXRlLFxuICAgIHNlbGVjdGlvbkFmdGVyOiBzZWxlY3Rpb25TdGF0ZS5tZXJnZSh7XG4gICAgICBhbmNob3JLZXk6IGZpbmFsS2V5LFxuICAgICAgYW5jaG9yT2Zmc2V0OiBmaW5hbE9mZnNldCxcbiAgICAgIGZvY3VzS2V5OiBmaW5hbEtleSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBmaW5hbE9mZnNldCxcbiAgICAgIGlzQmFja3dhcmQ6IGZhbHNlXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgdGV4dC9jaGFyYWN0ZXJMaXN0IGZyb20gdGhlIGZyYWdtZW50IGZpcnN0IGJsb2NrIHRvXG4gKiB0YXJnZXQgYmxvY2suXG4gKi9cbnZhciB1cGRhdGVIZWFkID0gZnVuY3Rpb24gdXBkYXRlSGVhZChibG9jaywgdGFyZ2V0T2Zmc2V0LCBmcmFnbWVudCkge1xuICB2YXIgdGV4dCA9IGJsb2NrLmdldFRleHQoKTtcbiAgdmFyIGNoYXJzID0gYmxvY2suZ2V0Q2hhcmFjdGVyTGlzdCgpO1xuXG4gIC8vIE1vZGlmeSBoZWFkIHBvcnRpb24gb2YgYmxvY2suXG4gIHZhciBoZWFkVGV4dCA9IHRleHQuc2xpY2UoMCwgdGFyZ2V0T2Zmc2V0KTtcbiAgdmFyIGhlYWRDaGFyYWN0ZXJzID0gY2hhcnMuc2xpY2UoMCwgdGFyZ2V0T2Zmc2V0KTtcbiAgdmFyIGFwcGVuZFRvSGVhZCA9IGZyYWdtZW50LmZpcnN0KCk7XG5cbiAgcmV0dXJuIGJsb2NrLm1lcmdlKHtcbiAgICB0ZXh0OiBoZWFkVGV4dCArIGFwcGVuZFRvSGVhZC5nZXRUZXh0KCksXG4gICAgY2hhcmFjdGVyTGlzdDogaGVhZENoYXJhY3RlcnMuY29uY2F0KGFwcGVuZFRvSGVhZC5nZXRDaGFyYWN0ZXJMaXN0KCkpLFxuICAgIHR5cGU6IGhlYWRUZXh0ID8gYmxvY2suZ2V0VHlwZSgpIDogYXBwZW5kVG9IZWFkLmdldFR5cGUoKSxcbiAgICBkYXRhOiBhcHBlbmRUb0hlYWQuZ2V0RGF0YSgpXG4gIH0pO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIG9mZnNldCB0ZXh0L2NoYXJhY3Rlckxpc3QgZnJvbSB0aGUgdGFyZ2V0IGJsb2NrIHRvIHRoZSBsYXN0XG4gKiBmcmFnbWVudCBibG9jay5cbiAqL1xudmFyIHVwZGF0ZVRhaWwgPSBmdW5jdGlvbiB1cGRhdGVUYWlsKGJsb2NrLCB0YXJnZXRPZmZzZXQsIGZyYWdtZW50KSB7XG4gIC8vIE1vZGlmeSB0YWlsIHBvcnRpb24gb2YgYmxvY2suXG4gIHZhciB0ZXh0ID0gYmxvY2suZ2V0VGV4dCgpO1xuICB2YXIgY2hhcnMgPSBibG9jay5nZXRDaGFyYWN0ZXJMaXN0KCk7XG5cbiAgLy8gTW9kaWZ5IGhlYWQgcG9ydGlvbiBvZiBibG9jay5cbiAgdmFyIGJsb2NrU2l6ZSA9IHRleHQubGVuZ3RoO1xuICB2YXIgdGFpbFRleHQgPSB0ZXh0LnNsaWNlKHRhcmdldE9mZnNldCwgYmxvY2tTaXplKTtcbiAgdmFyIHRhaWxDaGFyYWN0ZXJzID0gY2hhcnMuc2xpY2UodGFyZ2V0T2Zmc2V0LCBibG9ja1NpemUpO1xuICB2YXIgcHJlcGVuZFRvVGFpbCA9IGZyYWdtZW50Lmxhc3QoKTtcblxuICByZXR1cm4gcHJlcGVuZFRvVGFpbC5tZXJnZSh7XG4gICAgdGV4dDogcHJlcGVuZFRvVGFpbC5nZXRUZXh0KCkgKyB0YWlsVGV4dCxcbiAgICBjaGFyYWN0ZXJMaXN0OiBwcmVwZW5kVG9UYWlsLmdldENoYXJhY3Rlckxpc3QoKS5jb25jYXQodGFpbENoYXJhY3RlcnMpLFxuICAgIGRhdGE6IHByZXBlbmRUb1RhaWwuZ2V0RGF0YSgpXG4gIH0pO1xufTtcblxudmFyIGdldFJvb3RCbG9ja3MgPSBmdW5jdGlvbiBnZXRSb290QmxvY2tzKGJsb2NrLCBibG9ja01hcCkge1xuICB2YXIgaGVhZEtleSA9IGJsb2NrLmdldEtleSgpO1xuICB2YXIgcm9vdEJsb2NrID0gYmxvY2s7XG4gIHZhciByb290QmxvY2tzID0gW107XG5cbiAgLy8gc29tZXRpbWVzIHRoZSBmcmFnbWVudCBoZWFkIGJsb2NrIHdpbGwgbm90IGJlIHBhcnQgb2YgdGhlIGJsb2NrTWFwIGl0c2VsZiB0aGlzIGNhbiBoYXBwZW4gd2hlblxuICAvLyB0aGUgZnJhZ21lbnQgaGVhZCBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgdGFyZ2V0IGJsb2NrLCBob3dldmVyIHdoZW4gdGhpcyBkb2VzIG5vdCBoYXBwZW4gd2UgbmVlZFxuICAvLyB0byBtYWtlIHN1cmUgdGhhdCB3ZSBpbmNsdWRlIGl0IG9uIHRoZSByb290QmxvY2tzIHNpbmNlIHRoZSBmaXJzdCBibG9jayBvZiBhIGZyYWdtZW50IGlzIGFsd2F5cyBhXG4gIC8vIGZyYWdtZW50IHJvb3QgYmxvY2tcbiAgaWYgKGJsb2NrTWFwLmdldChoZWFkS2V5KSkge1xuICAgIHJvb3RCbG9ja3MucHVzaChoZWFkS2V5KTtcbiAgfVxuXG4gIHdoaWxlIChyb290QmxvY2sgJiYgcm9vdEJsb2NrLmdldE5leHRTaWJsaW5nS2V5KCkpIHtcbiAgICB2YXIgbGFzdFNpYmxpbmdLZXkgPSByb290QmxvY2suZ2V0TmV4dFNpYmxpbmdLZXkoKTtcblxuICAgIGlmICghbGFzdFNpYmxpbmdLZXkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJvb3RCbG9ja3MucHVzaChsYXN0U2libGluZ0tleSk7XG4gICAgcm9vdEJsb2NrID0gYmxvY2tNYXAuZ2V0KGxhc3RTaWJsaW5nS2V5KTtcbiAgfVxuXG4gIHJldHVybiByb290QmxvY2tzO1xufTtcblxudmFyIHVwZGF0ZUJsb2NrTWFwTGlua3MgPSBmdW5jdGlvbiB1cGRhdGVCbG9ja01hcExpbmtzKGJsb2NrTWFwLCBvcmlnaW5hbEJsb2NrTWFwLCB0YXJnZXRCbG9jaywgZnJhZ21lbnRIZWFkQmxvY2spIHtcbiAgcmV0dXJuIGJsb2NrTWFwLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGJsb2NrTWFwU3RhdGUpIHtcbiAgICB2YXIgdGFyZ2V0S2V5ID0gdGFyZ2V0QmxvY2suZ2V0S2V5KCk7XG4gICAgdmFyIGhlYWRLZXkgPSBmcmFnbWVudEhlYWRCbG9jay5nZXRLZXkoKTtcbiAgICB2YXIgdGFyZ2V0TmV4dEtleSA9IHRhcmdldEJsb2NrLmdldE5leHRTaWJsaW5nS2V5KCk7XG4gICAgdmFyIHRhcmdldFBhcmVudEtleSA9IHRhcmdldEJsb2NrLmdldFBhcmVudEtleSgpO1xuICAgIHZhciBmcmFnbWVudFJvb3RCbG9ja3MgPSBnZXRSb290QmxvY2tzKGZyYWdtZW50SGVhZEJsb2NrLCBibG9ja01hcCk7XG4gICAgdmFyIGxhc3RSb290RnJhZ21lbnRCbG9ja0tleSA9IGZyYWdtZW50Um9vdEJsb2Nrc1tmcmFnbWVudFJvb3RCbG9ja3MubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoYmxvY2tNYXBTdGF0ZS5nZXQoaGVhZEtleSkpIHtcbiAgICAgIC8vIHVwZGF0ZSB0aGUgZnJhZ21lbnQgaGVhZCB3aGVuIGl0IGlzIHBhcnQgb2YgdGhlIGJsb2NrTWFwIG90aGVyd2lzZVxuICAgICAgYmxvY2tNYXBTdGF0ZS5zZXRJbihbdGFyZ2V0S2V5LCAnbmV4dFNpYmxpbmcnXSwgaGVhZEtleSk7XG4gICAgICBibG9ja01hcFN0YXRlLnNldEluKFtoZWFkS2V5LCAncHJldlNpYmxpbmcnXSwgdGFyZ2V0S2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlIHRoZSB0YXJnZXQgYmxvY2sgdGhhdCBoYWQgdGhlIGZyYWdtZW50IGhlYWQgY29udGVudHMgbWVyZ2VkIGludG8gaXRcbiAgICAgIGJsb2NrTWFwU3RhdGUuc2V0SW4oW3RhcmdldEtleSwgJ25leHRTaWJsaW5nJ10sIGZyYWdtZW50SGVhZEJsb2NrLmdldE5leHRTaWJsaW5nS2V5KCkpO1xuICAgICAgYmxvY2tNYXBTdGF0ZS5zZXRJbihbZnJhZ21lbnRIZWFkQmxvY2suZ2V0TmV4dFNpYmxpbmdLZXkoKSwgJ3ByZXZTaWJsaW5nJ10sIHRhcmdldEtleSk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSBsYXN0IHJvb3QgYmxvY2sgZnJhZ21lbnRcbiAgICBibG9ja01hcFN0YXRlLnNldEluKFtsYXN0Um9vdEZyYWdtZW50QmxvY2tLZXksICduZXh0U2libGluZyddLCB0YXJnZXROZXh0S2V5KTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgb3JpZ2luYWwgdGFyZ2V0IG5leHQgYmxvY2tcbiAgICBpZiAodGFyZ2V0TmV4dEtleSkge1xuICAgICAgYmxvY2tNYXBTdGF0ZS5zZXRJbihbdGFyZ2V0TmV4dEtleSwgJ3ByZXZTaWJsaW5nJ10sIGxhc3RSb290RnJhZ21lbnRCbG9ja0tleSk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGZyYWdtZW50IHBhcmVudCBsaW5rc1xuICAgIGZyYWdtZW50Um9vdEJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9ja0tleSkge1xuICAgICAgcmV0dXJuIGJsb2NrTWFwU3RhdGUuc2V0SW4oW2Jsb2NrS2V5LCAncGFyZW50J10sIHRhcmdldFBhcmVudEtleSk7XG4gICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgdGFyZ2V0QmxvY2sgcGFyZW50IGNoaWxkIGxpbmtzXG4gICAgaWYgKHRhcmdldFBhcmVudEtleSkge1xuICAgICAgdmFyIHRhcmdldFBhcmVudCA9IGJsb2NrTWFwLmdldCh0YXJnZXRQYXJlbnRLZXkpO1xuICAgICAgdmFyIG9yaWdpbmFsVGFyZ2V0UGFyZW50Q2hpbGRLZXlzID0gdGFyZ2V0UGFyZW50LmdldENoaWxkS2V5cygpO1xuXG4gICAgICB2YXIgdGFyZ2V0QmxvY2tJbmRleCA9IG9yaWdpbmFsVGFyZ2V0UGFyZW50Q2hpbGRLZXlzLmluZGV4T2YodGFyZ2V0S2V5KTtcbiAgICAgIHZhciBpbnNlcnRpb25JbmRleCA9IHRhcmdldEJsb2NrSW5kZXggKyAxO1xuXG4gICAgICB2YXIgbmV3Q2hpbGRyZW5LZXlzQXJyYXkgPSBvcmlnaW5hbFRhcmdldFBhcmVudENoaWxkS2V5cy50b0FycmF5KCk7XG5cbiAgICAgIC8vIGluc2VydCBmcmFnbWVudCBjaGlsZHJlblxuICAgICAgbmV3Q2hpbGRyZW5LZXlzQXJyYXkuc3BsaWNlLmFwcGx5KG5ld0NoaWxkcmVuS2V5c0FycmF5LCBbaW5zZXJ0aW9uSW5kZXgsIDBdLmNvbmNhdChmcmFnbWVudFJvb3RCbG9ja3MpKTtcblxuICAgICAgYmxvY2tNYXBTdGF0ZS5zZXRJbihbdGFyZ2V0UGFyZW50S2V5LCAnY2hpbGRyZW4nXSwgTGlzdChuZXdDaGlsZHJlbktleXNBcnJheSkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgaW5zZXJ0RnJhZ21lbnQgPSBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudChjb250ZW50U3RhdGUsIHNlbGVjdGlvblN0YXRlLCBibG9ja01hcCwgZnJhZ21lbnQsIHRhcmdldEtleSwgdGFyZ2V0T2Zmc2V0KSB7XG4gIHZhciBpc1RyZWVCYXNlZEJsb2NrTWFwID0gYmxvY2tNYXAuZmlyc3QoKSBpbnN0YW5jZW9mIENvbnRlbnRCbG9ja05vZGU7XG4gIHZhciBuZXdCbG9ja0FyciA9IFtdO1xuICB2YXIgZnJhZ21lbnRTaXplID0gZnJhZ21lbnQuc2l6ZTtcbiAgdmFyIHRhcmdldCA9IGJsb2NrTWFwLmdldCh0YXJnZXRLZXkpO1xuICB2YXIgaGVhZCA9IGZyYWdtZW50LmZpcnN0KCk7XG4gIHZhciB0YWlsID0gZnJhZ21lbnQubGFzdCgpO1xuICB2YXIgZmluYWxPZmZzZXQgPSB0YWlsLmdldExlbmd0aCgpO1xuICB2YXIgZmluYWxLZXkgPSB0YWlsLmdldEtleSgpO1xuICB2YXIgc2hvdWxkTm90VXBkYXRlRnJvbUZyYWdtZW50QmxvY2sgPSBpc1RyZWVCYXNlZEJsb2NrTWFwICYmICghdGFyZ2V0LmdldENoaWxkS2V5cygpLmlzRW1wdHkoKSB8fCAhaGVhZC5nZXRDaGlsZEtleXMoKS5pc0VtcHR5KCkpO1xuXG4gIGJsb2NrTWFwLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrLCBibG9ja0tleSkge1xuICAgIGlmIChibG9ja0tleSAhPT0gdGFyZ2V0S2V5KSB7XG4gICAgICBuZXdCbG9ja0Fyci5wdXNoKGJsb2NrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkTm90VXBkYXRlRnJvbUZyYWdtZW50QmxvY2spIHtcbiAgICAgIG5ld0Jsb2NrQXJyLnB1c2goYmxvY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdCbG9ja0Fyci5wdXNoKHVwZGF0ZUhlYWQoYmxvY2ssIHRhcmdldE9mZnNldCwgZnJhZ21lbnQpKTtcbiAgICB9XG5cbiAgICAvLyBJbnNlcnQgZnJhZ21lbnQgYmxvY2tzIGFmdGVyIHRoZSBoZWFkIGFuZCBiZWZvcmUgdGhlIHRhaWwuXG4gICAgZnJhZ21lbnRcbiAgICAvLyB3aGVuIHdlIGFyZSB1cGRhdGluZyB0aGUgdGFyZ2V0IGJsb2NrIHdpdGggdGhlIGhlYWQgZnJhZ21lbnQgYmxvY2sgd2Ugc2tpcCB0aGUgZmlyc3QgZnJhZ21lbnRcbiAgICAvLyBoZWFkIHNpbmNlIGl0cyBjb250ZW50cyBoYXZlIGFscmVhZHkgYmVlbiBtZXJnZWQgd2l0aCB0aGUgdGFyZ2V0IGJsb2NrIG90aGVyd2lzZSB3ZSBpbmNsdWRlXG4gICAgLy8gdGhlIHdob2xlIGZyYWdtZW50XG4gICAgLnNsaWNlKHNob3VsZE5vdFVwZGF0ZUZyb21GcmFnbWVudEJsb2NrID8gMCA6IDEsIGZyYWdtZW50U2l6ZSAtIDEpLmZvckVhY2goZnVuY3Rpb24gKGZyYWdtZW50QmxvY2spIHtcbiAgICAgIHJldHVybiBuZXdCbG9ja0Fyci5wdXNoKGZyYWdtZW50QmxvY2spO1xuICAgIH0pO1xuXG4gICAgLy8gdXBkYXRlIHRhaWxcbiAgICBuZXdCbG9ja0Fyci5wdXNoKHVwZGF0ZVRhaWwoYmxvY2ssIHRhcmdldE9mZnNldCwgZnJhZ21lbnQpKTtcbiAgfSk7XG5cbiAgdmFyIHVwZGF0ZWRCbG9ja01hcCA9IEJsb2NrTWFwQnVpbGRlci5jcmVhdGVGcm9tQXJyYXkobmV3QmxvY2tBcnIpO1xuXG4gIGlmIChpc1RyZWVCYXNlZEJsb2NrTWFwKSB7XG4gICAgdXBkYXRlZEJsb2NrTWFwID0gdXBkYXRlQmxvY2tNYXBMaW5rcyh1cGRhdGVkQmxvY2tNYXAsIGJsb2NrTWFwLCB0YXJnZXQsIGhlYWQpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnRTdGF0ZS5tZXJnZSh7XG4gICAgYmxvY2tNYXA6IHVwZGF0ZWRCbG9ja01hcCxcbiAgICBzZWxlY3Rpb25CZWZvcmU6IHNlbGVjdGlvblN0YXRlLFxuICAgIHNlbGVjdGlvbkFmdGVyOiBzZWxlY3Rpb25TdGF0ZS5tZXJnZSh7XG4gICAgICBhbmNob3JLZXk6IGZpbmFsS2V5LFxuICAgICAgYW5jaG9yT2Zmc2V0OiBmaW5hbE9mZnNldCxcbiAgICAgIGZvY3VzS2V5OiBmaW5hbEtleSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBmaW5hbE9mZnNldCxcbiAgICAgIGlzQmFja3dhcmQ6IGZhbHNlXG4gICAgfSlcbiAgfSk7XG59O1xuXG52YXIgaW5zZXJ0RnJhZ21lbnRJbnRvQ29udGVudFN0YXRlID0gZnVuY3Rpb24gaW5zZXJ0RnJhZ21lbnRJbnRvQ29udGVudFN0YXRlKGNvbnRlbnRTdGF0ZSwgc2VsZWN0aW9uU3RhdGUsIGZyYWdtZW50QmxvY2tNYXApIHtcbiAgIXNlbGVjdGlvblN0YXRlLmlzQ29sbGFwc2VkKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYGluc2VydEZyYWdtZW50YCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2l0aCBhIGNvbGxhcHNlZCBzZWxlY3Rpb24gc3RhdGUuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIHZhciBibG9ja01hcCA9IGNvbnRlbnRTdGF0ZS5nZXRCbG9ja01hcCgpO1xuICB2YXIgZnJhZ21lbnQgPSByYW5kb21pemVCbG9ja01hcEtleXMoZnJhZ21lbnRCbG9ja01hcCk7XG4gIHZhciB0YXJnZXRLZXkgPSBzZWxlY3Rpb25TdGF0ZS5nZXRTdGFydEtleSgpO1xuICB2YXIgdGFyZ2V0T2Zmc2V0ID0gc2VsZWN0aW9uU3RhdGUuZ2V0U3RhcnRPZmZzZXQoKTtcblxuICB2YXIgdGFyZ2V0QmxvY2sgPSBibG9ja01hcC5nZXQodGFyZ2V0S2V5KTtcblxuICBpZiAodGFyZ2V0QmxvY2sgaW5zdGFuY2VvZiBDb250ZW50QmxvY2tOb2RlKSB7XG4gICAgIXRhcmdldEJsb2NrLmdldENoaWxkS2V5cygpLmlzRW1wdHkoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgaW5zZXJ0RnJhZ21lbnRgIHNob3VsZCBub3QgYmUgY2FsbGVkIHdoZW4gYSBjb250YWluZXIgbm9kZSBpcyBzZWxlY3RlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIH1cblxuICAvLyBXaGVuIHdlIGluc2VydCBhIGZyYWdtZW50IHdpdGggYSBzaW5nbGUgYmxvY2sgd2Ugc2ltcGx5IHVwZGF0ZSB0aGUgdGFyZ2V0IGJsb2NrXG4gIC8vIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBpbnNlcnRlZCBmcmFnbWVudCBibG9ja1xuICBpZiAoZnJhZ21lbnQuc2l6ZSA9PT0gMSkge1xuICAgIHJldHVybiB1cGRhdGVFeGlzdGluZ0Jsb2NrKGNvbnRlbnRTdGF0ZSwgc2VsZWN0aW9uU3RhdGUsIGJsb2NrTWFwLCBmcmFnbWVudC5maXJzdCgpLCB0YXJnZXRLZXksIHRhcmdldE9mZnNldCk7XG4gIH1cblxuICByZXR1cm4gaW5zZXJ0RnJhZ21lbnQoY29udGVudFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSwgYmxvY2tNYXAsIGZyYWdtZW50LCB0YXJnZXRLZXksIHRhcmdldE9mZnNldCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEZyYWdtZW50SW50b0NvbnRlbnRTdGF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvaW5zZXJ0RnJhZ21lbnRJbnRvQ29udGVudFN0YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGluc2VydFRleHRJbnRvQ29udGVudFN0YXRlXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBJbW11dGFibGUgPSByZXF1aXJlKCdpbW11dGFibGUnKTtcblxudmFyIGluc2VydEludG9MaXN0ID0gcmVxdWlyZSgnLi9pbnNlcnRJbnRvTGlzdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgUmVwZWF0ID0gSW1tdXRhYmxlLlJlcGVhdDtcblxuXG5mdW5jdGlvbiBpbnNlcnRUZXh0SW50b0NvbnRlbnRTdGF0ZShjb250ZW50U3RhdGUsIHNlbGVjdGlvblN0YXRlLCB0ZXh0LCBjaGFyYWN0ZXJNZXRhZGF0YSkge1xuICAhc2VsZWN0aW9uU3RhdGUuaXNDb2xsYXBzZWQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgaW5zZXJ0VGV4dGAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdpdGggYSBjb2xsYXBzZWQgcmFuZ2UuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gY29udGVudFN0YXRlO1xuICB9XG5cbiAgdmFyIGJsb2NrTWFwID0gY29udGVudFN0YXRlLmdldEJsb2NrTWFwKCk7XG4gIHZhciBrZXkgPSBzZWxlY3Rpb25TdGF0ZS5nZXRTdGFydEtleSgpO1xuICB2YXIgb2Zmc2V0ID0gc2VsZWN0aW9uU3RhdGUuZ2V0U3RhcnRPZmZzZXQoKTtcbiAgdmFyIGJsb2NrID0gYmxvY2tNYXAuZ2V0KGtleSk7XG4gIHZhciBibG9ja1RleHQgPSBibG9jay5nZXRUZXh0KCk7XG5cbiAgdmFyIG5ld0Jsb2NrID0gYmxvY2subWVyZ2Uoe1xuICAgIHRleHQ6IGJsb2NrVGV4dC5zbGljZSgwLCBvZmZzZXQpICsgdGV4dCArIGJsb2NrVGV4dC5zbGljZShvZmZzZXQsIGJsb2NrLmdldExlbmd0aCgpKSxcbiAgICBjaGFyYWN0ZXJMaXN0OiBpbnNlcnRJbnRvTGlzdChibG9jay5nZXRDaGFyYWN0ZXJMaXN0KCksIFJlcGVhdChjaGFyYWN0ZXJNZXRhZGF0YSwgbGVuKS50b0xpc3QoKSwgb2Zmc2V0KVxuICB9KTtcblxuICB2YXIgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgbGVuO1xuXG4gIHJldHVybiBjb250ZW50U3RhdGUubWVyZ2Uoe1xuICAgIGJsb2NrTWFwOiBibG9ja01hcC5zZXQoa2V5LCBuZXdCbG9jayksXG4gICAgc2VsZWN0aW9uQWZ0ZXI6IHNlbGVjdGlvblN0YXRlLm1lcmdlKHtcbiAgICAgIGFuY2hvck9mZnNldDogbmV3T2Zmc2V0LFxuICAgICAgZm9jdXNPZmZzZXQ6IG5ld09mZnNldFxuICAgIH0pXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFRleHRJbnRvQ29udGVudFN0YXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9pbnNlcnRUZXh0SW50b0NvbnRlbnRTdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtb2RpZnlCbG9ja0ZvckNvbnRlbnRTdGF0ZVxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSW1tdXRhYmxlID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG5cbnZhciBNYXAgPSBJbW11dGFibGUuTWFwO1xuXG5cbmZ1bmN0aW9uIG1vZGlmeUJsb2NrRm9yQ29udGVudFN0YXRlKGNvbnRlbnRTdGF0ZSwgc2VsZWN0aW9uU3RhdGUsIG9wZXJhdGlvbikge1xuICB2YXIgc3RhcnRLZXkgPSBzZWxlY3Rpb25TdGF0ZS5nZXRTdGFydEtleSgpO1xuICB2YXIgZW5kS2V5ID0gc2VsZWN0aW9uU3RhdGUuZ2V0RW5kS2V5KCk7XG4gIHZhciBibG9ja01hcCA9IGNvbnRlbnRTdGF0ZS5nZXRCbG9ja01hcCgpO1xuICB2YXIgbmV3QmxvY2tzID0gYmxvY2tNYXAudG9TZXEoKS5za2lwVW50aWwoZnVuY3Rpb24gKF8sIGspIHtcbiAgICByZXR1cm4gayA9PT0gc3RhcnRLZXk7XG4gIH0pLnRha2VVbnRpbChmdW5jdGlvbiAoXywgaykge1xuICAgIHJldHVybiBrID09PSBlbmRLZXk7XG4gIH0pLmNvbmNhdChNYXAoW1tlbmRLZXksIGJsb2NrTWFwLmdldChlbmRLZXkpXV0pKS5tYXAob3BlcmF0aW9uKTtcblxuICByZXR1cm4gY29udGVudFN0YXRlLm1lcmdlKHtcbiAgICBibG9ja01hcDogYmxvY2tNYXAubWVyZ2UobmV3QmxvY2tzKSxcbiAgICBzZWxlY3Rpb25CZWZvcmU6IHNlbGVjdGlvblN0YXRlLFxuICAgIHNlbGVjdGlvbkFmdGVyOiBzZWxlY3Rpb25TdGF0ZVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb2RpZnlCbG9ja0ZvckNvbnRlbnRTdGF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvbW9kaWZ5QmxvY2tGb3JDb250ZW50U3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDM5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcmVtb3ZlUmFuZ2VGcm9tQ29udGVudFN0YXRlXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDb250ZW50QmxvY2tOb2RlID0gcmVxdWlyZSgnLi9Db250ZW50QmxvY2tOb2RlJyk7XG52YXIgSW1tdXRhYmxlID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG5cbnZhciBnZXROZXh0RGVsaW1pdGVyQmxvY2tLZXkgPSByZXF1aXJlKCcuL2dldE5leHREZWxpbWl0ZXJCbG9ja0tleScpO1xuXG52YXIgTGlzdCA9IEltbXV0YWJsZS5MaXN0LFxuICAgIE1hcCA9IEltbXV0YWJsZS5NYXA7XG5cblxudmFyIHRyYW5zZm9ybUJsb2NrID0gZnVuY3Rpb24gdHJhbnNmb3JtQmxvY2soa2V5LCBibG9ja01hcCwgZnVuYykge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBibG9jayA9IGJsb2NrTWFwLmdldChrZXkpO1xuXG4gIGlmICghYmxvY2spIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBibG9ja01hcC5zZXQoa2V5LCBmdW5jKGJsb2NrKSk7XG59O1xuXG4vKipcbiAqIEFuY2VzdG9ycyBuZWVkcyB0byBiZSBwcmVzZXJ2ZWQgd2hlbiB0aGVyZSBhcmUgbm9uIHNlbGVjdGVkXG4gKiBjaGlsZHJlbiB0byBtYWtlIHN1cmUgd2UgZG8gbm90IGxlYXZlIGFueSBvcnBoYW5zIGJlaGluZFxuICovXG52YXIgZ2V0QW5jZXN0b3JzS2V5cyA9IGZ1bmN0aW9uIGdldEFuY2VzdG9yc0tleXMoYmxvY2tLZXksIGJsb2NrTWFwKSB7XG4gIHZhciBwYXJlbnRzID0gW107XG5cbiAgaWYgKCFibG9ja0tleSkge1xuICAgIHJldHVybiBwYXJlbnRzO1xuICB9XG5cbiAgdmFyIGJsb2NrTm9kZSA9IGJsb2NrTWFwLmdldChibG9ja0tleSk7XG4gIHdoaWxlIChibG9ja05vZGUgJiYgYmxvY2tOb2RlLmdldFBhcmVudEtleSgpKSB7XG4gICAgdmFyIHBhcmVudEtleSA9IGJsb2NrTm9kZS5nZXRQYXJlbnRLZXkoKTtcbiAgICBpZiAocGFyZW50S2V5KSB7XG4gICAgICBwYXJlbnRzLnB1c2gocGFyZW50S2V5KTtcbiAgICB9XG4gICAgYmxvY2tOb2RlID0gcGFyZW50S2V5ID8gYmxvY2tNYXAuZ2V0KHBhcmVudEtleSkgOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudHM7XG59O1xuXG4vKipcbiAqIEdldCBhbGwgbmV4dCBkZWxpbWl0ZXIga2V5cyB1bnRpbCB3ZSBoaXQgYSByb290IGRlbGltaXRlciBhbmQgcmV0dXJuXG4gKiBhbiBhcnJheSBvZiBrZXkgcmVmZXJlbmNlc1xuICovXG52YXIgZ2V0TmV4dERlbGltaXRlcnNCbG9ja0tleXMgPSBmdW5jdGlvbiBnZXROZXh0RGVsaW1pdGVyc0Jsb2NrS2V5cyhibG9jaywgYmxvY2tNYXApIHtcbiAgdmFyIG5leHREZWxpbWl0ZXJzID0gW107XG5cbiAgaWYgKCFibG9jaykge1xuICAgIHJldHVybiBuZXh0RGVsaW1pdGVycztcbiAgfVxuXG4gIHZhciBuZXh0RGVsaW1pdGVyID0gZ2V0TmV4dERlbGltaXRlckJsb2NrS2V5KGJsb2NrLCBibG9ja01hcCk7XG4gIHdoaWxlIChuZXh0RGVsaW1pdGVyICYmIGJsb2NrTWFwLmdldChuZXh0RGVsaW1pdGVyKSkge1xuICAgIHZhciBfYmxvY2sgPSBibG9ja01hcC5nZXQobmV4dERlbGltaXRlcik7XG4gICAgbmV4dERlbGltaXRlcnMucHVzaChuZXh0RGVsaW1pdGVyKTtcblxuICAgIC8vIHdlIGRvIG5vdCBuZWVkIHRvIGtlZXAgY2hlY2tpbmcgYWxsIHJvb3Qgbm9kZSBzaWJsaW5ncywganVzdCB0aGUgZmlyc3Qgb2NjdXJhbmNlXG4gICAgbmV4dERlbGltaXRlciA9IF9ibG9jay5nZXRQYXJlbnRLZXkoKSA/IGdldE5leHREZWxpbWl0ZXJCbG9ja0tleShfYmxvY2ssIGJsb2NrTWFwKSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4gbmV4dERlbGltaXRlcnM7XG59O1xuXG52YXIgZ2V0TmV4dFZhbGlkU2libGluZyA9IGZ1bmN0aW9uIGdldE5leHRWYWxpZFNpYmxpbmcoYmxvY2ssIGJsb2NrTWFwLCBvcmlnaW5hbEJsb2NrTWFwKSB7XG4gIGlmICghYmxvY2spIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIG5vdGUgdGhhdCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSByZWZlciB0byB0aGUgb3JpZ2luYWwgYmxvY2sgc2luY2UgdGhpc1xuICAvLyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aGluIGEgd2l0aE11dGF0aW9uc1xuICB2YXIgbmV4dFZhbGlkU2libGluZ0tleSA9IG9yaWdpbmFsQmxvY2tNYXAuZ2V0KGJsb2NrLmdldEtleSgpKS5nZXROZXh0U2libGluZ0tleSgpO1xuXG4gIHdoaWxlIChuZXh0VmFsaWRTaWJsaW5nS2V5ICYmICFibG9ja01hcC5nZXQobmV4dFZhbGlkU2libGluZ0tleSkpIHtcbiAgICBuZXh0VmFsaWRTaWJsaW5nS2V5ID0gb3JpZ2luYWxCbG9ja01hcC5nZXQobmV4dFZhbGlkU2libGluZ0tleSkuZ2V0TmV4dFNpYmxpbmdLZXkoKSB8fCBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG5leHRWYWxpZFNpYmxpbmdLZXk7XG59O1xuXG52YXIgZ2V0UHJldlZhbGlkU2libGluZyA9IGZ1bmN0aW9uIGdldFByZXZWYWxpZFNpYmxpbmcoYmxvY2ssIGJsb2NrTWFwLCBvcmlnaW5hbEJsb2NrTWFwKSB7XG4gIGlmICghYmxvY2spIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIG5vdGUgdGhhdCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSByZWZlciB0byB0aGUgb3JpZ2luYWwgYmxvY2sgc2luY2UgdGhpc1xuICAvLyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aGluIGEgd2l0aE11dGF0aW9uc1xuICB2YXIgcHJldlZhbGlkU2libGluZ0tleSA9IG9yaWdpbmFsQmxvY2tNYXAuZ2V0KGJsb2NrLmdldEtleSgpKS5nZXRQcmV2U2libGluZ0tleSgpO1xuXG4gIHdoaWxlIChwcmV2VmFsaWRTaWJsaW5nS2V5ICYmICFibG9ja01hcC5nZXQocHJldlZhbGlkU2libGluZ0tleSkpIHtcbiAgICBwcmV2VmFsaWRTaWJsaW5nS2V5ID0gb3JpZ2luYWxCbG9ja01hcC5nZXQocHJldlZhbGlkU2libGluZ0tleSkuZ2V0UHJldlNpYmxpbmdLZXkoKSB8fCBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHByZXZWYWxpZFNpYmxpbmdLZXk7XG59O1xuXG52YXIgdXBkYXRlQmxvY2tNYXBMaW5rcyA9IGZ1bmN0aW9uIHVwZGF0ZUJsb2NrTWFwTGlua3MoYmxvY2tNYXAsIHN0YXJ0QmxvY2ssIGVuZEJsb2NrLCBvcmlnaW5hbEJsb2NrTWFwKSB7XG4gIHJldHVybiBibG9ja01hcC53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChibG9ja3MpIHtcbiAgICAvLyB1cGRhdGUgc3RhcnQgYmxvY2sgaWYgaXRzIHJldGFpbmVkXG4gICAgdHJhbnNmb3JtQmxvY2soc3RhcnRCbG9jay5nZXRLZXkoKSwgYmxvY2tzLCBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgIHJldHVybiBibG9jay5tZXJnZSh7XG4gICAgICAgIG5leHRTaWJsaW5nOiBnZXROZXh0VmFsaWRTaWJsaW5nKHN0YXJ0QmxvY2ssIGJsb2Nrcywgb3JpZ2luYWxCbG9ja01hcCksXG4gICAgICAgIHByZXZTaWJsaW5nOiBnZXRQcmV2VmFsaWRTaWJsaW5nKHN0YXJ0QmxvY2ssIGJsb2Nrcywgb3JpZ2luYWxCbG9ja01hcClcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gdXBkYXRlIGVuZGJsb2NrIGlmIGl0cyByZXRhaW5lZFxuICAgIHRyYW5zZm9ybUJsb2NrKGVuZEJsb2NrLmdldEtleSgpLCBibG9ja3MsIGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgcmV0dXJuIGJsb2NrLm1lcmdlKHtcbiAgICAgICAgbmV4dFNpYmxpbmc6IGdldE5leHRWYWxpZFNpYmxpbmcoZW5kQmxvY2ssIGJsb2Nrcywgb3JpZ2luYWxCbG9ja01hcCksXG4gICAgICAgIHByZXZTaWJsaW5nOiBnZXRQcmV2VmFsaWRTaWJsaW5nKGVuZEJsb2NrLCBibG9ja3MsIG9yaWdpbmFsQmxvY2tNYXApXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSBzdGFydCBibG9jayBwYXJlbnQgYW5jZXN0b3JzXG4gICAgZ2V0QW5jZXN0b3JzS2V5cyhzdGFydEJsb2NrLmdldEtleSgpLCBvcmlnaW5hbEJsb2NrTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnRLZXkpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1CbG9jayhwYXJlbnRLZXksIGJsb2NrcywgZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHJldHVybiBibG9jay5tZXJnZSh7XG4gICAgICAgICAgY2hpbGRyZW46IGJsb2NrLmdldENoaWxkS2V5cygpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gYmxvY2tzLmdldChrZXkpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIG5leHRTaWJsaW5nOiBnZXROZXh0VmFsaWRTaWJsaW5nKGJsb2NrLCBibG9ja3MsIG9yaWdpbmFsQmxvY2tNYXApLFxuICAgICAgICAgIHByZXZTaWJsaW5nOiBnZXRQcmV2VmFsaWRTaWJsaW5nKGJsb2NrLCBibG9ja3MsIG9yaWdpbmFsQmxvY2tNYXApXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgc3RhcnQgYmxvY2sgbmV4dCAtIGNhbiBvbmx5IGhhcHBlbiBpZiBzdGFydEJsb2NrID09IGVuZEJsb2NrXG4gICAgdHJhbnNmb3JtQmxvY2soc3RhcnRCbG9jay5nZXROZXh0U2libGluZ0tleSgpLCBibG9ja3MsIGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgcmV0dXJuIGJsb2NrLm1lcmdlKHtcbiAgICAgICAgcHJldlNpYmxpbmc6IHN0YXJ0QmxvY2suZ2V0UHJldlNpYmxpbmdLZXkoKVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgc3RhcnQgYmxvY2sgcHJldlxuICAgIHRyYW5zZm9ybUJsb2NrKHN0YXJ0QmxvY2suZ2V0UHJldlNpYmxpbmdLZXkoKSwgYmxvY2tzLCBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgIHJldHVybiBibG9jay5tZXJnZSh7XG4gICAgICAgIG5leHRTaWJsaW5nOiBnZXROZXh0VmFsaWRTaWJsaW5nKHN0YXJ0QmxvY2ssIGJsb2Nrcywgb3JpZ2luYWxCbG9ja01hcClcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gdXBkYXRlIGVuZCBibG9jayBuZXh0XG4gICAgdHJhbnNmb3JtQmxvY2soZW5kQmxvY2suZ2V0TmV4dFNpYmxpbmdLZXkoKSwgYmxvY2tzLCBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgIHJldHVybiBibG9jay5tZXJnZSh7XG4gICAgICAgIHByZXZTaWJsaW5nOiBnZXRQcmV2VmFsaWRTaWJsaW5nKGVuZEJsb2NrLCBibG9ja3MsIG9yaWdpbmFsQmxvY2tNYXApXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSBlbmQgYmxvY2sgcHJldlxuICAgIHRyYW5zZm9ybUJsb2NrKGVuZEJsb2NrLmdldFByZXZTaWJsaW5nS2V5KCksIGJsb2NrcywgZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICByZXR1cm4gYmxvY2subWVyZ2Uoe1xuICAgICAgICBuZXh0U2libGluZzogZW5kQmxvY2suZ2V0TmV4dFNpYmxpbmdLZXkoKVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgZW5kIGJsb2NrIHBhcmVudCBhbmNlc3RvcnNcbiAgICBnZXRBbmNlc3RvcnNLZXlzKGVuZEJsb2NrLmdldEtleSgpLCBvcmlnaW5hbEJsb2NrTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnRLZXkpIHtcbiAgICAgIHRyYW5zZm9ybUJsb2NrKHBhcmVudEtleSwgYmxvY2tzLCBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrLm1lcmdlKHtcbiAgICAgICAgICBjaGlsZHJlbjogYmxvY2suZ2V0Q2hpbGRLZXlzKCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBibG9ja3MuZ2V0KGtleSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbmV4dFNpYmxpbmc6IGdldE5leHRWYWxpZFNpYmxpbmcoYmxvY2ssIGJsb2Nrcywgb3JpZ2luYWxCbG9ja01hcCksXG4gICAgICAgICAgcHJldlNpYmxpbmc6IGdldFByZXZWYWxpZFNpYmxpbmcoYmxvY2ssIGJsb2Nrcywgb3JpZ2luYWxCbG9ja01hcClcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSBuZXh0IGRlbGltaXRlcnMgYWxsIHRoZSB3YXkgdG8gYSByb290IGRlbGltaXRlclxuICAgIGdldE5leHREZWxpbWl0ZXJzQmxvY2tLZXlzKGVuZEJsb2NrLCBvcmlnaW5hbEJsb2NrTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChkZWxpbWl0ZXJLZXkpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1CbG9jayhkZWxpbWl0ZXJLZXksIGJsb2NrcywgZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHJldHVybiBibG9jay5tZXJnZSh7XG4gICAgICAgICAgbmV4dFNpYmxpbmc6IGdldE5leHRWYWxpZFNpYmxpbmcoYmxvY2ssIGJsb2Nrcywgb3JpZ2luYWxCbG9ja01hcCksXG4gICAgICAgICAgcHJldlNpYmxpbmc6IGdldFByZXZWYWxpZFNpYmxpbmcoYmxvY2ssIGJsb2Nrcywgb3JpZ2luYWxCbG9ja01hcClcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG52YXIgcmVtb3ZlUmFuZ2VGcm9tQ29udGVudFN0YXRlID0gZnVuY3Rpb24gcmVtb3ZlUmFuZ2VGcm9tQ29udGVudFN0YXRlKGNvbnRlbnRTdGF0ZSwgc2VsZWN0aW9uU3RhdGUpIHtcbiAgaWYgKHNlbGVjdGlvblN0YXRlLmlzQ29sbGFwc2VkKCkpIHtcbiAgICByZXR1cm4gY29udGVudFN0YXRlO1xuICB9XG5cbiAgdmFyIGJsb2NrTWFwID0gY29udGVudFN0YXRlLmdldEJsb2NrTWFwKCk7XG4gIHZhciBzdGFydEtleSA9IHNlbGVjdGlvblN0YXRlLmdldFN0YXJ0S2V5KCk7XG4gIHZhciBzdGFydE9mZnNldCA9IHNlbGVjdGlvblN0YXRlLmdldFN0YXJ0T2Zmc2V0KCk7XG4gIHZhciBlbmRLZXkgPSBzZWxlY3Rpb25TdGF0ZS5nZXRFbmRLZXkoKTtcbiAgdmFyIGVuZE9mZnNldCA9IHNlbGVjdGlvblN0YXRlLmdldEVuZE9mZnNldCgpO1xuXG4gIHZhciBzdGFydEJsb2NrID0gYmxvY2tNYXAuZ2V0KHN0YXJ0S2V5KTtcbiAgdmFyIGVuZEJsb2NrID0gYmxvY2tNYXAuZ2V0KGVuZEtleSk7XG5cbiAgLy8gd2UgYXNzdW1lIHRoYXQgQ29udGVudEJsb2NrTm9kZSBhbmQgQ29udGVudEJsb2NrcyBhcmUgbm90IG1peGVkIHRvZ2V0aGVyXG4gIHZhciBpc0V4cGVyaW1lbnRhbFRyZWVCbG9jayA9IHN0YXJ0QmxvY2sgaW5zdGFuY2VvZiBDb250ZW50QmxvY2tOb2RlO1xuXG4gIC8vIHVzZWQgdG8gcmV0YWluIGJsb2NrcyB0aGF0IHNob3VsZCBub3QgYmUgZGVsZXRlZCB0byBhdm9pZCBvcnBoYW4gY2hpbGRyZW5cbiAgdmFyIHBhcmVudEFuY2VzdG9ycyA9IFtdO1xuXG4gIGlmIChpc0V4cGVyaW1lbnRhbFRyZWVCbG9jaykge1xuICAgIHZhciBlbmRCbG9ja2NoaWxkcmVuS2V5cyA9IGVuZEJsb2NrLmdldENoaWxkS2V5cygpO1xuICAgIHZhciBlbmRCbG9ja0FuY2VzdG9ycyA9IGdldEFuY2VzdG9yc0tleXMoZW5kS2V5LCBibG9ja01hcCk7XG5cbiAgICAvLyBlbmRCbG9jayBoYXMgdW5zZWxlY3RlZCBzaWJibGluZ3Mgc28gd2UgY2FuIG5vdCByZW1vdmUgaXRzIGFuY2VzdG9ycyBwYXJlbnRzXG4gICAgaWYgKGVuZEJsb2NrLmdldE5leHRTaWJsaW5nS2V5KCkpIHtcbiAgICAgIHBhcmVudEFuY2VzdG9ycyA9IHBhcmVudEFuY2VzdG9ycy5jb25jYXQoZW5kQmxvY2tBbmNlc3RvcnMpO1xuICAgIH1cblxuICAgIC8vIGVuZEJsb2NrIGhhcyBjaGlsZHJlbiBzbyBjYW4gbm90IHJlbW92ZSB0aGlzIGJsb2NrIG9yIGFueSBvZiBpdHMgYW5jZXN0b3JzXG4gICAgaWYgKCFlbmRCbG9ja2NoaWxkcmVuS2V5cy5pc0VtcHR5KCkpIHtcbiAgICAgIHBhcmVudEFuY2VzdG9ycyA9IHBhcmVudEFuY2VzdG9ycy5jb25jYXQoZW5kQmxvY2tBbmNlc3RvcnMuY29uY2F0KFtlbmRLZXldKSk7XG4gICAgfVxuXG4gICAgLy8gd2UgbmVlZCB0byByZXRhaW4gYWxsIGFuY2VzdG9ycyBvZiB0aGUgbmV4dCBkZWxpbWl0ZXIgYmxvY2tcbiAgICBwYXJlbnRBbmNlc3RvcnMgPSBwYXJlbnRBbmNlc3RvcnMuY29uY2F0KGdldEFuY2VzdG9yc0tleXMoZ2V0TmV4dERlbGltaXRlckJsb2NrS2V5KGVuZEJsb2NrLCBibG9ja01hcCksIGJsb2NrTWFwKSk7XG4gIH1cblxuICB2YXIgY2hhcmFjdGVyTGlzdCA9IHZvaWQgMDtcblxuICBpZiAoc3RhcnRCbG9jayA9PT0gZW5kQmxvY2spIHtcbiAgICBjaGFyYWN0ZXJMaXN0ID0gcmVtb3ZlRnJvbUxpc3Qoc3RhcnRCbG9jay5nZXRDaGFyYWN0ZXJMaXN0KCksIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJhY3Rlckxpc3QgPSBzdGFydEJsb2NrLmdldENoYXJhY3Rlckxpc3QoKS5zbGljZSgwLCBzdGFydE9mZnNldCkuY29uY2F0KGVuZEJsb2NrLmdldENoYXJhY3Rlckxpc3QoKS5zbGljZShlbmRPZmZzZXQpKTtcbiAgfVxuXG4gIHZhciBtb2RpZmllZFN0YXJ0ID0gc3RhcnRCbG9jay5tZXJnZSh7XG4gICAgdGV4dDogc3RhcnRCbG9jay5nZXRUZXh0KCkuc2xpY2UoMCwgc3RhcnRPZmZzZXQpICsgZW5kQmxvY2suZ2V0VGV4dCgpLnNsaWNlKGVuZE9mZnNldCksXG4gICAgY2hhcmFjdGVyTGlzdDogY2hhcmFjdGVyTGlzdFxuICB9KTtcblxuICB2YXIgbmV3QmxvY2tzID0gYmxvY2tNYXAudG9TZXEoKS5za2lwVW50aWwoZnVuY3Rpb24gKF8sIGspIHtcbiAgICByZXR1cm4gayA9PT0gc3RhcnRLZXk7XG4gIH0pLnRha2VVbnRpbChmdW5jdGlvbiAoXywgaykge1xuICAgIHJldHVybiBrID09PSBlbmRLZXk7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoXywgaykge1xuICAgIHJldHVybiBwYXJlbnRBbmNlc3RvcnMuaW5kZXhPZihrKSA9PT0gLTE7XG4gIH0pLmNvbmNhdChNYXAoW1tlbmRLZXksIG51bGxdXSkpLm1hcChmdW5jdGlvbiAoXywgaykge1xuICAgIHJldHVybiBrID09PSBzdGFydEtleSA/IG1vZGlmaWVkU3RhcnQgOiBudWxsO1xuICB9KTtcblxuICB2YXIgdXBkYXRlZEJsb2NrTWFwID0gYmxvY2tNYXAubWVyZ2UobmV3QmxvY2tzKS5maWx0ZXIoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgcmV0dXJuICEhYmxvY2s7XG4gIH0pO1xuXG4gIGlmIChpc0V4cGVyaW1lbnRhbFRyZWVCbG9jaykge1xuICAgIHVwZGF0ZWRCbG9ja01hcCA9IHVwZGF0ZUJsb2NrTWFwTGlua3ModXBkYXRlZEJsb2NrTWFwLCBzdGFydEJsb2NrLCBlbmRCbG9jaywgYmxvY2tNYXApO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnRTdGF0ZS5tZXJnZSh7XG4gICAgYmxvY2tNYXA6IHVwZGF0ZWRCbG9ja01hcCxcbiAgICBzZWxlY3Rpb25CZWZvcmU6IHNlbGVjdGlvblN0YXRlLFxuICAgIHNlbGVjdGlvbkFmdGVyOiBzZWxlY3Rpb25TdGF0ZS5tZXJnZSh7XG4gICAgICBhbmNob3JLZXk6IHN0YXJ0S2V5LFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgIGZvY3VzS2V5OiBzdGFydEtleSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgIGlzQmFja3dhcmQ6IGZhbHNlXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vKipcbiAqIE1haW50YWluIHBlcnNpc3RlbmNlIGZvciB0YXJnZXQgbGlzdCB3aGVuIHJlbW92aW5nIGNoYXJhY3RlcnMgb24gdGhlXG4gKiBoZWFkIGFuZCB0YWlsIG9mIHRoZSBjaGFyYWN0ZXIgbGlzdC5cbiAqL1xudmFyIHJlbW92ZUZyb21MaXN0ID0gZnVuY3Rpb24gcmVtb3ZlRnJvbUxpc3QodGFyZ2V0TGlzdCwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICBpZiAoc3RhcnRPZmZzZXQgPT09IDApIHtcbiAgICB3aGlsZSAoc3RhcnRPZmZzZXQgPCBlbmRPZmZzZXQpIHtcbiAgICAgIHRhcmdldExpc3QgPSB0YXJnZXRMaXN0LnNoaWZ0KCk7XG4gICAgICBzdGFydE9mZnNldCsrO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbmRPZmZzZXQgPT09IHRhcmdldExpc3QuY291bnQoKSkge1xuICAgIHdoaWxlIChlbmRPZmZzZXQgPiBzdGFydE9mZnNldCkge1xuICAgICAgdGFyZ2V0TGlzdCA9IHRhcmdldExpc3QucG9wKCk7XG4gICAgICBlbmRPZmZzZXQtLTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGhlYWQgPSB0YXJnZXRMaXN0LnNsaWNlKDAsIHN0YXJ0T2Zmc2V0KTtcbiAgICB2YXIgdGFpbCA9IHRhcmdldExpc3Quc2xpY2UoZW5kT2Zmc2V0KTtcbiAgICB0YXJnZXRMaXN0ID0gaGVhZC5jb25jYXQodGFpbCkudG9MaXN0KCk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldExpc3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbW92ZVJhbmdlRnJvbUNvbnRlbnRTdGF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvcmVtb3ZlUmFuZ2VGcm9tQ29udGVudFN0YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNwbGl0QmxvY2tJbkNvbnRlbnRTdGF0ZVxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29udGVudEJsb2NrTm9kZSA9IHJlcXVpcmUoJy4vQ29udGVudEJsb2NrTm9kZScpO1xudmFyIEltbXV0YWJsZSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xuXG52YXIgZ2VuZXJhdGVSYW5kb21LZXkgPSByZXF1aXJlKCcuL2dlbmVyYXRlUmFuZG9tS2V5Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBMaXN0ID0gSW1tdXRhYmxlLkxpc3QsXG4gICAgTWFwID0gSW1tdXRhYmxlLk1hcDtcblxuXG52YXIgdHJhbnNmb3JtQmxvY2sgPSBmdW5jdGlvbiB0cmFuc2Zvcm1CbG9jayhrZXksIGJsb2NrTWFwLCBmdW5jKSB7XG4gIGlmICgha2V5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGJsb2NrID0gYmxvY2tNYXAuZ2V0KGtleSk7XG5cbiAgaWYgKCFibG9jaykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGJsb2NrTWFwLnNldChrZXksIGZ1bmMoYmxvY2spKTtcbn07XG5cbnZhciB1cGRhdGVCbG9ja01hcExpbmtzID0gZnVuY3Rpb24gdXBkYXRlQmxvY2tNYXBMaW5rcyhibG9ja01hcCwgb3JpZ2luYWxCbG9jaywgYmVsb3dCbG9jaykge1xuICByZXR1cm4gYmxvY2tNYXAud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoYmxvY2tzKSB7XG4gICAgdmFyIG9yaWdpbmFsQmxvY2tLZXkgPSBvcmlnaW5hbEJsb2NrLmdldEtleSgpO1xuICAgIHZhciBiZWxvd0Jsb2NrS2V5ID0gYmVsb3dCbG9jay5nZXRLZXkoKTtcblxuICAgIC8vIHVwZGF0ZSBibG9jayBwYXJlbnRcbiAgICB0cmFuc2Zvcm1CbG9jayhvcmlnaW5hbEJsb2NrLmdldFBhcmVudEtleSgpLCBibG9ja3MsIGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgdmFyIHBhcmVudENoaWxkcmVuTGlzdCA9IGJsb2NrLmdldENoaWxkS2V5cygpO1xuICAgICAgdmFyIGluc2VydGlvbkluZGV4ID0gcGFyZW50Q2hpbGRyZW5MaXN0LmluZGV4T2Yob3JpZ2luYWxCbG9ja0tleSkgKyAxO1xuICAgICAgdmFyIG5ld0NoaWxkcmVuQXJyYXkgPSBwYXJlbnRDaGlsZHJlbkxpc3QudG9BcnJheSgpO1xuXG4gICAgICBuZXdDaGlsZHJlbkFycmF5LnNwbGljZShpbnNlcnRpb25JbmRleCwgMCwgYmVsb3dCbG9ja0tleSk7XG5cbiAgICAgIHJldHVybiBibG9jay5tZXJnZSh7XG4gICAgICAgIGNoaWxkcmVuOiBMaXN0KG5ld0NoaWxkcmVuQXJyYXkpXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSBvcmlnaW5hbCBuZXh0IGJsb2NrXG4gICAgdHJhbnNmb3JtQmxvY2sob3JpZ2luYWxCbG9jay5nZXROZXh0U2libGluZ0tleSgpLCBibG9ja3MsIGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgcmV0dXJuIGJsb2NrLm1lcmdlKHtcbiAgICAgICAgcHJldlNpYmxpbmc6IGJlbG93QmxvY2tLZXlcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gdXBkYXRlIG9yaWdpbmFsIGJsb2NrXG4gICAgdHJhbnNmb3JtQmxvY2sob3JpZ2luYWxCbG9ja0tleSwgYmxvY2tzLCBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgIHJldHVybiBibG9jay5tZXJnZSh7XG4gICAgICAgIG5leHRTaWJsaW5nOiBiZWxvd0Jsb2NrS2V5XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSBiZWxvdyBibG9ja1xuICAgIHRyYW5zZm9ybUJsb2NrKGJlbG93QmxvY2tLZXksIGJsb2NrcywgZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICByZXR1cm4gYmxvY2subWVyZ2Uoe1xuICAgICAgICBwcmV2U2libGluZzogb3JpZ2luYWxCbG9ja0tleVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxudmFyIHNwbGl0QmxvY2tJbkNvbnRlbnRTdGF0ZSA9IGZ1bmN0aW9uIHNwbGl0QmxvY2tJbkNvbnRlbnRTdGF0ZShjb250ZW50U3RhdGUsIHNlbGVjdGlvblN0YXRlKSB7XG4gICFzZWxlY3Rpb25TdGF0ZS5pc0NvbGxhcHNlZCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1NlbGVjdGlvbiByYW5nZSBtdXN0IGJlIGNvbGxhcHNlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgdmFyIGtleSA9IHNlbGVjdGlvblN0YXRlLmdldEFuY2hvcktleSgpO1xuICB2YXIgb2Zmc2V0ID0gc2VsZWN0aW9uU3RhdGUuZ2V0QW5jaG9yT2Zmc2V0KCk7XG4gIHZhciBibG9ja01hcCA9IGNvbnRlbnRTdGF0ZS5nZXRCbG9ja01hcCgpO1xuICB2YXIgYmxvY2tUb1NwbGl0ID0gYmxvY2tNYXAuZ2V0KGtleSk7XG4gIHZhciB0ZXh0ID0gYmxvY2tUb1NwbGl0LmdldFRleHQoKTtcbiAgdmFyIGNoYXJzID0gYmxvY2tUb1NwbGl0LmdldENoYXJhY3Rlckxpc3QoKTtcbiAgdmFyIGtleUJlbG93ID0gZ2VuZXJhdGVSYW5kb21LZXkoKTtcbiAgdmFyIGlzRXhwZXJpbWVudGFsVHJlZUJsb2NrID0gYmxvY2tUb1NwbGl0IGluc3RhbmNlb2YgQ29udGVudEJsb2NrTm9kZTtcblxuICB2YXIgYmxvY2tBYm92ZSA9IGJsb2NrVG9TcGxpdC5tZXJnZSh7XG4gICAgdGV4dDogdGV4dC5zbGljZSgwLCBvZmZzZXQpLFxuICAgIGNoYXJhY3Rlckxpc3Q6IGNoYXJzLnNsaWNlKDAsIG9mZnNldClcbiAgfSk7XG4gIHZhciBibG9ja0JlbG93ID0gYmxvY2tBYm92ZS5tZXJnZSh7XG4gICAga2V5OiBrZXlCZWxvdyxcbiAgICB0ZXh0OiB0ZXh0LnNsaWNlKG9mZnNldCksXG4gICAgY2hhcmFjdGVyTGlzdDogY2hhcnMuc2xpY2Uob2Zmc2V0KSxcbiAgICBkYXRhOiBNYXAoKVxuICB9KTtcblxuICB2YXIgYmxvY2tzQmVmb3JlID0gYmxvY2tNYXAudG9TZXEoKS50YWtlVW50aWwoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gYmxvY2tUb1NwbGl0O1xuICB9KTtcbiAgdmFyIGJsb2Nrc0FmdGVyID0gYmxvY2tNYXAudG9TZXEoKS5za2lwVW50aWwoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gYmxvY2tUb1NwbGl0O1xuICB9KS5yZXN0KCk7XG4gIHZhciBuZXdCbG9ja3MgPSBibG9ja3NCZWZvcmUuY29uY2F0KFtba2V5LCBibG9ja0Fib3ZlXSwgW2tleUJlbG93LCBibG9ja0JlbG93XV0sIGJsb2Nrc0FmdGVyKS50b09yZGVyZWRNYXAoKTtcblxuICBpZiAoaXNFeHBlcmltZW50YWxUcmVlQmxvY2spIHtcbiAgICAhYmxvY2tUb1NwbGl0LmdldENoaWxkS2V5cygpLmlzRW1wdHkoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDb250ZW50QmxvY2tOb2RlIG11c3Qgbm90IGhhdmUgY2hpbGRyZW4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBuZXdCbG9ja3MgPSB1cGRhdGVCbG9ja01hcExpbmtzKG5ld0Jsb2NrcywgYmxvY2tBYm92ZSwgYmxvY2tCZWxvdyk7XG4gIH1cblxuICByZXR1cm4gY29udGVudFN0YXRlLm1lcmdlKHtcbiAgICBibG9ja01hcDogbmV3QmxvY2tzLFxuICAgIHNlbGVjdGlvbkJlZm9yZTogc2VsZWN0aW9uU3RhdGUsXG4gICAgc2VsZWN0aW9uQWZ0ZXI6IHNlbGVjdGlvblN0YXRlLm1lcmdlKHtcbiAgICAgIGFuY2hvcktleToga2V5QmVsb3csXG4gICAgICBhbmNob3JPZmZzZXQ6IDAsXG4gICAgICBmb2N1c0tleToga2V5QmVsb3csXG4gICAgICBmb2N1c09mZnNldDogMCxcbiAgICAgIGlzQmFja3dhcmQ6IGZhbHNlXG4gICAgfSlcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNwbGl0QmxvY2tJbkNvbnRlbnRTdGF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvc3BsaXRCbG9ja0luQ29udGVudFN0YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEVkaXRvckJpZGlTZXJ2aWNlXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBJbW11dGFibGUgPSByZXF1aXJlKCdpbW11dGFibGUnKTtcbnZhciBVbmljb2RlQmlkaVNlcnZpY2UgPSByZXF1aXJlKCdmYmpzL2xpYi9Vbmljb2RlQmlkaVNlcnZpY2UnKTtcblxudmFyIG51bGx0aHJvd3MgPSByZXF1aXJlKCdmYmpzL2xpYi9udWxsdGhyb3dzJyk7XG5cbnZhciBPcmRlcmVkTWFwID0gSW1tdXRhYmxlLk9yZGVyZWRNYXA7XG5cblxudmFyIGJpZGlTZXJ2aWNlO1xuXG52YXIgRWRpdG9yQmlkaVNlcnZpY2UgPSB7XG4gIGdldERpcmVjdGlvbk1hcDogZnVuY3Rpb24gZ2V0RGlyZWN0aW9uTWFwKGNvbnRlbnQsIHByZXZCaWRpTWFwKSB7XG4gICAgaWYgKCFiaWRpU2VydmljZSkge1xuICAgICAgYmlkaVNlcnZpY2UgPSBuZXcgVW5pY29kZUJpZGlTZXJ2aWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpZGlTZXJ2aWNlLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgdmFyIGJsb2NrTWFwID0gY29udGVudC5nZXRCbG9ja01hcCgpO1xuICAgIHZhciBuZXh0QmlkaSA9IGJsb2NrTWFwLnZhbHVlU2VxKCkubWFwKGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgcmV0dXJuIG51bGx0aHJvd3MoYmlkaVNlcnZpY2UpLmdldERpcmVjdGlvbihibG9jay5nZXRUZXh0KCkpO1xuICAgIH0pO1xuICAgIHZhciBiaWRpTWFwID0gT3JkZXJlZE1hcChibG9ja01hcC5rZXlTZXEoKS56aXAobmV4dEJpZGkpKTtcblxuICAgIGlmIChwcmV2QmlkaU1hcCAhPSBudWxsICYmIEltbXV0YWJsZS5pcyhwcmV2QmlkaU1hcCwgYmlkaU1hcCkpIHtcbiAgICAgIHJldHVybiBwcmV2QmlkaU1hcDtcbiAgICB9XG5cbiAgICByZXR1cm4gYmlkaU1hcDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFZGl0b3JCaWRpU2VydmljZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRWRpdG9yQmlkaVNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDQwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qKlxuICogU3RhdGVmdWwgQVBJIGZvciB0ZXh0IGRpcmVjdGlvbiBkZXRlY3Rpb25cbiAqXG4gKiBUaGlzIGNsYXNzIGNhbiBiZSB1c2VkIGluIGFwcGxpY2F0aW9ucyB3aGVyZSB5b3UgbmVlZCB0byBkZXRlY3QgdGhlXG4gKiBkaXJlY3Rpb24gb2YgYSBzZXF1ZW5jZSBvZiB0ZXh0IGJsb2Nrcywgd2hlcmUgZWFjaCBkaXJlY3Rpb24gc2hhbGwgYmUgdXNlZFxuICogYXMgdGhlIGZhbGxiYWNrIGRpcmVjdGlvbiBmb3IgdGhlIG5leHQgb25lLlxuICpcbiAqIE5PVEU6IEEgZGVmYXVsdCBkaXJlY3Rpb24sIGlmIG5vdCBwcm92aWRlZCwgaXMgc2V0IGJhc2VkIG9uIHRoZSBnbG9iYWxcbiAqICAgICAgIGRpcmVjdGlvbiwgYXMgZGVmaW5lZCBieSBgVW5pY29kZUJpZGlEaXJlY3Rpb25gLlxuICpcbiAqID09IEV4YW1wbGUgPT1cbiAqIGBgYFxuICogdmFyIFVuaWNvZGVCaWRpU2VydmljZSA9IHJlcXVpcmUoJ1VuaWNvZGVCaWRpU2VydmljZScpO1xuICpcbiAqIHZhciBiaWRpU2VydmljZSA9IG5ldyBVbmljb2RlQmlkaVNlcnZpY2UoKTtcbiAqXG4gKiAuLi5cbiAqXG4gKiBiaWRpU2VydmljZS5yZXNldCgpO1xuICogZm9yICh2YXIgcGFyYSBpbiBwYXJhZ3JhcGhzKSB7XG4gKiAgIHZhciBkaXIgPSBiaWRpU2VydmljZS5nZXREaXJlY3Rpb24ocGFyYSk7XG4gKiAgIC4uLlxuICogfVxuICogYGBgXG4gKlxuICogUGFydCBvZiBvdXIgaW1wbGVtZW50YXRpb24gb2YgVW5pY29kZSBCaWRpcmVjdGlvbmFsIEFsZ29yaXRobSAoVUJBKVxuICogVW5pY29kZSBTdGFuZGFyZCBBbm5leCAjOSAoVUFYOSlcbiAqIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjkvXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgVW5pY29kZUJpZGkgPSByZXF1aXJlKCcuL1VuaWNvZGVCaWRpJyk7XG52YXIgVW5pY29kZUJpZGlEaXJlY3Rpb24gPSByZXF1aXJlKCcuL1VuaWNvZGVCaWRpRGlyZWN0aW9uJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG52YXIgVW5pY29kZUJpZGlTZXJ2aWNlID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBTdGF0ZWZ1bCBjbGFzcyBmb3IgcGFyYWdyYXBoIGRpcmVjdGlvbiBkZXRlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIGRlZmF1bHREaXIgIERlZmF1bHQgZGlyZWN0aW9uIG9mIHRoZSBzZXJ2aWNlXG4gICAqL1xuICBmdW5jdGlvbiBVbmljb2RlQmlkaVNlcnZpY2UoZGVmYXVsdERpcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVbmljb2RlQmlkaVNlcnZpY2UpO1xuXG4gICAgaWYgKCFkZWZhdWx0RGlyKSB7XG4gICAgICBkZWZhdWx0RGlyID0gVW5pY29kZUJpZGlEaXJlY3Rpb24uZ2V0R2xvYmFsRGlyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICFVbmljb2RlQmlkaURpcmVjdGlvbi5pc1N0cm9uZyhkZWZhdWx0RGlyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEZWZhdWx0IGRpcmVjdGlvbiBtdXN0IGJlIGEgc3Ryb25nIGRpcmVjdGlvbiAoTFRSIG9yIFJUTCknKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHRoaXMuX2RlZmF1bHREaXIgPSBkZWZhdWx0RGlyO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgaW50ZXJuYWwgc3RhdGVcbiAgICpcbiAgICogSW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBpbnN0YW5jZSwgeW91IGNhbiBqdXN0IHJlc2V0KCkgeW91ciBpbnN0YW5jZVxuICAgKiBldmVyeXRpbWUgeW91IHN0YXJ0IGEgbmV3IGxvb3AuXG4gICAqL1xuXG5cbiAgVW5pY29kZUJpZGlTZXJ2aWNlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuX2xhc3REaXIgPSB0aGlzLl9kZWZhdWx0RGlyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaXJlY3Rpb24gb2YgYSBibG9jayBvZiB0ZXh0LCBhbmQgcmVtZW1iZXJzIGl0IGFzIHRoZVxuICAgKiBmYWxsLWJhY2sgZGlyZWN0aW9uIGZvciB0aGUgbmV4dCBwYXJhZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSBzdHIgIEEgdGV4dCBibG9jaywgZS5nLiBwYXJhZ3JhcGgsIHRhYmxlIGNlbGwsIHRhZ1xuICAgKiBAcmV0dXJuICAgICBUaGUgcmVzb2x2ZWQgZGlyZWN0aW9uXG4gICAqL1xuXG5cbiAgVW5pY29kZUJpZGlTZXJ2aWNlLnByb3RvdHlwZS5nZXREaXJlY3Rpb24gPSBmdW5jdGlvbiBnZXREaXJlY3Rpb24oc3RyKSB7XG4gICAgdGhpcy5fbGFzdERpciA9IFVuaWNvZGVCaWRpLmdldERpcmVjdGlvbihzdHIsIHRoaXMuX2xhc3REaXIpO1xuICAgIHJldHVybiB0aGlzLl9sYXN0RGlyO1xuICB9O1xuXG4gIHJldHVybiBVbmljb2RlQmlkaVNlcnZpY2U7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pY29kZUJpZGlTZXJ2aWNlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL1VuaWNvZGVCaWRpU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gNDAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtb3ZlQmxvY2tJbkNvbnRlbnRTdGF0ZVxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29udGVudEJsb2NrTm9kZSA9IHJlcXVpcmUoJy4vQ29udGVudEJsb2NrTm9kZScpO1xudmFyIEltbXV0YWJsZSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xuXG52YXIgZ2V0TmV4dERlbGltaXRlckJsb2NrS2V5ID0gcmVxdWlyZSgnLi9nZXROZXh0RGVsaW1pdGVyQmxvY2tLZXknKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIE9yZGVyZWRNYXAgPSBJbW11dGFibGUuT3JkZXJlZE1hcCxcbiAgICBMaXN0ID0gSW1tdXRhYmxlLkxpc3Q7XG5cblxudmFyIHRyYW5zZm9ybUJsb2NrID0gZnVuY3Rpb24gdHJhbnNmb3JtQmxvY2soa2V5LCBibG9ja01hcCwgZnVuYykge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBibG9jayA9IGJsb2NrTWFwLmdldChrZXkpO1xuXG4gIGlmICghYmxvY2spIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBibG9ja01hcC5zZXQoa2V5LCBmdW5jKGJsb2NrKSk7XG59O1xuXG52YXIgdXBkYXRlQmxvY2tNYXBMaW5rcyA9IGZ1bmN0aW9uIHVwZGF0ZUJsb2NrTWFwTGlua3MoYmxvY2tNYXAsIG9yaWdpbmFsQmxvY2tUb0JlTW92ZWQsIG9yaWdpbmFsVGFyZ2V0QmxvY2ssIGluc2VydGlvbk1vZGUsIGlzRXhwZXJpbWVudGFsVHJlZUJsb2NrKSB7XG4gIGlmICghaXNFeHBlcmltZW50YWxUcmVlQmxvY2spIHtcbiAgICByZXR1cm4gYmxvY2tNYXA7XG4gIH1cbiAgLy8gcG9zc2libGUgdmFsdWVzIG9mICdpbnNlcnRpb25Nb2RlJyBhcmU6ICdhZnRlcicsICdiZWZvcmUnXG4gIHZhciBpc0luc2VydGVkQWZ0ZXJUYXJnZXQgPSBpbnNlcnRpb25Nb2RlID09PSAnYWZ0ZXInO1xuXG4gIHZhciBvcmlnaW5hbEJsb2NrS2V5ID0gb3JpZ2luYWxCbG9ja1RvQmVNb3ZlZC5nZXRLZXkoKTtcbiAgdmFyIG9yaWdpbmFsVGFyZ2V0S2V5ID0gb3JpZ2luYWxUYXJnZXRCbG9jay5nZXRLZXkoKTtcbiAgdmFyIG9yaWdpbmFsUGFyZW50S2V5ID0gb3JpZ2luYWxCbG9ja1RvQmVNb3ZlZC5nZXRQYXJlbnRLZXkoKTtcbiAgdmFyIG9yaWdpbmFsTmV4dFNpYmxpbmdLZXkgPSBvcmlnaW5hbEJsb2NrVG9CZU1vdmVkLmdldE5leHRTaWJsaW5nS2V5KCk7XG4gIHZhciBvcmlnaW5hbFByZXZTaWJsaW5nS2V5ID0gb3JpZ2luYWxCbG9ja1RvQmVNb3ZlZC5nZXRQcmV2U2libGluZ0tleSgpO1xuICB2YXIgbmV3UGFyZW50S2V5ID0gb3JpZ2luYWxUYXJnZXRCbG9jay5nZXRQYXJlbnRLZXkoKTtcbiAgdmFyIG5ld05leHRTaWJsaW5nS2V5ID0gaXNJbnNlcnRlZEFmdGVyVGFyZ2V0ID8gb3JpZ2luYWxUYXJnZXRCbG9jay5nZXROZXh0U2libGluZ0tleSgpIDogb3JpZ2luYWxUYXJnZXRLZXk7XG4gIHZhciBuZXdQcmV2U2libGluZ0tleSA9IGlzSW5zZXJ0ZWRBZnRlclRhcmdldCA/IG9yaWdpbmFsVGFyZ2V0S2V5IDogb3JpZ2luYWxUYXJnZXRCbG9jay5nZXRQcmV2U2libGluZ0tleSgpO1xuXG4gIHJldHVybiBibG9ja01hcC53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChibG9ja3MpIHtcbiAgICAvLyB1cGRhdGUgb2xkIHBhcmVudFxuICAgIHRyYW5zZm9ybUJsb2NrKG9yaWdpbmFsUGFyZW50S2V5LCBibG9ja3MsIGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgdmFyIHBhcmVudENoaWxkcmVuTGlzdCA9IGJsb2NrLmdldENoaWxkS2V5cygpO1xuICAgICAgcmV0dXJuIGJsb2NrLm1lcmdlKHtcbiAgICAgICAgY2hpbGRyZW46IHBhcmVudENoaWxkcmVuTGlzdFsnZGVsZXRlJ10ocGFyZW50Q2hpbGRyZW5MaXN0LmluZGV4T2Yob3JpZ2luYWxCbG9ja0tleSkpXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSBvbGQgcHJldlxuICAgIHRyYW5zZm9ybUJsb2NrKG9yaWdpbmFsUHJldlNpYmxpbmdLZXksIGJsb2NrcywgZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICByZXR1cm4gYmxvY2subWVyZ2Uoe1xuICAgICAgICBuZXh0U2libGluZzogb3JpZ2luYWxOZXh0U2libGluZ0tleVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgb2xkIG5leHRcbiAgICB0cmFuc2Zvcm1CbG9jayhvcmlnaW5hbE5leHRTaWJsaW5nS2V5LCBibG9ja3MsIGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgcmV0dXJuIGJsb2NrLm1lcmdlKHtcbiAgICAgICAgcHJldlNpYmxpbmc6IG9yaWdpbmFsUHJldlNpYmxpbmdLZXlcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gdXBkYXRlIG5ldyBuZXh0XG4gICAgdHJhbnNmb3JtQmxvY2sobmV3TmV4dFNpYmxpbmdLZXksIGJsb2NrcywgZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICByZXR1cm4gYmxvY2subWVyZ2Uoe1xuICAgICAgICBwcmV2U2libGluZzogb3JpZ2luYWxCbG9ja0tleVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgbmV3IHByZXZcbiAgICB0cmFuc2Zvcm1CbG9jayhuZXdQcmV2U2libGluZ0tleSwgYmxvY2tzLCBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgIHJldHVybiBibG9jay5tZXJnZSh7XG4gICAgICAgIG5leHRTaWJsaW5nOiBvcmlnaW5hbEJsb2NrS2V5XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSBuZXcgcGFyZW50XG4gICAgdHJhbnNmb3JtQmxvY2sobmV3UGFyZW50S2V5LCBibG9ja3MsIGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgdmFyIG5ld1BhcmVudENoaWxkcmVuTGlzdCA9IGJsb2NrLmdldENoaWxkS2V5cygpO1xuICAgICAgdmFyIHRhcmdldEJsb2NrSW5kZXggPSBuZXdQYXJlbnRDaGlsZHJlbkxpc3QuaW5kZXhPZihvcmlnaW5hbFRhcmdldEtleSk7XG5cbiAgICAgIHZhciBpbnNlcnRpb25JbmRleCA9IGlzSW5zZXJ0ZWRBZnRlclRhcmdldCA/IHRhcmdldEJsb2NrSW5kZXggKyAxIDogdGFyZ2V0QmxvY2tJbmRleCAhPT0gMCA/IHRhcmdldEJsb2NrSW5kZXggLSAxIDogMDtcblxuICAgICAgdmFyIG5ld0NoaWxkcmVuQXJyYXkgPSBuZXdQYXJlbnRDaGlsZHJlbkxpc3QudG9BcnJheSgpO1xuICAgICAgbmV3Q2hpbGRyZW5BcnJheS5zcGxpY2UoaW5zZXJ0aW9uSW5kZXgsIDAsIG9yaWdpbmFsQmxvY2tLZXkpO1xuXG4gICAgICByZXR1cm4gYmxvY2subWVyZ2Uoe1xuICAgICAgICBjaGlsZHJlbjogTGlzdChuZXdDaGlsZHJlbkFycmF5KVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgYmxvY2tcbiAgICB0cmFuc2Zvcm1CbG9jayhvcmlnaW5hbEJsb2NrS2V5LCBibG9ja3MsIGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgcmV0dXJuIGJsb2NrLm1lcmdlKHtcbiAgICAgICAgbmV4dFNpYmxpbmc6IG5ld05leHRTaWJsaW5nS2V5LFxuICAgICAgICBwcmV2U2libGluZzogbmV3UHJldlNpYmxpbmdLZXksXG4gICAgICAgIHBhcmVudDogbmV3UGFyZW50S2V5XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG52YXIgbW92ZUJsb2NrSW5Db250ZW50U3RhdGUgPSBmdW5jdGlvbiBtb3ZlQmxvY2tJbkNvbnRlbnRTdGF0ZShjb250ZW50U3RhdGUsIGJsb2NrVG9CZU1vdmVkLCB0YXJnZXRCbG9jaywgaW5zZXJ0aW9uTW9kZSkge1xuICAhKGluc2VydGlvbk1vZGUgIT09ICdyZXBsYWNlJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVwbGFjaW5nIGJsb2NrcyBpcyBub3Qgc3VwcG9ydGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICB2YXIgdGFyZ2V0S2V5ID0gdGFyZ2V0QmxvY2suZ2V0S2V5KCk7XG4gIHZhciBibG9ja0tleSA9IGJsb2NrVG9CZU1vdmVkLmdldEtleSgpO1xuXG4gICEoYmxvY2tLZXkgIT09IHRhcmdldEtleSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQmxvY2sgY2Fubm90IGJlIG1vdmVkIG5leHQgdG8gaXRzZWxmLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICB2YXIgYmxvY2tNYXAgPSBjb250ZW50U3RhdGUuZ2V0QmxvY2tNYXAoKTtcbiAgdmFyIGlzRXhwZXJpbWVudGFsVHJlZUJsb2NrID0gYmxvY2tUb0JlTW92ZWQgaW5zdGFuY2VvZiBDb250ZW50QmxvY2tOb2RlO1xuXG4gIHZhciBibG9ja3NUb0JlTW92ZWQgPSBbYmxvY2tUb0JlTW92ZWRdO1xuICB2YXIgYmxvY2tNYXBXaXRob3V0QmxvY2tzVG9CZU1vdmVkID0gYmxvY2tNYXBbJ2RlbGV0ZSddKGJsb2NrS2V5KTtcblxuICBpZiAoaXNFeHBlcmltZW50YWxUcmVlQmxvY2spIHtcbiAgICBibG9ja3NUb0JlTW92ZWQgPSBbXTtcbiAgICBibG9ja01hcFdpdGhvdXRCbG9ja3NUb0JlTW92ZWQgPSBibG9ja01hcC53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChibG9ja3MpIHtcbiAgICAgIHZhciBuZXh0U2libGluZ0tleSA9IGJsb2NrVG9CZU1vdmVkLmdldE5leHRTaWJsaW5nS2V5KCk7XG4gICAgICB2YXIgbmV4dERlbGltaXRlckJsb2NrS2V5ID0gZ2V0TmV4dERlbGltaXRlckJsb2NrS2V5KGJsb2NrVG9CZU1vdmVkLCBibG9ja3MpO1xuXG4gICAgICBibG9ja3MudG9TZXEoKS5za2lwVW50aWwoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHJldHVybiBibG9jay5nZXRLZXkoKSA9PT0gYmxvY2tLZXk7XG4gICAgICB9KS50YWtlV2hpbGUoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBrZXkgPSBibG9jay5nZXRLZXkoKTtcbiAgICAgICAgdmFyIGlzQmxvY2tUb0JlTW92ZWQgPSBrZXkgPT09IGJsb2NrS2V5O1xuICAgICAgICB2YXIgaGFzTmV4dFNpYmxpbmdBbmRJc05vdE5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmdLZXkgJiYga2V5ICE9PSBuZXh0U2libGluZ0tleTtcbiAgICAgICAgdmFyIGRvZXNOb3RIYXZlTmV4dFNpYmxpbmdBbmRJc05vdERlbGltaXRlciA9ICFuZXh0U2libGluZ0tleSAmJiBibG9jay5nZXRQYXJlbnRLZXkoKSAmJiAoIW5leHREZWxpbWl0ZXJCbG9ja0tleSB8fCBrZXkgIT09IG5leHREZWxpbWl0ZXJCbG9ja0tleSk7XG5cbiAgICAgICAgcmV0dXJuICEhKGlzQmxvY2tUb0JlTW92ZWQgfHwgaGFzTmV4dFNpYmxpbmdBbmRJc05vdE5leHRTaWJsaW5nIHx8IGRvZXNOb3RIYXZlTmV4dFNpYmxpbmdBbmRJc05vdERlbGltaXRlcik7XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICBibG9ja3NUb0JlTW92ZWQucHVzaChibG9jayk7XG4gICAgICAgIGJsb2Nrc1snZGVsZXRlJ10oYmxvY2suZ2V0S2V5KCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgYmxvY2tzQmVmb3JlID0gYmxvY2tNYXBXaXRob3V0QmxvY2tzVG9CZU1vdmVkLnRvU2VxKCkudGFrZVVudGlsKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYgPT09IHRhcmdldEJsb2NrO1xuICB9KTtcblxuICB2YXIgYmxvY2tzQWZ0ZXIgPSBibG9ja01hcFdpdGhvdXRCbG9ja3NUb0JlTW92ZWQudG9TZXEoKS5za2lwVW50aWwoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gdGFyZ2V0QmxvY2s7XG4gIH0pLnNraXAoMSk7XG5cbiAgdmFyIHNsaWNlZEJsb2NrcyA9IGJsb2Nrc1RvQmVNb3ZlZC5tYXAoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgcmV0dXJuIFtibG9jay5nZXRLZXkoKSwgYmxvY2tdO1xuICB9KTtcblxuICB2YXIgbmV3QmxvY2tzID0gT3JkZXJlZE1hcCgpO1xuXG4gIGlmIChpbnNlcnRpb25Nb2RlID09PSAnYmVmb3JlJykge1xuICAgIHZhciBibG9ja0JlZm9yZSA9IGNvbnRlbnRTdGF0ZS5nZXRCbG9ja0JlZm9yZSh0YXJnZXRLZXkpO1xuXG4gICAgISghYmxvY2tCZWZvcmUgfHwgYmxvY2tCZWZvcmUuZ2V0S2V5KCkgIT09IGJsb2NrVG9CZU1vdmVkLmdldEtleSgpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdCbG9jayBjYW5ub3QgYmUgbW92ZWQgbmV4dCB0byBpdHNlbGYuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgbmV3QmxvY2tzID0gYmxvY2tzQmVmb3JlLmNvbmNhdChbXS5jb25jYXQoc2xpY2VkQmxvY2tzLCBbW3RhcmdldEtleSwgdGFyZ2V0QmxvY2tdXSksIGJsb2Nrc0FmdGVyKS50b09yZGVyZWRNYXAoKTtcbiAgfSBlbHNlIGlmIChpbnNlcnRpb25Nb2RlID09PSAnYWZ0ZXInKSB7XG4gICAgdmFyIGJsb2NrQWZ0ZXIgPSBjb250ZW50U3RhdGUuZ2V0QmxvY2tBZnRlcih0YXJnZXRLZXkpO1xuXG4gICAgISghYmxvY2tBZnRlciB8fCBibG9ja0FmdGVyLmdldEtleSgpICE9PSBibG9ja0tleSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQmxvY2sgY2Fubm90IGJlIG1vdmVkIG5leHQgdG8gaXRzZWxmLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIG5ld0Jsb2NrcyA9IGJsb2Nrc0JlZm9yZS5jb25jYXQoW1t0YXJnZXRLZXksIHRhcmdldEJsb2NrXV0uY29uY2F0KHNsaWNlZEJsb2NrcyksIGJsb2Nrc0FmdGVyKS50b09yZGVyZWRNYXAoKTtcbiAgfVxuXG4gIHJldHVybiBjb250ZW50U3RhdGUubWVyZ2Uoe1xuICAgIGJsb2NrTWFwOiB1cGRhdGVCbG9ja01hcExpbmtzKG5ld0Jsb2NrcywgYmxvY2tUb0JlTW92ZWQsIHRhcmdldEJsb2NrLCBpbnNlcnRpb25Nb2RlLCBpc0V4cGVyaW1lbnRhbFRyZWVCbG9jayksXG4gICAgc2VsZWN0aW9uQmVmb3JlOiBjb250ZW50U3RhdGUuZ2V0U2VsZWN0aW9uQWZ0ZXIoKSxcbiAgICBzZWxlY3Rpb25BZnRlcjogY29udGVudFN0YXRlLmdldFNlbGVjdGlvbkFmdGVyKCkubWVyZ2Uoe1xuICAgICAgYW5jaG9yS2V5OiBibG9ja0tleSxcbiAgICAgIGZvY3VzS2V5OiBibG9ja0tleVxuICAgIH0pXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtb3ZlQmxvY2tJbkNvbnRlbnRTdGF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvbW92ZUJsb2NrSW5Db250ZW50U3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDQwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ29tcG9zaXRlRHJhZnREZWNvcmF0b3JcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEltbXV0YWJsZSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xuXG52YXIgTGlzdCA9IEltbXV0YWJsZS5MaXN0O1xuXG5cbnZhciBERUxJTUlURVIgPSAnLic7XG5cbi8qKlxuICogQSBDb21wb3NpdGVEcmFmdERlY29yYXRvciB0cmF2ZXJzZXMgdGhyb3VnaCBhIGxpc3Qgb2YgRHJhZnREZWNvcmF0b3JcbiAqIGluc3RhbmNlcyB0byBpZGVudGlmeSBzZWN0aW9ucyBvZiBhIENvbnRlbnRCbG9jayB0aGF0IHNob3VsZCBiZSByZW5kZXJlZFxuICogaW4gYSBcImRlY29yYXRlZFwiIG1hbm5lci4gRm9yIGV4YW1wbGUsIGhhc2h0YWdzLCBtZW50aW9ucywgYW5kIGxpbmtzIG1heVxuICogYmUgaW50ZW5kZWQgdG8gc3RhbmQgb3V0IHZpc3VhbGx5LCBiZSByZW5kZXJlZCBhcyBhbmNob3JzLCBldGMuXG4gKlxuICogVGhlIGxpc3Qgb2YgZGVjb3JhdG9ycyBzdXBwbGllZCB0byB0aGUgY29uc3RydWN0b3Igd2lsbCBiZSB1c2VkIGluIHRoZVxuICogb3JkZXIgdGhleSBhcmUgcHJvdmlkZWQuIFRoaXMgYWxsb3dzIHRoZSBjYWxsZXIgdG8gc3BlY2lmeSBhIHByaW9yaXR5IGZvclxuICogc3RyaW5nIG1hdGNoaW5nLCBpbiBjYXNlIG9mIG1hdGNoIGNvbGxpc2lvbnMgYW1vbmcgZGVjb3JhdG9ycy5cbiAqXG4gKiBGb3IgaW5zdGFuY2UsIEkgbWF5IGhhdmUgYSBsaW5rIHdpdGggYSBgI2AgaW4gaXRzIHRleHQuIFRob3VnaCB0aGlzIHNlY3Rpb25cbiAqIG9mIHRleHQgbWF5IG1hdGNoIG91ciBoYXNodGFnIGRlY29yYXRvciwgaXQgc2hvdWxkIG5vdCBiZSB0cmVhdGVkIGFzIGFcbiAqIGhhc2h0YWcuIEkgc2hvdWxkIHRoZXJlZm9yZSBsaXN0IG15IGxpbmsgRHJhZnREZWNvcmF0b3JcbiAqIGJlZm9yZSBteSBoYXNodGFnIERyYWZ0RGVjb3JhdG9yIHdoZW4gY29uc3RydWN0aW5nIHRoaXMgY29tcG9zaXRlXG4gKiBkZWNvcmF0b3IgaW5zdGFuY2UuXG4gKlxuICogVGh1cywgd2hlbiBhIGNvbGxpc2lvbiBsaWtlIHRoaXMgaXMgZW5jb3VudGVyZWQsIHRoZSBlYXJsaWVyIG1hdGNoIGlzXG4gKiBwcmVzZXJ2ZWQgYW5kIHRoZSBuZXcgbWF0Y2ggaXMgZGlzY2FyZGVkLlxuICovXG5cbnZhciBDb21wb3NpdGVEcmFmdERlY29yYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29tcG9zaXRlRHJhZnREZWNvcmF0b3IoZGVjb3JhdG9ycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wb3NpdGVEcmFmdERlY29yYXRvcik7XG5cbiAgICAvLyBDb3B5IHRoZSBkZWNvcmF0b3IgYXJyYXksIHNpbmNlIHdlIHVzZSB0aGlzIGFycmF5IG9yZGVyIHRvIGRldGVybWluZVxuICAgIC8vIHByZWNlZGVuY2Ugb2YgZGVjb3JhdGlvbiBtYXRjaGluZy4gSWYgdGhlIGFycmF5IGlzIG11dGF0ZWQgZXh0ZXJuYWxseSxcbiAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGJlIGFmZmVjdGVkIGhlcmUuXG4gICAgdGhpcy5fZGVjb3JhdG9ycyA9IGRlY29yYXRvcnMuc2xpY2UoKTtcbiAgfVxuXG4gIENvbXBvc2l0ZURyYWZ0RGVjb3JhdG9yLnByb3RvdHlwZS5nZXREZWNvcmF0aW9ucyA9IGZ1bmN0aW9uIGdldERlY29yYXRpb25zKGJsb2NrLCBjb250ZW50U3RhdGUpIHtcbiAgICB2YXIgZGVjb3JhdGlvbnMgPSBBcnJheShibG9jay5nZXRUZXh0KCkubGVuZ3RoKS5maWxsKG51bGwpO1xuXG4gICAgdGhpcy5fZGVjb3JhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICggLypvYmplY3QqL2RlY29yYXRvciwgLypudW1iZXIqL2lpKSB7XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgc3RyYXRlZ3kgPSBkZWNvcmF0b3Iuc3RyYXRlZ3k7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayggLypudW1iZXIqL3N0YXJ0LCAvKm51bWJlciovZW5kKSB7XG4gICAgICAgIC8vIEZpbmQgb3V0IGlmIGFueSBvZiBvdXIgbWF0Y2hpbmcgcmFuZ2UgaXMgYWxyZWFkeSBvY2N1cGllZFxuICAgICAgICAvLyBieSBhbm90aGVyIGRlY29yYXRvci4gSWYgc28sIGRpc2NhcmQgdGhlIG1hdGNoLiBPdGhlcndpc2UsIHN0b3JlXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQga2V5IGZvciByZW5kZXJpbmcuXG4gICAgICAgIGlmIChjYW5PY2N1cHlTbGljZShkZWNvcmF0aW9ucywgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgICBvY2N1cHlTbGljZShkZWNvcmF0aW9ucywgc3RhcnQsIGVuZCwgaWkgKyBERUxJTUlURVIgKyBjb3VudGVyKTtcbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzdHJhdGVneShibG9jaywgY2FsbGJhY2ssIGNvbnRlbnRTdGF0ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gTGlzdChkZWNvcmF0aW9ucyk7XG4gIH07XG5cbiAgQ29tcG9zaXRlRHJhZnREZWNvcmF0b3IucHJvdG90eXBlLmdldENvbXBvbmVudEZvcktleSA9IGZ1bmN0aW9uIGdldENvbXBvbmVudEZvcktleShrZXkpIHtcbiAgICB2YXIgY29tcG9uZW50S2V5ID0gcGFyc2VJbnQoa2V5LnNwbGl0KERFTElNSVRFUilbMF0sIDEwKTtcbiAgICByZXR1cm4gdGhpcy5fZGVjb3JhdG9yc1tjb21wb25lbnRLZXldLmNvbXBvbmVudDtcbiAgfTtcblxuICBDb21wb3NpdGVEcmFmdERlY29yYXRvci5wcm90b3R5cGUuZ2V0UHJvcHNGb3JLZXkgPSBmdW5jdGlvbiBnZXRQcm9wc0ZvcktleShrZXkpIHtcbiAgICB2YXIgY29tcG9uZW50S2V5ID0gcGFyc2VJbnQoa2V5LnNwbGl0KERFTElNSVRFUilbMF0sIDEwKTtcbiAgICByZXR1cm4gdGhpcy5fZGVjb3JhdG9yc1tjb21wb25lbnRLZXldLnByb3BzO1xuICB9O1xuXG4gIHJldHVybiBDb21wb3NpdGVEcmFmdERlY29yYXRvcjtcbn0oKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB3ZSBjYW4gb2NjdXB5IHRoZSBzcGVjaWZpZWQgc2xpY2Ugb2YgdGhlIGRlY29yYXRpb25zXG4gKiBhcnJheS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNhbk9jY3VweVNsaWNlKGRlY29yYXRpb25zLCBzdGFydCwgZW5kKSB7XG4gIGZvciAodmFyIGlpID0gc3RhcnQ7IGlpIDwgZW5kOyBpaSsrKSB7XG4gICAgaWYgKGRlY29yYXRpb25zW2lpXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFNwbGljZSB0aGUgc3BlY2lmaWVkIGNvbXBvbmVudCBpbnRvIG91ciBkZWNvcmF0aW9uIGFycmF5IGF0IHRoZSBkZXNpcmVkXG4gKiByYW5nZS5cbiAqL1xuZnVuY3Rpb24gb2NjdXB5U2xpY2UodGFyZ2V0QXJyLCBzdGFydCwgZW5kLCBjb21wb25lbnRLZXkpIHtcbiAgZm9yICh2YXIgaWkgPSBzdGFydDsgaWkgPCBlbmQ7IGlpKyspIHtcbiAgICB0YXJnZXRBcnJbaWldID0gY29tcG9uZW50S2V5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9zaXRlRHJhZnREZWNvcmF0b3I7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0NvbXBvc2l0ZURyYWZ0RGVjb3JhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERyYWZ0RWRpdG9yLnJlYWN0XG4gKiBAZm9ybWF0XG4gKiBcbiAqIEBwcmV2ZW50TXVuZ2VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX2V4dGVuZHMgPSBfYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBEZWZhdWx0RHJhZnRCbG9ja1JlbmRlck1hcCA9IHJlcXVpcmUoJy4vRGVmYXVsdERyYWZ0QmxvY2tSZW5kZXJNYXAnKTtcbnZhciBEZWZhdWx0RHJhZnRJbmxpbmVTdHlsZSA9IHJlcXVpcmUoJy4vRGVmYXVsdERyYWZ0SW5saW5lU3R5bGUnKTtcbnZhciBEcmFmdEVkaXRvckNvbXBvc2l0aW9uSGFuZGxlciA9IHJlcXVpcmUoJy4vRHJhZnRFZGl0b3JDb21wb3NpdGlvbkhhbmRsZXInKTtcbnZhciBEcmFmdEVkaXRvckNvbnRlbnRzID0gcmVxdWlyZSgnLi9EcmFmdEVkaXRvckNvbnRlbnRzLnJlYWN0Jyk7XG52YXIgRHJhZnRFZGl0b3JEcmFnSGFuZGxlciA9IHJlcXVpcmUoJy4vRHJhZnRFZGl0b3JEcmFnSGFuZGxlcicpO1xudmFyIERyYWZ0RWRpdG9yRWRpdEhhbmRsZXIgPSByZXF1aXJlKCcuL0RyYWZ0RWRpdG9yRWRpdEhhbmRsZXInKTtcbnZhciBEcmFmdEVkaXRvclBsYWNlaG9sZGVyID0gcmVxdWlyZSgnLi9EcmFmdEVkaXRvclBsYWNlaG9sZGVyLnJlYWN0Jyk7XG52YXIgRWRpdG9yU3RhdGUgPSByZXF1aXJlKCcuL0VkaXRvclN0YXRlJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgU2Nyb2xsID0gcmVxdWlyZSgnZmJqcy9saWIvU2Nyb2xsJyk7XG52YXIgU3R5bGUgPSByZXF1aXJlKCdmYmpzL2xpYi9TdHlsZScpO1xudmFyIFVzZXJBZ2VudCA9IHJlcXVpcmUoJ2ZianMvbGliL1VzZXJBZ2VudCcpO1xuXG52YXIgY3ggPSByZXF1aXJlKCdmYmpzL2xpYi9jeCcpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2VuZXJhdGVSYW5kb21LZXkgPSByZXF1aXJlKCcuL2dlbmVyYXRlUmFuZG9tS2V5Jyk7XG52YXIgZ2V0RGVmYXVsdEtleUJpbmRpbmcgPSByZXF1aXJlKCcuL2dldERlZmF1bHRLZXlCaW5kaW5nJyk7XG52YXIgZ2V0U2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRTY3JvbGxQb3NpdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIG51bGx0aHJvd3MgPSByZXF1aXJlKCdmYmpzL2xpYi9udWxsdGhyb3dzJyk7XG5cbnZhciBpc0lFID0gVXNlckFnZW50LmlzQnJvd3NlcignSUUnKTtcblxuLy8gSUUgZG9lcyBub3Qgc3VwcG9ydCB0aGUgYGlucHV0YCBldmVudCBvbiBjb250ZW50RWRpdGFibGUsIHNvIHdlIGNhbid0XG4vLyBvYnNlcnZlIHNwZWxsY2hlY2sgYmVoYXZpb3IuXG52YXIgYWxsb3dTcGVsbENoZWNrID0gIWlzSUU7XG5cbi8vIERlZmluZSBhIHNldCBvZiBoYW5kbGVyIG9iamVjdHMgdG8gY29ycmVzcG9uZCB0byBlYWNoIHBvc3NpYmxlIGBtb2RlYFxuLy8gb2YgZWRpdG9yIGJlaGF2aW9yLlxudmFyIGhhbmRsZXJNYXAgPSB7XG4gIGVkaXQ6IERyYWZ0RWRpdG9yRWRpdEhhbmRsZXIsXG4gIGNvbXBvc2l0ZTogRHJhZnRFZGl0b3JDb21wb3NpdGlvbkhhbmRsZXIsXG4gIGRyYWc6IERyYWZ0RWRpdG9yRHJhZ0hhbmRsZXIsXG4gIGN1dDogbnVsbCxcbiAgcmVuZGVyOiBudWxsXG59O1xuXG4vKipcbiAqIGBEcmFmdEVkaXRvcmAgaXMgdGhlIHJvb3QgZWRpdG9yIGNvbXBvbmVudC4gSXQgY29tcG9zZXMgYSBgY29udGVudEVkaXRhYmxlYFxuICogZGl2LCBhbmQgcHJvdmlkZXMgYSB3aWRlIHZhcmlldHkgb2YgdXNlZnVsIGZ1bmN0aW9uIHByb3BzIGZvciBtYW5hZ2luZyB0aGVcbiAqIHN0YXRlIG9mIHRoZSBlZGl0b3IuIFNlZSBgRHJhZnRFZGl0b3JQcm9wc2AgZm9yIGRldGFpbHMuXG4gKi9cbnZhciBEcmFmdEVkaXRvciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhEcmFmdEVkaXRvciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRHJhZnRFZGl0b3IocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhZnRFZGl0b3IpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICBfdGhpcy5mb2N1cyA9IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xuICAgICAgdmFyIGVkaXRvclN0YXRlID0gX3RoaXMucHJvcHMuZWRpdG9yU3RhdGU7XG5cbiAgICAgIHZhciBhbHJlYWR5SGFzRm9jdXMgPSBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKS5nZXRIYXNGb2N1cygpO1xuICAgICAgdmFyIGVkaXRvck5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZShfdGhpcy5lZGl0b3IpO1xuXG4gICAgICBpZiAoIWVkaXRvck5vZGUpIHtcbiAgICAgICAgLy8gb25jZSBpbiBhIHdoaWxlIHBlb3BsZSBjYWxsICdmb2N1cycgaW4gYSBzZXRUaW1lb3V0LCBhbmQgdGhlIG5vZGUgaGFzXG4gICAgICAgIC8vIGJlZW4gZGVsZXRlZCwgc28gaXQgY2FuIGJlIG51bGwgaW4gdGhhdCBjYXNlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzY3JvbGxQYXJlbnQgPSBTdHlsZS5nZXRTY3JvbGxQYXJlbnQoZWRpdG9yTm9kZSk7XG5cbiAgICAgIHZhciBfcmVmID0gc2Nyb2xsUG9zaXRpb24gfHwgZ2V0U2Nyb2xsUG9zaXRpb24oc2Nyb2xsUGFyZW50KSxcbiAgICAgICAgICB4ID0gX3JlZi54LFxuICAgICAgICAgIHkgPSBfcmVmLnk7XG5cbiAgICAgICEoZWRpdG9yTm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdlZGl0b3JOb2RlIGlzIG5vdCBhbiBIVE1MRWxlbWVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIGVkaXRvck5vZGUuZm9jdXMoKTtcblxuICAgICAgLy8gUmVzdG9yZSBzY3JvbGwgcG9zaXRpb25cbiAgICAgIGlmIChzY3JvbGxQYXJlbnQgPT09IHdpbmRvdykge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oeCwgeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBTY3JvbGwuc2V0VG9wKHNjcm9sbFBhcmVudCwgeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE9uIENocm9tZSBhbmQgU2FmYXJpLCBjYWxsaW5nIGZvY3VzIG9uIGNvbnRlbnRlZGl0YWJsZSBmb2N1c2VzIHRoZVxuICAgICAgLy8gY3Vyc29yIGF0IHRoZSBmaXJzdCBjaGFyYWN0ZXIuIFRoaXMgaXMgc29tZXRoaW5nIHlvdSBkb24ndCBleHBlY3Qgd2hlblxuICAgICAgLy8geW91J3JlIGNsaWNraW5nIG9uIGFuIGlucHV0IGVsZW1lbnQgYnV0IG5vdCBkaXJlY3RseSBvbiBhIGNoYXJhY3Rlci5cbiAgICAgIC8vIFB1dCB0aGUgY3Vyc29yIGJhY2sgd2hlcmUgaXQgd2FzIGJlZm9yZSB0aGUgYmx1ci5cbiAgICAgIGlmICghYWxyZWFkeUhhc0ZvY3VzKSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZShFZGl0b3JTdGF0ZS5mb3JjZVNlbGVjdGlvbihlZGl0b3JTdGF0ZSwgZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCkpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuYmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlZGl0b3JOb2RlID0gUmVhY3RET00uZmluZERPTU5vZGUoX3RoaXMuZWRpdG9yKTtcbiAgICAgICEoZWRpdG9yTm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdlZGl0b3JOb2RlIGlzIG5vdCBhbiBIVE1MRWxlbWVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIGVkaXRvck5vZGUuYmx1cigpO1xuICAgIH07XG5cbiAgICBfdGhpcy5zZXRNb2RlID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICAgIF90aGlzLl9oYW5kbGVyID0gaGFuZGxlck1hcFttb2RlXTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZXhpdEN1cnJlbnRNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0TW9kZSgnZWRpdCcpO1xuICAgIH07XG5cbiAgICBfdGhpcy5yZXN0b3JlRWRpdG9yRE9NID0gZnVuY3Rpb24gKHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7IGNvbnRlbnRzS2V5OiBfdGhpcy5zdGF0ZS5jb250ZW50c0tleSArIDEgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5mb2N1cyhzY3JvbGxQb3NpdGlvbik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuc2V0Q2xpcGJvYXJkID0gZnVuY3Rpb24gKGNsaXBib2FyZCkge1xuICAgICAgX3RoaXMuX2NsaXBib2FyZCA9IGNsaXBib2FyZDtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0Q2xpcGJvYXJkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLl9jbGlwYm9hcmQ7XG4gICAgfTtcblxuICAgIF90aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIChlZGl0b3JTdGF0ZSkge1xuICAgICAgX3RoaXMuX2xhdGVzdEVkaXRvclN0YXRlID0gZWRpdG9yU3RhdGU7XG4gICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZShlZGl0b3JTdGF0ZSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uRHJhZ0VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX2RyYWdDb3VudCsrO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkRyYWdMZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9kcmFnQ291bnQtLTtcbiAgICAgIGlmIChfdGhpcy5fZHJhZ0NvdW50ID09PSAwKSB7XG4gICAgICAgIF90aGlzLmV4aXRDdXJyZW50TW9kZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5fYmxvY2tTZWxlY3RFdmVudHMgPSBmYWxzZTtcbiAgICBfdGhpcy5fY2xpcGJvYXJkID0gbnVsbDtcbiAgICBfdGhpcy5faGFuZGxlciA9IG51bGw7XG4gICAgX3RoaXMuX2RyYWdDb3VudCA9IDA7XG4gICAgX3RoaXMuX2VkaXRvcktleSA9IHByb3BzLmVkaXRvcktleSB8fCBnZW5lcmF0ZVJhbmRvbUtleSgpO1xuICAgIF90aGlzLl9wbGFjZWhvbGRlckFjY2Vzc2liaWxpdHlJRCA9ICdwbGFjZWhvbGRlci0nICsgX3RoaXMuX2VkaXRvcktleTtcbiAgICBfdGhpcy5fbGF0ZXN0RWRpdG9yU3RhdGUgPSBwcm9wcy5lZGl0b3JTdGF0ZTtcbiAgICBfdGhpcy5fbGF0ZXN0Q29tbWl0dGVkRWRpdG9yU3RhdGUgPSBwcm9wcy5lZGl0b3JTdGF0ZTtcblxuICAgIF90aGlzLl9vbkJlZm9yZUlucHV0ID0gX3RoaXMuX2J1aWxkSGFuZGxlcignb25CZWZvcmVJbnB1dCcpO1xuICAgIF90aGlzLl9vbkJsdXIgPSBfdGhpcy5fYnVpbGRIYW5kbGVyKCdvbkJsdXInKTtcbiAgICBfdGhpcy5fb25DaGFyYWN0ZXJEYXRhID0gX3RoaXMuX2J1aWxkSGFuZGxlcignb25DaGFyYWN0ZXJEYXRhJyk7XG4gICAgX3RoaXMuX29uQ29tcG9zaXRpb25FbmQgPSBfdGhpcy5fYnVpbGRIYW5kbGVyKCdvbkNvbXBvc2l0aW9uRW5kJyk7XG4gICAgX3RoaXMuX29uQ29tcG9zaXRpb25TdGFydCA9IF90aGlzLl9idWlsZEhhbmRsZXIoJ29uQ29tcG9zaXRpb25TdGFydCcpO1xuICAgIF90aGlzLl9vbkNvcHkgPSBfdGhpcy5fYnVpbGRIYW5kbGVyKCdvbkNvcHknKTtcbiAgICBfdGhpcy5fb25DdXQgPSBfdGhpcy5fYnVpbGRIYW5kbGVyKCdvbkN1dCcpO1xuICAgIF90aGlzLl9vbkRyYWdFbmQgPSBfdGhpcy5fYnVpbGRIYW5kbGVyKCdvbkRyYWdFbmQnKTtcbiAgICBfdGhpcy5fb25EcmFnT3ZlciA9IF90aGlzLl9idWlsZEhhbmRsZXIoJ29uRHJhZ092ZXInKTtcbiAgICBfdGhpcy5fb25EcmFnU3RhcnQgPSBfdGhpcy5fYnVpbGRIYW5kbGVyKCdvbkRyYWdTdGFydCcpO1xuICAgIF90aGlzLl9vbkRyb3AgPSBfdGhpcy5fYnVpbGRIYW5kbGVyKCdvbkRyb3AnKTtcbiAgICBfdGhpcy5fb25JbnB1dCA9IF90aGlzLl9idWlsZEhhbmRsZXIoJ29uSW5wdXQnKTtcbiAgICBfdGhpcy5fb25Gb2N1cyA9IF90aGlzLl9idWlsZEhhbmRsZXIoJ29uRm9jdXMnKTtcbiAgICBfdGhpcy5fb25LZXlEb3duID0gX3RoaXMuX2J1aWxkSGFuZGxlcignb25LZXlEb3duJyk7XG4gICAgX3RoaXMuX29uS2V5UHJlc3MgPSBfdGhpcy5fYnVpbGRIYW5kbGVyKCdvbktleVByZXNzJyk7XG4gICAgX3RoaXMuX29uS2V5VXAgPSBfdGhpcy5fYnVpbGRIYW5kbGVyKCdvbktleVVwJyk7XG4gICAgX3RoaXMuX29uTW91c2VEb3duID0gX3RoaXMuX2J1aWxkSGFuZGxlcignb25Nb3VzZURvd24nKTtcbiAgICBfdGhpcy5fb25Nb3VzZVVwID0gX3RoaXMuX2J1aWxkSGFuZGxlcignb25Nb3VzZVVwJyk7XG4gICAgX3RoaXMuX29uUGFzdGUgPSBfdGhpcy5fYnVpbGRIYW5kbGVyKCdvblBhc3RlJyk7XG4gICAgX3RoaXMuX29uU2VsZWN0ID0gX3RoaXMuX2J1aWxkSGFuZGxlcignb25TZWxlY3QnKTtcblxuICAgIF90aGlzLmdldEVkaXRvcktleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fZWRpdG9yS2V5O1xuICAgIH07XG5cbiAgICAvLyBTZWUgYHJlc3RvcmVFZGl0b3JET00oKWAuXG4gICAgX3RoaXMuc3RhdGUgPSB7IGNvbnRlbnRzS2V5OiAwIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgbWV0aG9kIHRoYXQgd2lsbCBwYXNzIHRoZSBldmVudCB0byB0aGUgc3BlY2lmaWVkIGhhbmRsZXIgbWV0aG9kLlxuICAgKiBUaGlzIGFsbG93cyB1cyB0byBsb29rIHVwIHRoZSBjb3JyZWN0IGhhbmRsZXIgZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50XG4gICAqIGVkaXRvciBtb2RlLCBpZiBhbnkgaGFzIGJlZW4gc3BlY2lmaWVkLlxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBEZWZpbmUgcHJveGllcyB0aGF0IGNhbiByb3V0ZSBldmVudHMgdG8gdGhlIGN1cnJlbnQgaGFuZGxlci5cbiAgICovXG5cblxuICBEcmFmdEVkaXRvci5wcm90b3R5cGUuX2J1aWxkSGFuZGxlciA9IGZ1bmN0aW9uIF9idWlsZEhhbmRsZXIoZXZlbnROYW1lKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghX3RoaXMyLnByb3BzLnJlYWRPbmx5KSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBfdGhpczIuX2hhbmRsZXIgJiYgX3RoaXMyLl9oYW5kbGVyW2V2ZW50TmFtZV07XG4gICAgICAgIG1ldGhvZCAmJiBtZXRob2QoX3RoaXMyLCBlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIERyYWZ0RWRpdG9yLnByb3RvdHlwZS5fc2hvd1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gX3Nob3dQbGFjZWhvbGRlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLnByb3BzLnBsYWNlaG9sZGVyICYmICF0aGlzLnByb3BzLmVkaXRvclN0YXRlLmlzSW5Db21wb3NpdGlvbk1vZGUoKSAmJiAhdGhpcy5wcm9wcy5lZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpLmhhc1RleHQoKTtcbiAgfTtcblxuICBEcmFmdEVkaXRvci5wcm90b3R5cGUuX3JlbmRlclBsYWNlaG9sZGVyID0gZnVuY3Rpb24gX3JlbmRlclBsYWNlaG9sZGVyKCkge1xuICAgIGlmICh0aGlzLl9zaG93UGxhY2Vob2xkZXIoKSkge1xuICAgICAgdmFyIHBsYWNlSG9sZGVyUHJvcHMgPSB7XG4gICAgICAgIHRleHQ6IG51bGx0aHJvd3ModGhpcy5wcm9wcy5wbGFjZWhvbGRlciksXG4gICAgICAgIGVkaXRvclN0YXRlOiB0aGlzLnByb3BzLmVkaXRvclN0YXRlLFxuICAgICAgICB0ZXh0QWxpZ25tZW50OiB0aGlzLnByb3BzLnRleHRBbGlnbm1lbnQsXG4gICAgICAgIGFjY2Vzc2liaWxpdHlJRDogdGhpcy5fcGxhY2Vob2xkZXJBY2Nlc3NpYmlsaXR5SURcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERyYWZ0RWRpdG9yUGxhY2Vob2xkZXIsIHBsYWNlSG9sZGVyUHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBEcmFmdEVkaXRvci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGJsb2NrUmVuZGVyTWFwID0gX3Byb3BzLmJsb2NrUmVuZGVyTWFwLFxuICAgICAgICBibG9ja1JlbmRlcmVyRm4gPSBfcHJvcHMuYmxvY2tSZW5kZXJlckZuLFxuICAgICAgICBibG9ja1N0eWxlRm4gPSBfcHJvcHMuYmxvY2tTdHlsZUZuLFxuICAgICAgICBjdXN0b21TdHlsZUZuID0gX3Byb3BzLmN1c3RvbVN0eWxlRm4sXG4gICAgICAgIGN1c3RvbVN0eWxlTWFwID0gX3Byb3BzLmN1c3RvbVN0eWxlTWFwLFxuICAgICAgICBlZGl0b3JTdGF0ZSA9IF9wcm9wcy5lZGl0b3JTdGF0ZSxcbiAgICAgICAgcmVhZE9ubHkgPSBfcHJvcHMucmVhZE9ubHksXG4gICAgICAgIHRleHRBbGlnbm1lbnQgPSBfcHJvcHMudGV4dEFsaWdubWVudCxcbiAgICAgICAgdGV4dERpcmVjdGlvbmFsaXR5ID0gX3Byb3BzLnRleHREaXJlY3Rpb25hbGl0eTtcblxuXG4gICAgdmFyIHJvb3RDbGFzcyA9IGN4KHtcbiAgICAgICdEcmFmdEVkaXRvci9yb290JzogdHJ1ZSxcbiAgICAgICdEcmFmdEVkaXRvci9hbGlnbkxlZnQnOiB0ZXh0QWxpZ25tZW50ID09PSAnbGVmdCcsXG4gICAgICAnRHJhZnRFZGl0b3IvYWxpZ25SaWdodCc6IHRleHRBbGlnbm1lbnQgPT09ICdyaWdodCcsXG4gICAgICAnRHJhZnRFZGl0b3IvYWxpZ25DZW50ZXInOiB0ZXh0QWxpZ25tZW50ID09PSAnY2VudGVyJ1xuICAgIH0pO1xuXG4gICAgdmFyIGNvbnRlbnRTdHlsZSA9IHtcbiAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgIC8vIGZpeCBwYXJlbnQtZHJhZ2dhYmxlIFNhZmFyaSBidWcuICMxMzI2XG4gICAgICB1c2VyU2VsZWN0OiAndGV4dCcsXG4gICAgICBXZWJraXRVc2VyU2VsZWN0OiAndGV4dCcsXG4gICAgICB3aGl0ZVNwYWNlOiAncHJlLXdyYXAnLFxuICAgICAgd29yZFdyYXA6ICdicmVhay13b3JkJ1xuICAgIH07XG5cbiAgICAvLyBUaGUgYXJpYS1leHBhbmRlZCBhbmQgYXJpYS1oYXNwb3B1cCBwcm9wZXJ0aWVzIHNob3VsZCBvbmx5IGJlIHJlbmRlcmVkXG4gICAgLy8gZm9yIGEgY29tYm9ib3guXG4gICAgdmFyIGFyaWFSb2xlID0gdGhpcy5wcm9wcy5yb2xlIHx8ICd0ZXh0Ym94JztcbiAgICB2YXIgYXJpYUV4cGFuZGVkID0gYXJpYVJvbGUgPT09ICdjb21ib2JveCcgPyAhIXRoaXMucHJvcHMuYXJpYUV4cGFuZGVkIDogbnVsbDtcblxuICAgIHZhciBlZGl0b3JDb250ZW50c1Byb3BzID0ge1xuICAgICAgYmxvY2tSZW5kZXJNYXA6IGJsb2NrUmVuZGVyTWFwLFxuICAgICAgYmxvY2tSZW5kZXJlckZuOiBibG9ja1JlbmRlcmVyRm4sXG4gICAgICBibG9ja1N0eWxlRm46IGJsb2NrU3R5bGVGbixcbiAgICAgIGN1c3RvbVN0eWxlTWFwOiBfZXh0ZW5kcyh7fSwgRGVmYXVsdERyYWZ0SW5saW5lU3R5bGUsIGN1c3RvbVN0eWxlTWFwKSxcbiAgICAgIGN1c3RvbVN0eWxlRm46IGN1c3RvbVN0eWxlRm4sXG4gICAgICBlZGl0b3JLZXk6IHRoaXMuX2VkaXRvcktleSxcbiAgICAgIGVkaXRvclN0YXRlOiBlZGl0b3JTdGF0ZSxcbiAgICAgIGtleTogJ2NvbnRlbnRzJyArIHRoaXMuc3RhdGUuY29udGVudHNLZXksXG4gICAgICB0ZXh0RGlyZWN0aW9uYWxpdHk6IHRleHREaXJlY3Rpb25hbGl0eVxuICAgIH07XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBjbGFzc05hbWU6IHJvb3RDbGFzcyB9LFxuICAgICAgdGhpcy5fcmVuZGVyUGxhY2Vob2xkZXIoKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBjeCgnRHJhZnRFZGl0b3IvZWRpdG9yQ29udGFpbmVyJyksXG4gICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYoX3JlZjMpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuZWRpdG9yQ29udGFpbmVyID0gX3JlZjM7XG4gICAgICAgICAgfSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiByZWFkT25seSA/IG51bGwgOiB0aGlzLnByb3BzLmFyaWFBY3RpdmVEZXNjZW5kYW50SUQsXG4gICAgICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiByZWFkT25seSA/IG51bGwgOiB0aGlzLnByb3BzLmFyaWFBdXRvQ29tcGxldGUsXG4gICAgICAgICAgICAnYXJpYS1jb250cm9scyc6IHJlYWRPbmx5ID8gbnVsbCA6IHRoaXMucHJvcHMuYXJpYUNvbnRyb2xzLFxuICAgICAgICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiB0aGlzLnByb3BzLmFyaWFEZXNjcmliZWRCeSB8fCB0aGlzLl9wbGFjZWhvbGRlckFjY2Vzc2liaWxpdHlJRCxcbiAgICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogcmVhZE9ubHkgPyBudWxsIDogYXJpYUV4cGFuZGVkLFxuICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiB0aGlzLnByb3BzLmFyaWFMYWJlbCxcbiAgICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiB0aGlzLnByb3BzLmFyaWFMYWJlbGxlZEJ5LFxuICAgICAgICAgICAgJ2FyaWEtbXVsdGlsaW5lJzogdGhpcy5wcm9wcy5hcmlhTXVsdGlsaW5lLFxuICAgICAgICAgICAgYXV0b0NhcGl0YWxpemU6IHRoaXMucHJvcHMuYXV0b0NhcGl0YWxpemUsXG4gICAgICAgICAgICBhdXRvQ29tcGxldGU6IHRoaXMucHJvcHMuYXV0b0NvbXBsZXRlLFxuICAgICAgICAgICAgYXV0b0NvcnJlY3Q6IHRoaXMucHJvcHMuYXV0b0NvcnJlY3QsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGN4KHtcbiAgICAgICAgICAgICAgLy8gQ2hyb21lJ3MgYnVpbHQtaW4gdHJhbnNsYXRpb24gZmVhdHVyZSBtdXRhdGVzIHRoZSBET00gaW4gd2F5c1xuICAgICAgICAgICAgICAvLyB0aGF0IERyYWZ0IGRvZXNuJ3QgZXhwZWN0IChleDogYWRkaW5nIDxmb250PiB0YWdzIGluc2lkZVxuICAgICAgICAgICAgICAvLyBEcmFmdEVkaXRvckxlYWYgc3BhbnMpIGFuZCBjYXVzZXMgcHJvYmxlbXMuIFdlIGFkZCBub3RyYW5zbGF0ZVxuICAgICAgICAgICAgICAvLyBoZXJlIHdoaWNoIG1ha2VzIGl0cyBhdXRvdHJhbnNsYXRpb24gc2tpcCBvdmVyIHRoaXMgc3VidHJlZS5cbiAgICAgICAgICAgICAgbm90cmFuc2xhdGU6ICFyZWFkT25seSxcbiAgICAgICAgICAgICAgJ3B1YmxpYy9EcmFmdEVkaXRvci9jb250ZW50JzogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjb250ZW50RWRpdGFibGU6ICFyZWFkT25seSxcbiAgICAgICAgICAgICdkYXRhLXRlc3RpZCc6IHRoaXMucHJvcHMud2ViRHJpdmVyVGVzdElELFxuICAgICAgICAgICAgb25CZWZvcmVJbnB1dDogdGhpcy5fb25CZWZvcmVJbnB1dCxcbiAgICAgICAgICAgIG9uQmx1cjogdGhpcy5fb25CbHVyLFxuICAgICAgICAgICAgb25Db21wb3NpdGlvbkVuZDogdGhpcy5fb25Db21wb3NpdGlvbkVuZCxcbiAgICAgICAgICAgIG9uQ29tcG9zaXRpb25TdGFydDogdGhpcy5fb25Db21wb3NpdGlvblN0YXJ0LFxuICAgICAgICAgICAgb25Db3B5OiB0aGlzLl9vbkNvcHksXG4gICAgICAgICAgICBvbkN1dDogdGhpcy5fb25DdXQsXG4gICAgICAgICAgICBvbkRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZCxcbiAgICAgICAgICAgIG9uRHJhZ0VudGVyOiB0aGlzLm9uRHJhZ0VudGVyLFxuICAgICAgICAgICAgb25EcmFnTGVhdmU6IHRoaXMub25EcmFnTGVhdmUsXG4gICAgICAgICAgICBvbkRyYWdPdmVyOiB0aGlzLl9vbkRyYWdPdmVyLFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICAgICAgICAgICAgb25Ecm9wOiB0aGlzLl9vbkRyb3AsXG4gICAgICAgICAgICBvbkZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuICAgICAgICAgICAgb25JbnB1dDogdGhpcy5fb25JbnB1dCxcbiAgICAgICAgICAgIG9uS2V5RG93bjogdGhpcy5fb25LZXlEb3duLFxuICAgICAgICAgICAgb25LZXlQcmVzczogdGhpcy5fb25LZXlQcmVzcyxcbiAgICAgICAgICAgIG9uS2V5VXA6IHRoaXMuX29uS2V5VXAsXG4gICAgICAgICAgICBvbk1vdXNlVXA6IHRoaXMuX29uTW91c2VVcCxcbiAgICAgICAgICAgIG9uUGFzdGU6IHRoaXMuX29uUGFzdGUsXG4gICAgICAgICAgICBvblNlbGVjdDogdGhpcy5fb25TZWxlY3QsXG4gICAgICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmMikge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLmVkaXRvciA9IF9yZWYyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvbGU6IHJlYWRPbmx5ID8gbnVsbCA6IGFyaWFSb2xlLFxuICAgICAgICAgICAgc3BlbGxDaGVjazogYWxsb3dTcGVsbENoZWNrICYmIHRoaXMucHJvcHMuc3BlbGxDaGVjayxcbiAgICAgICAgICAgIHN0eWxlOiBjb250ZW50U3R5bGUsXG4gICAgICAgICAgICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gICAgICAgICAgICB0YWJJbmRleDogdGhpcy5wcm9wcy50YWJJbmRleCB9LFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJhZnRFZGl0b3JDb250ZW50cywgZWRpdG9yQ29udGVudHNQcm9wcylcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgRHJhZnRFZGl0b3IucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zZXRNb2RlKCdlZGl0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBJRSBoYXMgYSBoYXJkY29kZWQgXCJmZWF0dXJlXCIgdGhhdCBhdHRlbXB0cyB0byBjb252ZXJ0IGxpbmsgdGV4dCBpbnRvXG4gICAgICogYW5jaG9ycyBpbiBjb250ZW50RWRpdGFibGUgRE9NLiBUaGlzIGJyZWFrcyB0aGUgZWRpdG9yJ3MgZXhwZWN0YXRpb25zIG9mXG4gICAgICogdGhlIERPTSwgYW5kIGNvbnRyb2wgaXMgbG9zdC4gRGlzYWJsZSBpdCB0byBtYWtlIElFIGJlaGF2ZS5cbiAgICAgKiBTZWU6IGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wOS8xNS9cbiAgICAgKiBpZTktYmV0YS1taW5vci1jaGFuZ2UtbGlzdC5hc3B4XG4gICAgICovXG4gICAgaWYgKGlzSUUpIHtcbiAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdBdXRvVXJsRGV0ZWN0JywgZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByZXZlbnQgc2VsZWN0aW9uIGV2ZW50cyBmcm9tIGFmZmVjdGluZyB0aGUgY3VycmVudCBlZGl0b3Igc3RhdGUuIFRoaXNcbiAgICogaXMgbW9zdGx5IGludGVuZGVkIHRvIGRlZmVuZCBhZ2FpbnN0IElFLCB3aGljaCBmaXJlcyBvZmYgYHNlbGVjdGlvbmNoYW5nZWBcbiAgICogZXZlbnRzIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIHNldCB2aWEgdGhlIGJyb3dzZXIgb3JcbiAgICogcHJvZ3JhbW1hdGljYWxseS4gV2Ugb25seSBjYXJlIGFib3V0IHNlbGVjdGlvbiBldmVudHMgdGhhdCBvY2N1ciBiZWNhdXNlXG4gICAqIG9mIGJyb3dzZXIgaW50ZXJhY3Rpb24sIG5vdCByZS1yZW5kZXJzIGFuZCBmb3JjZWQgc2VsZWN0aW9ucy5cbiAgICovXG5cblxuICBEcmFmdEVkaXRvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgdGhpcy5fYmxvY2tTZWxlY3RFdmVudHMgPSB0cnVlO1xuICAgIHRoaXMuX2xhdGVzdEVkaXRvclN0YXRlID0gbmV4dFByb3BzLmVkaXRvclN0YXRlO1xuICB9O1xuXG4gIERyYWZ0RWRpdG9yLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5fYmxvY2tTZWxlY3RFdmVudHMgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXRlc3RDb21taXR0ZWRFZGl0b3JTdGF0ZSA9IHRoaXMucHJvcHMuZWRpdG9yU3RhdGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVzZWQgdmlhIGB0aGlzLmZvY3VzKClgLlxuICAgKlxuICAgKiBGb3JjZSBmb2N1cyBiYWNrIG9udG8gdGhlIGVkaXRvciBub2RlLlxuICAgKlxuICAgKiBXZSBhdHRlbXB0IHRvIHByZXNlcnZlIHNjcm9sbCBwb3NpdGlvbiB3aGVuIGZvY3VzaW5nLiBZb3UgY2FuIGFsc28gcGFzc1xuICAgKiBhIHNwZWNpZmllZCBzY3JvbGwgcG9zaXRpb24gKGZvciBjYXNlcyBsaWtlIGBjdXRgIGJlaGF2aW9yIHdoZXJlIGl0IHNob3VsZFxuICAgKiBiZSByZXN0b3JlZCB0byBhIGtub3duIHBvc2l0aW9uKS5cbiAgICovXG5cblxuICAvKipcbiAgICogVXNlZCB2aWEgYHRoaXMuc2V0TW9kZSguLi4pYC5cbiAgICpcbiAgICogU2V0IHRoZSBiZWhhdmlvciBtb2RlIGZvciB0aGUgZWRpdG9yIGNvbXBvbmVudC4gVGhpcyBzd2l0Y2hlcyB0aGUgY3VycmVudFxuICAgKiBoYW5kbGVyIG1vZHVsZSB0byBlbnN1cmUgdGhhdCBET00gZXZlbnRzIGFyZSBtYW5hZ2VkIGFwcHJvcHJpYXRlbHkgZm9yXG4gICAqIHRoZSBhY3RpdmUgbW9kZS5cbiAgICovXG5cblxuICAvKipcbiAgICogVXNlZCB2aWEgYHRoaXMucmVzdG9yZUVkaXRvckRPTSgpYC5cbiAgICpcbiAgICogRm9yY2UgYSBjb21wbGV0ZSByZS1yZW5kZXIgb2YgdGhlIERyYWZ0RWRpdG9yQ29udGVudHMgYmFzZWQgb24gdGhlIGN1cnJlbnRcbiAgICogRWRpdG9yU3RhdGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gd2Uga25vdyB3ZSBhcmUgZ29pbmcgdG8gbG9zZSBjb250cm9sIG9mXG4gICAqIHRoZSBET00gc3RhdGUgKGN1dCBjb21tYW5kLCBJTUUpIGFuZCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAqIHJlY29uY2lsaWF0aW9uIG9jY3VycyBvbiBhIHZlcnNpb24gb2YgdGhlIERPTSB0aGF0IGlzIHN5bmNocm9uaXplZCB3aXRoXG4gICAqIG91ciBFZGl0b3JTdGF0ZS5cbiAgICovXG5cblxuICAvKipcbiAgICogVXNlZCB2aWEgYHRoaXMuc2V0Q2xpcGJvYXJkKC4uLilgLlxuICAgKlxuICAgKiBTZXQgdGhlIGNsaXBib2FyZCBzdGF0ZSBmb3IgYSBjdXQvY29weSBldmVudC5cbiAgICovXG5cblxuICAvKipcbiAgICogVXNlZCB2aWEgYHRoaXMuZ2V0Q2xpcGJvYXJkKClgLlxuICAgKlxuICAgKiBSZXRyaWV2ZSB0aGUgY2xpcGJvYXJkIHN0YXRlIGZvciBhIGN1dC9jb3B5IGV2ZW50LlxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBVc2VkIHZpYSBgdGhpcy51cGRhdGUoLi4uKWAuXG4gICAqXG4gICAqIFByb3BhZ2F0ZSBhIG5ldyBgRWRpdG9yU3RhdGVgIG9iamVjdCB0byBoaWdoZXItbGV2ZWwgY29tcG9uZW50cy4gVGhpcyBpc1xuICAgKiB0aGUgbWV0aG9kIGJ5IHdoaWNoIGV2ZW50IGhhbmRsZXJzIGluZm9ybSB0aGUgYERyYWZ0RWRpdG9yYCBjb21wb25lbnQgb2ZcbiAgICogc3RhdGUgY2hhbmdlcy4gQSBjb21wb25lbnQgdGhhdCBjb21wb3NlcyBhIGBEcmFmdEVkaXRvcmAgKiptdXN0KiogcHJvdmlkZVxuICAgKiBhbiBgb25DaGFuZ2VgIHByb3AgdG8gcmVjZWl2ZSBzdGF0ZSB1cGRhdGVzIHBhc3NlZCBhbG9uZyBmcm9tIHRoaXNcbiAgICogZnVuY3Rpb24uXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIFVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgb25EcmFnTGVhdmUoKWAsIGJ5IGNvdW50aW5nIHRoZSBudW1iZXIgb2YgdGltZXNcbiAgICogYSBkcmFnZ2VkIGVsZW1lbnQgZW50ZXJzIGFuZCBsZWF2ZXMgdGhlIGVkaXRvciAob3IgYW55IG9mIGl0cyBjaGlsZHJlbiksXG4gICAqIHRvIGRldGVybWluZSB3aGVuIHRoZSBkcmFnZ2VkIGVsZW1lbnQgYWJzb2x1dGVseSBsZWF2ZXMgdGhlIGVkaXRvci5cbiAgICovXG5cblxuICAvKipcbiAgICogU2VlIGBvbkRyYWdFbnRlcigpYC5cbiAgICovXG5cblxuICByZXR1cm4gRHJhZnRFZGl0b3I7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkRyYWZ0RWRpdG9yLmRlZmF1bHRQcm9wcyA9IHtcbiAgYmxvY2tSZW5kZXJNYXA6IERlZmF1bHREcmFmdEJsb2NrUmVuZGVyTWFwLFxuICBibG9ja1JlbmRlcmVyRm46IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBibG9ja1N0eWxlRm46IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMoJycpLFxuICBrZXlCaW5kaW5nRm46IGdldERlZmF1bHRLZXlCaW5kaW5nLFxuICByZWFkT25seTogZmFsc2UsXG4gIHNwZWxsQ2hlY2s6IGZhbHNlLFxuICBzdHJpcFBhc3RlZFN0eWxlczogZmFsc2Vcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEcmFmdEVkaXRvcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRHJhZnRFZGl0b3IucmVhY3QuanNcbi8vIG1vZHVsZSBpZCA9IDQwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRHJhZnRFZGl0b3JDb21wb3NpdGlvbkhhbmRsZXJcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERyYWZ0RmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9EcmFmdEZlYXR1cmVGbGFncycpO1xudmFyIERyYWZ0TW9kaWZpZXIgPSByZXF1aXJlKCcuL0RyYWZ0TW9kaWZpZXInKTtcbnZhciBFZGl0b3JTdGF0ZSA9IHJlcXVpcmUoJy4vRWRpdG9yU3RhdGUnKTtcbnZhciBLZXlzID0gcmVxdWlyZSgnZmJqcy9saWIvS2V5cycpO1xuXG52YXIgZ2V0RW50aXR5S2V5Rm9yU2VsZWN0aW9uID0gcmVxdWlyZSgnLi9nZXRFbnRpdHlLZXlGb3JTZWxlY3Rpb24nKTtcbnZhciBpc0V2ZW50SGFuZGxlZCA9IHJlcXVpcmUoJy4vaXNFdmVudEhhbmRsZWQnKTtcbnZhciBpc1NlbGVjdGlvbkF0TGVhZlN0YXJ0ID0gcmVxdWlyZSgnLi9pc1NlbGVjdGlvbkF0TGVhZlN0YXJ0Jyk7XG5cbi8qKlxuICogTWlsbGlzZWNvbmQgZGVsYXkgdG8gYWxsb3cgYGNvbXBvc2l0aW9uc3RhcnRgIHRvIGZpcmUgYWdhaW4gdXBvblxuICogYGNvbXBvc2l0aW9uZW5kYC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgZm9yIEtvcmVhbiBpbnB1dCB0byBlbnN1cmUgdGhhdCB0eXBpbmcgY2FuIGNvbnRpbnVlIHdpdGhvdXRcbiAqIHRoZSBlZGl0b3IgdHJ5aW5nIHRvIHJlbmRlciB0b28gcXVpY2tseS4gTW9yZSBzcGVjaWZpY2FsbHksIFNhZmFyaSA3LjErXG4gKiB0cmlnZ2VycyBgY29tcG9zaXRpb25zdGFydGAgYSBsaXR0bGUgc2xvd2VyIHRoYW4gQ2hyb21lL0ZGLCB3aGljaFxuICogbGVhZHMgdG8gY29tcG9zZWQgY2hhcmFjdGVycyBiZWluZyByZXNvbHZlZCBhbmQgcmUtcmVuZGVyIG9jY3VycmluZ1xuICogc29vbmVyIHRoYW4gd2Ugd2FudC5cbiAqL1xudmFyIFJFU09MVkVfREVMQVkgPSAyMDtcblxuLyoqXG4gKiBBIGhhbmRmdWwgb2YgdmFyaWFibGVzIHVzZWQgdG8gdHJhY2sgdGhlIGN1cnJlbnQgY29tcG9zaXRpb24gYW5kIGl0c1xuICogcmVzb2x1dGlvbiBzdGF0dXMuIFRoZXNlIGV4aXN0IGF0IHRoZSBtb2R1bGUgbGV2ZWwgYmVjYXVzZSBpdCBpcyBub3RcbiAqIHBvc3NpYmxlIHRvIGhhdmUgY29tcG9zaXRpb25zIG9jY3VycmluZyBpbiBtdWx0aXBsZSBlZGl0b3JzIHNpbXVsdGFuZW91c2x5LFxuICogYW5kIGl0IHNpbXBsaWZpZXMgc3RhdGUgbWFuYWdlbWVudCB3aXRoIHJlc3BlY3QgdG8gdGhlIERyYWZ0RWRpdG9yIGNvbXBvbmVudC5cbiAqL1xudmFyIHJlc29sdmVkID0gZmFsc2U7XG52YXIgc3RpbGxDb21wb3NpbmcgPSBmYWxzZTtcbnZhciB0ZXh0SW5wdXREYXRhID0gJyc7XG5cbnZhciBEcmFmdEVkaXRvckNvbXBvc2l0aW9uSGFuZGxlciA9IHtcbiAgb25CZWZvcmVJbnB1dDogZnVuY3Rpb24gb25CZWZvcmVJbnB1dChlZGl0b3IsIGUpIHtcbiAgICB0ZXh0SW5wdXREYXRhID0gKHRleHRJbnB1dERhdGEgfHwgJycpICsgZS5kYXRhO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBIGBjb21wb3NpdGlvbnN0YXJ0YCBldmVudCBoYXMgZmlyZWQgd2hpbGUgd2UncmUgc3RpbGwgaW4gY29tcG9zaXRpb25cbiAgICogbW9kZS4gQ29udGludWUgdGhlIGN1cnJlbnQgY29tcG9zaXRpb24gc2Vzc2lvbiB0byBwcmV2ZW50IGEgcmUtcmVuZGVyLlxuICAgKi9cbiAgb25Db21wb3NpdGlvblN0YXJ0OiBmdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZWRpdG9yKSB7XG4gICAgc3RpbGxDb21wb3NpbmcgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGVuZCB0aGUgY3VycmVudCBjb21wb3NpdGlvbiBzZXNzaW9uLlxuICAgKlxuICAgKiBEZWZlciBoYW5kbGluZyBiZWNhdXNlIGJyb3dzZXIgd2lsbCBzdGlsbCBpbnNlcnQgdGhlIGNoYXJzIGludG8gYWN0aXZlXG4gICAqIGVsZW1lbnQgYWZ0ZXIgYGNvbXBvc2l0aW9uZW5kYC4gSWYgYSBgY29tcG9zaXRpb25zdGFydGAgZXZlbnQgZmlyZXNcbiAgICogYmVmb3JlIGByZXNvbHZlQ29tcG9zaXRpb25gIGV4ZWN1dGVzLCBvdXIgY29tcG9zaXRpb24gc2Vzc2lvbiB3aWxsXG4gICAqIGNvbnRpbnVlLlxuICAgKlxuICAgKiBUaGUgYHJlc29sdmVkYCBmbGFnIGlzIHVzZWZ1bCBiZWNhdXNlIGNlcnRhaW4gSU1FIGludGVyZmFjZXMgZmlyZSB0aGVcbiAgICogYGNvbXBvc2l0aW9uZW5kYCBldmVudCBtdWx0aXBsZSB0aW1lcywgdGh1cyBxdWV1ZWluZyB1cCBtdWx0aXBsZSBhdHRlbXB0c1xuICAgKiBhdCBoYW5kbGluZyB0aGUgY29tcG9zaXRpb24uIFNpbmNlIGhhbmRsaW5nIHRoZSBzYW1lIGNvbXBvc2l0aW9uIGV2ZW50XG4gICAqIHR3aWNlIGNvdWxkIGJyZWFrIHRoZSBET00sIHdlIG9ubHkgdXNlIHRoZSBmaXJzdCBldmVudC4gRXhhbXBsZTogQXJhYmljXG4gICAqIEdvb2dsZSBJbnB1dCBUb29scyBvbiBXaW5kb3dzIDguMSBmaXJlcyBgY29tcG9zaXRpb25lbmRgIHRocmVlIHRpbWVzLlxuICAgKi9cbiAgb25Db21wb3NpdGlvbkVuZDogZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlZGl0b3IpIHtcbiAgICByZXNvbHZlZCA9IGZhbHNlO1xuICAgIHN0aWxsQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICAgIERyYWZ0RWRpdG9yQ29tcG9zaXRpb25IYW5kbGVyLnJlc29sdmVDb21wb3NpdGlvbihlZGl0b3IpO1xuICAgICAgfVxuICAgIH0sIFJFU09MVkVfREVMQVkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbiBTYWZhcmksIGtleWRvd24gZXZlbnRzIG1heSBmaXJlIHdoZW4gY29tbWl0dGluZyBjb21wb3NpdGlvbnMuIElmXG4gICAqIHRoZSBhcnJvdyBrZXlzIGFyZSB1c2VkIHRvIGNvbW1pdCwgcHJldmVudCBkZWZhdWx0IHNvIHRoYXQgdGhlIGN1cnNvclxuICAgKiBkb2Vzbid0IG1vdmUsIG90aGVyd2lzZSBpdCB3aWxsIGp1bXAgYmFjayBub3RpY2VhYmx5IG9uIHJlLXJlbmRlci5cbiAgICovXG4gIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKGVkaXRvciwgZSkge1xuICAgIGlmICghc3RpbGxDb21wb3NpbmcpIHtcbiAgICAgIC8vIElmIGEga2V5ZG93biBldmVudCBpcyByZWNlaXZlZCBhZnRlciBjb21wb3NpdGlvbmVuZCBidXQgYmVmb3JlIHRoZVxuICAgICAgLy8gMjBtcyB0aW1lciBleHBpcmVzIChleDogdHlwZSBvcHRpb24tRSB0aGVuIGJhY2tzcGFjZSwgb3IgdHlwZSBBIHRoZW5cbiAgICAgIC8vIGJhY2tzcGFjZSBpbiAyLVNldCBLb3JlYW4pLCB3ZSBzaG91bGQgaW1tZWRpYXRlbHkgcmVzb2x2ZSB0aGVcbiAgICAgIC8vIGNvbXBvc2l0aW9uIGFuZCByZWludGVycHJldCB0aGUga2V5IHByZXNzIGluIGVkaXQgbW9kZS5cbiAgICAgIERyYWZ0RWRpdG9yQ29tcG9zaXRpb25IYW5kbGVyLnJlc29sdmVDb21wb3NpdGlvbihlZGl0b3IpO1xuICAgICAgZWRpdG9yLl9vbktleURvd24oZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLndoaWNoID09PSBLZXlzLlJJR0hUIHx8IGUud2hpY2ggPT09IEtleXMuTEVGVCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogS2V5cHJlc3MgZXZlbnRzIG1heSBmaXJlIHdoZW4gY29tbWl0dGluZyBjb21wb3NpdGlvbnMuIEluIEZpcmVmb3gsXG4gICAqIHByZXNzaW5nIFJFVFVSTiBjb21taXRzIHRoZSBjb21wb3NpdGlvbiBhbmQgaW5zZXJ0cyBleHRyYSBuZXdsaW5lXG4gICAqIGNoYXJhY3RlcnMgdGhhdCB3ZSBkbyBub3Qgd2FudC4gYHByZXZlbnREZWZhdWx0YCBhbGxvd3MgdGhlIGNvbXBvc2l0aW9uXG4gICAqIHRvIGJlIGNvbW1pdHRlZCB3aGlsZSBwcmV2ZW50aW5nIHRoZSBleHRyYSBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgb25LZXlQcmVzczogZnVuY3Rpb24gb25LZXlQcmVzcyhlZGl0b3IsIGUpIHtcbiAgICBpZiAoZS53aGljaCA9PT0gS2V5cy5SRVRVUk4pIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gaW5zZXJ0IGNvbXBvc2VkIGNoYXJhY3RlcnMgaW50byB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIElmIHdlIGFyZSBzdGlsbCBpbiBhIGNvbXBvc2l0aW9uIHNlc3Npb24sIGRvIG5vdGhpbmcuIE90aGVyd2lzZSwgaW5zZXJ0XG4gICAqIHRoZSBjaGFyYWN0ZXJzIGludG8gdGhlIGRvY3VtZW50IGFuZCB0ZXJtaW5hdGUgdGhlIGNvbXBvc2l0aW9uIHNlc3Npb24uXG4gICAqXG4gICAqIElmIG5vIGNoYXJhY3RlcnMgd2VyZSBjb21wb3NlZCAtLSBmb3IgaW5zdGFuY2UsIHRoZSB1c2VyXG4gICAqIGRlbGV0ZWQgYWxsIGNvbXBvc2VkIGNoYXJhY3RlcnMgYW5kIGNvbW1pdHRlZCBub3RoaW5nIG5ldyAtLVxuICAgKiBmb3JjZSBhIHJlLXJlbmRlci4gV2UgYWxzbyByZS1yZW5kZXIgd2hlbiB0aGUgY29tcG9zaXRpb24gb2NjdXJzXG4gICAqIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBsZWFmLCB0byBlbnN1cmUgdGhhdCBpZiB0aGUgYnJvd3NlciBoYXNcbiAgICogY3JlYXRlZCBhIG5ldyB0ZXh0IG5vZGUgZm9yIHRoZSBjb21wb3NpdGlvbiwgd2Ugd2lsbCBkaXNjYXJkIGl0LlxuICAgKlxuICAgKiBSZXNldHRpbmcgaW5uZXJIVE1MIHdpbGwgbW92ZSBmb2N1cyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBlZGl0b3IsXG4gICAqIHNvIHdlIHVwZGF0ZSB0byBmb3JjZSBpdCBiYWNrIHRvIHRoZSBjb3JyZWN0IHBsYWNlLlxuICAgKi9cbiAgcmVzb2x2ZUNvbXBvc2l0aW9uOiBmdW5jdGlvbiByZXNvbHZlQ29tcG9zaXRpb24oZWRpdG9yKSB7XG4gICAgaWYgKHN0aWxsQ29tcG9zaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgIHZhciBjb21wb3NlZENoYXJzID0gdGV4dElucHV0RGF0YTtcbiAgICB0ZXh0SW5wdXREYXRhID0gJyc7XG5cbiAgICB2YXIgZWRpdG9yU3RhdGUgPSBFZGl0b3JTdGF0ZS5zZXQoZWRpdG9yLl9sYXRlc3RFZGl0b3JTdGF0ZSwge1xuICAgICAgaW5Db21wb3NpdGlvbk1vZGU6IGZhbHNlXG4gICAgfSk7XG5cbiAgICB2YXIgY3VycmVudFN0eWxlID0gZWRpdG9yU3RhdGUuZ2V0Q3VycmVudElubGluZVN0eWxlKCk7XG4gICAgdmFyIGVudGl0eUtleSA9IGdldEVudGl0eUtleUZvclNlbGVjdGlvbihlZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpLCBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKSk7XG5cbiAgICB2YXIgbXVzdFJlc2V0ID0gIWNvbXBvc2VkQ2hhcnMgfHwgaXNTZWxlY3Rpb25BdExlYWZTdGFydChlZGl0b3JTdGF0ZSkgfHwgY3VycmVudFN0eWxlLnNpemUgPiAwIHx8IGVudGl0eUtleSAhPT0gbnVsbDtcblxuICAgIGlmIChtdXN0UmVzZXQpIHtcbiAgICAgIGVkaXRvci5yZXN0b3JlRWRpdG9yRE9NKCk7XG4gICAgfVxuXG4gICAgZWRpdG9yLmV4aXRDdXJyZW50TW9kZSgpO1xuXG4gICAgaWYgKGNvbXBvc2VkQ2hhcnMpIHtcbiAgICAgIGlmIChEcmFmdEZlYXR1cmVGbGFncy5kcmFmdF9oYW5kbGViZWZvcmVpbnB1dF9jb21wb3NlZF90ZXh0ICYmIGVkaXRvci5wcm9wcy5oYW5kbGVCZWZvcmVJbnB1dCAmJiBpc0V2ZW50SGFuZGxlZChlZGl0b3IucHJvcHMuaGFuZGxlQmVmb3JlSW5wdXQoY29tcG9zZWRDaGFycywgZWRpdG9yU3RhdGUpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBJZiBjaGFyYWN0ZXJzIGhhdmUgYmVlbiBjb21wb3NlZCwgcmUtcmVuZGVyaW5nIHdpdGggdGhlIHVwZGF0ZVxuICAgICAgLy8gaXMgc3VmZmljaWVudCB0byByZXNldCB0aGUgZWRpdG9yLlxuICAgICAgdmFyIGNvbnRlbnRTdGF0ZSA9IERyYWZ0TW9kaWZpZXIucmVwbGFjZVRleHQoZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKSwgZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCksIGNvbXBvc2VkQ2hhcnMsIGN1cnJlbnRTdHlsZSwgZW50aXR5S2V5KTtcbiAgICAgIGVkaXRvci51cGRhdGUoRWRpdG9yU3RhdGUucHVzaChlZGl0b3JTdGF0ZSwgY29udGVudFN0YXRlLCAnaW5zZXJ0LWNoYXJhY3RlcnMnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG11c3RSZXNldCkge1xuICAgICAgZWRpdG9yLnVwZGF0ZShFZGl0b3JTdGF0ZS5zZXQoZWRpdG9yU3RhdGUsIHtcbiAgICAgICAgbmF0aXZlbHlSZW5kZXJlZENvbnRlbnQ6IG51bGwsXG4gICAgICAgIGZvcmNlU2VsZWN0aW9uOiB0cnVlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWZ0RWRpdG9yQ29tcG9zaXRpb25IYW5kbGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdEVkaXRvckNvbXBvc2l0aW9uSGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gNDA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERyYWZ0RWRpdG9yQ29udGVudHMucmVhY3RcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERyYWZ0RWRpdG9yQ29udGVudHMgPSByZXF1aXJlKCcuL0RyYWZ0RWRpdG9yQ29udGVudHMtY29yZS5yZWFjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWZ0RWRpdG9yQ29udGVudHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0RWRpdG9yQ29udGVudHMucmVhY3QuanNcbi8vIG1vZHVsZSBpZCA9IDQwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRHJhZnRFZGl0b3JDb250ZW50cy1jb3JlLnJlYWN0XG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX2V4dGVuZHMgPSBfYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBEcmFmdEVkaXRvckJsb2NrID0gcmVxdWlyZSgnLi9EcmFmdEVkaXRvckJsb2NrLnJlYWN0Jyk7XG52YXIgRHJhZnRPZmZzZXRLZXkgPSByZXF1aXJlKCcuL0RyYWZ0T2Zmc2V0S2V5Jyk7XG52YXIgRWRpdG9yU3RhdGUgPSByZXF1aXJlKCcuL0VkaXRvclN0YXRlJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgY3ggPSByZXF1aXJlKCdmYmpzL2xpYi9jeCcpO1xudmFyIGpvaW5DbGFzc2VzID0gcmVxdWlyZSgnZmJqcy9saWIvam9pbkNsYXNzZXMnKTtcbnZhciBudWxsdGhyb3dzID0gcmVxdWlyZSgnZmJqcy9saWIvbnVsbHRocm93cycpO1xuXG4vKipcbiAqIFByb3ZpZGUgZGVmYXVsdCBzdHlsaW5nIGZvciBsaXN0IGl0ZW1zLiBUaGlzIHdheSwgbGlzdHMgd2lsbCBiZSBzdHlsZWQgd2l0aFxuICogcHJvcGVyIGNvdW50ZXJzIGFuZCBpbmRlbnRhdGlvbiBldmVuIGlmIHRoZSBjYWxsZXIgZG9lcyBub3Qgc3BlY2lmeVxuICogdGhlaXIgb3duIHN0eWxpbmcgYXQgYWxsLiBJZiBtb3JlIHRoYW4gZml2ZSBsZXZlbHMgb2YgbmVzdGluZyBhcmUgbmVlZGVkLFxuICogdGhlIG5lY2Vzc2FyeSBDU1MgY2xhc3NlcyBjYW4gYmUgcHJvdmlkZWQgdmlhIGBibG9ja1N0eWxlRm5gIGNvbmZpZ3VyYXRpb24uXG4gKi9cbnZhciBnZXRMaXN0SXRlbUNsYXNzZXMgPSBmdW5jdGlvbiBnZXRMaXN0SXRlbUNsYXNzZXModHlwZSwgZGVwdGgsIHNob3VsZFJlc2V0Q291bnQsIGRpcmVjdGlvbikge1xuICByZXR1cm4gY3goe1xuICAgICdwdWJsaWMvRHJhZnRTdHlsZURlZmF1bHQvdW5vcmRlcmVkTGlzdEl0ZW0nOiB0eXBlID09PSAndW5vcmRlcmVkLWxpc3QtaXRlbScsXG4gICAgJ3B1YmxpYy9EcmFmdFN0eWxlRGVmYXVsdC9vcmRlcmVkTGlzdEl0ZW0nOiB0eXBlID09PSAnb3JkZXJlZC1saXN0LWl0ZW0nLFxuICAgICdwdWJsaWMvRHJhZnRTdHlsZURlZmF1bHQvcmVzZXQnOiBzaG91bGRSZXNldENvdW50LFxuICAgICdwdWJsaWMvRHJhZnRTdHlsZURlZmF1bHQvZGVwdGgwJzogZGVwdGggPT09IDAsXG4gICAgJ3B1YmxpYy9EcmFmdFN0eWxlRGVmYXVsdC9kZXB0aDEnOiBkZXB0aCA9PT0gMSxcbiAgICAncHVibGljL0RyYWZ0U3R5bGVEZWZhdWx0L2RlcHRoMic6IGRlcHRoID09PSAyLFxuICAgICdwdWJsaWMvRHJhZnRTdHlsZURlZmF1bHQvZGVwdGgzJzogZGVwdGggPT09IDMsXG4gICAgJ3B1YmxpYy9EcmFmdFN0eWxlRGVmYXVsdC9kZXB0aDQnOiBkZXB0aCA9PT0gNCxcbiAgICAncHVibGljL0RyYWZ0U3R5bGVEZWZhdWx0L2xpc3RMVFInOiBkaXJlY3Rpb24gPT09ICdMVFInLFxuICAgICdwdWJsaWMvRHJhZnRTdHlsZURlZmF1bHQvbGlzdFJUTCc6IGRpcmVjdGlvbiA9PT0gJ1JUTCdcbiAgfSk7XG59O1xuXG4vKipcbiAqIGBEcmFmdEVkaXRvckNvbnRlbnRzYCBpcyB0aGUgY29udGFpbmVyIGNvbXBvbmVudCBmb3IgYWxsIGJsb2NrIGNvbXBvbmVudHNcbiAqIHJlbmRlcmVkIGZvciBhIGBEcmFmdEVkaXRvcmAuIEl0IGlzIG9wdGltaXplZCB0byBhZ2dyZXNzaXZlbHkgYXZvaWRcbiAqIHJlLXJlbmRlcmluZyBibG9ja3Mgd2hlbmV2ZXIgcG9zc2libGUuXG4gKlxuICogVGhpcyBjb21wb25lbnQgaXMgc2VwYXJhdGUgZnJvbSBgRHJhZnRFZGl0b3JgIGJlY2F1c2UgY2VydGFpbiBwcm9wc1xuICogKGZvciBpbnN0YW5jZSwgQVJJQSBwcm9wcykgbXVzdCBiZSBhbGxvd2VkIHRvIHVwZGF0ZSB3aXRob3V0IGFmZmVjdGluZ1xuICogdGhlIGNvbnRlbnRzIG9mIHRoZSBlZGl0b3IuXG4gKi9cblxudmFyIERyYWZ0RWRpdG9yQ29udGVudHMgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRHJhZnRFZGl0b3JDb250ZW50cywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRHJhZnRFZGl0b3JDb250ZW50cygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhZnRFZGl0b3JDb250ZW50cyk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIERyYWZ0RWRpdG9yQ29udGVudHMucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICB2YXIgcHJldkVkaXRvclN0YXRlID0gdGhpcy5wcm9wcy5lZGl0b3JTdGF0ZTtcbiAgICB2YXIgbmV4dEVkaXRvclN0YXRlID0gbmV4dFByb3BzLmVkaXRvclN0YXRlO1xuXG4gICAgdmFyIHByZXZEaXJlY3Rpb25NYXAgPSBwcmV2RWRpdG9yU3RhdGUuZ2V0RGlyZWN0aW9uTWFwKCk7XG4gICAgdmFyIG5leHREaXJlY3Rpb25NYXAgPSBuZXh0RWRpdG9yU3RhdGUuZ2V0RGlyZWN0aW9uTWFwKCk7XG5cbiAgICAvLyBUZXh0IGRpcmVjdGlvbiBoYXMgY2hhbmdlZCBmb3Igb25lIG9yIG1vcmUgYmxvY2tzLiBXZSBtdXN0IHJlLXJlbmRlci5cbiAgICBpZiAocHJldkRpcmVjdGlvbk1hcCAhPT0gbmV4dERpcmVjdGlvbk1hcCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGRpZEhhdmVGb2N1cyA9IHByZXZFZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKS5nZXRIYXNGb2N1cygpO1xuICAgIHZhciBub3dIYXNGb2N1cyA9IG5leHRFZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKS5nZXRIYXNGb2N1cygpO1xuXG4gICAgaWYgKGRpZEhhdmVGb2N1cyAhPT0gbm93SGFzRm9jdXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBuZXh0TmF0aXZlQ29udGVudCA9IG5leHRFZGl0b3JTdGF0ZS5nZXROYXRpdmVseVJlbmRlcmVkQ29udGVudCgpO1xuXG4gICAgdmFyIHdhc0NvbXBvc2luZyA9IHByZXZFZGl0b3JTdGF0ZS5pc0luQ29tcG9zaXRpb25Nb2RlKCk7XG4gICAgdmFyIG5vd0NvbXBvc2luZyA9IG5leHRFZGl0b3JTdGF0ZS5pc0luQ29tcG9zaXRpb25Nb2RlKCk7XG5cbiAgICAvLyBJZiB0aGUgc3RhdGUgaXMgdW5jaGFuZ2VkIG9yIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgYSBuYXRpdmVseVxuICAgIC8vIHJlbmRlcmVkIHN0YXRlLCB0aGVyZSdzIG5vdGhpbmcgbmV3IHRvIGJlIGRvbmUuXG4gICAgaWYgKHByZXZFZGl0b3JTdGF0ZSA9PT0gbmV4dEVkaXRvclN0YXRlIHx8IG5leHROYXRpdmVDb250ZW50ICE9PSBudWxsICYmIG5leHRFZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpID09PSBuZXh0TmF0aXZlQ29udGVudCB8fCB3YXNDb21wb3NpbmcgJiYgbm93Q29tcG9zaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb250ZW50ID0gcHJldkVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG4gICAgdmFyIG5leHRDb250ZW50ID0gbmV4dEVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG4gICAgdmFyIHByZXZEZWNvcmF0b3IgPSBwcmV2RWRpdG9yU3RhdGUuZ2V0RGVjb3JhdG9yKCk7XG4gICAgdmFyIG5leHREZWNvcmF0b3IgPSBuZXh0RWRpdG9yU3RhdGUuZ2V0RGVjb3JhdG9yKCk7XG4gICAgcmV0dXJuIHdhc0NvbXBvc2luZyAhPT0gbm93Q29tcG9zaW5nIHx8IHByZXZDb250ZW50ICE9PSBuZXh0Q29udGVudCB8fCBwcmV2RGVjb3JhdG9yICE9PSBuZXh0RGVjb3JhdG9yIHx8IG5leHRFZGl0b3JTdGF0ZS5tdXN0Rm9yY2VTZWxlY3Rpb24oKTtcbiAgfTtcblxuICBEcmFmdEVkaXRvckNvbnRlbnRzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGJsb2NrUmVuZGVyTWFwID0gX3Byb3BzLmJsb2NrUmVuZGVyTWFwLFxuICAgICAgICBibG9ja1JlbmRlcmVyRm4gPSBfcHJvcHMuYmxvY2tSZW5kZXJlckZuLFxuICAgICAgICBibG9ja1N0eWxlRm4gPSBfcHJvcHMuYmxvY2tTdHlsZUZuLFxuICAgICAgICBjdXN0b21TdHlsZU1hcCA9IF9wcm9wcy5jdXN0b21TdHlsZU1hcCxcbiAgICAgICAgY3VzdG9tU3R5bGVGbiA9IF9wcm9wcy5jdXN0b21TdHlsZUZuLFxuICAgICAgICBlZGl0b3JTdGF0ZSA9IF9wcm9wcy5lZGl0b3JTdGF0ZSxcbiAgICAgICAgZWRpdG9yS2V5ID0gX3Byb3BzLmVkaXRvcktleSxcbiAgICAgICAgdGV4dERpcmVjdGlvbmFsaXR5ID0gX3Byb3BzLnRleHREaXJlY3Rpb25hbGl0eTtcblxuXG4gICAgdmFyIGNvbnRlbnQgPSBlZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpO1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKTtcbiAgICB2YXIgZm9yY2VTZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5tdXN0Rm9yY2VTZWxlY3Rpb24oKTtcbiAgICB2YXIgZGVjb3JhdG9yID0gZWRpdG9yU3RhdGUuZ2V0RGVjb3JhdG9yKCk7XG4gICAgdmFyIGRpcmVjdGlvbk1hcCA9IG51bGx0aHJvd3MoZWRpdG9yU3RhdGUuZ2V0RGlyZWN0aW9uTWFwKCkpO1xuXG4gICAgdmFyIGJsb2Nrc0FzQXJyYXkgPSBjb250ZW50LmdldEJsb2Nrc0FzQXJyYXkoKTtcbiAgICB2YXIgcHJvY2Vzc2VkQmxvY2tzID0gW107XG5cbiAgICB2YXIgY3VycmVudERlcHRoID0gbnVsbDtcbiAgICB2YXIgbGFzdFdyYXBwZXJUZW1wbGF0ZSA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgYmxvY2tzQXNBcnJheS5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHZhciBfYmxvY2sgPSBibG9ja3NBc0FycmF5W2lpXTtcbiAgICAgIHZhciBrZXkgPSBfYmxvY2suZ2V0S2V5KCk7XG4gICAgICB2YXIgYmxvY2tUeXBlID0gX2Jsb2NrLmdldFR5cGUoKTtcblxuICAgICAgdmFyIGN1c3RvbVJlbmRlcmVyID0gYmxvY2tSZW5kZXJlckZuKF9ibG9jayk7XG4gICAgICB2YXIgQ3VzdG9tQ29tcG9uZW50ID0gdm9pZCAwLFxuICAgICAgICAgIGN1c3RvbVByb3BzID0gdm9pZCAwLFxuICAgICAgICAgIGN1c3RvbUVkaXRhYmxlID0gdm9pZCAwO1xuICAgICAgaWYgKGN1c3RvbVJlbmRlcmVyKSB7XG4gICAgICAgIEN1c3RvbUNvbXBvbmVudCA9IGN1c3RvbVJlbmRlcmVyLmNvbXBvbmVudDtcbiAgICAgICAgY3VzdG9tUHJvcHMgPSBjdXN0b21SZW5kZXJlci5wcm9wcztcbiAgICAgICAgY3VzdG9tRWRpdGFibGUgPSBjdXN0b21SZW5kZXJlci5lZGl0YWJsZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpcmVjdGlvbiA9IHRleHREaXJlY3Rpb25hbGl0eSA/IHRleHREaXJlY3Rpb25hbGl0eSA6IGRpcmVjdGlvbk1hcC5nZXQoa2V5KTtcbiAgICAgIHZhciBvZmZzZXRLZXkgPSBEcmFmdE9mZnNldEtleS5lbmNvZGUoa2V5LCAwLCAwKTtcbiAgICAgIHZhciBjb21wb25lbnRQcm9wcyA9IHtcbiAgICAgICAgY29udGVudFN0YXRlOiBjb250ZW50LFxuICAgICAgICBibG9jazogX2Jsb2NrLFxuICAgICAgICBibG9ja1Byb3BzOiBjdXN0b21Qcm9wcyxcbiAgICAgICAgYmxvY2tTdHlsZUZuOiBibG9ja1N0eWxlRm4sXG4gICAgICAgIGN1c3RvbVN0eWxlTWFwOiBjdXN0b21TdHlsZU1hcCxcbiAgICAgICAgY3VzdG9tU3R5bGVGbjogY3VzdG9tU3R5bGVGbixcbiAgICAgICAgZGVjb3JhdG9yOiBkZWNvcmF0b3IsXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICBmb3JjZVNlbGVjdGlvbjogZm9yY2VTZWxlY3Rpb24sXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBvZmZzZXRLZXk6IG9mZnNldEtleSxcbiAgICAgICAgc2VsZWN0aW9uOiBzZWxlY3Rpb24sXG4gICAgICAgIHRyZWU6IGVkaXRvclN0YXRlLmdldEJsb2NrVHJlZShrZXkpXG4gICAgICB9O1xuXG4gICAgICB2YXIgY29uZmlnRm9yVHlwZSA9IGJsb2NrUmVuZGVyTWFwLmdldChibG9ja1R5cGUpIHx8IGJsb2NrUmVuZGVyTWFwLmdldCgndW5zdHlsZWQnKTtcbiAgICAgIHZhciB3cmFwcGVyVGVtcGxhdGUgPSBjb25maWdGb3JUeXBlLndyYXBwZXI7XG5cbiAgICAgIHZhciBFbGVtZW50ID0gY29uZmlnRm9yVHlwZS5lbGVtZW50IHx8IGJsb2NrUmVuZGVyTWFwLmdldCgndW5zdHlsZWQnKS5lbGVtZW50O1xuXG4gICAgICB2YXIgZGVwdGggPSBfYmxvY2suZ2V0RGVwdGgoKTtcbiAgICAgIHZhciBjbGFzc05hbWUgPSAnJztcbiAgICAgIGlmIChibG9ja1N0eWxlRm4pIHtcbiAgICAgICAgY2xhc3NOYW1lID0gYmxvY2tTdHlsZUZuKF9ibG9jayk7XG4gICAgICB9XG5cbiAgICAgIC8vIExpc3QgaXRlbXMgYXJlIHNwZWNpYWwgc25vd2ZsYWtlcywgc2luY2Ugd2UgaGFuZGxlIG5lc3RpbmcgYW5kXG4gICAgICAvLyBjb3VudGVycyBtYW51YWxseS5cbiAgICAgIGlmIChFbGVtZW50ID09PSAnbGknKSB7XG4gICAgICAgIHZhciBzaG91bGRSZXNldENvdW50ID0gbGFzdFdyYXBwZXJUZW1wbGF0ZSAhPT0gd3JhcHBlclRlbXBsYXRlIHx8IGN1cnJlbnREZXB0aCA9PT0gbnVsbCB8fCBkZXB0aCA+IGN1cnJlbnREZXB0aDtcbiAgICAgICAgY2xhc3NOYW1lID0gam9pbkNsYXNzZXMoY2xhc3NOYW1lLCBnZXRMaXN0SXRlbUNsYXNzZXMoYmxvY2tUeXBlLCBkZXB0aCwgc2hvdWxkUmVzZXRDb3VudCwgZGlyZWN0aW9uKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBDb21wb25lbnQgPSBDdXN0b21Db21wb25lbnQgfHwgRHJhZnRFZGl0b3JCbG9jaztcbiAgICAgIHZhciBjaGlsZFByb3BzID0ge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgJ2RhdGEtYmxvY2snOiB0cnVlLFxuICAgICAgICAnZGF0YS1lZGl0b3InOiBlZGl0b3JLZXksXG4gICAgICAgICdkYXRhLW9mZnNldC1rZXknOiBvZmZzZXRLZXksXG4gICAgICAgIGtleToga2V5XG4gICAgICB9O1xuICAgICAgaWYgKGN1c3RvbUVkaXRhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2hpbGRQcm9wcyA9IF9leHRlbmRzKHt9LCBjaGlsZFByb3BzLCB7XG4gICAgICAgICAgY29udGVudEVkaXRhYmxlOiBjdXN0b21FZGl0YWJsZSxcbiAgICAgICAgICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWxlbWVudCwgY2hpbGRQcm9wcywgUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIGNvbXBvbmVudFByb3BzKSk7XG5cbiAgICAgIHByb2Nlc3NlZEJsb2Nrcy5wdXNoKHtcbiAgICAgICAgYmxvY2s6IGNoaWxkLFxuICAgICAgICB3cmFwcGVyVGVtcGxhdGU6IHdyYXBwZXJUZW1wbGF0ZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIG9mZnNldEtleTogb2Zmc2V0S2V5XG4gICAgICB9KTtcblxuICAgICAgaWYgKHdyYXBwZXJUZW1wbGF0ZSkge1xuICAgICAgICBjdXJyZW50RGVwdGggPSBfYmxvY2suZ2V0RGVwdGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnREZXB0aCA9IG51bGw7XG4gICAgICB9XG4gICAgICBsYXN0V3JhcHBlclRlbXBsYXRlID0gd3JhcHBlclRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8vIEdyb3VwIGNvbnRpZ3VvdXMgcnVucyBvZiBibG9ja3MgdGhhdCBoYXZlIHRoZSBzYW1lIHdyYXBwZXJUZW1wbGF0ZVxuICAgIHZhciBvdXRwdXRCbG9ja3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaWkgPSAwOyBfaWkgPCBwcm9jZXNzZWRCbG9ja3MubGVuZ3RoOykge1xuICAgICAgdmFyIGluZm8gPSBwcm9jZXNzZWRCbG9ja3NbX2lpXTtcbiAgICAgIGlmIChpbmZvLndyYXBwZXJUZW1wbGF0ZSkge1xuICAgICAgICB2YXIgYmxvY2tzID0gW107XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBibG9ja3MucHVzaChwcm9jZXNzZWRCbG9ja3NbX2lpXS5ibG9jayk7XG4gICAgICAgICAgX2lpKys7XG4gICAgICAgIH0gd2hpbGUgKF9paSA8IHByb2Nlc3NlZEJsb2Nrcy5sZW5ndGggJiYgcHJvY2Vzc2VkQmxvY2tzW19paV0ud3JhcHBlclRlbXBsYXRlID09PSBpbmZvLndyYXBwZXJUZW1wbGF0ZSk7XG4gICAgICAgIHZhciB3cmFwcGVyRWxlbWVudCA9IFJlYWN0LmNsb25lRWxlbWVudChpbmZvLndyYXBwZXJUZW1wbGF0ZSwge1xuICAgICAgICAgIGtleTogaW5mby5rZXkgKyAnLXdyYXAnLFxuICAgICAgICAgICdkYXRhLW9mZnNldC1rZXknOiBpbmZvLm9mZnNldEtleVxuICAgICAgICB9LCBibG9ja3MpO1xuICAgICAgICBvdXRwdXRCbG9ja3MucHVzaCh3cmFwcGVyRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXRCbG9ja3MucHVzaChpbmZvLmJsb2NrKTtcbiAgICAgICAgX2lpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgJ2RhdGEtY29udGVudHMnOiAndHJ1ZScgfSxcbiAgICAgIG91dHB1dEJsb2Nrc1xuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIERyYWZ0RWRpdG9yQ29udGVudHM7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZnRFZGl0b3JDb250ZW50cztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvRHJhZnRFZGl0b3JDb250ZW50cy1jb3JlLnJlYWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERyYWZ0RWRpdG9yTGVhZi5yZWFjdFxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRHJhZnRFZGl0b3JUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vRHJhZnRFZGl0b3JUZXh0Tm9kZS5yZWFjdCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2V0RHJhZnRFZGl0b3JTZWxlY3Rpb24gPSByZXF1aXJlKCcuL3NldERyYWZ0RWRpdG9yU2VsZWN0aW9uJyk7XG5cbi8qKlxuICogQWxsIGxlYWYgbm9kZXMgaW4gdGhlIGVkaXRvciBhcmUgc3BhbnMgd2l0aCBzaW5nbGUgdGV4dCBub2Rlcy4gTGVhZlxuICogZWxlbWVudHMgYXJlIHN0eWxlZCBiYXNlZCBvbiB0aGUgbWVyZ2luZyBvZiBhbiBvcHRpb25hbCBjdXN0b20gc3R5bGUgbWFwXG4gKiBhbmQgYSBkZWZhdWx0IHN0eWxlIG1hcC5cbiAqXG4gKiBgRHJhZnRFZGl0b3JMZWFmYCBhbHNvIHByb3ZpZGVzIGEgd3JhcHBlciBmb3IgY2FsbGluZyBpbnRvIHRoZSBpbXBlcmF0aXZlXG4gKiBET00gU2VsZWN0aW9uIEFQSS4gSW4gdGhpcyB3YXksIHRvcC1sZXZlbCBjb21wb25lbnRzIGNhbiBkZWNsYXJhdGl2ZWx5XG4gKiBtYWludGFpbiB0aGUgc2VsZWN0aW9uIHN0YXRlLlxuICovXG52YXIgRHJhZnRFZGl0b3JMZWFmID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKERyYWZ0RWRpdG9yTGVhZiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRHJhZnRFZGl0b3JMZWFmKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcmFmdEVkaXRvckxlYWYpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBEcmFmdEVkaXRvckxlYWYucHJvdG90eXBlLl9zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiBfc2V0U2VsZWN0aW9uKCkge1xuICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnByb3BzLnNlbGVjdGlvbjtcblxuICAgIC8vIElmIHNlbGVjdGlvbiBzdGF0ZSBpcyBpcnJlbGV2YW50IHRvIHRoZSBwYXJlbnQgYmxvY2ssIG5vLW9wLlxuXG4gICAgaWYgKHNlbGVjdGlvbiA9PSBudWxsIHx8ICFzZWxlY3Rpb24uZ2V0SGFzRm9jdXMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBibG9jayA9IF9wcm9wcy5ibG9jayxcbiAgICAgICAgc3RhcnQgPSBfcHJvcHMuc3RhcnQsXG4gICAgICAgIHRleHQgPSBfcHJvcHMudGV4dDtcblxuICAgIHZhciBibG9ja0tleSA9IGJsb2NrLmdldEtleSgpO1xuICAgIHZhciBlbmQgPSBzdGFydCArIHRleHQubGVuZ3RoO1xuICAgIGlmICghc2VsZWN0aW9uLmhhc0VkZ2VXaXRoaW4oYmxvY2tLZXksIHN0YXJ0LCBlbmQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSB0YXJnZXQgbm9kZSBmb3Igc2VsZWN0aW9uLiBJZiB0aGUgY2hpbGRcbiAgICAvLyBpcyBub3QgYSB0ZXh0IG5vZGUsIGl0IGlzIGEgPGJyIC8+IHNwYWNlci4gSW4gdGhpcyBjYXNlLCB1c2UgdGhlXG4gICAgLy8gPHNwYW4+IGl0c2VsZiBhcyB0aGUgc2VsZWN0aW9uIHRhcmdldC5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICFub2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc3Npbmcgbm9kZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgIWNoaWxkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc3NpbmcgY2hpbGQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB2b2lkIDA7XG5cbiAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChjaGlsZC50YWdOYW1lID09PSAnQlInKSB7XG4gICAgICB0YXJnZXROb2RlID0gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkLmZpcnN0Q2hpbGQ7XG4gICAgICAhdGFyZ2V0Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNzaW5nIHRhcmdldE5vZGUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgc2V0RHJhZnRFZGl0b3JTZWxlY3Rpb24oc2VsZWN0aW9uLCB0YXJnZXROb2RlLCBibG9ja0tleSwgc3RhcnQsIGVuZCk7XG4gIH07XG4gIC8qKlxuICAgKiBCeSBtYWtpbmcgaW5kaXZpZHVhbCBsZWFmIGluc3RhbmNlcyBhd2FyZSBvZiB0aGVpciBjb250ZXh0IHdpdGhpblxuICAgKiB0aGUgdGV4dCBvZiB0aGUgZWRpdG9yLCB3ZSBjYW4gc2V0IG91ciBzZWxlY3Rpb24gcmFuZ2UgbW9yZVxuICAgKiBlYXNpbHkgdGhhbiB3ZSBjb3VsZCBpbiB0aGUgbm9uLVJlYWN0IHdvcmxkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBkZXBlbmRzIG9uIG91ciBtYWludGFpbmluZyB0aWdodCBjb250cm9sIG92ZXIgdGhlXG4gICAqIERPTSBzdHJ1Y3R1cmUgb2YgdGhlIERyYWZ0RWRpdG9yIGNvbXBvbmVudC4gSWYgbGVhdmVzIGhhZCBtdWx0aXBsZVxuICAgKiB0ZXh0IG5vZGVzLCB0aGlzIHdvdWxkIGJlIGhhcmRlci5cbiAgICovXG5cbiAgRHJhZnRFZGl0b3JMZWFmLnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgdmFyIGxlYWZOb2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5sZWFmKTtcbiAgICAhbGVhZk5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBsZWFmTm9kZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbGVhZk5vZGUudGV4dENvbnRlbnQgIT09IG5leHRQcm9wcy50ZXh0IHx8IG5leHRQcm9wcy5zdHlsZVNldCAhPT0gdGhpcy5wcm9wcy5zdHlsZVNldCB8fCBuZXh0UHJvcHMuZm9yY2VTZWxlY3Rpb247XG4gIH07XG5cbiAgRHJhZnRFZGl0b3JMZWFmLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5fc2V0U2VsZWN0aW9uKCk7XG4gIH07XG5cbiAgRHJhZnRFZGl0b3JMZWFmLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuX3NldFNlbGVjdGlvbigpO1xuICB9O1xuXG4gIERyYWZ0RWRpdG9yTGVhZi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGJsb2NrID0gdGhpcy5wcm9wcy5ibG9jaztcbiAgICB2YXIgdGV4dCA9IHRoaXMucHJvcHMudGV4dDtcblxuICAgIC8vIElmIHRoZSBsZWFmIGlzIGF0IHRoZSBlbmQgb2YgaXRzIGJsb2NrIGFuZCBlbmRzIGluIGEgc29mdCBuZXdsaW5lLCBhcHBlbmRcbiAgICAvLyBhbiBleHRyYSBsaW5lIGZlZWQgY2hhcmFjdGVyLiBCcm93c2VycyBjb2xsYXBzZSB0cmFpbGluZyBuZXdsaW5lXG4gICAgLy8gY2hhcmFjdGVycywgd2hpY2ggbGVhdmVzIHRoZSBjdXJzb3IgaW4gdGhlIHdyb25nIHBsYWNlIGFmdGVyIGFcbiAgICAvLyBzaGlmdCtlbnRlci4gVGhlIGV4dHJhIGNoYXJhY3RlciByZXBhaXJzIHRoaXMuXG5cbiAgICBpZiAodGV4dC5lbmRzV2l0aCgnXFxuJykgJiYgdGhpcy5wcm9wcy5pc0xhc3QpIHtcbiAgICAgIHRleHQgKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBjdXN0b21TdHlsZU1hcCA9IF9wcm9wczIuY3VzdG9tU3R5bGVNYXAsXG4gICAgICAgIGN1c3RvbVN0eWxlRm4gPSBfcHJvcHMyLmN1c3RvbVN0eWxlRm4sXG4gICAgICAgIG9mZnNldEtleSA9IF9wcm9wczIub2Zmc2V0S2V5LFxuICAgICAgICBzdHlsZVNldCA9IF9wcm9wczIuc3R5bGVTZXQ7XG5cbiAgICB2YXIgc3R5bGVPYmogPSBzdHlsZVNldC5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgc3R5bGVOYW1lKSB7XG4gICAgICB2YXIgbWVyZ2VkU3R5bGVzID0ge307XG4gICAgICB2YXIgc3R5bGUgPSBjdXN0b21TdHlsZU1hcFtzdHlsZU5hbWVdO1xuXG4gICAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCAmJiBtYXAudGV4dERlY29yYXRpb24gIT09IHN0eWxlLnRleHREZWNvcmF0aW9uKSB7XG4gICAgICAgIC8vIC50cmltKCkgaXMgbmVjZXNzYXJ5IGZvciBJRTkvMTAvMTEgYW5kIEVkZ2VcbiAgICAgICAgbWVyZ2VkU3R5bGVzLnRleHREZWNvcmF0aW9uID0gW21hcC50ZXh0RGVjb3JhdGlvbiwgc3R5bGUudGV4dERlY29yYXRpb25dLmpvaW4oJyAnKS50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfYXNzaWduKG1hcCwgc3R5bGUsIG1lcmdlZFN0eWxlcyk7XG4gICAgfSwge30pO1xuXG4gICAgaWYgKGN1c3RvbVN0eWxlRm4pIHtcbiAgICAgIHZhciBuZXdTdHlsZXMgPSBjdXN0b21TdHlsZUZuKHN0eWxlU2V0LCBibG9jayk7XG4gICAgICBzdHlsZU9iaiA9IF9hc3NpZ24oc3R5bGVPYmosIG5ld1N0eWxlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnc3BhbicsXG4gICAgICB7XG4gICAgICAgICdkYXRhLW9mZnNldC1rZXknOiBvZmZzZXRLZXksXG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKF9yZWYpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmxlYWYgPSBfcmVmO1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogc3R5bGVPYmogfSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIERyYWZ0RWRpdG9yVGV4dE5vZGUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRleHRcbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBEcmFmdEVkaXRvckxlYWY7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZnRFZGl0b3JMZWFmO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdEVkaXRvckxlYWYucmVhY3QuanNcbi8vIG1vZHVsZSBpZCA9IDQxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRHJhZnRFZGl0b3JUZXh0Tm9kZS5yZWFjdFxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBVc2VyQWdlbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9Vc2VyQWdlbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vLyBJbiBJRSwgc3BhbnMgd2l0aCA8YnI+IHRhZ3MgcmVuZGVyIGFzIHR3byBuZXdsaW5lcy4gQnkgcmVuZGVyaW5nIGEgc3BhblxuLy8gd2l0aCBvbmx5IGEgbmV3bGluZSBjaGFyYWN0ZXIsIHdlIGNhbiBiZSBzdXJlIHRvIHJlbmRlciBhIHNpbmdsZSBsaW5lLlxudmFyIHVzZU5ld2xpbmVDaGFyID0gVXNlckFnZW50LmlzQnJvd3NlcignSUUgPD0gMTEnKTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBjb25zaWRlcmVkIGEgbmV3bGluZS5cbiAqL1xuZnVuY3Rpb24gaXNOZXdsaW5lKG5vZGUpIHtcbiAgcmV0dXJuIHVzZU5ld2xpbmVDaGFyID8gbm9kZS50ZXh0Q29udGVudCA9PT0gJ1xcbicgOiBub2RlLnRhZ05hbWUgPT09ICdCUic7XG59XG5cbi8qKlxuICogUGxhY2Vob2xkZXIgZWxlbWVudHMgZm9yIGVtcHR5IHRleHQgY29udGVudC5cbiAqXG4gKiBXaGF0IGlzIHRoaXMgYGRhdGEtdGV4dGAgYXR0cmlidXRlLCBhbnl3YXk/IEl0IHR1cm5zIG91dCB0aGF0IHdlIG5lZWQgdG9cbiAqIHB1dCBhbiBhdHRyaWJ1dGUgb24gdGhlIGxvd2VzdC1sZXZlbCB0ZXh0IG5vZGUgaW4gb3JkZXIgdG8gcHJlc2VydmUgY29ycmVjdFxuICogc3BlbGxjaGVjayBoYW5kbGluZy4gSWYgdGhlIDxzcGFuPiBpcyBuYWtlZCwgQ2hyb21lIGFuZCBTYWZhcmkgbWF5IGRvXG4gKiBiaXphcnJlIHRoaW5ncyB0byBkbyB0aGUgRE9NIC0tIHNwbGl0IHRleHQgbm9kZXMsIGNyZWF0ZSBleHRyYSBzcGFucywgZXRjLlxuICogSWYgdGhlIDxzcGFuPiBoYXMgYW4gYXR0cmlidXRlLCB0aGlzIGFwcGVhcnMgbm90IHRvIGhhcHBlbi5cbiAqIFNlZSBodHRwOi8vanNmaWRkbGUubmV0LzlraGRhdm9kLyBmb3IgdGhlIGZhaWx1cmUgY2FzZSwgYW5kXG4gKiBodHRwOi8vanNmaWRkbGUubmV0LzdwZzE0M2Y3LyBmb3IgdGhlIGZpeGVkIGNhc2UuXG4gKi9cbnZhciBORVdMSU5FX0EgPSB1c2VOZXdsaW5lQ2hhciA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICdzcGFuJyxcbiAgeyBrZXk6ICdBJywgJ2RhdGEtdGV4dCc6ICd0cnVlJyB9LFxuICAnXFxuJ1xuKSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2JyJywgeyBrZXk6ICdBJywgJ2RhdGEtdGV4dCc6ICd0cnVlJyB9KTtcblxudmFyIE5FV0xJTkVfQiA9IHVzZU5ld2xpbmVDaGFyID8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgJ3NwYW4nLFxuICB7IGtleTogJ0InLCAnZGF0YS10ZXh0JzogJ3RydWUnIH0sXG4gICdcXG4nXG4pIDogUmVhY3QuY3JlYXRlRWxlbWVudCgnYnInLCB7IGtleTogJ0InLCAnZGF0YS10ZXh0JzogJ3RydWUnIH0pO1xuXG4vKipcbiAqIFRoZSBsb3dlc3QtbGV2ZWwgY29tcG9uZW50IGluIGEgYERyYWZ0RWRpdG9yYCwgdGhlIHRleHQgbm9kZSBjb21wb25lbnRcbiAqIHJlcGxhY2VzIHRoZSBkZWZhdWx0IFJlYWN0IHRleHQgbm9kZSBpbXBsZW1lbnRhdGlvbi4gVGhpcyBhbGxvd3MgdXMgdG9cbiAqIHBlcmZvcm0gY3VzdG9tIGhhbmRsaW5nIG9mIG5ld2xpbmUgYmVoYXZpb3IgYW5kIGF2b2lkIHJlLXJlbmRlcmluZyB0ZXh0XG4gKiBub2RlcyB3aXRoIERPTSBzdGF0ZSB0aGF0IGFscmVhZHkgbWF0Y2hlcyB0aGUgZXhwZWN0YXRpb25zIG9mIG91ciBpbW11dGFibGVcbiAqIGVkaXRvciBzdGF0ZS5cbiAqL1xudmFyIERyYWZ0RWRpdG9yVGV4dE5vZGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRHJhZnRFZGl0b3JUZXh0Tm9kZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRHJhZnRFZGl0b3JUZXh0Tm9kZShwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcmFmdEVkaXRvclRleHROb2RlKTtcblxuICAgIC8vIEJ5IGZsaXBwaW5nIHRoaXMgZmxhZywgd2UgYWxzbyBrZWVwIGZsaXBwaW5nIGtleXMgd2hpY2ggZm9yY2VzXG4gICAgLy8gUmVhY3QgdG8gcmVtb3VudCB0aGlzIG5vZGUgZXZlcnkgdGltZSBpdCByZXJlbmRlcnMuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICBfdGhpcy5fZm9yY2VGbGFnID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgRHJhZnRFZGl0b3JUZXh0Tm9kZS5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgIHZhciBub2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG4gICAgdmFyIHNob3VsZEJlTmV3bGluZSA9IG5leHRQcm9wcy5jaGlsZHJlbiA9PT0gJyc7XG4gICAgIShub2RlIGluc3RhbmNlb2YgRWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbm9kZSBpcyBub3QgYW4gRWxlbWVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBpZiAoc2hvdWxkQmVOZXdsaW5lKSB7XG4gICAgICByZXR1cm4gIWlzTmV3bGluZShub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudGV4dENvbnRlbnQgIT09IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgfTtcblxuICBEcmFmdEVkaXRvclRleHROb2RlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuX2ZvcmNlRmxhZyA9ICF0aGlzLl9mb3JjZUZsYWc7XG4gIH07XG5cbiAgRHJhZnRFZGl0b3JUZXh0Tm9kZS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMuX2ZvcmNlRmxhZyA9ICF0aGlzLl9mb3JjZUZsYWc7XG4gIH07XG5cbiAgRHJhZnRFZGl0b3JUZXh0Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLnByb3BzLmNoaWxkcmVuID09PSAnJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZvcmNlRmxhZyA/IE5FV0xJTkVfQSA6IE5FV0xJTkVfQjtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnc3BhbicsXG4gICAgICB7IGtleTogdGhpcy5fZm9yY2VGbGFnID8gJ0EnIDogJ0InLCAnZGF0YS10ZXh0JzogJ3RydWUnIH0sXG4gICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gRHJhZnRFZGl0b3JUZXh0Tm9kZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFmdEVkaXRvclRleHROb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdEVkaXRvclRleHROb2RlLnJlYWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIFVzYWdlIG5vdGU6XG4gKiBUaGlzIG1vZHVsZSBtYWtlcyBhIGJlc3QgZWZmb3J0IHRvIGV4cG9ydCB0aGUgc2FtZSBkYXRhIHdlIHdvdWxkIGludGVybmFsbHkuXG4gKiBBdCBGYWNlYm9vayB3ZSB1c2UgYSBzZXJ2ZXItZ2VuZXJhdGVkIG1vZHVsZSB0aGF0IGRvZXMgdGhlIHBhcnNpbmcgYW5kXG4gKiBleHBvcnRzIHRoZSBkYXRhIGZvciB0aGUgY2xpZW50IHRvIHVzZS4gV2UgY2FuJ3QgcmVseSBvbiBhIHNlcnZlci1zaWRlXG4gKiBpbXBsZW1lbnRhdGlvbiBpbiBvcGVuIHNvdXJjZSBzbyBpbnN0ZWFkIHdlIG1ha2UgdXNlIG9mIGFuIG9wZW4gc291cmNlXG4gKiBsaWJyYXJ5IHRvIGRvIHRoZSBoZWF2eSBsaWZ0aW5nIGFuZCB0aGVuIG1ha2Ugc29tZSBhZGp1c3RtZW50cyBhcyBuZWNlc3NhcnkuXG4gKiBJdCdzIGxpa2VseSB0aGVyZSB3aWxsIGJlIHNvbWUgZGlmZmVyZW5jZXMuIFNvbWUgd2UgY2FuIHNtb290aCBvdmVyLlxuICogT3RoZXJzIGFyZSBnb2luZyB0byBiZSBoYXJkZXIuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVUFQYXJzZXIgPSByZXF1aXJlKCd1YS1wYXJzZXItanMnKTtcblxudmFyIFVOS05PV04gPSAnVW5rbm93bic7XG5cbnZhciBQTEFURk9STV9NQVAgPSB7XG4gICdNYWMgT1MnOiAnTWFjIE9TIFgnXG59O1xuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBVQVBhcnNlciBwbGF0Zm9ybSBuYW1lIHRvIHdoYXQgd2UgZXhwZWN0LlxuICovXG5mdW5jdGlvbiBjb252ZXJ0UGxhdGZvcm1OYW1lKG5hbWUpIHtcbiAgcmV0dXJuIFBMQVRGT1JNX01BUFtuYW1lXSB8fCBuYW1lO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdmVyc2lvbiBudW1iZXIgaW4gcGFydHMuIFRoaXMgaXMgdmVyeSBuYWl2ZS4gV2UgYWN0dWFsbHkgZ2V0IG1ham9yXG4gKiB2ZXJzaW9uIGFzIGEgcGFydCBvZiBVQVBhcnNlciBhbHJlYWR5LCB3aGljaCBpcyBnZW5lcmFsbHkgZ29vZCBlbm91Z2gsIGJ1dFxuICogbGV0J3MgZ2V0IHRoZSBtaW5vciBqdXN0IGluIGNhc2UuXG4gKi9cbmZ1bmN0aW9uIGdldEJyb3dzZXJWZXJzaW9uKHZlcnNpb24pIHtcbiAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ham9yOiAnJyxcbiAgICAgIG1pbm9yOiAnJ1xuICAgIH07XG4gIH1cbiAgdmFyIHBhcnRzID0gdmVyc2lvbi5zcGxpdCgnLicpO1xuICByZXR1cm4ge1xuICAgIG1ham9yOiBwYXJ0c1swXSxcbiAgICBtaW5vcjogcGFydHNbMV1cbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIFVBIGRhdGEgZm9tIFVBUGFyc2VyIGFuZCB0aGVuIGNvbnZlcnQgaXQgdG8gdGhlIGZvcm1hdCB3ZSdyZVxuICogZXhwZWN0aW5nIGZvciBvdXIgQVBJUy5cbiAqL1xudmFyIHBhcnNlciA9IG5ldyBVQVBhcnNlcigpO1xudmFyIHJlc3VsdHMgPSBwYXJzZXIuZ2V0UmVzdWx0KCk7XG5cbi8vIERvIHNvbWUgY29udmVyc2lvbiBmaXJzdC5cbnZhciBicm93c2VyVmVyc2lvbkRhdGEgPSBnZXRCcm93c2VyVmVyc2lvbihyZXN1bHRzLmJyb3dzZXIudmVyc2lvbik7XG52YXIgdWFEYXRhID0ge1xuICBicm93c2VyQXJjaGl0ZWN0dXJlOiByZXN1bHRzLmNwdS5hcmNoaXRlY3R1cmUgfHwgVU5LTk9XTixcbiAgYnJvd3NlckZ1bGxWZXJzaW9uOiByZXN1bHRzLmJyb3dzZXIudmVyc2lvbiB8fCBVTktOT1dOLFxuICBicm93c2VyTWlub3JWZXJzaW9uOiBicm93c2VyVmVyc2lvbkRhdGEubWlub3IgfHwgVU5LTk9XTixcbiAgYnJvd3Nlck5hbWU6IHJlc3VsdHMuYnJvd3Nlci5uYW1lIHx8IFVOS05PV04sXG4gIGJyb3dzZXJWZXJzaW9uOiByZXN1bHRzLmJyb3dzZXIubWFqb3IgfHwgVU5LTk9XTixcbiAgZGV2aWNlTmFtZTogcmVzdWx0cy5kZXZpY2UubW9kZWwgfHwgVU5LTk9XTixcbiAgZW5naW5lTmFtZTogcmVzdWx0cy5lbmdpbmUubmFtZSB8fCBVTktOT1dOLFxuICBlbmdpbmVWZXJzaW9uOiByZXN1bHRzLmVuZ2luZS52ZXJzaW9uIHx8IFVOS05PV04sXG4gIHBsYXRmb3JtQXJjaGl0ZWN0dXJlOiByZXN1bHRzLmNwdS5hcmNoaXRlY3R1cmUgfHwgVU5LTk9XTixcbiAgcGxhdGZvcm1OYW1lOiBjb252ZXJ0UGxhdGZvcm1OYW1lKHJlc3VsdHMub3MubmFtZSkgfHwgVU5LTk9XTixcbiAgcGxhdGZvcm1WZXJzaW9uOiByZXN1bHRzLm9zLnZlcnNpb24gfHwgVU5LTk9XTixcbiAgcGxhdGZvcm1GdWxsVmVyc2lvbjogcmVzdWx0cy5vcy52ZXJzaW9uIHx8IFVOS05PV05cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdWFEYXRhO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL1VzZXJBZ2VudERhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDQxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVUFQYXJzZXIuanMgdjAuNy4xN1xuICogTGlnaHR3ZWlnaHQgSmF2YVNjcmlwdC1iYXNlZCBVc2VyLUFnZW50IHN0cmluZyBwYXJzZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWlzYWxtYW4vdWEtcGFyc2VyLWpzXG4gKlxuICogQ29weXJpZ2h0IMKpIDIwMTItMjAxNiBGYWlzYWwgU2FsbWFuIDxmeXpsbWFuQGdtYWlsLmNvbT5cbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgR1BMdjIgJiBNSVRcbiAqL1xuXG4oZnVuY3Rpb24gKHdpbmRvdywgdW5kZWZpbmVkKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLy8vLy8vLy8vLy8vL1xuICAgIC8vIENvbnN0YW50c1xuICAgIC8vLy8vLy8vLy8vLy9cblxuXG4gICAgdmFyIExJQlZFUlNJT04gID0gJzAuNy4xNycsXG4gICAgICAgIEVNUFRZICAgICAgID0gJycsXG4gICAgICAgIFVOS05PV04gICAgID0gJz8nLFxuICAgICAgICBGVU5DX1RZUEUgICA9ICdmdW5jdGlvbicsXG4gICAgICAgIFVOREVGX1RZUEUgID0gJ3VuZGVmaW5lZCcsXG4gICAgICAgIE9CSl9UWVBFICAgID0gJ29iamVjdCcsXG4gICAgICAgIFNUUl9UWVBFICAgID0gJ3N0cmluZycsXG4gICAgICAgIE1BSk9SICAgICAgID0gJ21ham9yJywgLy8gZGVwcmVjYXRlZFxuICAgICAgICBNT0RFTCAgICAgICA9ICdtb2RlbCcsXG4gICAgICAgIE5BTUUgICAgICAgID0gJ25hbWUnLFxuICAgICAgICBUWVBFICAgICAgICA9ICd0eXBlJyxcbiAgICAgICAgVkVORE9SICAgICAgPSAndmVuZG9yJyxcbiAgICAgICAgVkVSU0lPTiAgICAgPSAndmVyc2lvbicsXG4gICAgICAgIEFSQ0hJVEVDVFVSRT0gJ2FyY2hpdGVjdHVyZScsXG4gICAgICAgIENPTlNPTEUgICAgID0gJ2NvbnNvbGUnLFxuICAgICAgICBNT0JJTEUgICAgICA9ICdtb2JpbGUnLFxuICAgICAgICBUQUJMRVQgICAgICA9ICd0YWJsZXQnLFxuICAgICAgICBTTUFSVFRWICAgICA9ICdzbWFydHR2JyxcbiAgICAgICAgV0VBUkFCTEUgICAgPSAnd2VhcmFibGUnLFxuICAgICAgICBFTUJFRERFRCAgICA9ICdlbWJlZGRlZCc7XG5cblxuICAgIC8vLy8vLy8vLy8vXG4gICAgLy8gSGVscGVyXG4gICAgLy8vLy8vLy8vL1xuXG5cbiAgICB2YXIgdXRpbCA9IHtcbiAgICAgICAgZXh0ZW5kIDogZnVuY3Rpb24gKHJlZ2V4ZXMsIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIHZhciBtYXJnZWRSZWdleGVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHJlZ2V4ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uc1tpXSAmJiBleHRlbnNpb25zW2ldLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2VkUmVnZXhlc1tpXSA9IGV4dGVuc2lvbnNbaV0uY29uY2F0KHJlZ2V4ZXNbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdlZFJlZ2V4ZXNbaV0gPSByZWdleGVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXJnZWRSZWdleGVzO1xuICAgICAgICB9LFxuICAgICAgICBoYXMgOiBmdW5jdGlvbiAoc3RyMSwgc3RyMikge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RyMSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjIudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cjEudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb3dlcml6ZSA6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFqb3IgOiBmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZih2ZXJzaW9uKSA9PT0gU1RSX1RZUEUgPyB2ZXJzaW9uLnJlcGxhY2UoL1teXFxkXFwuXS9nLCcnKS5zcGxpdChcIi5cIilbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaW0gOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gTWFwIGhlbHBlclxuICAgIC8vLy8vLy8vLy8vLy8vXG5cblxuICAgIHZhciBtYXBwZXIgPSB7XG5cbiAgICAgICAgcmd4IDogZnVuY3Rpb24gKHVhLCBhcnJheXMpIHtcblxuICAgICAgICAgICAgLy92YXIgcmVzdWx0ID0ge30sXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGosIGssIHAsIHEsIG1hdGNoZXMsIG1hdGNoOy8vLCBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgICAvKi8vIGNvbnN0cnVjdCBvYmplY3QgYmFyZWJvbmVzXG4gICAgICAgICAgICBmb3IgKHAgPSAwOyBwIDwgYXJnc1sxXS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgICAgIHEgPSBhcmdzWzFdW3BdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFt0eXBlb2YgcSA9PT0gT0JKX1RZUEUgPyBxWzBdIDogcV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9Ki9cblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCByZWdleGVzIG1hcHNcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYXJyYXlzLmxlbmd0aCAmJiAhbWF0Y2hlcykge1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gYXJyYXlzW2ldLCAgICAgICAvLyBldmVuIHNlcXVlbmNlICgwLDIsNCwuLilcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBhcnJheXNbaSArIDFdOyAgIC8vIG9kZCBzZXF1ZW5jZSAoMSwzLDUsLi4pXG4gICAgICAgICAgICAgICAgaiA9IGsgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IG1hdGNoaW5nIHVhc3RyaW5nIHdpdGggcmVnZXhlc1xuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgcmVnZXgubGVuZ3RoICYmICFtYXRjaGVzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHJlZ2V4W2orK10uZXhlYyh1YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwID0gMDsgcCA8IHByb3BzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzWysra107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHByb3BzW3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGdpdmVuIHByb3BlcnR5IGlzIGFjdHVhbGx5IGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxID09PSBPQkpfVFlQRSAmJiBxLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcVsxXSA9PSBGVU5DX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gbW9kaWZpZWQgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gcVsxXS5jYWxsKHRoaXMsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzaWduIGdpdmVuIHZhbHVlLCBpZ25vcmUgcmVnZXggbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gcVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIGZ1bmN0aW9uIG9yIHJlZ2V4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHFbMV0gPT09IEZVTkNfVFlQRSAmJiAhKHFbMV0uZXhlYyAmJiBxWzFdLnRlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBmdW5jdGlvbiAodXN1YWxseSBzdHJpbmcgbWFwcGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBtYXRjaCA/IHFbMV0uY2FsbCh0aGlzLCBtYXRjaCwgcVsyXSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbml0aXplIG1hdGNoIHVzaW5nIGdpdmVuIHJlZ2V4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1txWzBdXSA9IG1hdGNoID8gbWF0Y2gucmVwbGFjZShxWzFdLCBxWzJdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1txWzBdXSA9IG1hdGNoID8gcVszXS5jYWxsKHRoaXMsIG1hdGNoLnJlcGxhY2UocVsxXSwgcVsyXSkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1txXSA9IG1hdGNoID8gbWF0Y2ggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMpO1xuICAgICAgICAgICAgLy9yZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBzdHIgOiBmdW5jdGlvbiAoc3RyLCBtYXApIHtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBhcnJheVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFwW2ldID09PSBPQkpfVFlQRSAmJiBtYXBbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcFtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWwuaGFzKG1hcFtpXVtqXSwgc3RyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaSA9PT0gVU5LTk9XTikgPyB1bmRlZmluZWQgOiBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmhhcyhtYXBbaV0sIHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpID09PSBVTktOT1dOKSA/IHVuZGVmaW5lZCA6IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFN0cmluZyBtYXBcbiAgICAvLy8vLy8vLy8vLy8vL1xuXG5cbiAgICB2YXIgbWFwcyA9IHtcblxuICAgICAgICBicm93c2VyIDoge1xuICAgICAgICAgICAgb2xkc2FmYXJpIDoge1xuICAgICAgICAgICAgICAgIHZlcnNpb24gOiB7XG4gICAgICAgICAgICAgICAgICAgICcxLjAnICAgOiAnLzgnLFxuICAgICAgICAgICAgICAgICAgICAnMS4yJyAgIDogJy8xJyxcbiAgICAgICAgICAgICAgICAgICAgJzEuMycgICA6ICcvMycsXG4gICAgICAgICAgICAgICAgICAgICcyLjAnICAgOiAnLzQxMicsXG4gICAgICAgICAgICAgICAgICAgICcyLjAuMicgOiAnLzQxNicsXG4gICAgICAgICAgICAgICAgICAgICcyLjAuMycgOiAnLzQxNycsXG4gICAgICAgICAgICAgICAgICAgICcyLjAuNCcgOiAnLzQxOScsXG4gICAgICAgICAgICAgICAgICAgICc/JyAgICAgOiAnLydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV2aWNlIDoge1xuICAgICAgICAgICAgYW1hem9uIDoge1xuICAgICAgICAgICAgICAgIG1vZGVsIDoge1xuICAgICAgICAgICAgICAgICAgICAnRmlyZSBQaG9uZScgOiBbJ1NEJywgJ0tGJ11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3ByaW50IDoge1xuICAgICAgICAgICAgICAgIG1vZGVsIDoge1xuICAgICAgICAgICAgICAgICAgICAnRXZvIFNoaWZ0IDRHJyA6ICc3MzczS1QnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2ZW5kb3IgOiB7XG4gICAgICAgICAgICAgICAgICAgICdIVEMnICAgICAgIDogJ0FQQScsXG4gICAgICAgICAgICAgICAgICAgICdTcHJpbnQnICAgIDogJ1NwcmludCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3MgOiB7XG4gICAgICAgICAgICB3aW5kb3dzIDoge1xuICAgICAgICAgICAgICAgIHZlcnNpb24gOiB7XG4gICAgICAgICAgICAgICAgICAgICdNRScgICAgICAgIDogJzQuOTAnLFxuICAgICAgICAgICAgICAgICAgICAnTlQgMy4xMScgICA6ICdOVDMuNTEnLFxuICAgICAgICAgICAgICAgICAgICAnTlQgNC4wJyAgICA6ICdOVDQuMCcsXG4gICAgICAgICAgICAgICAgICAgICcyMDAwJyAgICAgIDogJ05UIDUuMCcsXG4gICAgICAgICAgICAgICAgICAgICdYUCcgICAgICAgIDogWydOVCA1LjEnLCAnTlQgNS4yJ10sXG4gICAgICAgICAgICAgICAgICAgICdWaXN0YScgICAgIDogJ05UIDYuMCcsXG4gICAgICAgICAgICAgICAgICAgICc3JyAgICAgICAgIDogJ05UIDYuMScsXG4gICAgICAgICAgICAgICAgICAgICc4JyAgICAgICAgIDogJ05UIDYuMicsXG4gICAgICAgICAgICAgICAgICAgICc4LjEnICAgICAgIDogJ05UIDYuMycsXG4gICAgICAgICAgICAgICAgICAgICcxMCcgICAgICAgIDogWydOVCA2LjQnLCAnTlQgMTAuMCddLFxuICAgICAgICAgICAgICAgICAgICAnUlQnICAgICAgICA6ICdBUk0nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBSZWdleCBtYXBcbiAgICAvLy8vLy8vLy8vLy8vXG5cblxuICAgIHZhciByZWdleGVzID0ge1xuXG4gICAgICAgIGJyb3dzZXIgOiBbW1xuXG4gICAgICAgICAgICAvLyBQcmVzdG8gYmFzZWRcbiAgICAgICAgICAgIC8ob3BlcmFcXHNtaW5pKVxcLyhbXFx3XFwuLV0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIE1pbmlcbiAgICAgICAgICAgIC8ob3BlcmFcXHNbbW9iaWxldGFiXSspLit2ZXJzaW9uXFwvKFtcXHdcXC4tXSspL2ksICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIE1vYmkvVGFibGV0XG4gICAgICAgICAgICAvKG9wZXJhKS4rdmVyc2lvblxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhID4gOS44MFxuICAgICAgICAgICAgLyhvcGVyYSlbXFwvXFxzXSsoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgPCA5LjgwXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhvcGlvcylbXFwvXFxzXSsoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgbWluaSBvbiBpcGhvbmUgPj0gOC4wXG4gICAgICAgICAgICBdLCBbW05BTUUsICdPcGVyYSBNaW5pJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC9cXHMob3ByKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIFdlYmtpdFxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnT3BlcmEnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLy8gTWl4ZWRcbiAgICAgICAgICAgIC8oa2luZGxlKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2luZGxlXG4gICAgICAgICAgICAvKGx1bmFzY2FwZXxtYXh0aG9ufG5ldGZyb250fGphc21pbmV8YmxhemVyKVtcXC9cXHNdPyhbXFx3XFwuXSspKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMdW5hc2NhcGUvTWF4dGhvbi9OZXRmcm9udC9KYXNtaW5lL0JsYXplclxuXG4gICAgICAgICAgICAvLyBUcmlkZW50IGJhc2VkXG4gICAgICAgICAgICAvKGF2YW50XFxzfGllbW9iaWxlfHNsaW18YmFpZHUpKD86YnJvd3Nlcik/W1xcL1xcc10/KFtcXHdcXC5dKikvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZhbnQvSUVNb2JpbGUvU2xpbUJyb3dzZXIvQmFpZHVcbiAgICAgICAgICAgIC8oPzptc3xcXCgpKGllKVxccyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyXG5cbiAgICAgICAgICAgIC8vIFdlYmtpdC9LSFRNTCBiYXNlZFxuICAgICAgICAgICAgLyhyZWtvbnEpXFwvKFtcXHdcXC5dKykqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWtvbnFcbiAgICAgICAgICAgIC8oY2hyb21pdW18ZmxvY2t8cm9ja21lbHR8bWlkb3JpfGVwaXBoYW55fHNpbGt8c2t5ZmlyZXxvdmlicm93c2VyfGJvbHR8aXJvbnx2aXZhbGRpfGlyaWRpdW18cGhhbnRvbWpzfGJvd3NlcilcXC8oW1xcd1xcLi1dKykvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWl1bS9GbG9jay9Sb2NrTWVsdC9NaWRvcmkvRXBpcGhhbnkvU2lsay9Ta3lmaXJlL0JvbHQvSXJvbi9JcmlkaXVtL1BoYW50b21KUy9Cb3dzZXJcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKHRyaWRlbnQpLitydls6XFxzXShbXFx3XFwuXSspLitsaWtlXFxzZ2Vja28vaSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTExXG4gICAgICAgICAgICBdLCBbW05BTUUsICdJRSddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKGVkZ2UpXFwvKChcXGQrKT9bXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgRWRnZVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oeWFicm93c2VyKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWWFuZGV4XG4gICAgICAgICAgICBdLCBbW05BTUUsICdZYW5kZXgnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhwdWZmaW4pXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdWZmaW5cbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1B1ZmZpbiddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKCg/OltcXHNcXC9dKXVjP1xccz9icm93c2VyfCg/Omp1Yy4rKXVjd2ViKVtcXC9cXHNdPyhbXFx3XFwuXSspL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVUNCcm93c2VyXG4gICAgICAgICAgICBdLCBbW05BTUUsICdVQ0Jyb3dzZXInXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhjb21vZG9fZHJhZ29uKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21vZG8gRHJhZ29uXG4gICAgICAgICAgICBdLCBbW05BTUUsIC9fL2csICcgJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8obWljcm9tZXNzZW5nZXIpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2VDaGF0XG4gICAgICAgICAgICBdLCBbW05BTUUsICdXZUNoYXQnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhRUSlcXC8oW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBRUSwgYWthIFNob3VRXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL20/KHFxYnJvd3NlcilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUVFCcm93c2VyXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL3hpYW9taVxcL21pdWlicm93c2VyXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTUlVSSBCcm93c2VyXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdNSVVJIEJyb3dzZXInXV0sIFtcblxuICAgICAgICAgICAgLztmYmF2XFwvKFtcXHdcXC5dKyk7L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWNlYm9vayBBcHAgZm9yIGlPUyAmIEFuZHJvaWRcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0ZhY2Vib29rJ11dLCBbXG5cbiAgICAgICAgICAgIC9oZWFkbGVzc2Nocm9tZSg/OlxcLyhbXFx3XFwuXSspfFxccykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSBIZWFkbGVzc1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnQ2hyb21lIEhlYWRsZXNzJ11dLCBbXG5cbiAgICAgICAgICAgIC9cXHN3dlxcKS4rKGNocm9tZSlcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgV2ViVmlld1xuICAgICAgICAgICAgXSwgW1tOQU1FLCAvKC4rKS8sICckMSBXZWJWaWV3J10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oKD86b2N1bHVzfHNhbXN1bmcpYnJvd3NlcilcXC8oW1xcd1xcLl0rKS9pXG4gICAgICAgICAgICBdLCBbW05BTUUsIC8oLisoPzpnfHVzKSkoLispLywgJyQxICQyJ10sIFZFUlNJT05dLCBbICAgICAgICAgICAgICAgIC8vIE9jdWx1cyAvIFNhbXN1bmcgQnJvd3NlclxuXG4gICAgICAgICAgICAvYW5kcm9pZC4rdmVyc2lvblxcLyhbXFx3XFwuXSspXFxzKyg/Om1vYmlsZVxccz9zYWZhcml8c2FmYXJpKSovaSAgICAgICAgLy8gQW5kcm9pZCBCcm93c2VyXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdBbmRyb2lkIEJyb3dzZXInXV0sIFtcblxuICAgICAgICAgICAgLyhjaHJvbWV8b21uaXdlYnxhcm9yYXxbdGl6ZW5va2FdezV9XFxzP2Jyb3dzZXIpXFwvdj8oW1xcd1xcLl0rKS9pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZS9PbW5pV2ViL0Fyb3JhL1RpemVuL05va2lhXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhkb2xmaW4pXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb2xwaGluXG4gICAgICAgICAgICBdLCBbW05BTUUsICdEb2xwaGluJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oKD86YW5kcm9pZC4rKWNybW98Y3Jpb3MpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIGZvciBBbmRyb2lkL2lPU1xuICAgICAgICAgICAgXSwgW1tOQU1FLCAnQ2hyb21lJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oY29hc3QpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgQ29hc3RcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ09wZXJhIENvYXN0J10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC9meGlvc1xcLyhbXFx3XFwuLV0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBmb3IgaU9TXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdGaXJlZm94J11dLCBbXG5cbiAgICAgICAgICAgIC92ZXJzaW9uXFwvKFtcXHdcXC5dKykuKz9tb2JpbGVcXC9cXHcrXFxzKHNhZmFyaSkvaSAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9iaWxlIFNhZmFyaVxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnTW9iaWxlIFNhZmFyaSddXSwgW1xuXG4gICAgICAgICAgICAvdmVyc2lvblxcLyhbXFx3XFwuXSspLis/KG1vYmlsZVxccz9zYWZhcml8c2FmYXJpKS9pICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgJiBTYWZhcmkgTW9iaWxlXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgTkFNRV0sIFtcblxuICAgICAgICAgICAgL3dlYmtpdC4rPyhnc2EpXFwvKFtcXHdcXC5dKykuKz8obW9iaWxlXFxzP3NhZmFyaXxzYWZhcmkpKFxcL1tcXHdcXC5dKykvaSAgLy8gR29vZ2xlIFNlYXJjaCBBcHBsaWFuY2Ugb24gaU9TXG4gICAgICAgICAgICBdLCBbW05BTUUsICdHU0EnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL3dlYmtpdC4rPyhtb2JpbGVcXHM/c2FmYXJpfHNhZmFyaSkoXFwvW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDwgMy4wXG4gICAgICAgICAgICBdLCBbTkFNRSwgW1ZFUlNJT04sIG1hcHBlci5zdHIsIG1hcHMuYnJvd3Nlci5vbGRzYWZhcmkudmVyc2lvbl1dLCBbXG5cbiAgICAgICAgICAgIC8oa29ucXVlcm9yKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS29ucXVlcm9yXG4gICAgICAgICAgICAvKHdlYmtpdHxraHRtbClcXC8oW1xcd1xcLl0rKS9pXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLy8gR2Vja28gYmFzZWRcbiAgICAgICAgICAgIC8obmF2aWdhdG9yfG5ldHNjYXBlKVxcLyhbXFx3XFwuLV0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV0c2NhcGVcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ05ldHNjYXBlJ10sIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKHN3aWZ0Zm94KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3aWZ0Zm94XG4gICAgICAgICAgICAvKGljZWRyYWdvbnxpY2V3ZWFzZWx8Y2FtaW5vfGNoaW1lcmF8ZmVubmVjfG1hZW1vXFxzYnJvd3NlcnxtaW5pbW98Y29ua2Vyb3IpW1xcL1xcc10/KFtcXHdcXC5cXCtdKykvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWNlRHJhZ29uL0ljZXdlYXNlbC9DYW1pbm8vQ2hpbWVyYS9GZW5uZWMvTWFlbW8vTWluaW1vL0Nvbmtlcm9yXG4gICAgICAgICAgICAvKGZpcmVmb3h8c2VhbW9ua2V5fGstbWVsZW9ufGljZWNhdHxpY2VhcGV8ZmlyZWJpcmR8cGhvZW5peClcXC8oW1xcd1xcLi1dKykvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveC9TZWFNb25rZXkvSy1NZWxlb24vSWNlQ2F0L0ljZUFwZS9GaXJlYmlyZC9QaG9lbml4XG4gICAgICAgICAgICAvKG1vemlsbGEpXFwvKFtcXHdcXC5dKykuK3J2XFw6LitnZWNrb1xcL1xcZCsvaSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vemlsbGFcblxuICAgICAgICAgICAgLy8gT3RoZXJcbiAgICAgICAgICAgIC8ocG9sYXJpc3xseW54fGRpbGxvfGljYWJ8ZG9yaXN8YW1heWF8dzNtfG5ldHN1cmZ8c2xlaXBuaXIpW1xcL1xcc10/KFtcXHdcXC5dKykvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9sYXJpcy9MeW54L0RpbGxvL2lDYWIvRG9yaXMvQW1heWEvdzNtL05ldFN1cmYvU2xlaXBuaXJcbiAgICAgICAgICAgIC8obGlua3MpXFxzXFwoKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpbmtzXG4gICAgICAgICAgICAvKGdvYnJvd3NlcilcXC8/KFtcXHdcXC5dKykqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvQnJvd3NlclxuICAgICAgICAgICAgLyhpY2VcXHM/YnJvd3NlcilcXC92PyhbXFx3XFwuX10rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUNFIEJyb3dzZXJcbiAgICAgICAgICAgIC8obW9zYWljKVtcXC9cXHNdKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vc2FpY1xuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dXG5cbiAgICAgICAgICAgIC8qIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gTWVkaWEgcGxheWVycyBCRUdJTlxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICAgICwgW1xuXG4gICAgICAgICAgICAvKGFwcGxlKD86Y29yZW1lZGlhfCkpXFwvKChcXGQrKVtcXHdcXC5fXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmljIEFwcGxlIENvcmVNZWRpYVxuICAgICAgICAgICAgLyhjb3JlbWVkaWEpIHYoKFxcZCspW1xcd1xcLl9dKykvaVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oYXF1YWx1bmd8bHlzc25hfGJzcGxheWVyKVxcLygoXFxkKyk/W1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgIC8vIEFxdWFsdW5nL0x5c3NuYS9CU1BsYXllclxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oYXJlc3xvc3Nwcm94eSlcXHMoKFxcZCspW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyZXMvT1NTUHJveHlcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKGF1ZGFjaW91c3xhdWRpbXVzaWNzdHJlYW18YW1hcm9rfGJhc3N8Y29yZXxkYWx2aWt8Z25vbWVtcGxheWVyfG11c2ljIG9uIGNvbnNvbGV8bnNwbGF5ZXJ8cHNwLWludGVybmV0cmFkaW9wbGF5ZXJ8dmlkZW9zKVxcLygoXFxkKylbXFx3XFwuLV0rKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdWRhY2lvdXMvQXVkaU11c2ljU3RyZWFtL0FtYXJvay9CQVNTL09wZW5DT1JFL0RhbHZpay9Hbm9tZU1wbGF5ZXIvTW9DXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5TUGxheWVyL1BTUC1JbnRlcm5ldFJhZGlvUGxheWVyL1ZpZGVvc1xuICAgICAgICAgICAgLyhjbGVtZW50aW5lfG11c2ljIHBsYXllciBkYWVtb24pXFxzKChcXGQrKVtcXHdcXC4tXSspL2ksICAgICAgICAgICAgICAgLy8gQ2xlbWVudGluZS9NUERcbiAgICAgICAgICAgIC8obGcgcGxheWVyfG5leHBsYXllcilcXHMoKFxcZCspW1xcZFxcLl0rKS9pLFxuICAgICAgICAgICAgL3BsYXllclxcLyhuZXhwbGF5ZXJ8bGcgcGxheWVyKVxccygoXFxkKylbXFx3XFwuLV0rKS9pICAgICAgICAgICAgICAgICAgIC8vIE5leFBsYXllci9MRyBQbGF5ZXJcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyhuZXhwbGF5ZXIpXFxzKChcXGQrKVtcXHdcXC4tXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV4cGxheWVyXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhmbHJwKVxcLygoXFxkKylbXFx3XFwuLV0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxpcCBQbGF5ZXJcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0ZsaXAgUGxheWVyJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oZnN0cmVhbXxuYXRpdmVob3N0fHF1ZXJ5c2Vla3NwaWRlcnxpYS1hcmNoaXZlcnxmYWNlYm9va2V4dGVybmFsaGl0KS9pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZTdHJlYW0vTmF0aXZlSG9zdC9RdWVyeVNlZWtTcGlkZXIvSUEgQXJjaGl2ZXIvZmFjZWJvb2tleHRlcm5hbGhpdFxuICAgICAgICAgICAgXSwgW05BTUVdLCBbXG5cbiAgICAgICAgICAgIC8oZ3N0cmVhbWVyKSBzb3VwaHR0cHNyYyAoPzpcXChbXlxcKV0rXFwpKXswLDF9IGxpYnNvdXBcXC8oKFxcZCspW1xcd1xcLi1dKykvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHc3RyZWFtZXJcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKGh0YyBzdHJlYW1pbmcgcGxheWVyKVxcc1tcXHdfXStcXHNcXC9cXHMoKFxcZCspW1xcZFxcLl0rKS9pLCAgICAgICAgICAgICAgLy8gSFRDIFN0cmVhbWluZyBQbGF5ZXJcbiAgICAgICAgICAgIC8oamF2YXxweXRob24tdXJsbGlifHB5dGhvbi1yZXF1ZXN0c3x3Z2V0fGxpYmN1cmwpXFwvKChcXGQrKVtcXHdcXC4tX10rKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKYXZhL3VybGxpYi9yZXF1ZXN0cy93Z2V0L2NVUkxcbiAgICAgICAgICAgIC8obGF2ZikoKFxcZCspW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGF2ZiAoRkZNUEVHKVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oaHRjX29uZV9zKVxcLygoXFxkKylbXFxkXFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhUQyBPbmUgU1xuICAgICAgICAgICAgXSwgW1tOQU1FLCAvXy9nLCAnICddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKG1wbGF5ZXIpKD86XFxzfFxcLykoPzooPzpzaGVycHlhLSl7MCwxfXN2bikoPzotfFxccykoclxcZCsoPzotXFxkK1tcXHdcXC4tXSspezAsMX0pL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTVBsYXllciBTVk5cbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKG1wbGF5ZXIpKD86XFxzfFxcL3xbdW5rb3ctXSspKChcXGQrKVtcXHdcXC4tXSspL2kgICAgICAgICAgICAgICAgICAgICAgLy8gTVBsYXllclxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8obXBsYXllcikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTVBsYXllciAobm8gb3RoZXIgaW5mbylcbiAgICAgICAgICAgIC8oeW91cm11emUpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWW91ck11emVcbiAgICAgICAgICAgIC8obWVkaWEgcGxheWVyIGNsYXNzaWN8bmVybyBzaG93dGltZSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWVkaWEgUGxheWVyIENsYXNzaWMvTmVybyBTaG93VGltZVxuICAgICAgICAgICAgXSwgW05BTUVdLCBbXG5cbiAgICAgICAgICAgIC8obmVybyAoPzpob21lfHNjb3V0KSlcXC8oKFxcZCspW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lcm8gSG9tZS9OZXJvIFNjb3V0XG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhub2tpYVxcZCspXFwvKChcXGQrKVtcXHdcXC4tXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5va2lhXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL1xccyhzb25nYmlyZClcXC8oKFxcZCspW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbmdiaXJkL1BoaWxpcHMtU29uZ2JpcmRcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKHdpbmFtcCkzIHZlcnNpb24gKChcXGQrKVtcXHdcXC4tXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpbmFtcFxuICAgICAgICAgICAgLyh3aW5hbXApXFxzKChcXGQrKVtcXHdcXC4tXSspL2ksXG4gICAgICAgICAgICAvKHdpbmFtcCltcGVnXFwvKChcXGQrKVtcXHdcXC4tXSspL2lcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKG9jbXMtYm90fHRhcGlucmFkaW98dHVuZWluIHJhZGlvfHVua25vd258d2luYW1wfGlubGlnaHQgcmFkaW8pL2kgIC8vIE9DTVMtYm90L3RhcCBpbiByYWRpby90dW5laW4vdW5rbm93bi93aW5hbXAgKG5vIG90aGVyIGluZm8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlubGlnaHQgcmFkaW9cbiAgICAgICAgICAgIF0sIFtOQU1FXSwgW1xuXG4gICAgICAgICAgICAvKHF1aWNrdGltZXxybWF8cmFkaW9hcHB8cmFkaW9jbGllbnRhcHBsaWNhdGlvbnxzb3VuZHRhcHx0b3RlbXxzdGFnZWZyaWdodHxzdHJlYW1pdW0pXFwvKChcXGQrKVtcXHdcXC4tXSspL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVpY2tUaW1lL1JlYWxNZWRpYS9SYWRpb0FwcC9SYWRpb0NsaWVudEFwcGxpY2F0aW9uL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb3VuZFRhcC9Ub3RlbS9TdGFnZWZyaWdodC9TdHJlYW1pdW1cbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKHNtcCkoKFxcZCspW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNNUFxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8odmxjKSBtZWRpYSBwbGF5ZXIgLSB2ZXJzaW9uICgoXFxkKylbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgLy8gVkxDIFZpZGVvbGFuXG4gICAgICAgICAgICAvKHZsYylcXC8oKFxcZCspW1xcd1xcLi1dKykvaSxcbiAgICAgICAgICAgIC8oeGJtY3xndmZzfHhpbmV8eG1tc3xpcmFwcClcXC8oKFxcZCspW1xcd1xcLi1dKykvaSwgICAgICAgICAgICAgICAgICAgIC8vIFhCTUMvZ3Zmcy9YaW5lL1hNTVMvaXJhcHBcbiAgICAgICAgICAgIC8oZm9vYmFyMjAwMClcXC8oKFxcZCspW1xcZFxcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvb2JhcjIwMDBcbiAgICAgICAgICAgIC8oaXR1bmVzKVxcLygoXFxkKylbXFxkXFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlUdW5lc1xuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8od21wbGF5ZXIpXFwvKChcXGQrKVtcXHdcXC4tXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgTWVkaWEgUGxheWVyXG4gICAgICAgICAgICAvKHdpbmRvd3MtbWVkaWEtcGxheWVyKVxcLygoXFxkKylbXFx3XFwuLV0rKS9pXG4gICAgICAgICAgICBdLCBbW05BTUUsIC8tL2csICcgJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC93aW5kb3dzXFwvKChcXGQrKVtcXHdcXC4tXSspIHVwbnBcXC9bXFxkXFwuXSsgZGxuYWRvY1xcL1tcXGRcXC5dKyAoaG9tZSBtZWRpYSBzZXJ2ZXIpL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyBNZWRpYSBTZXJ2ZXJcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ1dpbmRvd3MnXV0sIFtcblxuICAgICAgICAgICAgLyhjb21cXC5yaXNldXByYWRpb2FsYXJtKVxcLygoXFxkKylbXFxkXFwuXSopL2kgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJpc2VVUCBSYWRpbyBBbGFybVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8ocmFkLmlvKVxccygoXFxkKylbXFxkXFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJhZC5pb1xuICAgICAgICAgICAgLyhyYWRpby4oPzpkZXxhdHxmcikpXFxzKChcXGQrKVtcXGRcXC5dKykvaVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAncmFkLmlvJ10sIFZFUlNJT05dXG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIE1lZGlhIHBsYXllcnMgRU5EXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLyovXG5cbiAgICAgICAgXSxcblxuICAgICAgICBjcHUgOiBbW1xuXG4gICAgICAgICAgICAvKD86KGFtZHx4KD86KD86ODZ8NjQpW18tXSk/fHdvd3x3aW4pNjQpWztcXCldL2kgICAgICAgICAgICAgICAgICAgICAvLyBBTUQ2NFxuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdhbWQ2NCddXSwgW1xuXG4gICAgICAgICAgICAvKGlhMzIoPz07KSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElBMzIgKHF1aWNrdGltZSlcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCB1dGlsLmxvd2VyaXplXV0sIFtcblxuICAgICAgICAgICAgLygoPzppWzM0Nl18eCk4NilbO1xcKV0vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUEzMlxuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdpYTMyJ11dLCBbXG5cbiAgICAgICAgICAgIC8vIFBvY2tldFBDIG1pc3Rha2VubHkgaWRlbnRpZmllZCBhcyBQb3dlclBDXG4gICAgICAgICAgICAvd2luZG93c1xccyhjZXxtb2JpbGUpO1xcc3BwYzsvaVxuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdhcm0nXV0sIFtcblxuICAgICAgICAgICAgLygoPzpwcGN8cG93ZXJwYykoPzo2NCk/KSg/Olxcc21hY3w7fFxcKSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvd2VyUENcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAvb3dlci8sICcnLCB1dGlsLmxvd2VyaXplXV0sIFtcblxuICAgICAgICAgICAgLyhzdW40XFx3KVs7XFwpXS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNQQVJDXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ3NwYXJjJ11dLCBbXG5cbiAgICAgICAgICAgIC8oKD86YXZyMzJ8aWE2NCg/PTspKXw2OGsoPz1cXCkpfGFybSg/OjY0fCg/PXZcXGQrOykpfCg/PWF0bWVsXFxzKWF2cnwoPzppcml4fG1pcHN8c3BhcmMpKD86NjQpPyg/PTspfHBhLXJpc2MpL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUE2NCwgNjhLLCBBUk0vNjQsIEFWUi8zMiwgSVJJWC82NCwgTUlQUy82NCwgU1BBUkMvNjQsIFBBLVJJU0NcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCB1dGlsLmxvd2VyaXplXV1cbiAgICAgICAgXSxcblxuICAgICAgICBkZXZpY2UgOiBbW1xuXG4gICAgICAgICAgICAvXFwoKGlwYWR8cGxheWJvb2spO1tcXHdcXHNcXCk7LV0rKHJpbXxhcHBsZSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUGFkL1BsYXlCb29rXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFZFTkRPUiwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hcHBsZWNvcmVtZWRpYVxcL1tcXHdcXC5dKyBcXCgoaXBhZCkvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlQYWRcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FwcGxlJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvKGFwcGxlXFxzezAsMX10dikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBsZSBUVlxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ0FwcGxlIFRWJ10sIFtWRU5ET1IsICdBcHBsZSddXSwgW1xuXG4gICAgICAgICAgICAvKGFyY2hvcylcXHMoZ2FtZXBhZDI/KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcmNob3NcbiAgICAgICAgICAgIC8oaHApLisodG91Y2hwYWQpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFAgVG91Y2hQYWRcbiAgICAgICAgICAgIC8oaHApLisodGFibGV0KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFAgVGFibGV0XG4gICAgICAgICAgICAvKGtpbmRsZSlcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtpbmRsZVxuICAgICAgICAgICAgL1xccyhub29rKVtcXHdcXHNdK2J1aWxkXFwvKFxcdyspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vb2tcbiAgICAgICAgICAgIC8oZGVsbClcXHMoc3RyZWFba3ByXFxzXFxkXSpbXFxka29dKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGwgU3RyZWFrXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8oa2ZbQS16XSspXFxzYnVpbGRcXC9bXFx3XFwuXSsuKnNpbGtcXC8vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLaW5kbGUgRmlyZSBIRFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQW1hem9uJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyhzZHxrZilbMDM0OWhpam9yc3R1d10rXFxzYnVpbGRcXC9bXFx3XFwuXSsuKnNpbGtcXC8vaSAgICAgICAgICAgICAgICAgIC8vIEZpcmUgUGhvbmVcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsIG1hcHBlci5zdHIsIG1hcHMuZGV2aWNlLmFtYXpvbi5tb2RlbF0sIFtWRU5ET1IsICdBbWF6b24nXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9cXCgoaXBbaG9uZWR8XFxzXFx3Kl0rKTsuKyhhcHBsZSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaVBvZC9pUGhvbmVcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgVkVORE9SLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXCgoaXBbaG9uZWR8XFxzXFx3Kl0rKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaVBvZC9pUGhvbmVcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FwcGxlJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKGJsYWNrYmVycnkpW1xccy1dPyhcXHcrKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2tCZXJyeVxuICAgICAgICAgICAgLyhibGFja2JlcnJ5fGJlbnF8cGFsbSg/PVxcLSl8c29ueWVyaWNzc29ufGFjZXJ8YXN1c3xkZWxsfG1laXp1fG1vdG9yb2xhfHBvbHl0cm9uKVtcXHNfLV0/KFtcXHctXSspKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCZW5RL1BhbG0vU29ueS1Fcmljc3Nvbi9BY2VyL0FzdXMvRGVsbC9NZWl6dS9Nb3Rvcm9sYS9Qb2x5dHJvblxuICAgICAgICAgICAgLyhocClcXHMoW1xcd1xcc10rXFx3KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFAgaVBBUVxuICAgICAgICAgICAgLyhhc3VzKS0/KFxcdyspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXN1c1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcKGJiMTA7XFxzKFxcdyspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFja0JlcnJ5IDEwXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdCbGFja0JlcnJ5J10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3VzIFRhYmxldHNcbiAgICAgICAgICAgIC9hbmRyb2lkLisodHJhbnNmb1twcmltZVxcc117NCwxMH1cXHNcXHcrfGVlZXBjfHNsaWRlclxcc1xcdyt8bmV4dXMgN3xwYWRmb25lKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBc3VzJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvKHNvbnkpXFxzKHRhYmxldFxcc1twc10pXFxzYnVpbGRcXC8vaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ueVxuICAgICAgICAgICAgLyhzb255KT8oPzpzZ3AuKylcXHNidWlsZFxcLy9pXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ1NvbnknXSwgW01PREVMLCAnWHBlcmlhIFRhYmxldCddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9hbmRyb2lkLitcXHMoW2MtZ11cXGR7NH18c29bLWxdXFx3KylcXHNidWlsZFxcLy9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTb255J10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvXFxzKG91eWEpXFxzL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3V5YVxuICAgICAgICAgICAgLyhuaW50ZW5kbylcXHMoW3dpZHMzdV0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmludGVuZG9cbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgQ09OU09MRV1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKHNoaWVsZClcXHNidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOdmlkaWFcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ052aWRpYSddLCBbVFlQRSwgQ09OU09MRV1dLCBbXG5cbiAgICAgICAgICAgIC8ocGxheXN0YXRpb25cXHNbMzRwb3J0YWJsZXZpXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYXlzdGF0aW9uXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTb255J10sIFtUWVBFLCBDT05TT0xFXV0sIFtcblxuICAgICAgICAgICAgLyhzcHJpbnRcXHMoXFx3KykpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwcmludCBQaG9uZXNcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCBtYXBwZXIuc3RyLCBtYXBzLmRldmljZS5zcHJpbnQudmVuZG9yXSwgW01PREVMLCBtYXBwZXIuc3RyLCBtYXBzLmRldmljZS5zcHJpbnQubW9kZWxdLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLyhsZW5vdm8pXFxzPyhTKD86NTAwMHw2MDAwKSsoPzpbLV1bXFx3K10pKS9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlbm92byB0YWJsZXRzXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8oaHRjKVs7X1xccy1dKyhbXFx3XFxzXSsoPz1cXCkpfFxcdyspKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIVENcbiAgICAgICAgICAgIC8oenRlKS0oXFx3KykqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFpURVxuICAgICAgICAgICAgLyhhbGNhdGVsfGdlZWtzcGhvbmV8bGVub3ZvfG5leGlhbnxwYW5hc29uaWN8KD89O1xccylzb255KVtfXFxzLV0/KFtcXHctXSspKi9pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsY2F0ZWwvR2Vla3NQaG9uZS9MZW5vdm8vTmV4aWFuL1BhbmFzb25pYy9Tb255XG4gICAgICAgICAgICBdLCBbVkVORE9SLCBbTU9ERUwsIC9fL2csICcgJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKG5leHVzXFxzOSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIVEMgTmV4dXMgOVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnSFRDJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvZFxcL2h1YXdlaShbXFx3XFxzLV0rKVs7XFwpXS9pLFxuICAgICAgICAgICAgLyhuZXh1c1xcczZwKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSHVhd2VpXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdIdWF3ZWknXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8obWljcm9zb2Z0KTtcXHMobHVtaWFbXFxzXFx3XSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IEx1bWlhXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9bXFxzXFwoO10oeGJveCg/Olxcc29uZSk/KVtcXHNcXCk7XS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgWGJveFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTWljcm9zb2Z0J10sIFtUWVBFLCBDT05TT0xFXV0sIFtcbiAgICAgICAgICAgIC8oa2luXFwuW29uZXR3XXszfSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBLaW5cbiAgICAgICAgICAgIF0sIFtbTU9ERUwsIC9cXC4vZywgJyAnXSwgW1ZFTkRPUiwgJ01pY3Jvc29mdCddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3Rvcm9sYVxuICAgICAgICAgICAgL1xccyhtaWxlc3RvbmV8ZHJvaWQoPzpbMi00eF18XFxzKD86YmlvbmljfHgyfHByb3xyYXpyKSk/KDo/XFxzNGcpPylbXFx3XFxzXStidWlsZFxcLy9pLFxuICAgICAgICAgICAgL21vdFtcXHMtXT8oXFx3KykqL2ksXG4gICAgICAgICAgICAvKFhUXFxkezMsNH0pIGJ1aWxkXFwvL2ksXG4gICAgICAgICAgICAvKG5leHVzXFxzNikvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTW90b3JvbGEnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvYW5kcm9pZC4rXFxzKG16NjBcXGR8eG9vbVtcXHMyXXswLDJ9KVxcc2J1aWxkXFwvL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ01vdG9yb2xhJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvaGJidHZcXC9cXGQrXFwuXFxkK1xcLlxcZCtcXHMrXFwoW1xcd1xcc10qO1xccyooXFx3W147XSopOyhbXjtdKikvaSAgICAgICAgICAgIC8vIEhiYlRWIGRldmljZXNcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCB1dGlsLnRyaW1dLCBbTU9ERUwsIHV0aWwudHJpbV0sIFtUWVBFLCBTTUFSVFRWXV0sIFtcblxuICAgICAgICAgICAgL2hiYnR2LittYXBsZTsoXFxkKykvaVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgL14vLCAnU21hcnRUViddLCBbVkVORE9SLCAnU2Ftc3VuZyddLCBbVFlQRSwgU01BUlRUVl1dLCBbXG5cbiAgICAgICAgICAgIC9cXChkdHZbXFwpO10uKyhhcXVvcykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGFycFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU2hhcnAnXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rKChzY2gtaVs4OV0wXFxkfHNody1tMzgwc3xndC1wXFxkezR9fGd0LW5cXGQrfHNnaC10OFs1Nl05fG5leHVzIDEwKSkvaSxcbiAgICAgICAgICAgIC8oKFNNLVRcXHcrKSkvaVxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdTYW1zdW5nJ10sIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFsgICAgICAgICAgICAgICAgICAvLyBTYW1zdW5nXG4gICAgICAgICAgICAvc21hcnQtdHYuKyhzYW1zdW5nKS9pXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBbVFlQRSwgU01BUlRUVl0sIE1PREVMXSwgW1xuICAgICAgICAgICAgLygoc1tjZ3BdaC1cXHcrfGd0LVxcdyt8Z2FsYXh5XFxzbmV4dXN8c20tXFx3W1xcd1xcZF0rKSkvaSxcbiAgICAgICAgICAgIC8oc2FtW3N1bmddKilbXFxzLV0qKFxcdystP1tcXHctXSopKi9pLFxuICAgICAgICAgICAgL3NlYy0oKHNnaFxcdyspKS9pXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ1NhbXN1bmcnXSwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvc2llLShcXHcrKSovaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaWVtZW5zXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTaWVtZW5zJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKG1hZW1vfG5va2lhKS4qKG45MDB8bHVtaWFcXHNcXGQrKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9raWFcbiAgICAgICAgICAgIC8obm9raWEpW1xcc18tXT8oW1xcdy1dKykqL2lcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnTm9raWEnXSwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZFxcczNcXC5bXFxzXFx3Oy1dezEwfShhXFxkezN9KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNlclxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQWNlciddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKyhbdmxda1xcLT9cXGR7M30pXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMRyBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0xHJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL2FuZHJvaWRcXHMzXFwuW1xcc1xcdzstXXsxMH0obGc/KS0oWzA2Y3Y5XXszLDR9KS9pICAgICAgICAgICAgICAgICAgICAgLy8gTEcgVGFibGV0XG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ0xHJ10sIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8obGcpIG5ldGNhc3RcXC50di9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExHIFNtYXJ0VFZcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvKG5leHVzXFxzWzQ1XSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMR1xuICAgICAgICAgICAgL2xnW2U7XFxzXFwvLV0rKFxcdyspKi9pLFxuICAgICAgICAgICAgL2FuZHJvaWQuK2xnKFxcLT9bXFxkXFx3XSspXFxzK2J1aWxkL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0xHJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rKGlkZWF0YWJbYS16MC05XFwtXFxzXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVub3ZvXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdMZW5vdm8nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9saW51eDsuKygoam9sbGEpKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSm9sbGFcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLygocGViYmxlKSlhcHBcXC9bXFxkXFwuXStcXHMvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGViYmxlXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKztcXHMob3BwbylcXHM/KFtcXHdcXHNdKylcXHNidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9QUE9cbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL2Nya2V5L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgQ2hyb21lY2FzdFxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ0Nocm9tZWNhc3QnXSwgW1ZFTkRPUiwgJ0dvb2dsZSddXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rO1xccyhnbGFzcylcXHNcXGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBHbGFzc1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnR29vZ2xlJ10sIFtUWVBFLCBXRUFSQUJMRV1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKHBpeGVsIGMpXFxzL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgUGl4ZWwgQ1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnR29vZ2xlJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rO1xccyhwaXhlbCB4bHxwaXhlbClcXHMvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIFBpeGVsXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdHb29nbGUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLisoXFx3KylcXHMrYnVpbGRcXC9obVxcMS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhpYW9taSBIb25nbWkgJ251bWVyaWMnIG1vZGVsc1xuICAgICAgICAgICAgL2FuZHJvaWQuKyhobVtcXHNcXC1fXSpub3RlP1tcXHNfXSooPzpcXGRcXHcpPylcXHMrYnVpbGQvaSwgICAgICAgICAgICAgICAvLyBYaWFvbWkgSG9uZ21pXG4gICAgICAgICAgICAvYW5kcm9pZC4rKG1pW1xcc1xcLV9dKig/Om9uZXxvbmVbXFxzX11wbHVzfG5vdGUgbHRlKT9bXFxzX10qKD86XFxkXFx3KT8pXFxzK2J1aWxkL2ksICAgIC8vIFhpYW9taSBNaVxuICAgICAgICAgICAgL2FuZHJvaWQuKyhyZWRtaVtcXHNcXC1fXSooPzpub3RlKT8oPzpbXFxzX10qW1xcd1xcc10rKT8pXFxzK2J1aWxkL2kgICAgICAvLyBSZWRtaSBQaG9uZXNcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsIC9fL2csICcgJ10sIFtWRU5ET1IsICdYaWFvbWknXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvYW5kcm9pZC4rKG1pW1xcc1xcLV9dKig/OnBhZCk/KD86W1xcc19dKltcXHdcXHNdKyk/KVxccytidWlsZC9pICAgICAgICAgIC8vIE1pIFBhZCB0YWJsZXRzXG4gICAgICAgICAgICBdLFtbTU9ERUwsIC9fL2csICcgJ10sIFtWRU5ET1IsICdYaWFvbWknXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvYW5kcm9pZC4rO1xccyhtWzEtNV1cXHNub3RlKVxcc2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1laXp1IFRhYmxldFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTWVpenUnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLithMDAwKDEpXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9uZVBsdXNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ09uZVBsdXMnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKFJDVFtcXGRcXHddKylcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSQ0EgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnUkNBJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihWZW51ZVtcXGRcXHNdKilcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsbCBWZW51ZSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdEZWxsJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihRW1R8TV1bXFxkXFx3XSspXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaXpvbiBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1Zlcml6b24nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMrKEJhcm5lc1smXFxzXStOb2JsZVxccyt8Qk5bUlRdKShWPy4qKVxccytidWlsZC9pICAgICAvLyBCYXJuZXMgJiBOb2JsZSBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnQmFybmVzICYgTm9ibGUnXSwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKyhUTVxcZHszfS4qXFxiKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFybmVzICYgTm9ibGUgVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdOdVZpc2lvbiddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooenRlKT8uKyhrXFxkezJ9KVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgLy8gWlRFIEsgU2VyaWVzIFRhYmxldFxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdaVEUnXSwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihnZW5cXGR7M30pXFxzK2J1aWxkLio0OWgvaSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2lzcyBHRU4gTW9iaWxlXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTd2lzcyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooenVyXFxkezN9KVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dpc3MgWlVSIFRhYmxldFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU3dpc3MnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKChaZWtpKT9UQi4qXFxiKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFpla2kgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnWmVraSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgLyhhbmRyb2lkKS4rWztcXC9dXFxzKyhbWVJdXFxkezJ9eD8uKilcXHMrYnVpbGQvaSxcbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMrKERyYWdvbltcXC1cXHNdK1RvdWNoXFxzK3xEVCkoLispXFxzK2J1aWxkL2kgICAgICAgICAgLy8gRHJhZ29uIFRvdWNoIFRhYmxldFxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdEcmFnb24gVG91Y2gnXSwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihOUy0/LispXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2lnbmlhIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0luc2lnbmlhJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKigoTlh8TmV4dCktPy4rKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5leHRCb29rIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ05leHRCb29rJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihYdHJlbWVcXF8/KT8oVigxWzA0NV18MlswMTVdfDMwfDQwfDYwfDdbMDVdfDkwKSlcXHMrYnVpbGQvaVxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdWb2ljZSddLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbICAgICAgICAgICAgICAgICAgICAvLyBWb2ljZSBYdHJlbWUgUGhvbmVzXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKExWVEVMXFwtPyk/KFYxWzEyXSlcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgIC8vIEx2VGVsIFBob25lc1xuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdMdlRlbCddLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKFYoMTAwTUR8NzAwTkF8NzAxMXw5MTdHKS4qXFxiKVxccytidWlsZC9pICAgICAgICAgIC8vIEVudml6ZW4gVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnRW52aXplbiddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooTGVbXFxzXFwtXStQYW4pW1xcc1xcLV0rKC4qXFxiKVxccytidWlsZC9pICAgICAgICAgICAgIC8vIExlIFBhbiBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKFRyaW9bXFxzXFwtXSouKilcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWNoU3BlZWQgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTWFjaFNwZWVkJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihUcmluaXR5KVtcXC1cXHNdKihUXFxkezN9KVxccytidWlsZC9pICAgICAgICAgICAgICAgIC8vIFRyaW5pdHkgVGFibGV0c1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKlRVXygxNDkxKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdG9yIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1JvdG9yJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rKEtTKC4rKSlcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbWF6b24gS2luZGxlIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FtYXpvbiddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKyhHaWdhc2V0KVtcXHNcXC1dKyhRLispXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHaWdhc2V0IFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL1xccyh0YWJsZXR8dGFiKVs7XFwvXS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuaWRlbnRpZmlhYmxlIFRhYmxldFxuICAgICAgICAgICAgL1xccyhtb2JpbGUpKD86WztcXC9dfFxcc3NhZmFyaSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmlkZW50aWZpYWJsZSBNb2JpbGVcbiAgICAgICAgICAgIF0sIFtbVFlQRSwgdXRpbC5sb3dlcml6ZV0sIFZFTkRPUiwgTU9ERUxdLCBbXG5cbiAgICAgICAgICAgIC8oYW5kcm9pZC4rKVs7XFwvXS4rYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyaWMgQW5kcm9pZCBEZXZpY2VcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0dlbmVyaWMnXV1cblxuXG4gICAgICAgIC8qLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIFRPRE86IG1vdmUgdG8gc3RyaW5nIG1hcFxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAvKEM2NjAzKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbnkgWHBlcmlhIFogQzY2MDNcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsICdYcGVyaWEgWiBDNjYwMyddLCBbVkVORE9SLCAnU29ueSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC8oQzY5MDMpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ueSBYcGVyaWEgWiAxXG4gICAgICAgICAgICBdLCBbW01PREVMLCAnWHBlcmlhIFogMSddLCBbVkVORE9SLCAnU29ueSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLyhTTS1HOTAwW0Z8SF0pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYW1zdW5nIEdhbGF4eSBTNVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ0dhbGF4eSBTNSddLCBbVkVORE9SLCAnU2Ftc3VuZyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC8oU00tRzcxMDIpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Ftc3VuZyBHYWxheHkgR3JhbmQgMlxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ0dhbGF4eSBHcmFuZCAyJ10sIFtWRU5ET1IsICdTYW1zdW5nJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhTTS1HNTMwSCkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYW1zdW5nIEdhbGF4eSBHcmFuZCBQcmltZVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ0dhbGF4eSBHcmFuZCBQcmltZSddLCBbVkVORE9SLCAnU2Ftc3VuZyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC8oU00tRzMxM0haKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Ftc3VuZyBHYWxheHkgVlxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ0dhbGF4eSBWJ10sIFtWRU5ET1IsICdTYW1zdW5nJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhTTS1UODA1KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYW1zdW5nIEdhbGF4eSBUYWIgUyAxMC41XG4gICAgICAgICAgICBdLCBbW01PREVMLCAnR2FsYXh5IFRhYiBTIDEwLjUnXSwgW1ZFTkRPUiwgJ1NhbXN1bmcnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKFNNLUc4MDBGKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhbXN1bmcgR2FsYXh5IFM1IE1pbmlcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsICdHYWxheHkgUzUgTWluaSddLCBbVkVORE9SLCAnU2Ftc3VuZyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC8oU00tVDMxMSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Ftc3VuZyBHYWxheHkgVGFiIDMgOC4wXG4gICAgICAgICAgICBdLCBbW01PREVMLCAnR2FsYXh5IFRhYiAzIDguMCddLCBbVkVORE9SLCAnU2Ftc3VuZyddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgLyhUM0MpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbiBWYW5kcm9pZCBUM0NcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FkdmFuJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyhBRFZBTiBUMUpcXCspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW4gVmFuZHJvaWQgVDFKK1xuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ1ZhbmRyb2lkIFQxSisnXSwgW1ZFTkRPUiwgJ0FkdmFuJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyhBRFZBTiBTNEEpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbiBWYW5kcm9pZCBTNEFcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsICdWYW5kcm9pZCBTNEEnXSwgW1ZFTkRPUiwgJ0FkdmFuJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKFY5NzJNKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFpURSBWOTcyTVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnWlRFJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKGktbW9iaWxlKVxccyhJUVxcc1tcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpLW1vYmlsZSBJUVxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhJUTYuMykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpLW1vYmlsZSBJUSBJUSA2LjNcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsICdJUSA2LjMnXSwgW1ZFTkRPUiwgJ2ktbW9iaWxlJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhpLW1vYmlsZSlcXHMoaS1zdHlsZVxcc1tcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaS1tb2JpbGUgaS1TVFlMRVxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhpLVNUWUxFMi4xKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpLW1vYmlsZSBpLVNUWUxFIDIuMVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ2ktU1RZTEUgMi4xJ10sIFtWRU5ET1IsICdpLW1vYmlsZSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLyhtb2JpaXN0YXIgdG91Y2ggTEFJIDUxMikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb2JpaXN0YXIgdG91Y2ggTEFJIDUxMlxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ1RvdWNoIExBSSA1MTInXSwgW1ZFTkRPUiwgJ21vYmlpc3RhciddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gRU5EIFRPRE9cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vKi9cblxuICAgICAgICBdLFxuXG4gICAgICAgIGVuZ2luZSA6IFtbXG5cbiAgICAgICAgICAgIC93aW5kb3dzLitcXHNlZGdlXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVkZ2VIVE1MXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdFZGdlSFRNTCddXSwgW1xuXG4gICAgICAgICAgICAvKHByZXN0bylcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXN0b1xuICAgICAgICAgICAgLyh3ZWJraXR8dHJpZGVudHxuZXRmcm9udHxuZXRzdXJmfGFtYXlhfGx5bnh8dzNtKVxcLyhbXFx3XFwuXSspL2ksICAgICAvLyBXZWJLaXQvVHJpZGVudC9OZXRGcm9udC9OZXRTdXJmL0FtYXlhL0x5bngvdzNtXG4gICAgICAgICAgICAvKGtodG1sfHRhc21hbnxsaW5rcylbXFwvXFxzXVxcKD8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS0hUTUwvVGFzbWFuL0xpbmtzXG4gICAgICAgICAgICAvKGljYWIpW1xcL1xcc10oWzIzXVxcLltcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaUNhYlxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC9ydlxcOihbXFx3XFwuXSspLiooZ2Vja28pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2Vja29cbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBOQU1FXVxuICAgICAgICBdLFxuXG4gICAgICAgIG9zIDogW1tcblxuICAgICAgICAgICAgLy8gV2luZG93cyBiYXNlZFxuICAgICAgICAgICAgL21pY3Jvc29mdFxccyh3aW5kb3dzKVxccyh2aXN0YXx4cCkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgKGlUdW5lcylcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyh3aW5kb3dzKVxcc250XFxzNlxcLjI7XFxzKGFybSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyBSVFxuICAgICAgICAgICAgLyh3aW5kb3dzXFxzcGhvbmUoPzpcXHNvcykqKVtcXHNcXC9dPyhbXFxkXFwuXFxzXStcXHcpKi9pLCAgICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgUGhvbmVcbiAgICAgICAgICAgIC8od2luZG93c1xcc21vYmlsZXx3aW5kb3dzKVtcXHNcXC9dPyhbbnRjZVxcZFxcLlxcc10rXFx3KS9pXG4gICAgICAgICAgICBdLCBbTkFNRSwgW1ZFUlNJT04sIG1hcHBlci5zdHIsIG1hcHMub3Mud2luZG93cy52ZXJzaW9uXV0sIFtcbiAgICAgICAgICAgIC8od2luKD89M3w5fG4pfHdpblxcczl4XFxzKShbbnRcXGRcXC5dKykvaVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnV2luZG93cyddLCBbVkVSU0lPTiwgbWFwcGVyLnN0ciwgbWFwcy5vcy53aW5kb3dzLnZlcnNpb25dXSwgW1xuXG4gICAgICAgICAgICAvLyBNb2JpbGUvRW1iZWRkZWQgT1NcbiAgICAgICAgICAgIC9cXCgoYmIpKDEwKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrQmVycnkgMTBcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0JsYWNrQmVycnknXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8oYmxhY2tiZXJyeSlcXHcqXFwvPyhbXFx3XFwuXSspKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrYmVycnlcbiAgICAgICAgICAgIC8odGl6ZW4pW1xcL1xcc10oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRpemVuXG4gICAgICAgICAgICAvKGFuZHJvaWR8d2Vib3N8cGFsbVxcc29zfHFueHxiYWRhfHJpbVxcc3RhYmxldFxcc29zfG1lZWdvfGNvbnRpa2kpW1xcL1xccy1dPyhbXFx3XFwuXSspKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmRyb2lkL1dlYk9TL1BhbG0vUU5YL0JhZGEvUklNL01lZUdvL0NvbnRpa2lcbiAgICAgICAgICAgIC9saW51eDsuKyhzYWlsZmlzaCk7L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2FpbGZpc2ggT1NcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyhzeW1iaWFuXFxzP29zfHN5bWJvc3xzNjAoPz07KSlbXFwvXFxzLV0/KFtcXHdcXC5dKykqL2kgICAgICAgICAgICAgICAgIC8vIFN5bWJpYW5cbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1N5bWJpYW4nXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC9cXCgoc2VyaWVzNDApOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlcmllcyA0MFxuICAgICAgICAgICAgXSwgW05BTUVdLCBbXG4gICAgICAgICAgICAvbW96aWxsYS4rXFwobW9iaWxlOy4rZ2Vja28uK2ZpcmVmb3gvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IE9TXG4gICAgICAgICAgICBdLCBbW05BTUUsICdGaXJlZm94IE9TJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8vIENvbnNvbGVcbiAgICAgICAgICAgIC8obmludGVuZG98cGxheXN0YXRpb24pXFxzKFt3aWRzMzRwb3J0YWJsZXZ1XSspL2ksICAgICAgICAgICAgICAgICAgIC8vIE5pbnRlbmRvL1BsYXlzdGF0aW9uXG5cbiAgICAgICAgICAgIC8vIEdOVS9MaW51eCBiYXNlZFxuICAgICAgICAgICAgLyhtaW50KVtcXC9cXHNcXChdPyhcXHcrKSovaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWludFxuICAgICAgICAgICAgLyhtYWdlaWF8dmVjdG9ybGludXgpWztcXHNdL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFnZWlhL1ZlY3RvckxpbnV4XG4gICAgICAgICAgICAvKGpvbGl8W2t4bG5dP3VidW50dXxkZWJpYW58W29wZW5dKnN1c2V8Z2VudG9vfCg/PVxccylhcmNofHNsYWNrd2FyZXxmZWRvcmF8bWFuZHJpdmF8Y2VudG9zfHBjbGludXhvc3xyZWRoYXR8emVud2Fsa3xsaW5wdXMpW1xcL1xccy1dPyg/IWNocm9tKShbXFx3XFwuLV0rKSovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSm9saS9VYnVudHUvRGViaWFuL1NVU0UvR2VudG9vL0FyY2gvU2xhY2t3YXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZlZG9yYS9NYW5kcml2YS9DZW50T1MvUENMaW51eE9TL1JlZEhhdC9aZW53YWxrL0xpbnB1c1xuICAgICAgICAgICAgLyhodXJkfGxpbnV4KVxccz8oW1xcd1xcLl0rKSovaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIdXJkL0xpbnV4XG4gICAgICAgICAgICAvKGdudSlcXHM/KFtcXHdcXC5dKykqL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdOVVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oY3JvcylcXHNbXFx3XStcXHMoW1xcd1xcLl0rXFx3KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21pdW0gT1NcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0Nocm9taXVtIE9TJ10sIFZFUlNJT05dLFtcblxuICAgICAgICAgICAgLy8gU29sYXJpc1xuICAgICAgICAgICAgLyhzdW5vcylcXHM/KFtcXHdcXC5dK1xcZCkqL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29sYXJpc1xuICAgICAgICAgICAgXSwgW1tOQU1FLCAnU29sYXJpcyddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvLyBCU0QgYmFzZWRcbiAgICAgICAgICAgIC9cXHMoW2ZyZW50b3BjLV17MCw0fWJzZHxkcmFnb25mbHkpXFxzPyhbXFx3XFwuXSspKi9pICAgICAgICAgICAgICAgICAgIC8vIEZyZWVCU0QvTmV0QlNEL09wZW5CU0QvUEMtQlNEL0RyYWdvbkZseVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLFtcblxuICAgICAgICAgICAgLyhoYWlrdSlcXHMoXFx3KykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFpa3VcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSxbXG5cbiAgICAgICAgICAgIC9jZm5ldHdvcmtcXC8uK2Rhcndpbi9pLFxuICAgICAgICAgICAgL2lwW2hvbmVhZF0rKD86Lipvc1xccyhbXFx3XSspXFxzbGlrZVxcc21hY3w7XFxzb3BlcmEpL2kgICAgICAgICAgICAgICAgIC8vIGlPU1xuICAgICAgICAgICAgXSwgW1tWRVJTSU9OLCAvXy9nLCAnLiddLCBbTkFNRSwgJ2lPUyddXSwgW1xuXG4gICAgICAgICAgICAvKG1hY1xcc29zXFxzeClcXHM/KFtcXHdcXHNcXC5dK1xcdykqL2ksXG4gICAgICAgICAgICAvKG1hY2ludG9zaHxtYWMoPz1fcG93ZXJwYylcXHMpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWMgT1NcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ01hYyBPUyddLCBbVkVSU0lPTiwgL18vZywgJy4nXV0sIFtcblxuICAgICAgICAgICAgLy8gT3RoZXJcbiAgICAgICAgICAgIC8oKD86b3Blbik/c29sYXJpcylbXFwvXFxzLV0/KFtcXHdcXC5dKykqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbGFyaXNcbiAgICAgICAgICAgIC8oYWl4KVxccygoXFxkKSg/PVxcLnxcXCl8XFxzKVtcXHdcXC5dKikqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFJWFxuICAgICAgICAgICAgLyhwbGFuXFxzOXxtaW5peHxiZW9zfG9zXFwvMnxhbWlnYW9zfG1vcnBob3N8cmlzY1xcc29zfG9wZW52bXMpL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYW45L01pbml4L0JlT1MvT1MyL0FtaWdhT1MvTW9ycGhPUy9SSVNDT1MvT3BlblZNU1xuICAgICAgICAgICAgLyh1bml4KVxccz8oW1xcd1xcLl0rKSovaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVTklYXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl1cbiAgICAgICAgXVxuICAgIH07XG5cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQ29uc3RydWN0b3JcbiAgICAvLy8vLy8vLy8vLy8vLy8vXG4gICAgLypcbiAgICB2YXIgQnJvd3NlciA9IGZ1bmN0aW9uIChuYW1lLCB2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXNbTkFNRV0gPSBuYW1lO1xuICAgICAgICB0aGlzW1ZFUlNJT05dID0gdmVyc2lvbjtcbiAgICB9O1xuICAgIHZhciBDUFUgPSBmdW5jdGlvbiAoYXJjaCkge1xuICAgICAgICB0aGlzW0FSQ0hJVEVDVFVSRV0gPSBhcmNoO1xuICAgIH07XG4gICAgdmFyIERldmljZSA9IGZ1bmN0aW9uICh2ZW5kb3IsIG1vZGVsLCB0eXBlKSB7XG4gICAgICAgIHRoaXNbVkVORE9SXSA9IHZlbmRvcjtcbiAgICAgICAgdGhpc1tNT0RFTF0gPSBtb2RlbDtcbiAgICAgICAgdGhpc1tUWVBFXSA9IHR5cGU7XG4gICAgfTtcbiAgICB2YXIgRW5naW5lID0gQnJvd3NlcjtcbiAgICB2YXIgT1MgPSBCcm93c2VyO1xuICAgICovXG4gICAgdmFyIFVBUGFyc2VyID0gZnVuY3Rpb24gKHVhc3RyaW5nLCBleHRlbnNpb25zKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB1YXN0cmluZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMgPSB1YXN0cmluZztcbiAgICAgICAgICAgIHVhc3RyaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVBUGFyc2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVQVBhcnNlcih1YXN0cmluZywgZXh0ZW5zaW9ucykuZ2V0UmVzdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdWEgPSB1YXN0cmluZyB8fCAoKHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSA/IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IDogRU1QVFkpO1xuICAgICAgICB2YXIgcmd4bWFwID0gZXh0ZW5zaW9ucyA/IHV0aWwuZXh0ZW5kKHJlZ2V4ZXMsIGV4dGVuc2lvbnMpIDogcmVnZXhlcztcbiAgICAgICAgLy92YXIgYnJvd3NlciA9IG5ldyBCcm93c2VyKCk7XG4gICAgICAgIC8vdmFyIGNwdSA9IG5ldyBDUFUoKTtcbiAgICAgICAgLy92YXIgZGV2aWNlID0gbmV3IERldmljZSgpO1xuICAgICAgICAvL3ZhciBlbmdpbmUgPSBuZXcgRW5naW5lKCk7XG4gICAgICAgIC8vdmFyIG9zID0gbmV3IE9TKCk7XG5cbiAgICAgICAgdGhpcy5nZXRCcm93c2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJyb3dzZXIgPSB7IG5hbWU6IHVuZGVmaW5lZCwgdmVyc2lvbjogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICBtYXBwZXIucmd4LmNhbGwoYnJvd3NlciwgdWEsIHJneG1hcC5icm93c2VyKTtcbiAgICAgICAgICAgIGJyb3dzZXIubWFqb3IgPSB1dGlsLm1ham9yKGJyb3dzZXIudmVyc2lvbik7IC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgIHJldHVybiBicm93c2VyO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENQVSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjcHUgPSB7IGFyY2hpdGVjdHVyZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICBtYXBwZXIucmd4LmNhbGwoY3B1LCB1YSwgcmd4bWFwLmNwdSk7XG4gICAgICAgICAgICByZXR1cm4gY3B1O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldERldmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2UgPSB7IHZlbmRvcjogdW5kZWZpbmVkLCBtb2RlbDogdW5kZWZpbmVkLCB0eXBlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIG1hcHBlci5yZ3guY2FsbChkZXZpY2UsIHVhLCByZ3htYXAuZGV2aWNlKTtcbiAgICAgICAgICAgIHJldHVybiBkZXZpY2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0RW5naW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVuZ2luZSA9IHsgbmFtZTogdW5kZWZpbmVkLCB2ZXJzaW9uOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIG1hcHBlci5yZ3guY2FsbChlbmdpbmUsIHVhLCByZ3htYXAuZW5naW5lKTtcbiAgICAgICAgICAgIHJldHVybiBlbmdpbmU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0T1MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3MgPSB7IG5hbWU6IHVuZGVmaW5lZCwgdmVyc2lvbjogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICBtYXBwZXIucmd4LmNhbGwob3MsIHVhLCByZ3htYXAub3MpO1xuICAgICAgICAgICAgcmV0dXJuIG9zO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdWEgICAgICA6IHRoaXMuZ2V0VUEoKSxcbiAgICAgICAgICAgICAgICBicm93c2VyIDogdGhpcy5nZXRCcm93c2VyKCksXG4gICAgICAgICAgICAgICAgZW5naW5lICA6IHRoaXMuZ2V0RW5naW5lKCksXG4gICAgICAgICAgICAgICAgb3MgICAgICA6IHRoaXMuZ2V0T1MoKSxcbiAgICAgICAgICAgICAgICBkZXZpY2UgIDogdGhpcy5nZXREZXZpY2UoKSxcbiAgICAgICAgICAgICAgICBjcHUgICAgIDogdGhpcy5nZXRDUFUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRVQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB1YTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRVQSA9IGZ1bmN0aW9uICh1YXN0cmluZykge1xuICAgICAgICAgICAgdWEgPSB1YXN0cmluZztcbiAgICAgICAgICAgIC8vYnJvd3NlciA9IG5ldyBCcm93c2VyKCk7XG4gICAgICAgICAgICAvL2NwdSA9IG5ldyBDUFUoKTtcbiAgICAgICAgICAgIC8vZGV2aWNlID0gbmV3IERldmljZSgpO1xuICAgICAgICAgICAgLy9lbmdpbmUgPSBuZXcgRW5naW5lKCk7XG4gICAgICAgICAgICAvL29zID0gbmV3IE9TKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFVBUGFyc2VyLlZFUlNJT04gPSBMSUJWRVJTSU9OO1xuICAgIFVBUGFyc2VyLkJST1dTRVIgPSB7XG4gICAgICAgIE5BTUUgICAgOiBOQU1FLFxuICAgICAgICBNQUpPUiAgIDogTUFKT1IsIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgVkVSU0lPTiA6IFZFUlNJT05cbiAgICB9O1xuICAgIFVBUGFyc2VyLkNQVSA9IHtcbiAgICAgICAgQVJDSElURUNUVVJFIDogQVJDSElURUNUVVJFXG4gICAgfTtcbiAgICBVQVBhcnNlci5ERVZJQ0UgPSB7XG4gICAgICAgIE1PREVMICAgOiBNT0RFTCxcbiAgICAgICAgVkVORE9SICA6IFZFTkRPUixcbiAgICAgICAgVFlQRSAgICA6IFRZUEUsXG4gICAgICAgIENPTlNPTEUgOiBDT05TT0xFLFxuICAgICAgICBNT0JJTEUgIDogTU9CSUxFLFxuICAgICAgICBTTUFSVFRWIDogU01BUlRUVixcbiAgICAgICAgVEFCTEVUICA6IFRBQkxFVCxcbiAgICAgICAgV0VBUkFCTEU6IFdFQVJBQkxFLFxuICAgICAgICBFTUJFRERFRDogRU1CRURERURcbiAgICB9O1xuICAgIFVBUGFyc2VyLkVOR0lORSA9IHtcbiAgICAgICAgTkFNRSAgICA6IE5BTUUsXG4gICAgICAgIFZFUlNJT04gOiBWRVJTSU9OXG4gICAgfTtcbiAgICBVQVBhcnNlci5PUyA9IHtcbiAgICAgICAgTkFNRSAgICA6IE5BTUUsXG4gICAgICAgIFZFUlNJT04gOiBWRVJTSU9OXG4gICAgfTtcbiAgICAvL1VBUGFyc2VyLlV0aWxzID0gdXRpbDtcblxuICAgIC8vLy8vLy8vLy8vXG4gICAgLy8gRXhwb3J0XG4gICAgLy8vLy8vLy8vL1xuXG5cbiAgICAvLyBjaGVjayBqcyBlbnZpcm9ubWVudFxuICAgIGlmICh0eXBlb2YoZXhwb3J0cykgIT09IFVOREVGX1RZUEUpIHtcbiAgICAgICAgLy8gbm9kZWpzIGVudlxuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gVU5ERUZfVFlQRSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVUFQYXJzZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogdGVzdCEhISEhISEhXG4gICAgICAgIC8qXG4gICAgICAgIGlmIChyZXF1aXJlICYmIHJlcXVpcmUubWFpbiA9PT0gbW9kdWxlICYmIHByb2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIGNsaVxuICAgICAgICAgICAgdmFyIGpzb25pemUgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gYXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKG5ldyBVQVBhcnNlcihhcnJbaV0pLmdldFJlc3VsdCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoSlNPTi5zdHJpbmdpZnkocmVzLCBudWxsLCAyKSArICdcXG4nKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5zdGRpbi5pc1RUWSkge1xuICAgICAgICAgICAgICAgIC8vIHZpYSBhcmdzXG4gICAgICAgICAgICAgICAganNvbml6ZShwcm9jZXNzLmFyZ3Yuc2xpY2UoMikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB2aWEgcGlwZVxuICAgICAgICAgICAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgICAgICAgICAgICBwcm9jZXNzLnN0ZGluLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZCA9IHByb2Nlc3Muc3RkaW4ucmVhZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHJlYWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLnN0ZGluLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGpzb25pemUoc3RyLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICBleHBvcnRzLlVBUGFyc2VyID0gVUFQYXJzZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVxdWlyZWpzIGVudiAob3B0aW9uYWwpXG4gICAgICAgIGlmICh0eXBlb2YoZGVmaW5lKSA9PT0gRlVOQ19UWVBFICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFVBUGFyc2VyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93KSB7XG4gICAgICAgICAgICAvLyBicm93c2VyIGVudlxuICAgICAgICAgICAgd2luZG93LlVBUGFyc2VyID0gVUFQYXJzZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBqUXVlcnkvWmVwdG8gc3BlY2lmaWMgKG9wdGlvbmFsKVxuICAgIC8vIE5vdGU6XG4gICAgLy8gICBJbiBBTUQgZW52IHRoZSBnbG9iYWwgc2NvcGUgc2hvdWxkIGJlIGtlcHQgY2xlYW4sIGJ1dCBqUXVlcnkgaXMgYW4gZXhjZXB0aW9uLlxuICAgIC8vICAgalF1ZXJ5IGFsd2F5cyBleHBvcnRzIHRvIGdsb2JhbCBzY29wZSwgdW5sZXNzIGpRdWVyeS5ub0NvbmZsaWN0KHRydWUpIGlzIHVzZWQsXG4gICAgLy8gICBhbmQgd2Ugc2hvdWxkIGNhdGNoIHRoYXQuXG4gICAgdmFyICQgPSB3aW5kb3cgJiYgKHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvKTtcbiAgICBpZiAodHlwZW9mICQgIT09IFVOREVGX1RZUEUpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBVQVBhcnNlcigpO1xuICAgICAgICAkLnVhID0gcGFyc2VyLmdldFJlc3VsdCgpO1xuICAgICAgICAkLnVhLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIuZ2V0VUEoKTtcbiAgICAgICAgfTtcbiAgICAgICAgJC51YS5zZXQgPSBmdW5jdGlvbiAodWFzdHJpbmcpIHtcbiAgICAgICAgICAgIHBhcnNlci5zZXRVQSh1YXN0cmluZyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VyLmdldFJlc3VsdCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAkLnVhW3Byb3BdID0gcmVzdWx0W3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxufSkodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgPyB3aW5kb3cgOiB0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3VhLXBhcnNlci1qcy9zcmMvdWEtcGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA0MTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG52YXIgY29tcG9uZW50UmVnZXggPSAvXFwuLztcbnZhciBvclJlZ2V4ID0gL1xcfFxcfC87XG52YXIgcmFuZ2VSZWdleCA9IC9cXHMrXFwtXFxzKy87XG52YXIgbW9kaWZpZXJSZWdleCA9IC9eKDw9fDx8PXw+PXx+Pnx+fD58KT9cXHMqKC4rKS87XG52YXIgbnVtZXJpY1JlZ2V4ID0gL14oXFxkKikoLiopLztcblxuLyoqXG4gKiBTcGxpdHMgaW5wdXQgYHJhbmdlYCBvbiBcInx8XCIgYW5kIHJldHVybnMgdHJ1ZSBpZiBhbnkgc3VicmFuZ2UgbWF0Y2hlc1xuICogYHZlcnNpb25gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByYW5nZVxuICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb25cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjaGVja09yRXhwcmVzc2lvbihyYW5nZSwgdmVyc2lvbikge1xuICB2YXIgZXhwcmVzc2lvbnMgPSByYW5nZS5zcGxpdChvclJlZ2V4KTtcblxuICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBleHByZXNzaW9ucy5zb21lKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgcmV0dXJuIFZlcnNpb25SYW5nZS5jb250YWlucyhyYW5nZSwgdmVyc2lvbik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmFuZ2UgPSBleHByZXNzaW9uc1swXS50cmltKCk7XG4gICAgcmV0dXJuIGNoZWNrUmFuZ2VFeHByZXNzaW9uKHJhbmdlLCB2ZXJzaW9uKTtcbiAgfVxufVxuXG4vKipcbiAqIFNwbGl0cyBpbnB1dCBgcmFuZ2VgIG9uIFwiIC0gXCIgKHRoZSBzdXJyb3VuZGluZyB3aGl0ZXNwYWNlIGlzIHJlcXVpcmVkKSBhbmRcbiAqIHJldHVybnMgdHJ1ZSBpZiB2ZXJzaW9uIGZhbGxzIGJldHdlZW4gdGhlIHR3byBvcGVyYW5kcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmFuZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY2hlY2tSYW5nZUV4cHJlc3Npb24ocmFuZ2UsIHZlcnNpb24pIHtcbiAgdmFyIGV4cHJlc3Npb25zID0gcmFuZ2Uuc3BsaXQocmFuZ2VSZWdleCk7XG5cbiAgIShleHByZXNzaW9ucy5sZW5ndGggPiAwICYmIGV4cHJlc3Npb25zLmxlbmd0aCA8PSAyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0aGUgXCItXCIgb3BlcmF0b3IgZXhwZWN0cyBleGFjdGx5IDIgb3BlcmFuZHMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBjaGVja1NpbXBsZUV4cHJlc3Npb24oZXhwcmVzc2lvbnNbMF0sIHZlcnNpb24pO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdGFydFZlcnNpb24gPSBleHByZXNzaW9uc1swXSxcbiAgICAgICAgZW5kVmVyc2lvbiA9IGV4cHJlc3Npb25zWzFdO1xuXG4gICAgIShpc1NpbXBsZVZlcnNpb24oc3RhcnRWZXJzaW9uKSAmJiBpc1NpbXBsZVZlcnNpb24oZW5kVmVyc2lvbikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ29wZXJhbmRzIHRvIHRoZSBcIi1cIiBvcGVyYXRvciBtdXN0IGJlIHNpbXBsZSAobm8gbW9kaWZpZXJzKScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHJldHVybiBjaGVja1NpbXBsZUV4cHJlc3Npb24oJz49JyArIHN0YXJ0VmVyc2lvbiwgdmVyc2lvbikgJiYgY2hlY2tTaW1wbGVFeHByZXNzaW9uKCc8PScgKyBlbmRWZXJzaW9uLCB2ZXJzaW9uKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcmFuZ2VgIG1hdGNoZXMgYHZlcnNpb25gLiBgcmFuZ2VgIHNob3VsZCBiZSBhIFwic2ltcGxlXCIgcmFuZ2UgKGllLlxuICogbm90IGEgY29tcG91bmQgcmFuZ2UgdXNpbmcgdGhlIFwiIC0gXCIgb3IgXCJ8fFwiIG9wZXJhdG9ycykuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJhbmdlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvblxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2ltcGxlRXhwcmVzc2lvbihyYW5nZSwgdmVyc2lvbikge1xuICByYW5nZSA9IHJhbmdlLnRyaW0oKTtcbiAgaWYgKHJhbmdlID09PSAnJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHZlcnNpb25Db21wb25lbnRzID0gdmVyc2lvbi5zcGxpdChjb21wb25lbnRSZWdleCk7XG5cbiAgdmFyIF9nZXRNb2RpZmllckFuZENvbXBvbiA9IGdldE1vZGlmaWVyQW5kQ29tcG9uZW50cyhyYW5nZSksXG4gICAgICBtb2RpZmllciA9IF9nZXRNb2RpZmllckFuZENvbXBvbi5tb2RpZmllcixcbiAgICAgIHJhbmdlQ29tcG9uZW50cyA9IF9nZXRNb2RpZmllckFuZENvbXBvbi5yYW5nZUNvbXBvbmVudHM7XG5cbiAgc3dpdGNoIChtb2RpZmllcikge1xuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuIGNoZWNrTGVzc1RoYW4odmVyc2lvbkNvbXBvbmVudHMsIHJhbmdlQ29tcG9uZW50cyk7XG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmV0dXJuIGNoZWNrTGVzc1RoYW5PckVxdWFsKHZlcnNpb25Db21wb25lbnRzLCByYW5nZUNvbXBvbmVudHMpO1xuICAgIGNhc2UgJz49JzpcbiAgICAgIHJldHVybiBjaGVja0dyZWF0ZXJUaGFuT3JFcXVhbCh2ZXJzaW9uQ29tcG9uZW50cywgcmFuZ2VDb21wb25lbnRzKTtcbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiBjaGVja0dyZWF0ZXJUaGFuKHZlcnNpb25Db21wb25lbnRzLCByYW5nZUNvbXBvbmVudHMpO1xuICAgIGNhc2UgJ34nOlxuICAgIGNhc2UgJ34+JzpcbiAgICAgIHJldHVybiBjaGVja0FwcHJveGltYXRlVmVyc2lvbih2ZXJzaW9uQ29tcG9uZW50cywgcmFuZ2VDb21wb25lbnRzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNoZWNrRXF1YWwodmVyc2lvbkNvbXBvbmVudHMsIHJhbmdlQ29tcG9uZW50cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBgYWAgaXMgbGVzcyB0aGFuIGBiYC5cbiAqXG4gKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IGFcbiAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNoZWNrTGVzc1RoYW4oYSwgYikge1xuICByZXR1cm4gY29tcGFyZUNvbXBvbmVudHMoYSwgYikgPT09IC0xO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGBhYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYGJgLlxuICpcbiAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gYVxuICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY2hlY2tMZXNzVGhhbk9yRXF1YWwoYSwgYikge1xuICB2YXIgcmVzdWx0ID0gY29tcGFyZUNvbXBvbmVudHMoYSwgYik7XG4gIHJldHVybiByZXN1bHQgPT09IC0xIHx8IHJlc3VsdCA9PT0gMDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBgYWAgaXMgZXF1YWwgdG8gYGJgLlxuICpcbiAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gYVxuICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY2hlY2tFcXVhbChhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlQ29tcG9uZW50cyhhLCBiKSA9PT0gMDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBgYWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBiYC5cbiAqXG4gKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IGFcbiAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNoZWNrR3JlYXRlclRoYW5PckVxdWFsKGEsIGIpIHtcbiAgdmFyIHJlc3VsdCA9IGNvbXBhcmVDb21wb25lbnRzKGEsIGIpO1xuICByZXR1cm4gcmVzdWx0ID09PSAxIHx8IHJlc3VsdCA9PT0gMDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBgYWAgaXMgZ3JlYXRlciB0aGFuIGBiYC5cbiAqXG4gKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IGFcbiAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNoZWNrR3JlYXRlclRoYW4oYSwgYikge1xuICByZXR1cm4gY29tcGFyZUNvbXBvbmVudHMoYSwgYikgPT09IDE7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYGFgIGlzIFwicmVhc29uYWJseSBjbG9zZVwiIHRvIGBiYCAoYXMgZGVzY3JpYmVkIGluXG4gKiBodHRwczovL3d3dy5ucG1qcy5vcmcvZG9jL21pc2Mvc2VtdmVyLmh0bWwpLiBGb3IgZXhhbXBsZSwgaWYgYGJgIGlzIFwiMS4zLjFcIlxuICogdGhlbiBcInJlYXNvbmFibHkgY2xvc2VcIiBpcyBkZWZpbmVkIGFzIFwiPj0gMS4zLjEgYW5kIDwgMS40XCIuXG4gKlxuICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBhXG4gKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjaGVja0FwcHJveGltYXRlVmVyc2lvbihhLCBiKSB7XG4gIHZhciBsb3dlckJvdW5kID0gYi5zbGljZSgpO1xuICB2YXIgdXBwZXJCb3VuZCA9IGIuc2xpY2UoKTtcblxuICBpZiAodXBwZXJCb3VuZC5sZW5ndGggPiAxKSB7XG4gICAgdXBwZXJCb3VuZC5wb3AoKTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gdXBwZXJCb3VuZC5sZW5ndGggLSAxO1xuICB2YXIgbnVtZXJpYyA9IHBhcnNlSW50KHVwcGVyQm91bmRbbGFzdEluZGV4XSwgMTApO1xuICBpZiAoaXNOdW1iZXIobnVtZXJpYykpIHtcbiAgICB1cHBlckJvdW5kW2xhc3RJbmRleF0gPSBudW1lcmljICsgMSArICcnO1xuICB9XG5cbiAgcmV0dXJuIGNoZWNrR3JlYXRlclRoYW5PckVxdWFsKGEsIGxvd2VyQm91bmQpICYmIGNoZWNrTGVzc1RoYW4oYSwgdXBwZXJCb3VuZCk7XG59XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIG9wdGlvbmFsIG1vZGlmaWVyICg8LCA8PSwgPSwgPj0sID4sIH4sIH4+KSBhbmQgdmVyc2lvblxuICogY29tcG9uZW50cyBmcm9tIGByYW5nZWAuXG4gKlxuICogRm9yIGV4YW1wbGUsIGdpdmVuIGByYW5nZWAgXCI+PSAxLjIuM1wiIHJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBgbW9kaWZpZXJgIG9mXG4gKiBgXCI+PVwiYCBhbmQgYGNvbXBvbmVudHNgIG9mIGBbMSwgMiwgM11gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByYW5nZVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kaWZpZXJBbmRDb21wb25lbnRzKHJhbmdlKSB7XG4gIHZhciByYW5nZUNvbXBvbmVudHMgPSByYW5nZS5zcGxpdChjb21wb25lbnRSZWdleCk7XG4gIHZhciBtYXRjaGVzID0gcmFuZ2VDb21wb25lbnRzWzBdLm1hdGNoKG1vZGlmaWVyUmVnZXgpO1xuICAhbWF0Y2hlcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdleHBlY3RlZCByZWdleCB0byBtYXRjaCBidXQgaXQgZGlkIG5vdCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICByZXR1cm4ge1xuICAgIG1vZGlmaWVyOiBtYXRjaGVzWzFdLFxuICAgIHJhbmdlQ29tcG9uZW50czogW21hdGNoZXNbMl1dLmNvbmNhdChyYW5nZUNvbXBvbmVudHMuc2xpY2UoMSkpXG4gIH07XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgbnVtYmVyYCBpcyBhIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge21peGVkfSBudW1iZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bWJlcihudW1iZXIpIHtcbiAgcmV0dXJuICFpc05hTihudW1iZXIpICYmIGlzRmluaXRlKG51bWJlcik7XG59XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBgcmFuZ2VgIGlzIGEgXCJzaW1wbGVcIiB2ZXJzaW9uIG51bWJlciB3aXRob3V0IGFueSBtb2RpZmllcnNcbiAqIChcIj5cIiwgXCJ+XCIgZXRjKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmFuZ2VcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NpbXBsZVZlcnNpb24ocmFuZ2UpIHtcbiAgcmV0dXJuICFnZXRNb2RpZmllckFuZENvbXBvbmVudHMocmFuZ2UpLm1vZGlmaWVyO1xufVxuXG4vKipcbiAqIFplcm8tcGFkcyBhcnJheSBgYXJyYXlgIHVudGlsIGl0IGlzIGF0IGxlYXN0IGBsZW5ndGhgIGxvbmcuXG4gKlxuICogQHBhcmFtIHthcnJheX0gYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gemVyb1BhZChhcnJheSwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gJzAnO1xuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBgYWAgYW5kIGBiYCBpbiBwcmVwYXJhdGlvbiBmb3IgY29tcGFyaXNvbiBieSBkb2luZyB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gemVyby1wYWRzIGBhYCBhbmQgYGJgXG4gKiAtIG1hcmtzIGFueSBcInhcIiwgXCJYXCIgb3IgXCIqXCIgY29tcG9uZW50IGluIGBiYCBhcyBlcXVpdmFsZW50IGJ5IHplcm8taW5nIGl0IG91dFxuICogICBpbiBib3RoIGBhYCBhbmQgYGJgXG4gKiAtIG1hcmtzIGFueSBmaW5hbCBcIipcIiBjb21wb25lbnQgaW4gYGJgIGFzIGEgZ3JlZWR5IHdpbGRjYXJkIGJ5IHplcm8taW5nIGl0XG4gKiAgIGFuZCBhbGwgb2YgaXRzIHN1Y2Nlc3NvcnMgaW4gYGFgXG4gKlxuICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBhXG4gKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IGJcbiAqIEByZXR1cm5zIHthcnJheTxhcnJheTxzdHJpbmc+Pn1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVmVyc2lvbnMoYSwgYikge1xuICBhID0gYS5zbGljZSgpO1xuICBiID0gYi5zbGljZSgpO1xuXG4gIHplcm9QYWQoYSwgYi5sZW5ndGgpO1xuXG4gIC8vIG1hcmsgXCJ4XCIgYW5kIFwiKlwiIGNvbXBvbmVudHMgYXMgZXF1YWxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBiW2ldLm1hdGNoKC9eW3gqXSQvaSk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgIGJbaV0gPSBhW2ldID0gJzAnO1xuXG4gICAgICAvLyBmaW5hbCBcIipcIiBncmVlZGlseSB6ZXJvcyBhbGwgcmVtYWluaW5nIGNvbXBvbmVudHNcbiAgICAgIGlmIChtYXRjaGVzWzBdID09PSAnKicgJiYgaSA9PT0gYi5sZW5ndGggLSAxKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgYS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGFbal0gPSAnMCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB6ZXJvUGFkKGIsIGEubGVuZ3RoKTtcblxuICByZXR1cm4gW2EsIGJdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWVyaWNhbCAtLSBub3QgdGhlIGxleGljb2dyYXBoaWNhbCAtLSBvcmRlcmluZyBvZiBgYWAgYW5kIGBiYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYDEwLWFscGhhYCBpcyBncmVhdGVyIHRoYW4gYDItYmV0YWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtMSwgMCBvciAxIHRvIGluZGljYXRlIHdoZXRoZXIgYGFgIGlzIGxlc3MgdGhhbiwgZXF1YWwgdG8sXG4gKiBvciBncmVhdGVyIHRoYW4gYGJgLCByZXNwZWN0aXZlbHlcbiAqL1xuZnVuY3Rpb24gY29tcGFyZU51bWVyaWMoYSwgYikge1xuICB2YXIgYVByZWZpeCA9IGEubWF0Y2gobnVtZXJpY1JlZ2V4KVsxXTtcbiAgdmFyIGJQcmVmaXggPSBiLm1hdGNoKG51bWVyaWNSZWdleClbMV07XG4gIHZhciBhTnVtZXJpYyA9IHBhcnNlSW50KGFQcmVmaXgsIDEwKTtcbiAgdmFyIGJOdW1lcmljID0gcGFyc2VJbnQoYlByZWZpeCwgMTApO1xuXG4gIGlmIChpc051bWJlcihhTnVtZXJpYykgJiYgaXNOdW1iZXIoYk51bWVyaWMpICYmIGFOdW1lcmljICE9PSBiTnVtZXJpYykge1xuICAgIHJldHVybiBjb21wYXJlKGFOdW1lcmljLCBiTnVtZXJpYyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmRlcmluZyBvZiBgYWAgYW5kIGBiYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGFcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYlxuICogQHJldHVybnMge251bWJlcn0gLTEsIDAgb3IgMSB0byBpbmRpY2F0ZSB3aGV0aGVyIGBhYCBpcyBsZXNzIHRoYW4sIGVxdWFsIHRvLFxuICogb3IgZ3JlYXRlciB0aGFuIGBiYCwgcmVzcGVjdGl2ZWx5XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAhKHR5cGVvZiBhID09PSB0eXBlb2YgYikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnXCJhXCIgYW5kIFwiYlwiIG11c3QgYmUgb2YgdGhlIHNhbWUgdHlwZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4vKipcbiAqIENvbXBhcmVzIGFycmF5cyBvZiB2ZXJzaW9uIGNvbXBvbmVudHMuXG4gKlxuICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBhXG4gKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IGJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0xLCAwIG9yIDEgdG8gaW5kaWNhdGUgd2hldGhlciBgYWAgaXMgbGVzcyB0aGFuLCBlcXVhbCB0byxcbiAqIG9yIGdyZWF0ZXIgdGhhbiBgYmAsIHJlc3BlY3RpdmVseVxuICovXG5mdW5jdGlvbiBjb21wYXJlQ29tcG9uZW50cyhhLCBiKSB7XG4gIHZhciBfbm9ybWFsaXplVmVyc2lvbnMgPSBub3JtYWxpemVWZXJzaW9ucyhhLCBiKSxcbiAgICAgIGFOb3JtYWxpemVkID0gX25vcm1hbGl6ZVZlcnNpb25zWzBdLFxuICAgICAgYk5vcm1hbGl6ZWQgPSBfbm9ybWFsaXplVmVyc2lvbnNbMV07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiTm9ybWFsaXplZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlTnVtZXJpYyhhTm9ybWFsaXplZFtpXSwgYk5vcm1hbGl6ZWRbaV0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbnZhciBWZXJzaW9uUmFuZ2UgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBgdmVyc2lvbmAgc2F0aXNmaWVzIHRoZSBgcmFuZ2VgIHNwZWNpZmljYXRpb24uXG4gICAqXG4gICAqIFdlIHN1cHBvcnQgYSBzdWJzZXQgb2YgdGhlIGV4cHJlc3Npb25zIGRlZmluZWQgaW5cbiAgICogaHR0cHM6Ly93d3cubnBtanMub3JnL2RvYy9taXNjL3NlbXZlci5odG1sOlxuICAgKlxuICAgKiAgICB2ZXJzaW9uICAgTXVzdCBtYXRjaCB2ZXJzaW9uIGV4YWN0bHlcbiAgICogICAgPXZlcnNpb24gIFNhbWUgYXMganVzdCB2ZXJzaW9uXG4gICAqICAgID52ZXJzaW9uICBNdXN0IGJlIGdyZWF0ZXIgdGhhbiB2ZXJzaW9uXG4gICAqICAgID49dmVyc2lvbiBNdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB2ZXJzaW9uXG4gICAqICAgIDx2ZXJzaW9uICBNdXN0IGJlIGxlc3MgdGhhbiB2ZXJzaW9uXG4gICAqICAgIDw9dmVyc2lvbiBNdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB2ZXJzaW9uXG4gICAqICAgIH52ZXJzaW9uICBNdXN0IGJlIGF0IGxlYXN0IHZlcnNpb24sIGJ1dCBsZXNzIHRoYW4gdGhlIG5leHQgc2lnbmlmaWNhbnRcbiAgICogICAgICAgICAgICAgIHJldmlzaW9uIGFib3ZlIHZlcnNpb246XG4gICAqICAgICAgICAgICAgICBcIn4xLjIuM1wiIGlzIGVxdWl2YWxlbnQgdG8gXCI+PSAxLjIuMyBhbmQgPCAxLjNcIlxuICAgKiAgICB+PnZlcnNpb24gRXF1aXZhbGVudCB0byB+dmVyc2lvblxuICAgKiAgICAxLjIueCAgICAgTXVzdCBtYXRjaCBcIjEuMi54XCIsIHdoZXJlIFwieFwiIGlzIGEgd2lsZGNhcmQgdGhhdCBtYXRjaGVzXG4gICAqICAgICAgICAgICAgICBhbnl0aGluZ1xuICAgKiAgICAxLjIuKiAgICAgU2ltaWxhciB0byBcIjEuMi54XCIsIGJ1dCBcIipcIiBpbiB0aGUgdHJhaWxpbmcgcG9zaXRpb24gaXMgYVxuICAgKiAgICAgICAgICAgICAgXCJncmVlZHlcIiB3aWxkY2FyZCwgc28gd2lsbCBtYXRjaCBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWxcbiAgICogICAgICAgICAgICAgIGNvbXBvbmVudHM6XG4gICAqICAgICAgICAgICAgICBcIjEuMi4qXCIgd2lsbCBtYXRjaCBcIjEuMi4xXCIsIFwiMS4yLjEuMVwiLCBcIjEuMi4xLjEuMVwiIGV0Y1xuICAgKiAgICAqICAgICAgICAgQW55IHZlcnNpb25cbiAgICogICAgXCJcIiAgICAgICAgKEVtcHR5IHN0cmluZykgU2FtZSBhcyAqXG4gICAqICAgIHYxIC0gdjIgICBFcXVpdmFsZW50IHRvIFwiPj0gdjEgYW5kIDw9IHYyXCJcbiAgICogICAgcjEgfHwgcjIgIFBhc3NlcyBpZiBlaXRoZXIgcjEgb3IgcjIgYXJlIHNhdGlzZmllZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmFuZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb25cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWluczogZnVuY3Rpb24gY29udGFpbnMocmFuZ2UsIHZlcnNpb24pIHtcbiAgICByZXR1cm4gY2hlY2tPckV4cHJlc3Npb24ocmFuZ2UudHJpbSgpLCB2ZXJzaW9uLnRyaW0oKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmVyc2lvblJhbmdlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL1ZlcnNpb25SYW5nZS5qc1xuLy8gbW9kdWxlIGlkID0gNDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCBgY2FsbGJhY2tgIG9uY2UgZm9yIGVhY2ggZW51bWVyYWJsZSBvd24gcHJvcGVydHkgaW4gdGhlXG4gKiBvYmplY3QgYW5kIGNvbnN0cnVjdHMgYSBuZXcgb2JqZWN0IGZyb20gdGhlIHJlc3VsdHMuIFRoZSBgY2FsbGJhY2tgIGlzXG4gKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICpcbiAqICAtIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICogIC0gdGhlIHByb3BlcnR5IG5hbWVcbiAqICAtIHRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gKlxuICogUHJvcGVydGllcyB0aGF0IGFyZSBhZGRlZCBhZnRlciB0aGUgY2FsbCB0byBgbWFwT2JqZWN0YCB3aWxsIG5vdCBiZSB2aXNpdGVkXG4gKiBieSBgY2FsbGJhY2tgLiBJZiB0aGUgdmFsdWVzIG9mIGV4aXN0aW5nIHByb3BlcnRpZXMgYXJlIGNoYW5nZWQsIHRoZSB2YWx1ZVxuICogcGFzc2VkIHRvIGBjYWxsYmFja2Agd2lsbCBiZSB0aGUgdmFsdWUgYXQgdGhlIHRpbWUgYG1hcE9iamVjdGAgdmlzaXRzIHRoZW0uXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYXJlIGRlbGV0ZWQgYmVmb3JlIGJlaW5nIHZpc2l0ZWQgYXJlIG5vdCB2aXNpdGVkLlxuICpcbiAqIEBncmVwIGZ1bmN0aW9uIG9iamVjdE1hcCgpXG4gKiBAZ3JlcCBmdW5jdGlvbiBvYmpNYXAoKVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBjb250ZXh0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYXBPYmplY3Qob2JqZWN0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpKSB7XG4gICAgICByZXN1bHRbbmFtZV0gPSBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG9iamVjdFtuYW1lXSwgbmFtZSwgb2JqZWN0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBPYmplY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvbWFwT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWVtb2l6ZXMgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgc3RyaW5nIGFyZ3VtZW50LlxuICovXG5cbmZ1bmN0aW9uIG1lbW9pemVTdHJpbmdPbmx5KGNhbGxiYWNrKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIGlmICghY2FjaGUuaGFzT3duUHJvcGVydHkoc3RyaW5nKSkge1xuICAgICAgY2FjaGVbc3RyaW5nXSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW3N0cmluZ107XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZVN0cmluZ09ubHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanNcbi8vIG1vZHVsZSBpZCA9IDQxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0RHJhZnRFZGl0b3JTZWxlY3Rpb25cbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERyYWZ0SnNEZWJ1Z0xvZ2dpbmcgPSByZXF1aXJlKCcuL0RyYWZ0SnNEZWJ1Z0xvZ2dpbmcnKTtcblxudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbmZ1bmN0aW9uIGdldEFub255bWl6ZWRET00obm9kZSwgZ2V0Tm9kZUxhYmVscykge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gJ1tlbXB0eV0nO1xuICB9XG5cbiAgdmFyIGFub255bWl6ZWQgPSBhbm9ueW1pemVUZXh0V2l0aGluKG5vZGUsIGdldE5vZGVMYWJlbHMpO1xuICBpZiAoYW5vbnltaXplZC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICByZXR1cm4gYW5vbnltaXplZC50ZXh0Q29udGVudDtcbiAgfVxuXG4gICEoYW5vbnltaXplZCBpbnN0YW5jZW9mIEVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ05vZGUgbXVzdCBiZSBhbiBFbGVtZW50IGlmIGl0IGlzIG5vdCBhIHRleHQgbm9kZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBhbm9ueW1pemVkLm91dGVySFRNTDtcbn1cblxuZnVuY3Rpb24gYW5vbnltaXplVGV4dFdpdGhpbihub2RlLCBnZXROb2RlTGFiZWxzKSB7XG4gIHZhciBsYWJlbHMgPSBnZXROb2RlTGFiZWxzICE9PSB1bmRlZmluZWQgPyBnZXROb2RlTGFiZWxzKG5vZGUpIDogW107XG5cbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgdmFyIGxlbmd0aCA9IG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnW3RleHQgJyArIGxlbmd0aCArIChsYWJlbHMubGVuZ3RoID8gJyB8ICcgKyBsYWJlbHMuam9pbignLCAnKSA6ICcnKSArICddJyk7XG4gIH1cblxuICB2YXIgY2xvbmUgPSBub2RlLmNsb25lTm9kZSgpO1xuICBpZiAoY2xvbmUubm9kZVR5cGUgPT09IDEgJiYgbGFiZWxzLmxlbmd0aCkge1xuICAgIGNsb25lLnNldEF0dHJpYnV0ZSgnZGF0YS1sYWJlbHMnLCBsYWJlbHMuam9pbignLCAnKSk7XG4gIH1cbiAgdmFyIGNoaWxkTm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaWkrKykge1xuICAgIGNsb25lLmFwcGVuZENoaWxkKGFub255bWl6ZVRleHRXaXRoaW4oY2hpbGROb2Rlc1tpaV0sIGdldE5vZGVMYWJlbHMpKTtcbiAgfVxuXG4gIHJldHVybiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gZ2V0QW5vbnltaXplZEVkaXRvckRPTShub2RlLCBnZXROb2RlTGFiZWxzKSB7XG4gIC8vIGdyYWJiaW5nIHRoZSBET00gY29udGVudCBvZiB0aGUgRHJhZnQgZWRpdG9yXG4gIHZhciBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gIHdoaWxlIChjdXJyZW50Tm9kZSkge1xuICAgIGlmIChjdXJyZW50Tm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgY3VycmVudE5vZGUuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSkge1xuICAgICAgLy8gZm91bmQgdGhlIERyYWZ0IGVkaXRvciBjb250YWluZXJcbiAgICAgIHJldHVybiBnZXRBbm9ueW1pemVkRE9NKGN1cnJlbnROb2RlLCBnZXROb2RlTGFiZWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJ0NvdWxkIG5vdCBmaW5kIGNvbnRlbnRFZGl0YWJsZSBwYXJlbnQgb2Ygbm9kZSc7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVMZW5ndGgobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlVmFsdWUgPT09IG51bGwgPyBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIDogbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHNldERyYWZ0RWRpdG9yU2VsZWN0aW9uKHNlbGVjdGlvblN0YXRlLCBub2RlLCBibG9ja0tleSwgbm9kZVN0YXJ0LCBub2RlRW5kKSB7XG4gIC8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgZWRpdG9yIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgRE9NIGJ1dFxuICAvLyBvdXIgc2VsZWN0aW9uIGNvZGUgZG9lc24ndCBrbm93IGl0IHlldC4gRm9yY2luZyBzZWxlY3Rpb24gaW5cbiAgLy8gdGhpcyBjYXNlIG1heSBsZWFkIHRvIGVycm9ycywgc28ganVzdCBiYWlsIG5vdy5cbiAgaWYgKCFjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSBnbG9iYWwuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBhbmNob3JLZXkgPSBzZWxlY3Rpb25TdGF0ZS5nZXRBbmNob3JLZXkoKTtcbiAgdmFyIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvblN0YXRlLmdldEFuY2hvck9mZnNldCgpO1xuICB2YXIgZm9jdXNLZXkgPSBzZWxlY3Rpb25TdGF0ZS5nZXRGb2N1c0tleSgpO1xuICB2YXIgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb25TdGF0ZS5nZXRGb2N1c09mZnNldCgpO1xuICB2YXIgaXNCYWNrd2FyZCA9IHNlbGVjdGlvblN0YXRlLmdldElzQmFja3dhcmQoKTtcblxuICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgYmFja3dhcmQgc2VsZWN0aW9uLiBTd2FwIGtleS9vZmZzZXQgcGFpcnMuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBpc0JhY2t3YXJkKSB7XG4gICAgdmFyIHRlbXBLZXkgPSBhbmNob3JLZXk7XG4gICAgdmFyIHRlbXBPZmZzZXQgPSBhbmNob3JPZmZzZXQ7XG4gICAgYW5jaG9yS2V5ID0gZm9jdXNLZXk7XG4gICAgYW5jaG9yT2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgZm9jdXNLZXkgPSB0ZW1wS2V5O1xuICAgIGZvY3VzT2Zmc2V0ID0gdGVtcE9mZnNldDtcbiAgICBpc0JhY2t3YXJkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgaGFzQW5jaG9yID0gYW5jaG9yS2V5ID09PSBibG9ja0tleSAmJiBub2RlU3RhcnQgPD0gYW5jaG9yT2Zmc2V0ICYmIG5vZGVFbmQgPj0gYW5jaG9yT2Zmc2V0O1xuXG4gIHZhciBoYXNGb2N1cyA9IGZvY3VzS2V5ID09PSBibG9ja0tleSAmJiBub2RlU3RhcnQgPD0gZm9jdXNPZmZzZXQgJiYgbm9kZUVuZCA+PSBmb2N1c09mZnNldDtcblxuICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGVudGlyZWx5IGJvdW5kIHdpdGhpbiB0aGlzIG5vZGUsIHNldCB0aGUgc2VsZWN0aW9uXG4gIC8vIGFuZCBiZSBkb25lLlxuICBpZiAoaGFzQW5jaG9yICYmIGhhc0ZvY3VzKSB7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIGFkZFBvaW50VG9TZWxlY3Rpb24oc2VsZWN0aW9uLCBub2RlLCBhbmNob3JPZmZzZXQgLSBub2RlU3RhcnQsIHNlbGVjdGlvblN0YXRlKTtcbiAgICBhZGRGb2N1c1RvU2VsZWN0aW9uKHNlbGVjdGlvbiwgbm9kZSwgZm9jdXNPZmZzZXQgLSBub2RlU3RhcnQsIHNlbGVjdGlvblN0YXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWlzQmFja3dhcmQpIHtcbiAgICAvLyBJZiB0aGUgYW5jaG9yIGlzIHdpdGhpbiB0aGlzIG5vZGUsIHNldCB0aGUgcmFuZ2Ugc3RhcnQuXG4gICAgaWYgKGhhc0FuY2hvcikge1xuICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgYWRkUG9pbnRUb1NlbGVjdGlvbihzZWxlY3Rpb24sIG5vZGUsIGFuY2hvck9mZnNldCAtIG5vZGVTdGFydCwgc2VsZWN0aW9uU3RhdGUpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBmb2N1cyBpcyB3aXRoaW4gdGhpcyBub2RlLCB3ZSBjYW4gYXNzdW1lIHRoYXQgd2UgaGF2ZVxuICAgIC8vIGFscmVhZHkgc2V0IHRoZSBhcHByb3ByaWF0ZSBzdGFydCByYW5nZSBvbiB0aGUgc2VsZWN0aW9uLCBhbmRcbiAgICAvLyBjYW4gc2ltcGx5IGV4dGVuZCB0aGUgc2VsZWN0aW9uLlxuICAgIGlmIChoYXNGb2N1cykge1xuICAgICAgYWRkRm9jdXNUb1NlbGVjdGlvbihzZWxlY3Rpb24sIG5vZGUsIGZvY3VzT2Zmc2V0IC0gbm9kZVN0YXJ0LCBzZWxlY3Rpb25TdGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoaXMgbm9kZSBoYXMgdGhlIGZvY3VzLCBzZXQgdGhlIHNlbGVjdGlvbiByYW5nZSB0byBiZSBhXG4gICAgLy8gY29sbGFwc2VkIHJhbmdlIGJlZ2lubmluZyBoZXJlLiBMYXRlciwgd2hlbiB3ZSBlbmNvdW50ZXIgdGhlIGFuY2hvcixcbiAgICAvLyB3ZSdsbCB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBleHRlbmQgdGhlIHNlbGVjdGlvbi5cbiAgICBpZiAoaGFzRm9jdXMpIHtcbiAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIGFkZFBvaW50VG9TZWxlY3Rpb24oc2VsZWN0aW9uLCBub2RlLCBmb2N1c09mZnNldCAtIG5vZGVTdGFydCwgc2VsZWN0aW9uU3RhdGUpO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgbm9kZSBoYXMgdGhlIGFuY2hvciwgd2UgbWF5IGFzc3VtZSB0aGF0IHRoZSBjb3JyZWN0XG4gICAgLy8gZm9jdXMgaW5mb3JtYXRpb24gaXMgYWxyZWFkeSBzdG9yZWQgb24gdGhlIHNlbGVjdGlvbiBvYmplY3QuXG4gICAgLy8gV2Uga2VlcCB0cmFjayBvZiBpdCwgcmVzZXQgdGhlIHNlbGVjdGlvbiByYW5nZSwgYW5kIGV4dGVuZCBpdFxuICAgIC8vIGJhY2sgdG8gdGhlIGZvY3VzIHBvaW50LlxuICAgIGlmIChoYXNBbmNob3IpIHtcbiAgICAgIHZhciBzdG9yZWRGb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xuICAgICAgdmFyIHN0b3JlZEZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICBhZGRQb2ludFRvU2VsZWN0aW9uKHNlbGVjdGlvbiwgbm9kZSwgYW5jaG9yT2Zmc2V0IC0gbm9kZVN0YXJ0LCBzZWxlY3Rpb25TdGF0ZSk7XG4gICAgICBhZGRGb2N1c1RvU2VsZWN0aW9uKHNlbGVjdGlvbiwgc3RvcmVkRm9jdXNOb2RlLCBzdG9yZWRGb2N1c09mZnNldCwgc2VsZWN0aW9uU3RhdGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEV4dGVuZCBzZWxlY3Rpb24gdG93YXJkcyBmb2N1cyBwb2ludC5cbiAqL1xuZnVuY3Rpb24gYWRkRm9jdXNUb1NlbGVjdGlvbihzZWxlY3Rpb24sIG5vZGUsIG9mZnNldCwgc2VsZWN0aW9uU3RhdGUpIHtcbiAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIGlmIChzZWxlY3Rpb24uZXh0ZW5kICYmIGNvbnRhaW5zTm9kZShhY3RpdmVFbGVtZW50LCBub2RlKSkge1xuICAgIC8vIElmIGBleHRlbmRgIGlzIGNhbGxlZCB3aGlsZSBhbm90aGVyIGVsZW1lbnQgaGFzIGZvY3VzLCBhbiBlcnJvciBpc1xuICAgIC8vIHRocm93bi4gV2UgdGhlcmVmb3JlIGRpc2FibGUgYGV4dGVuZGAgaWYgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIHNvbWV3aGVyZVxuICAgIC8vIG90aGVyIHRoYW4gdGhlIG5vZGUgd2UgYXJlIHNlbGVjdGluZy4gVGhpcyBzaG91bGQgb25seSBvY2N1ciBpbiBGaXJlZm94LFxuICAgIC8vIHNpbmNlIGl0IGlzIHRoZSBvbmx5IGJyb3dzZXIgdG8gc3VwcG9ydCBtdWx0aXBsZSBzZWxlY3Rpb25zLlxuICAgIC8vIFNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05MjE0NDQuXG5cbiAgICAvLyBsb2dnaW5nIHRvIGNhdGNoIGJ1ZyB0aGF0IGlzIGJlaW5nIHJlcG9ydGVkIGluIHQxNjI1MDc5NVxuICAgIGlmIChvZmZzZXQgPiBnZXROb2RlTGVuZ3RoKG5vZGUpKSB7XG4gICAgICAvLyB0aGUgY2FsbCB0byAnc2VsZWN0aW9uLmV4dGVuZCcgaXMgYWJvdXQgdG8gdGhyb3dcbiAgICAgIERyYWZ0SnNEZWJ1Z0xvZ2dpbmcubG9nU2VsZWN0aW9uU3RhdGVGYWlsdXJlKHtcbiAgICAgICAgYW5vbnltaXplZERvbTogZ2V0QW5vbnltaXplZEVkaXRvckRPTShub2RlKSxcbiAgICAgICAgZXh0cmFQYXJhbXM6IEpTT04uc3RyaW5naWZ5KHsgb2Zmc2V0OiBvZmZzZXQgfSksXG4gICAgICAgIHNlbGVjdGlvblN0YXRlOiBKU09OLnN0cmluZ2lmeShzZWxlY3Rpb25TdGF0ZS50b0pTKCkpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBsb2dnaW5nIHRvIGNhdGNoIGJ1ZyB0aGF0IGlzIGJlaW5nIHJlcG9ydGVkIGluIHQxODExMDYzMlxuICAgIHZhciBub2RlV2FzRm9jdXMgPSBub2RlID09PSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xuICAgIHRyeSB7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKG5vZGUsIG9mZnNldCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgRHJhZnRKc0RlYnVnTG9nZ2luZy5sb2dTZWxlY3Rpb25TdGF0ZUZhaWx1cmUoe1xuICAgICAgICBhbm9ueW1pemVkRG9tOiBnZXRBbm9ueW1pemVkRWRpdG9yRE9NKG5vZGUsIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgdmFyIGxhYmVscyA9IFtdO1xuICAgICAgICAgIGlmIChuID09PSBhY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICBsYWJlbHMucHVzaCgnYWN0aXZlIGVsZW1lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG4gPT09IHNlbGVjdGlvbi5hbmNob3JOb2RlKSB7XG4gICAgICAgICAgICBsYWJlbHMucHVzaCgnc2VsZWN0aW9uIGFuY2hvciBub2RlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuID09PSBzZWxlY3Rpb24uZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICBsYWJlbHMucHVzaCgnc2VsZWN0aW9uIGZvY3VzIG5vZGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICAgICAgfSksXG4gICAgICAgIGV4dHJhUGFyYW1zOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudE5hbWU6IGFjdGl2ZUVsZW1lbnQgPyBhY3RpdmVFbGVtZW50Lm5vZGVOYW1lIDogbnVsbCxcbiAgICAgICAgICBub2RlSXNGb2N1czogbm9kZSA9PT0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgICAgICBub2RlV2FzRm9jdXM6IG5vZGVXYXNGb2N1cyxcbiAgICAgICAgICBzZWxlY3Rpb25SYW5nZUNvdW50OiBzZWxlY3Rpb24ucmFuZ2VDb3VudCxcbiAgICAgICAgICBzZWxlY3Rpb25BbmNob3JOb2RlTmFtZTogc2VsZWN0aW9uLmFuY2hvck5vZGUgPyBzZWxlY3Rpb24uYW5jaG9yTm9kZS5ub2RlTmFtZSA6IG51bGwsXG4gICAgICAgICAgc2VsZWN0aW9uQW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgICAgIHNlbGVjdGlvbkZvY3VzTm9kZU5hbWU6IHNlbGVjdGlvbi5mb2N1c05vZGUgPyBzZWxlY3Rpb24uZm9jdXNOb2RlLm5vZGVOYW1lIDogbnVsbCxcbiAgICAgICAgICBzZWxlY3Rpb25Gb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0LFxuICAgICAgICAgIG1lc3NhZ2U6IGUgPyAnJyArIGUgOiBudWxsLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgIH0sIG51bGwsIDIpLFxuICAgICAgICBzZWxlY3Rpb25TdGF0ZTogSlNPTi5zdHJpbmdpZnkoc2VsZWN0aW9uU3RhdGUudG9KUygpLCBudWxsLCAyKVxuICAgICAgfSk7XG4gICAgICAvLyBhbGxvdyB0aGUgZXJyb3IgdG8gYmUgdGhyb3duIC1cbiAgICAgIC8vIGJldHRlciB0aGFuIGNvbnRpbnVpbmcgaW4gYSBicm9rZW4gc3RhdGVcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBleHRlbmQuIFRoaXMgd2lsbCBtZWFuIG5vIGJhY2t3YXJkIHNlbGVjdGlvbi5cbiAgICAvLyBFeHRyYWN0IHRoZSBleGlzdGluZyBzZWxlY3Rpb24gcmFuZ2UgYW5kIGFkZCBmb2N1cyB0byBpdC5cbiAgICAvLyBBZGRpdGlvbmFsbHksIGNsb25lIHRoZSBzZWxlY3Rpb24gcmFuZ2UuIElFMTEgdGhyb3dzIGFuXG4gICAgLy8gSW52YWxpZFN0YXRlRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBzZWxlY3Rpb24gcHJvcGVydGllc1xuICAgIC8vIGFmdGVyIHRoZSByYW5nZSBpcyBkZXRhY2hlZC5cbiAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UuY2xvbmVSYW5nZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRQb2ludFRvU2VsZWN0aW9uKHNlbGVjdGlvbiwgbm9kZSwgb2Zmc2V0LCBzZWxlY3Rpb25TdGF0ZSkge1xuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAvLyBsb2dnaW5nIHRvIGNhdGNoIGJ1ZyB0aGF0IGlzIGJlaW5nIHJlcG9ydGVkIGluIHQxNjI1MDc5NVxuICBpZiAob2Zmc2V0ID4gZ2V0Tm9kZUxlbmd0aChub2RlKSkge1xuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBrbm93IHRoYXQgdGhlIGNhbGwgdG8gJ3JhbmdlLnNldFN0YXJ0JyBpcyBhYm91dCB0byB0aHJvd1xuICAgIERyYWZ0SnNEZWJ1Z0xvZ2dpbmcubG9nU2VsZWN0aW9uU3RhdGVGYWlsdXJlKHtcbiAgICAgIGFub255bWl6ZWREb206IGdldEFub255bWl6ZWRFZGl0b3JET00obm9kZSksXG4gICAgICBleHRyYVBhcmFtczogSlNPTi5zdHJpbmdpZnkoeyBvZmZzZXQ6IG9mZnNldCB9KSxcbiAgICAgIHNlbGVjdGlvblN0YXRlOiBKU09OLnN0cmluZ2lmeShzZWxlY3Rpb25TdGF0ZS50b0pTKCkpXG4gICAgfSk7XG4gIH1cbiAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXREcmFmdEVkaXRvclNlbGVjdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvc2V0RHJhZnRFZGl0b3JTZWxlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDQxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRHJhZnRKc0RlYnVnTG9nZ2luZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvZ1NlbGVjdGlvblN0YXRlRmFpbHVyZTogZnVuY3Rpb24gbG9nU2VsZWN0aW9uU3RhdGVGYWlsdXJlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdEpzRGVidWdMb2dnaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA0MTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgY2FtZWxpemUgPSByZXF1aXJlKCcuL2NhbWVsaXplJyk7XG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxuZnVuY3Rpb24gYXNTdHJpbmcodmFsdWUpIC8qP3N0cmluZyove1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHZhbHVlIDogU3RyaW5nKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3R5bGVQcm9wZXJ0eSggLypET01Ob2RlKi9ub2RlLCAvKnN0cmluZyovbmFtZSkgLyo/c3RyaW5nKi97XG4gIHZhciBjb21wdXRlZFN0eWxlID0gdm9pZCAwO1xuXG4gIC8vIFczQyBTdGFuZGFyZFxuICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAvLyBJbiBjZXJ0YWluIGNhc2VzIHN1Y2ggYXMgd2l0aGluIGFuIGlmcmFtZSBpbiBGRjMsIHRoaXMgcmV0dXJucyBudWxsLlxuICAgIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKTtcbiAgICBpZiAoY29tcHV0ZWRTdHlsZSkge1xuICAgICAgcmV0dXJuIGFzU3RyaW5nKGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShoeXBoZW5hdGUobmFtZSkpKTtcbiAgICB9XG4gIH1cbiAgLy8gU2FmYXJpXG4gIGlmIChkb2N1bWVudC5kZWZhdWx0VmlldyAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgY29tcHV0ZWRTdHlsZSA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCk7XG4gICAgLy8gQSBTYWZhcmkgYnVnIGNhdXNlcyB0aGlzIHRvIHJldHVybiBudWxsIGZvciBgZGlzcGxheTogbm9uZWAgZWxlbWVudHMuXG4gICAgaWYgKGNvbXB1dGVkU3R5bGUpIHtcbiAgICAgIHJldHVybiBhc1N0cmluZyhjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoaHlwaGVuYXRlKG5hbWUpKSk7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSAnZGlzcGxheScpIHtcbiAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgfVxuICB9XG4gIC8vIEludGVybmV0IEV4cGxvcmVyXG4gIGlmIChub2RlLmN1cnJlbnRTdHlsZSkge1xuICAgIGlmIChuYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICByZXR1cm4gYXNTdHJpbmcobm9kZS5jdXJyZW50U3R5bGUuY3NzRmxvYXQgfHwgbm9kZS5jdXJyZW50U3R5bGUuc3R5bGVGbG9hdCk7XG4gICAgfVxuICAgIHJldHVybiBhc1N0cmluZyhub2RlLmN1cnJlbnRTdHlsZVtjYW1lbGl6ZShuYW1lKV0pO1xuICB9XG4gIHJldHVybiBhc1N0cmluZyhub2RlLnN0eWxlICYmIG5vZGUuc3R5bGVbY2FtZWxpemUobmFtZSldKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTdHlsZVByb3BlcnR5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldFN0eWxlUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDQyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBnZXRFbGVtZW50UmVjdCA9IHJlcXVpcmUoJy4vZ2V0RWxlbWVudFJlY3QnKTtcblxuLyoqXG4gKiBHZXRzIGFuIGVsZW1lbnQncyBwb3NpdGlvbiBpbiBwaXhlbHMgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LiBUaGUgcmV0dXJuZWRcbiAqIG9iamVjdCByZXByZXNlbnRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCdzIHRvcCBsZWZ0IGNvcm5lci5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0RWxlbWVudFBvc2l0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBnZXRFbGVtZW50UmVjdChlbGVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQsXG4gICAgeTogcmVjdC50b3AsXG4gICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RWxlbWVudFBvc2l0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEVsZW1lbnRQb3NpdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJy4vY29udGFpbnNOb2RlJyk7XG5cbi8qKlxuICogR2V0cyBhbiBlbGVtZW50J3MgYm91bmRpbmcgcmVjdCBpbiBwaXhlbHMgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRFbGVtZW50UmVjdChlbGVtKSB7XG4gIHZhciBkb2NFbGVtID0gZWxlbS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAvLyBGRiAyLCBTYWZhcmkgMyBhbmQgT3BlcmEgOS41LSBkbyBub3Qgc3VwcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5cbiAgLy8gSUU5LSB3aWxsIHRocm93IGlmIHRoZSBlbGVtZW50IGlzIG5vdCBpbiB0aGUgZG9jdW1lbnQuXG4gIGlmICghKCdnZXRCb3VuZGluZ0NsaWVudFJlY3QnIGluIGVsZW0pIHx8ICFjb250YWluc05vZGUoZG9jRWxlbSwgZWxlbSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgfVxuXG4gIC8vIFN1YnRyYWN0cyBjbGllbnRUb3AvTGVmdCBiZWNhdXNlIElFOC0gYWRkZWQgYSAycHggYm9yZGVyIHRvIHRoZVxuICAvLyA8aHRtbD4gZWxlbWVudCAoc2VlIGh0dHA6Ly9mYnVybC5jb20vMTQ5MzIxMykuIElFIDcgaW5cbiAgLy8gUXVpY2tzbW9kZSBkb2VzIG5vdCByZXBvcnQgY2xpZW50TGVmdC9jbGllbnRUb3Agc28gdGhlcmVcbiAgLy8gd2lsbCBiZSBhbiB1bmFjY291bnRlZCBvZmZzZXQgb2YgMnB4IHdoZW4gaW4gcXVpcmtzbW9kZVxuICB2YXIgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBNYXRoLnJvdW5kKHJlY3QubGVmdCkgLSBkb2NFbGVtLmNsaWVudExlZnQsXG4gICAgcmlnaHQ6IE1hdGgucm91bmQocmVjdC5yaWdodCkgLSBkb2NFbGVtLmNsaWVudExlZnQsXG4gICAgdG9wOiBNYXRoLnJvdW5kKHJlY3QudG9wKSAtIGRvY0VsZW0uY2xpZW50VG9wLFxuICAgIGJvdHRvbTogTWF0aC5yb3VuZChyZWN0LmJvdHRvbSkgLSBkb2NFbGVtLmNsaWVudFRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEVsZW1lbnRSZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEVsZW1lbnRSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNXZWJraXQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0FwcGxlV2ViS2l0JykgPiAtMTtcblxuLyoqXG4gKiBHZXRzIHRoZSBlbGVtZW50IHdpdGggdGhlIGRvY3VtZW50IHNjcm9sbCBwcm9wZXJ0aWVzIHN1Y2ggYXMgYHNjcm9sbExlZnRgIGFuZFxuICogYHNjcm9sbEhlaWdodGAuIFRoaXMgbWF5IGRpZmZlciBhY3Jvc3MgZGlmZmVyZW50IGJyb3dzZXJzLlxuICpcbiAqIE5PVEU6IFRoZSByZXR1cm4gdmFsdWUgY2FuIGJlIG51bGwgaWYgdGhlIERPTSBpcyBub3QgeWV0IHJlYWR5LlxuICpcbiAqIEBwYXJhbSB7P0RPTURvY3VtZW50fSBkb2MgRGVmYXVsdHMgdG8gY3VycmVudCBkb2N1bWVudC5cbiAqIEByZXR1cm4gez9ET01FbGVtZW50fVxuICovXG5mdW5jdGlvbiBnZXREb2N1bWVudFNjcm9sbEVsZW1lbnQoZG9jKSB7XG4gIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgaWYgKGRvYy5zY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvYy5zY3JvbGxpbmdFbGVtZW50O1xuICB9XG4gIHJldHVybiAhaXNXZWJraXQgJiYgZG9jLmNvbXBhdE1vZGUgPT09ICdDU1MxQ29tcGF0JyA/IGRvYy5kb2N1bWVudEVsZW1lbnQgOiBkb2MuYm9keTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXREb2N1bWVudFNjcm9sbEVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0RG9jdW1lbnRTY3JvbGxFbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0MjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc3VwcGxpZWQgZWxlbWVudCBvciB3aW5kb3cuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZXMgYXJlIHVuYm91bmRlZCwgdW5saWtlIGBnZXRTY3JvbGxQb3NpdGlvbmAuIFRoaXMgbWVhbnMgdGhleVxuICogbWF5IGJlIG5lZ2F0aXZlIG9yIGV4Y2VlZCB0aGUgZWxlbWVudCBib3VuZGFyaWVzICh3aGljaCBpcyBwb3NzaWJsZSB1c2luZ1xuICogaW5lcnRpYWwgc2Nyb2xsaW5nKS5cbiAqXG4gKiBAcGFyYW0ge0RPTVdpbmRvd3xET01FbGVtZW50fSBzY3JvbGxhYmxlXG4gKiBAcmV0dXJuIHtvYmplY3R9IE1hcCB3aXRoIGB4YCBhbmQgYHlgIGtleXMuXG4gKi9cblxuZnVuY3Rpb24gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZSkge1xuICBpZiAoc2Nyb2xsYWJsZS5XaW5kb3cgJiYgc2Nyb2xsYWJsZSBpbnN0YW5jZW9mIHNjcm9sbGFibGUuV2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHNjcm9sbGFibGUucGFnZVhPZmZzZXQgfHwgc2Nyb2xsYWJsZS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHk6IHNjcm9sbGFibGUucGFnZVlPZmZzZXQgfHwgc2Nyb2xsYWJsZS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcbiAgICB5OiBzY3JvbGxhYmxlLnNjcm9sbFRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRXaWR0aCgpIHtcbiAgdmFyIHdpZHRoID0gdm9pZCAwO1xuICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgd2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIH1cblxuICBpZiAoIXdpZHRoICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICB3aWR0aCA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7XG4gIH1cblxuICByZXR1cm4gd2lkdGggfHwgMDtcbn0gLyoqXG4gICAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKlxuICAgKiBcbiAgICogQHR5cGVjaGVja3NcbiAgICovXG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0SGVpZ2h0KCkge1xuICB2YXIgaGVpZ2h0ID0gdm9pZCAwO1xuICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgaGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgfVxuXG4gIGlmICghaGVpZ2h0ICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICBoZWlnaHQgPSBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDtcbiAgfVxuXG4gIHJldHVybiBoZWlnaHQgfHwgMDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zIGluY2x1ZGluZyBhbnkgc2Nyb2xsYmFycy5cbiAqL1xuZnVuY3Rpb24gZ2V0Vmlld3BvcnREaW1lbnNpb25zKCkge1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCB8fCBnZXRWaWV3cG9ydFdpZHRoKCksXG4gICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZ2V0Vmlld3BvcnRIZWlnaHQoKVxuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZpZXdwb3J0IGRpbWVuc2lvbnMgZXhjbHVkaW5nIGFueSBzY3JvbGxiYXJzLlxuICovXG5nZXRWaWV3cG9ydERpbWVuc2lvbnMud2l0aG91dFNjcm9sbGJhcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGdldFZpZXdwb3J0V2lkdGgoKSxcbiAgICBoZWlnaHQ6IGdldFZpZXdwb3J0SGVpZ2h0KClcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Vmlld3BvcnREaW1lbnNpb25zO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldFZpZXdwb3J0RGltZW5zaW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gNDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBjbGFzc05hbWUgc3RyaW5ncyBpbnRvIG9uZS5cbiAqIGh0dHA6Ly9qc3BlcmYuY29tL2pvaW5jbGFzc2VzLWFyZ3MtdnMtYXJyYXlcbiAqXG4gKiBAcGFyYW0gey4uLj9zdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGpvaW5DbGFzc2VzKGNsYXNzTmFtZSAvKiwgLi4uICovKSB7XG4gIGlmICghY2xhc3NOYW1lKSB7XG4gICAgY2xhc3NOYW1lID0gJyc7XG4gIH1cbiAgdmFyIG5leHRDbGFzcyA9IHZvaWQgMDtcbiAgdmFyIGFyZ0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChhcmdMZW5ndGggPiAxKSB7XG4gICAgZm9yICh2YXIgaWkgPSAxOyBpaSA8IGFyZ0xlbmd0aDsgaWkrKykge1xuICAgICAgbmV4dENsYXNzID0gYXJndW1lbnRzW2lpXTtcbiAgICAgIGlmIChuZXh0Q2xhc3MpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5leHRDbGFzcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBqb2luQ2xhc3NlcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9qb2luQ2xhc3Nlcy5qc1xuLy8gbW9kdWxlIGlkID0gNDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEcmFmdEVkaXRvckRyYWdIYW5kbGVyXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhVHJhbnNmZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9EYXRhVHJhbnNmZXInKTtcbnZhciBEcmFmdE1vZGlmaWVyID0gcmVxdWlyZSgnLi9EcmFmdE1vZGlmaWVyJyk7XG52YXIgRWRpdG9yU3RhdGUgPSByZXF1aXJlKCcuL0VkaXRvclN0YXRlJyk7XG5cbnZhciBmaW5kQW5jZXN0b3JPZmZzZXRLZXkgPSByZXF1aXJlKCcuL2ZpbmRBbmNlc3Rvck9mZnNldEtleScpO1xudmFyIGdldFRleHRDb250ZW50RnJvbUZpbGVzID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEZyb21GaWxlcycpO1xudmFyIGdldFVwZGF0ZWRTZWxlY3Rpb25TdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0VXBkYXRlZFNlbGVjdGlvblN0YXRlJyk7XG52YXIgaXNFdmVudEhhbmRsZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRIYW5kbGVkJyk7XG52YXIgbnVsbHRocm93cyA9IHJlcXVpcmUoJ2ZianMvbGliL251bGx0aHJvd3MnKTtcblxuLyoqXG4gKiBHZXQgYSBTZWxlY3Rpb25TdGF0ZSBmb3IgdGhlIHN1cHBsaWVkIG1vdXNlIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25Gb3JFdmVudChldmVudCwgZWRpdG9yU3RhdGUpIHtcbiAgdmFyIG5vZGUgPSBudWxsO1xuICB2YXIgb2Zmc2V0ID0gbnVsbDtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZHJvcFJhbmdlID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludChldmVudC54LCBldmVudC55KTtcbiAgICBub2RlID0gZHJvcFJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgIG9mZnNldCA9IGRyb3BSYW5nZS5zdGFydE9mZnNldDtcbiAgfSBlbHNlIGlmIChldmVudC5yYW5nZVBhcmVudCkge1xuICAgIG5vZGUgPSBldmVudC5yYW5nZVBhcmVudDtcbiAgICBvZmZzZXQgPSBldmVudC5yYW5nZU9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG5vZGUgPSBudWxsdGhyb3dzKG5vZGUpO1xuICBvZmZzZXQgPSBudWxsdGhyb3dzKG9mZnNldCk7XG4gIHZhciBvZmZzZXRLZXkgPSBudWxsdGhyb3dzKGZpbmRBbmNlc3Rvck9mZnNldEtleShub2RlKSk7XG5cbiAgcmV0dXJuIGdldFVwZGF0ZWRTZWxlY3Rpb25TdGF0ZShlZGl0b3JTdGF0ZSwgb2Zmc2V0S2V5LCBvZmZzZXQsIG9mZnNldEtleSwgb2Zmc2V0KTtcbn1cblxudmFyIERyYWZ0RWRpdG9yRHJhZ0hhbmRsZXIgPSB7XG4gIC8qKlxuICAgKiBEcmFnIG9yaWdpbmF0aW5nIGZyb20gaW5wdXQgdGVybWluYXRlZC5cbiAgICovXG4gIG9uRHJhZ0VuZDogZnVuY3Rpb24gb25EcmFnRW5kKGVkaXRvcikge1xuICAgIGVkaXRvci5leGl0Q3VycmVudE1vZGUoKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlIGRhdGEgYmVpbmcgZHJvcHBlZC5cbiAgICovXG4gIG9uRHJvcDogZnVuY3Rpb24gb25Ecm9wKGVkaXRvciwgZSkge1xuICAgIHZhciBkYXRhID0gbmV3IERhdGFUcmFuc2ZlcihlLm5hdGl2ZUV2ZW50LmRhdGFUcmFuc2Zlcik7XG5cbiAgICB2YXIgZWRpdG9yU3RhdGUgPSBlZGl0b3IuX2xhdGVzdEVkaXRvclN0YXRlO1xuICAgIHZhciBkcm9wU2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uRm9yRXZlbnQoZS5uYXRpdmVFdmVudCwgZWRpdG9yU3RhdGUpO1xuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGVkaXRvci5leGl0Q3VycmVudE1vZGUoKTtcblxuICAgIGlmIChkcm9wU2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZmlsZXMgPSBkYXRhLmdldEZpbGVzKCk7XG4gICAgaWYgKGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChlZGl0b3IucHJvcHMuaGFuZGxlRHJvcHBlZEZpbGVzICYmIGlzRXZlbnRIYW5kbGVkKGVkaXRvci5wcm9wcy5oYW5kbGVEcm9wcGVkRmlsZXMoZHJvcFNlbGVjdGlvbiwgZmlsZXMpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGdldFRleHRDb250ZW50RnJvbUZpbGVzKGZpbGVzLCBmdW5jdGlvbiAoZmlsZVRleHQpIHtcbiAgICAgICAgZmlsZVRleHQgJiYgZWRpdG9yLnVwZGF0ZShpbnNlcnRUZXh0QXRTZWxlY3Rpb24oZWRpdG9yU3RhdGUsIGRyb3BTZWxlY3Rpb24sIGZpbGVUZXh0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZHJhZ1R5cGUgPSBlZGl0b3IuX2ludGVybmFsRHJhZyA/ICdpbnRlcm5hbCcgOiAnZXh0ZXJuYWwnO1xuICAgIGlmIChlZGl0b3IucHJvcHMuaGFuZGxlRHJvcCAmJiBpc0V2ZW50SGFuZGxlZChlZGl0b3IucHJvcHMuaGFuZGxlRHJvcChkcm9wU2VsZWN0aW9uLCBkYXRhLCBkcmFnVHlwZSkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVkaXRvci5faW50ZXJuYWxEcmFnKSB7XG4gICAgICBlZGl0b3IudXBkYXRlKG1vdmVUZXh0KGVkaXRvclN0YXRlLCBkcm9wU2VsZWN0aW9uKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWRpdG9yLnVwZGF0ZShpbnNlcnRUZXh0QXRTZWxlY3Rpb24oZWRpdG9yU3RhdGUsIGRyb3BTZWxlY3Rpb24sIGRhdGEuZ2V0VGV4dCgpKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1vdmVUZXh0KGVkaXRvclN0YXRlLCB0YXJnZXRTZWxlY3Rpb24pIHtcbiAgdmFyIG5ld0NvbnRlbnRTdGF0ZSA9IERyYWZ0TW9kaWZpZXIubW92ZVRleHQoZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKSwgZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCksIHRhcmdldFNlbGVjdGlvbik7XG4gIHJldHVybiBFZGl0b3JTdGF0ZS5wdXNoKGVkaXRvclN0YXRlLCBuZXdDb250ZW50U3RhdGUsICdpbnNlcnQtZnJhZ21lbnQnKTtcbn1cblxuLyoqXG4gKiBJbnNlcnQgdGV4dCBhdCBhIHNwZWNpZmllZCBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGluc2VydFRleHRBdFNlbGVjdGlvbihlZGl0b3JTdGF0ZSwgc2VsZWN0aW9uLCB0ZXh0KSB7XG4gIHZhciBuZXdDb250ZW50U3RhdGUgPSBEcmFmdE1vZGlmaWVyLmluc2VydFRleHQoZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKSwgc2VsZWN0aW9uLCB0ZXh0LCBlZGl0b3JTdGF0ZS5nZXRDdXJyZW50SW5saW5lU3R5bGUoKSk7XG4gIHJldHVybiBFZGl0b3JTdGF0ZS5wdXNoKGVkaXRvclN0YXRlLCBuZXdDb250ZW50U3RhdGUsICdpbnNlcnQtZnJhZ21lbnQnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEcmFmdEVkaXRvckRyYWdIYW5kbGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdEVkaXRvckRyYWdIYW5kbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0Mjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG52YXIgUGhvdG9zTWltZVR5cGUgPSB7XG4gIGlzSW1hZ2U6IGZ1bmN0aW9uIGlzSW1hZ2UobWltZVN0cmluZykge1xuICAgIHJldHVybiBnZXRQYXJ0cyhtaW1lU3RyaW5nKVswXSA9PT0gJ2ltYWdlJztcbiAgfSxcbiAgaXNKcGVnOiBmdW5jdGlvbiBpc0pwZWcobWltZVN0cmluZykge1xuICAgIHZhciBwYXJ0cyA9IGdldFBhcnRzKG1pbWVTdHJpbmcpO1xuICAgIHJldHVybiBQaG90b3NNaW1lVHlwZS5pc0ltYWdlKG1pbWVTdHJpbmcpICYmIChcbiAgICAvLyBzZWUgaHR0cDovL2ZidXJsLmNvbS8xMDk3MjE5NFxuICAgIHBhcnRzWzFdID09PSAnanBlZycgfHwgcGFydHNbMV0gPT09ICdwanBlZycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRQYXJ0cyhtaW1lU3RyaW5nKSB7XG4gIHJldHVybiBtaW1lU3RyaW5nLnNwbGl0KCcvJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGhvdG9zTWltZVR5cGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvUGhvdG9zTWltZVR5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDQyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIGFycmF5cy5cbiAqXG4gKiBUaGlzIEFQSSBhc3N1bWVzIHRoZSBjYWxsZXIga25vd3MgdGhlIGNvbnRlbnRzIG9mIHRoZSBkYXRhIHR5cGUuIEZvciBsZXNzXG4gKiB3ZWxsIGRlZmluZWQgaW5wdXRzIHVzZSBjcmVhdGVBcnJheUZyb21NaXhlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbnxmaWxlbGlzdH0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cbiAgLy8gU29tZSBicm93c2VycyBidWlsdGluIG9iamVjdHMgY2FuIHJlcG9ydCB0eXBlb2YgJ2Z1bmN0aW9uJyAoZS5nLiBOb2RlTGlzdFxuICAvLyBpbiBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpKS5cbiAgISghQXJyYXkuaXNBcnJheShvYmopICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogQXJyYXktbGlrZSBvYmplY3QgZXhwZWN0ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgISh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IG5lZWRzIGEgbGVuZ3RoIHByb3BlcnR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEobGVuZ3RoID09PSAwIHx8IGxlbmd0aCAtIDEgaW4gb2JqKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3Qgc2hvdWxkIGhhdmUga2V5cyBmb3IgaW5kaWNlcycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKHR5cGVvZiBvYmouY2FsbGVlICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgY2FuXFwndCBiZSBgYXJndW1lbnRzYC4gVXNlIHJlc3QgcGFyYW1zICcgKyAnKGZ1bmN0aW9uKC4uLmFyZ3MpIHt9KSBvciBBcnJheS5mcm9tKCkgaW5zdGVhZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgLy8gT2xkIElFIGRvZXNuJ3QgZ2l2ZSBjb2xsZWN0aW9ucyBhY2Nlc3MgdG8gaGFzT3duUHJvcGVydHkuIEFzc3VtZSBpbnB1dHNcbiAgLy8gd2l0aG91dCBtZXRob2Qgd2lsbCB0aHJvdyBkdXJpbmcgdGhlIHNsaWNlIGNhbGwgYW5kIHNraXAgc3RyYWlnaHQgdG8gdGhlXG4gIC8vIGZhbGxiYWNrLlxuICBpZiAob2JqLmhhc093blByb3BlcnR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFIDwgOSBkb2VzIG5vdCBzdXBwb3J0IEFycmF5I3NsaWNlIG9uIGNvbGxlY3Rpb25zIG9iamVjdHNcbiAgICB9XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gY29weWluZyBrZXkgYnkga2V5LiBUaGlzIGFzc3VtZXMgYWxsIGtleXMgaGF2ZSBhIHZhbHVlLFxuICAvLyBzbyB3aWxsIG5vdCBwcmVzZXJ2ZSBzcGFyc2VseSBwb3B1bGF0ZWQgaW5wdXRzLlxuICB2YXIgcmV0ID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbmd0aDsgaWkrKykge1xuICAgIHJldFtpaV0gPSBvYmpbaWldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybSBhIGhldXJpc3RpYyB0ZXN0IHRvIGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgXCJhcnJheS1saWtlXCIuXG4gKlxuICogICBBIG1vbmsgYXNrZWQgSm9zaHUsIGEgWmVuIG1hc3RlciwgXCJIYXMgYSBkb2cgQnVkZGhhIG5hdHVyZT9cIlxuICogICBKb3NodSByZXBsaWVkOiBcIk11LlwiXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIGlmIGl0cyBhcmd1bWVudCBoYXMgXCJhcnJheSBuYXR1cmVcIjogaXQgcmV0dXJuc1xuICogdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYWN0dWFsIGFycmF5LCBhbiBgYXJndW1lbnRzJyBvYmplY3QsIG9yIGFuXG4gKiBIVE1MQ29sbGVjdGlvbiAoZS5nLiBub2RlLmNoaWxkTm9kZXMgb3Igbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgpKS5cbiAqXG4gKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3Igb3RoZXIgYXJyYXktbGlrZSBvYmplY3RzIGxpa2UgRmlsZWxpc3QuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc0FycmF5TmF0dXJlKG9iaikge1xuICByZXR1cm4gKFxuICAgIC8vIG5vdCBudWxsL2ZhbHNlXG4gICAgISFvYmogJiYgKFxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXG4gICAgdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicpICYmXG4gICAgLy8gcXVhY2tzIGxpa2UgYW4gYXJyYXlcbiAgICAnbGVuZ3RoJyBpbiBvYmogJiZcbiAgICAvLyBub3Qgd2luZG93XG4gICAgISgnc2V0SW50ZXJ2YWwnIGluIG9iaikgJiZcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXG4gICAgLy8gYSAnc2VsZWN0JyBlbGVtZW50IGhhcyAnbGVuZ3RoJyBhbmQgJ2l0ZW0nIHByb3BlcnRpZXMgb24gSUU4XG4gICAgdHlwZW9mIG9iai5ub2RlVHlwZSAhPSAnbnVtYmVyJyAmJiAoXG4gICAgLy8gYSByZWFsIGFycmF5XG4gICAgQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgLy8gYXJndW1lbnRzXG4gICAgJ2NhbGxlZScgaW4gb2JqIHx8XG4gICAgLy8gSFRNTENvbGxlY3Rpb24vTm9kZUxpc3RcbiAgICAnaXRlbScgaW4gb2JqKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBieSB3cmFwcGluZyBpdCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3QuXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYXJndW1lbnQgaWYgaXQgaXMgYWxyZWFkeSBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgaWRpb21hdGljYWxseTpcbiAqXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG4gKlxuICogICBmdW5jdGlvbiB0YWtlc09uZU9yTW9yZVRoaW5ncyh0aGluZ3MpIHtcbiAqICAgICB0aGluZ3MgPSBjcmVhdGVBcnJheUZyb21NaXhlZCh0aGluZ3MpO1xuICogICAgIC4uLlxuICogICB9XG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyZWF0IGB0aGluZ3MnIGFzIGFuIGFycmF5LCBidXQgYWNjZXB0IHNjYWxhcnMgaW4gdGhlIEFQSS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XG4gKiB1c2UgdG9BcnJheSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWl4ZWQob2JqKSB7XG4gIGlmICghaGFzQXJyYXlOYXR1cmUob2JqKSkge1xuICAgIHJldHVybiBbb2JqXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzXG4vLyBtb2R1bGUgaWQgPSA0Mjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERyYWZ0RWRpdG9yRWRpdEhhbmRsZXJcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG9uQmVmb3JlSW5wdXQgPSByZXF1aXJlKCcuL2VkaXRPbkJlZm9yZUlucHV0Jyk7XG52YXIgb25CbHVyID0gcmVxdWlyZSgnLi9lZGl0T25CbHVyJyk7XG52YXIgb25Db21wb3NpdGlvblN0YXJ0ID0gcmVxdWlyZSgnLi9lZGl0T25Db21wb3NpdGlvblN0YXJ0Jyk7XG52YXIgb25Db3B5ID0gcmVxdWlyZSgnLi9lZGl0T25Db3B5Jyk7XG52YXIgb25DdXQgPSByZXF1aXJlKCcuL2VkaXRPbkN1dCcpO1xudmFyIG9uRHJhZ092ZXIgPSByZXF1aXJlKCcuL2VkaXRPbkRyYWdPdmVyJyk7XG52YXIgb25EcmFnU3RhcnQgPSByZXF1aXJlKCcuL2VkaXRPbkRyYWdTdGFydCcpO1xudmFyIG9uRm9jdXMgPSByZXF1aXJlKCcuL2VkaXRPbkZvY3VzJyk7XG52YXIgb25JbnB1dCA9IHJlcXVpcmUoJy4vZWRpdE9uSW5wdXQnKTtcbnZhciBvbktleURvd24gPSByZXF1aXJlKCcuL2VkaXRPbktleURvd24nKTtcbnZhciBvblBhc3RlID0gcmVxdWlyZSgnLi9lZGl0T25QYXN0ZScpO1xudmFyIG9uU2VsZWN0ID0gcmVxdWlyZSgnLi9lZGl0T25TZWxlY3QnKTtcblxudmFyIERyYWZ0RWRpdG9yRWRpdEhhbmRsZXIgPSB7XG4gIG9uQmVmb3JlSW5wdXQ6IG9uQmVmb3JlSW5wdXQsXG4gIG9uQmx1cjogb25CbHVyLFxuICBvbkNvbXBvc2l0aW9uU3RhcnQ6IG9uQ29tcG9zaXRpb25TdGFydCxcbiAgb25Db3B5OiBvbkNvcHksXG4gIG9uQ3V0OiBvbkN1dCxcbiAgb25EcmFnT3Zlcjogb25EcmFnT3ZlcixcbiAgb25EcmFnU3RhcnQ6IG9uRHJhZ1N0YXJ0LFxuICBvbkZvY3VzOiBvbkZvY3VzLFxuICBvbklucHV0OiBvbklucHV0LFxuICBvbktleURvd246IG9uS2V5RG93bixcbiAgb25QYXN0ZTogb25QYXN0ZSxcbiAgb25TZWxlY3Q6IG9uU2VsZWN0XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWZ0RWRpdG9yRWRpdEhhbmRsZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0RWRpdG9yRWRpdEhhbmRsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZWRpdE9uQmVmb3JlSW5wdXRcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJsb2NrVHJlZSA9IHJlcXVpcmUoJy4vQmxvY2tUcmVlJyk7XG52YXIgRHJhZnRNb2RpZmllciA9IHJlcXVpcmUoJy4vRHJhZnRNb2RpZmllcicpO1xudmFyIEVkaXRvclN0YXRlID0gcmVxdWlyZSgnLi9FZGl0b3JTdGF0ZScpO1xudmFyIFVzZXJBZ2VudCA9IHJlcXVpcmUoJ2ZianMvbGliL1VzZXJBZ2VudCcpO1xuXG52YXIgZ2V0RW50aXR5S2V5Rm9yU2VsZWN0aW9uID0gcmVxdWlyZSgnLi9nZXRFbnRpdHlLZXlGb3JTZWxlY3Rpb24nKTtcbnZhciBpc0V2ZW50SGFuZGxlZCA9IHJlcXVpcmUoJy4vaXNFdmVudEhhbmRsZWQnKTtcbnZhciBpc1NlbGVjdGlvbkF0TGVhZlN0YXJ0ID0gcmVxdWlyZSgnLi9pc1NlbGVjdGlvbkF0TGVhZlN0YXJ0Jyk7XG52YXIgbnVsbHRocm93cyA9IHJlcXVpcmUoJ2ZianMvbGliL251bGx0aHJvd3MnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdmYmpzL2xpYi9zZXRJbW1lZGlhdGUnKTtcblxuLy8gV2hlbiBub3RoaW5nIGlzIGZvY3VzZWQsIEZpcmVmb3ggcmVnYXJkcyB0d28gY2hhcmFjdGVycywgYCdgIGFuZCBgL2AsIGFzXG4vLyBjb21tYW5kcyB0aGF0IHNob3VsZCBvcGVuIGFuZCBmb2N1cyB0aGUgXCJxdWlja2ZpbmRcIiBzZWFyY2ggYmFyLiBUaGlzIHNob3VsZFxuLy8gKm5ldmVyKiBoYXBwZW4gd2hpbGUgYSBjb250ZW50ZWRpdGFibGUgaXMgZm9jdXNlZCwgYnV0IGFzIG9mIHYyOCwgaXRcbi8vIHNvbWV0aW1lcyBkb2VzLCBldmVuIHdoZW4gdGhlIGtleXByZXNzIGV2ZW50IHRhcmdldCBpcyB0aGUgY29udGVudGVkaXRhYmxlLlxuLy8gVGhpcyBicmVha3MgdGhlIGlucHV0LiBTcGVjaWFsIGNhc2UgdGhlc2UgY2hhcmFjdGVycyB0byBlbnN1cmUgdGhhdCB3aGVuXG4vLyB0aGV5IGFyZSB0eXBlZCwgd2UgcHJldmVudCBkZWZhdWx0IG9uIHRoZSBldmVudCB0byBtYWtlIHN1cmUgbm90IHRvXG4vLyB0cmlnZ2VyIHF1aWNrZmluZC5cbnZhciBGRl9RVUlDS0ZJTkRfQ0hBUiA9IFwiJ1wiO1xudmFyIEZGX1FVSUNLRklORF9MSU5LX0NIQVIgPSAnLyc7XG52YXIgaXNGaXJlZm94ID0gVXNlckFnZW50LmlzQnJvd3NlcignRmlyZWZveCcpO1xuXG5mdW5jdGlvbiBtdXN0UHJldmVudERlZmF1bHRGb3JDaGFyYWN0ZXIoY2hhcmFjdGVyKSB7XG4gIHJldHVybiBpc0ZpcmVmb3ggJiYgKGNoYXJhY3RlciA9PSBGRl9RVUlDS0ZJTkRfQ0hBUiB8fCBjaGFyYWN0ZXIgPT0gRkZfUVVJQ0tGSU5EX0xJTktfQ0hBUik7XG59XG5cbi8qKlxuICogUmVwbGFjZSB0aGUgY3VycmVudCBzZWxlY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHRleHQgc3RyaW5nLCB3aXRoIHRoZVxuICogaW5saW5lIHN0eWxlIGFuZCBlbnRpdHkga2V5IGFwcGxpZWQgdG8gdGhlIG5ld2x5IGluc2VydGVkIHRleHQuXG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2VUZXh0KGVkaXRvclN0YXRlLCB0ZXh0LCBpbmxpbmVTdHlsZSwgZW50aXR5S2V5KSB7XG4gIHZhciBjb250ZW50U3RhdGUgPSBEcmFmdE1vZGlmaWVyLnJlcGxhY2VUZXh0KGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCksIGVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpLCB0ZXh0LCBpbmxpbmVTdHlsZSwgZW50aXR5S2V5KTtcbiAgcmV0dXJuIEVkaXRvclN0YXRlLnB1c2goZWRpdG9yU3RhdGUsIGNvbnRlbnRTdGF0ZSwgJ2luc2VydC1jaGFyYWN0ZXJzJyk7XG59XG5cbi8qKlxuICogV2hlbiBgb25CZWZvcmVJbnB1dGAgZXhlY3V0ZXMsIHRoZSBicm93c2VyIGlzIGF0dGVtcHRpbmcgdG8gaW5zZXJ0IGFcbiAqIGNoYXJhY3RlciBpbnRvIHRoZSBlZGl0b3IuIEFwcGx5IHRoaXMgY2hhcmFjdGVyIGRhdGEgdG8gdGhlIGRvY3VtZW50LFxuICogYWxsb3dpbmcgbmF0aXZlIGluc2VydGlvbiBpZiBwb3NzaWJsZS5cbiAqXG4gKiBOYXRpdmUgaW5zZXJ0aW9uIGlzIGVuY291cmFnZWQgaW4gb3JkZXIgdG8gbGltaXQgcmUtcmVuZGVyaW5nIGFuZCB0b1xuICogcHJlc2VydmUgc3BlbGxjaGVjayBoaWdobGlnaHRpbmcsIHdoaWNoIGRpc2FwcGVhcnMgb3IgZmxhc2hlcyBpZiByZS1yZW5kZXJcbiAqIG9jY3VycyBvbiB0aGUgcmVsZXZhbnQgdGV4dCBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gZWRpdE9uQmVmb3JlSW5wdXQoZWRpdG9yLCBlKSB7XG4gIGlmIChlZGl0b3IuX3BlbmRpbmdTdGF0ZUZyb21CZWZvcmVJbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWRpdG9yLnVwZGF0ZShlZGl0b3IuX3BlbmRpbmdTdGF0ZUZyb21CZWZvcmVJbnB1dCk7XG4gICAgZWRpdG9yLl9wZW5kaW5nU3RhdGVGcm9tQmVmb3JlSW5wdXQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgZWRpdG9yU3RhdGUgPSBlZGl0b3IuX2xhdGVzdEVkaXRvclN0YXRlO1xuXG4gIHZhciBjaGFycyA9IGUuZGF0YTtcblxuICAvLyBJbiBzb21lIGNhc2VzIChleDogSUUgaWRlb2dyYXBoaWMgc3BhY2UgaW5zZXJ0aW9uKSBubyBjaGFyYWN0ZXIgZGF0YVxuICAvLyBpcyBwcm92aWRlZC4gVGhlcmUncyBub3RoaW5nIHRvIGRvIHdoZW4gdGhpcyBoYXBwZW5zLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQWxsb3cgdGhlIHRvcC1sZXZlbCBjb21wb25lbnQgdG8gaGFuZGxlIHRoZSBpbnNlcnRpb24gbWFudWFsbHkuIFRoaXMgaXNcbiAgLy8gdXNlZnVsIHdoZW4gdHJpZ2dlcmluZyBpbnRlcmVzdGluZyBiZWhhdmlvcnMgZm9yIGEgY2hhcmFjdGVyIGluc2VydGlvbixcbiAgLy8gU2ltcGxlIGV4YW1wbGVzOiByZXBsYWNpbmcgYSByYXcgdGV4dCAnOiknIHdpdGggYSBzbWlsZSBlbW9qaSBvciBpbWFnZVxuICAvLyBkZWNvcmF0b3IsIG9yIHNldHRpbmcgYSBibG9jayB0byBiZSBhIGxpc3QgaXRlbSBhZnRlciB0eXBpbmcgJy0gJyBhdCB0aGVcbiAgLy8gc3RhcnQgb2YgdGhlIGJsb2NrLlxuICBpZiAoZWRpdG9yLnByb3BzLmhhbmRsZUJlZm9yZUlucHV0ICYmIGlzRXZlbnRIYW5kbGVkKGVkaXRvci5wcm9wcy5oYW5kbGVCZWZvcmVJbnB1dChjaGFycywgZWRpdG9yU3RhdGUpKSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBzZWxlY3Rpb24gaXMgY29sbGFwc2VkLCBjb25kaXRpb25hbGx5IGFsbG93IG5hdGl2ZSBiZWhhdmlvci4gVGhpc1xuICAvLyByZWR1Y2VzIHJlLXJlbmRlcnMgYW5kIHByZXNlcnZlcyBzcGVsbGNoZWNrIGhpZ2hsaWdodGluZy4gSWYgdGhlIHNlbGVjdGlvblxuICAvLyBpcyBub3QgY29sbGFwc2VkLCB3ZSB3aWxsIHJlLXJlbmRlci5cbiAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpO1xuICB2YXIgc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb24uZ2V0U3RhcnRPZmZzZXQoKTtcbiAgdmFyIHNlbGVjdGlvbkVuZCA9IHNlbGVjdGlvbi5nZXRFbmRPZmZzZXQoKTtcbiAgdmFyIGFuY2hvcktleSA9IHNlbGVjdGlvbi5nZXRBbmNob3JLZXkoKTtcblxuICBpZiAoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0IG1hdGNoZXMgd2hhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG9cbiAgICAvLyByZXBsYWNlIGl0IHdpdGgsIGxldCdzIGp1c3QgdXBkYXRlIHRoZSBgU2VsZWN0aW9uU3RhdGVgLiBJZiBub3QsIHVwZGF0ZVxuICAgIC8vIHRoZSBgQ29udGVudFN0YXRlYCB3aXRoIHRoZSBuZXcgdGV4dC5cbiAgICB2YXIgY3VycmVudGx5U2VsZWN0ZWRDaGFycyA9IGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCkuZ2V0UGxhaW5UZXh0KCkuc2xpY2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgaWYgKGNoYXJzID09PSBjdXJyZW50bHlTZWxlY3RlZENoYXJzKSB7XG4gICAgICBlZGl0b3IudXBkYXRlKEVkaXRvclN0YXRlLmZvcmNlU2VsZWN0aW9uKGVkaXRvclN0YXRlLCBzZWxlY3Rpb24ubWVyZ2Uoe1xuICAgICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uRW5kXG4gICAgICB9KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IudXBkYXRlKHJlcGxhY2VUZXh0KGVkaXRvclN0YXRlLCBjaGFycywgZWRpdG9yU3RhdGUuZ2V0Q3VycmVudElubGluZVN0eWxlKCksIGdldEVudGl0eUtleUZvclNlbGVjdGlvbihlZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpLCBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5ld0VkaXRvclN0YXRlID0gcmVwbGFjZVRleHQoZWRpdG9yU3RhdGUsIGNoYXJzLCBlZGl0b3JTdGF0ZS5nZXRDdXJyZW50SW5saW5lU3R5bGUoKSwgZ2V0RW50aXR5S2V5Rm9yU2VsZWN0aW9uKGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCksIGVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpKSk7XG5cbiAgLy8gQnVuY2ggb2YgZGlmZmVyZW50IGNhc2VzIGZvbGxvdyB3aGVyZSB3ZSBuZWVkIHRvIHByZXZlbnQgbmF0aXZlIGluc2VydGlvbi5cbiAgdmFyIG11c3RQcmV2ZW50TmF0aXZlID0gZmFsc2U7XG4gIGlmICghbXVzdFByZXZlbnROYXRpdmUpIHtcbiAgICAvLyBCcm93c2VycyB0ZW5kIHRvIGluc2VydCB0ZXh0IGluIHdlaXJkIHBsYWNlcyBpbiB0aGUgRE9NIHdoZW4gdHlwaW5nIGF0XG4gICAgLy8gdGhlIHN0YXJ0IG9mIGEgbGVhZiwgc28gd2UnbGwgaGFuZGxlIGl0IG91cnNlbHZlcy5cbiAgICBtdXN0UHJldmVudE5hdGl2ZSA9IGlzU2VsZWN0aW9uQXRMZWFmU3RhcnQoZWRpdG9yLl9sYXRlc3RDb21taXR0ZWRFZGl0b3JTdGF0ZSk7XG4gIH1cbiAgaWYgKCFtdXN0UHJldmVudE5hdGl2ZSkge1xuICAgIC8vIENocm9tZSB3aWxsIGFsc28gc3BsaXQgdXAgYSBub2RlIGludG8gdHdvIHBpZWNlcyBpZiBpdCBjb250YWlucyBhIFRhYlxuICAgIC8vIGNoYXIsIGZvciBubyBleHBsaWNhYmxlIHJlYXNvbi4gU2VlbWluZ2x5IGNhdXNlZCBieSB0aGlzIGNvbW1pdDpcbiAgICAvLyBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLysvMDEzYWM1ZWFmMyU1RSUyMS9cbiAgICB2YXIgbmF0aXZlU2VsZWN0aW9uID0gZ2xvYmFsLmdldFNlbGVjdGlvbigpO1xuICAgIC8vIFNlbGVjdGlvbiBpcyBuZWNlc3NhcmlseSBjb2xsYXBzZWQgYXQgdGhpcyBwb2ludCBkdWUgdG8gZWFybGllciBjaGVjay5cbiAgICBpZiAobmF0aXZlU2VsZWN0aW9uLmFuY2hvck5vZGUgJiYgbmF0aXZlU2VsZWN0aW9uLmFuY2hvck5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAvLyBTZWUgaXNUYWJIVE1MU3BhbkVsZW1lbnQgaW4gY2hyb21pdW0gRWRpdGluZ1V0aWxpdGllcy5jcHAuXG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IG5hdGl2ZVNlbGVjdGlvbi5hbmNob3JOb2RlLnBhcmVudE5vZGU7XG4gICAgICBtdXN0UHJldmVudE5hdGl2ZSA9IHBhcmVudE5vZGUubm9kZU5hbWUgPT09ICdTUEFOJyAmJiBwYXJlbnROb2RlLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIHBhcmVudE5vZGUuZmlyc3RDaGlsZC5ub2RlVmFsdWUuaW5kZXhPZignXFx0JykgIT09IC0xO1xuICAgIH1cbiAgfVxuICBpZiAoIW11c3RQcmV2ZW50TmF0aXZlKSB7XG4gICAgLy8gQ2hlY2sgdGhlIG9sZCBhbmQgbmV3IFwiZmluZ2VycHJpbnRzXCIgb2YgdGhlIGN1cnJlbnQgYmxvY2sgdG8gZGV0ZXJtaW5lXG4gICAgLy8gd2hldGhlciB0aGlzIGluc2VydGlvbiByZXF1aXJlcyBhbnkgYWRkaXRpb24gb3IgcmVtb3ZhbCBvZiB0ZXh0IG5vZGVzLFxuICAgIC8vIGluIHdoaWNoIGNhc2Ugd2Ugd291bGQgcHJldmVudCB0aGUgbmF0aXZlIGNoYXJhY3RlciBpbnNlcnRpb24uXG4gICAgdmFyIG9yaWdpbmFsRmluZ2VycHJpbnQgPSBCbG9ja1RyZWUuZ2V0RmluZ2VycHJpbnQoZWRpdG9yU3RhdGUuZ2V0QmxvY2tUcmVlKGFuY2hvcktleSkpO1xuICAgIHZhciBuZXdGaW5nZXJwcmludCA9IEJsb2NrVHJlZS5nZXRGaW5nZXJwcmludChuZXdFZGl0b3JTdGF0ZS5nZXRCbG9ja1RyZWUoYW5jaG9yS2V5KSk7XG4gICAgbXVzdFByZXZlbnROYXRpdmUgPSBvcmlnaW5hbEZpbmdlcnByaW50ICE9PSBuZXdGaW5nZXJwcmludDtcbiAgfVxuICBpZiAoIW11c3RQcmV2ZW50TmF0aXZlKSB7XG4gICAgbXVzdFByZXZlbnROYXRpdmUgPSBtdXN0UHJldmVudERlZmF1bHRGb3JDaGFyYWN0ZXIoY2hhcnMpO1xuICB9XG4gIGlmICghbXVzdFByZXZlbnROYXRpdmUpIHtcbiAgICBtdXN0UHJldmVudE5hdGl2ZSA9IG51bGx0aHJvd3MobmV3RWRpdG9yU3RhdGUuZ2V0RGlyZWN0aW9uTWFwKCkpLmdldChhbmNob3JLZXkpICE9PSBudWxsdGhyb3dzKGVkaXRvclN0YXRlLmdldERpcmVjdGlvbk1hcCgpKS5nZXQoYW5jaG9yS2V5KTtcbiAgfVxuXG4gIGlmIChtdXN0UHJldmVudE5hdGl2ZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlZGl0b3IudXBkYXRlKG5ld0VkaXRvclN0YXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBXZSBtYWRlIGl0IGFsbCB0aGUgd2F5ISBMZXQgdGhlIGJyb3dzZXIgZG8gaXRzIHRoaW5nIGFuZCBpbnNlcnQgdGhlIGNoYXIuXG4gIG5ld0VkaXRvclN0YXRlID0gRWRpdG9yU3RhdGUuc2V0KG5ld0VkaXRvclN0YXRlLCB7XG4gICAgbmF0aXZlbHlSZW5kZXJlZENvbnRlbnQ6IG5ld0VkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KClcbiAgfSk7XG4gIC8vIFRoZSBuYXRpdmUgZXZlbnQgaXMgYWxsb3dlZCB0byBvY2N1ci4gVG8gYWxsb3cgdXNlciBvbkNoYW5nZSBoYW5kbGVycyB0b1xuICAvLyBjaGFuZ2UgdGhlIGluc2VydGVkIHRleHQsIHdlIHdhaXQgdW50aWwgdGhlIHRleHQgaXMgYWN0dWFsbHkgaW5zZXJ0ZWRcbiAgLy8gYmVmb3JlIHdlIGFjdHVhbGx5IHVwZGF0ZSBvdXIgc3RhdGUuIFRoYXQgd2F5IHdoZW4gd2UgcmVyZW5kZXIsIHRoZSB0ZXh0XG4gIC8vIHdlIHNlZSBpbiB0aGUgRE9NIHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gaW5zZXJ0ZWQgcHJvcGVybHkuXG4gIGVkaXRvci5fcGVuZGluZ1N0YXRlRnJvbUJlZm9yZUlucHV0ID0gbmV3RWRpdG9yU3RhdGU7XG4gIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVkaXRvci5fcGVuZGluZ1N0YXRlRnJvbUJlZm9yZUlucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVkaXRvci51cGRhdGUoZWRpdG9yLl9wZW5kaW5nU3RhdGVGcm9tQmVmb3JlSW5wdXQpO1xuICAgICAgZWRpdG9yLl9wZW5kaW5nU3RhdGVGcm9tQmVmb3JlSW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlZGl0T25CZWZvcmVJbnB1dDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZWRpdE9uQmVmb3JlSW5wdXQuanNcbi8vIG1vZHVsZSBpZCA9IDQzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gc2V0aW1tZWRpYXRlIGFkZHMgc2V0SW1tZWRpYXRlIHRvIHRoZSBnbG9iYWwuIFdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGV4cG9ydFxuLy8gdGhlIGFjdHVhbCBmdW5jdGlvbi5cblxucmVxdWlyZSgnc2V0aW1tZWRpYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVkaXRPbkJsdXJcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVkaXRvclN0YXRlID0gcmVxdWlyZSgnLi9FZGl0b3JTdGF0ZScpO1xuXG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcblxuZnVuY3Rpb24gZWRpdE9uQmx1cihlZGl0b3IsIGUpIHtcbiAgLy8gSW4gYSBjb250ZW50RWRpdGFibGUgZWxlbWVudCwgd2hlbiB5b3Ugc2VsZWN0IGEgcmFuZ2UgYW5kIHRoZW4gY2xpY2tcbiAgLy8gYW5vdGhlciBhY3RpdmUgZWxlbWVudCwgdGhpcyBkb2VzIHRyaWdnZXIgYSBgYmx1cmAgZXZlbnQgYnV0IHdpbGwgbm90XG4gIC8vIHJlbW92ZSB0aGUgRE9NIHNlbGVjdGlvbiBmcm9tIHRoZSBjb250ZW50ZWRpdGFibGUuXG4gIC8vIFRoaXMgaXMgY29uc2lzdGVudCBhY3Jvc3MgYWxsIGJyb3dzZXJzLCBidXQgd2UgcHJlZmVyIHRoYXQgdGhlIGVkaXRvclxuICAvLyBiZWhhdmUgbGlrZSBhIHRleHRhcmVhLCB3aGVyZSBhIGBibHVyYCBldmVudCBjbGVhcnMgdGhlIERPTSBzZWxlY3Rpb24uXG4gIC8vIFdlIHRoZXJlZm9yZSBmb3JjZSB0aGUgaXNzdWUgdG8gYmUgY2VydGFpbiwgY2hlY2tpbmcgd2hldGhlciB0aGUgYWN0aXZlXG4gIC8vIGVsZW1lbnQgaXMgYGJvZHlgIHRvIGZvcmNlIGl0IHdoZW4gYmx1cnJpbmcgb2NjdXJzIHdpdGhpbiB0aGUgd2luZG93IChhc1xuICAvLyBvcHBvc2VkIHRvIGNsaWNraW5nIHRvIGFub3RoZXIgdGFiIG9yIHdpbmRvdykuXG4gIGlmIChnZXRBY3RpdmVFbGVtZW50KCkgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICB2YXIgX3NlbGVjdGlvbiA9IGdsb2JhbC5nZXRTZWxlY3Rpb24oKTtcbiAgICB2YXIgZWRpdG9yTm9kZSA9IGVkaXRvci5lZGl0b3I7XG4gICAgaWYgKF9zZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMSAmJiBjb250YWluc05vZGUoZWRpdG9yTm9kZSwgX3NlbGVjdGlvbi5hbmNob3JOb2RlKSAmJiBjb250YWluc05vZGUoZWRpdG9yTm9kZSwgX3NlbGVjdGlvbi5mb2N1c05vZGUpKSB7XG4gICAgICBfc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlZGl0b3JTdGF0ZSA9IGVkaXRvci5fbGF0ZXN0RWRpdG9yU3RhdGU7XG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghY3VycmVudFNlbGVjdGlvbi5nZXRIYXNGb2N1cygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb24uc2V0KCdoYXNGb2N1cycsIGZhbHNlKTtcbiAgZWRpdG9yLnByb3BzLm9uQmx1ciAmJiBlZGl0b3IucHJvcHMub25CbHVyKGUpO1xuICBlZGl0b3IudXBkYXRlKEVkaXRvclN0YXRlLmFjY2VwdFNlbGVjdGlvbihlZGl0b3JTdGF0ZSwgc2VsZWN0aW9uKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZWRpdE9uQmx1cjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZWRpdE9uQmx1ci5qc1xuLy8gbW9kdWxlIGlkID0gNDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlZGl0T25Db21wb3NpdGlvblN0YXJ0XG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFZGl0b3JTdGF0ZSA9IHJlcXVpcmUoJy4vRWRpdG9yU3RhdGUnKTtcblxuLyoqXG4gKiBUaGUgdXNlciBoYXMgYmVndW4gdXNpbmcgYW4gSU1FIGlucHV0IHN5c3RlbS4gU3dpdGNoaW5nIHRvIGBjb21wb3NpdGVgIG1vZGVcbiAqIGFsbG93cyBoYW5kbGluZyBjb21wb3NpdGlvbiBpbnB1dCBhbmQgZGlzYWJsZXMgb3RoZXIgZWRpdCBiZWhhdmlvci5cbiAqL1xuZnVuY3Rpb24gZWRpdE9uQ29tcG9zaXRpb25TdGFydChlZGl0b3IsIGUpIHtcbiAgZWRpdG9yLnNldE1vZGUoJ2NvbXBvc2l0ZScpO1xuICBlZGl0b3IudXBkYXRlKEVkaXRvclN0YXRlLnNldChlZGl0b3IuX2xhdGVzdEVkaXRvclN0YXRlLCB7IGluQ29tcG9zaXRpb25Nb2RlOiB0cnVlIH0pKTtcbiAgLy8gQWxsb3cgY29tcG9zaXRpb24gaGFuZGxlciB0byBpbnRlcnByZXQgdGhlIGNvbXBvc2l0aW9uc3RhcnQgZXZlbnRcbiAgZWRpdG9yLl9vbkNvbXBvc2l0aW9uU3RhcnQoZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZWRpdE9uQ29tcG9zaXRpb25TdGFydDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZWRpdE9uQ29tcG9zaXRpb25TdGFydC5qc1xuLy8gbW9kdWxlIGlkID0gNDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlZGl0T25Db3B5XG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnZXRGcmFnbWVudEZyb21TZWxlY3Rpb24gPSByZXF1aXJlKCcuL2dldEZyYWdtZW50RnJvbVNlbGVjdGlvbicpO1xuXG4vKipcbiAqIElmIHdlIGhhdmUgYSBzZWxlY3Rpb24sIGNyZWF0ZSBhIENvbnRlbnRTdGF0ZSBmcmFnbWVudCBhbmQgc3RvcmVcbiAqIGl0IGluIG91ciBpbnRlcm5hbCBjbGlwYm9hcmQuIFN1YnNlcXVlbnQgcGFzdGUgZXZlbnRzIHdpbGwgdXNlIHRoaXNcbiAqIGZyYWdtZW50IGlmIG5vIGV4dGVybmFsIGNsaXBib2FyZCBkYXRhIGlzIHN1cHBsaWVkLlxuICovXG5mdW5jdGlvbiBlZGl0T25Db3B5KGVkaXRvciwgZSkge1xuICB2YXIgZWRpdG9yU3RhdGUgPSBlZGl0b3IuX2xhdGVzdEVkaXRvclN0YXRlO1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgLy8gTm8gc2VsZWN0aW9uLCBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gY29weS5cbiAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVkaXRvci5zZXRDbGlwYm9hcmQoZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uKGVkaXRvci5fbGF0ZXN0RWRpdG9yU3RhdGUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlZGl0T25Db3B5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9lZGl0T25Db3B5LmpzXG4vLyBtb2R1bGUgaWQgPSA0MzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVkaXRPbkN1dFxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRHJhZnRNb2RpZmllciA9IHJlcXVpcmUoJy4vRHJhZnRNb2RpZmllcicpO1xudmFyIEVkaXRvclN0YXRlID0gcmVxdWlyZSgnLi9FZGl0b3JTdGF0ZScpO1xudmFyIFN0eWxlID0gcmVxdWlyZSgnZmJqcy9saWIvU3R5bGUnKTtcblxudmFyIGdldEZyYWdtZW50RnJvbVNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uJyk7XG52YXIgZ2V0U2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRTY3JvbGxQb3NpdGlvbicpO1xuXG4vKipcbiAqIE9uIGBjdXRgIGV2ZW50cywgbmF0aXZlIGJlaGF2aW9yIGlzIGFsbG93ZWQgdG8gb2NjdXIgc28gdGhhdCB0aGUgc3lzdGVtXG4gKiBjbGlwYm9hcmQgaXMgc2V0IHByb3Blcmx5LiBUaGlzIG1lYW5zIHRoYXQgd2UgbmVlZCB0byB0YWtlIHN0ZXBzIHRvIHJlY292ZXJcbiAqIHRoZSBlZGl0b3IgRE9NIHN0YXRlIGFmdGVyIHRoZSBgY3V0YCBoYXMgb2NjdXJyZWQgaW4gb3JkZXIgdG8gbWFpbnRhaW5cbiAqIGNvbnRyb2wgb2YgdGhlIGNvbXBvbmVudC5cbiAqXG4gKiBJbiBhZGRpdGlvbiwgd2UgY2FuIGtlZXAgYSBjb3B5IG9mIHRoZSByZW1vdmVkIGZyYWdtZW50LCBpbmNsdWRpbmcgYWxsXG4gKiBzdHlsZXMgYW5kIGVudGl0aWVzLCBmb3IgdXNlIGFzIGFuIGludGVybmFsIHBhc3RlLlxuICovXG5mdW5jdGlvbiBlZGl0T25DdXQoZWRpdG9yLCBlKSB7XG4gIHZhciBlZGl0b3JTdGF0ZSA9IGVkaXRvci5fbGF0ZXN0RWRpdG9yU3RhdGU7XG4gIHZhciBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGVsZW1lbnQgPSBlLnRhcmdldDtcbiAgdmFyIHNjcm9sbFBvc2l0aW9uID0gdm9pZCAwO1xuXG4gIC8vIE5vIHNlbGVjdGlvbiwgc28gdGhlcmUncyBub3RoaW5nIHRvIGN1dC5cbiAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRyYWNrIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBzbyB0aGF0IGl0IGNhbiBiZSBmb3JjZWQgYmFjayBpbiBwbGFjZVxuICAvLyBhZnRlciB0aGUgZWRpdG9yIHJlZ2FpbnMgY29udHJvbCBvZiB0aGUgRE9NLlxuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICBzY3JvbGxQb3NpdGlvbiA9IGdldFNjcm9sbFBvc2l0aW9uKFN0eWxlLmdldFNjcm9sbFBhcmVudChlbGVtZW50KSk7XG4gIH1cblxuICB2YXIgZnJhZ21lbnQgPSBnZXRGcmFnbWVudEZyb21TZWxlY3Rpb24oZWRpdG9yU3RhdGUpO1xuICBlZGl0b3Iuc2V0Q2xpcGJvYXJkKGZyYWdtZW50KTtcblxuICAvLyBTZXQgYGN1dGAgbW9kZSB0byBkaXNhYmxlIGFsbCBldmVudCBoYW5kbGluZyB0ZW1wb3JhcmlseS5cbiAgZWRpdG9yLnNldE1vZGUoJ2N1dCcpO1xuXG4gIC8vIExldCBuYXRpdmUgYGN1dGAgYmVoYXZpb3Igb2NjdXIsIHRoZW4gcmVjb3ZlciBjb250cm9sLlxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBlZGl0b3IucmVzdG9yZUVkaXRvckRPTShzY3JvbGxQb3NpdGlvbik7XG4gICAgZWRpdG9yLmV4aXRDdXJyZW50TW9kZSgpO1xuICAgIGVkaXRvci51cGRhdGUocmVtb3ZlRnJhZ21lbnQoZWRpdG9yU3RhdGUpKTtcbiAgfSwgMCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZyYWdtZW50KGVkaXRvclN0YXRlKSB7XG4gIHZhciBuZXdDb250ZW50ID0gRHJhZnRNb2RpZmllci5yZW1vdmVSYW5nZShlZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpLCBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKSwgJ2ZvcndhcmQnKTtcbiAgcmV0dXJuIEVkaXRvclN0YXRlLnB1c2goZWRpdG9yU3RhdGUsIG5ld0NvbnRlbnQsICdyZW1vdmUtcmFuZ2UnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlZGl0T25DdXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2VkaXRPbkN1dC5qc1xuLy8gbW9kdWxlIGlkID0gNDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlZGl0T25EcmFnT3ZlclxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERyYWcgYmVoYXZpb3IgaGFzIGJlZ3VuIGZyb20gb3V0c2lkZSB0aGUgZWRpdG9yIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGVkaXRPbkRyYWdPdmVyKGVkaXRvciwgZSkge1xuICBlZGl0b3IuX2ludGVybmFsRHJhZyA9IGZhbHNlO1xuICBlZGl0b3Iuc2V0TW9kZSgnZHJhZycpO1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZWRpdE9uRHJhZ092ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2VkaXRPbkRyYWdPdmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0Mzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVkaXRPbkRyYWdTdGFydFxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYGRyYWdzdGFydGAgZXZlbnQgaGFzIGJlZ3VuIHdpdGhpbiB0aGUgdGV4dCBlZGl0b3IgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBlZGl0T25EcmFnU3RhcnQoZWRpdG9yKSB7XG4gIGVkaXRvci5faW50ZXJuYWxEcmFnID0gdHJ1ZTtcbiAgZWRpdG9yLnNldE1vZGUoJ2RyYWcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlZGl0T25EcmFnU3RhcnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2VkaXRPbkRyYWdTdGFydC5qc1xuLy8gbW9kdWxlIGlkID0gNDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlZGl0T25Gb2N1c1xuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRWRpdG9yU3RhdGUgPSByZXF1aXJlKCcuL0VkaXRvclN0YXRlJyk7XG52YXIgVXNlckFnZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvVXNlckFnZW50Jyk7XG5cbmZ1bmN0aW9uIGVkaXRPbkZvY3VzKGVkaXRvciwgZSkge1xuICB2YXIgZWRpdG9yU3RhdGUgPSBlZGl0b3IuX2xhdGVzdEVkaXRvclN0YXRlO1xuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpO1xuICBpZiAoY3VycmVudFNlbGVjdGlvbi5nZXRIYXNGb2N1cygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb24uc2V0KCdoYXNGb2N1cycsIHRydWUpO1xuICBlZGl0b3IucHJvcHMub25Gb2N1cyAmJiBlZGl0b3IucHJvcHMub25Gb2N1cyhlKTtcblxuICAvLyBXaGVuIHRoZSB0YWIgY29udGFpbmluZyB0aGlzIHRleHQgZWRpdG9yIGlzIGhpZGRlbiBhbmQgdGhlIHVzZXIgZG9lcyBhXG4gIC8vIGZpbmQtaW4tcGFnZSBpbiBhIF9kaWZmZXJlbnRfIHRhYiwgQ2hyb21lIG9uIE1hYyBsaWtlcyB0byBmb3JnZXQgd2hhdCB0aGVcbiAgLy8gc2VsZWN0aW9uIHdhcyByaWdodCBhZnRlciBzZW5kaW5nIHRoaXMgZm9jdXMgZXZlbnQgYW5kIChpZiB5b3UgbGV0IGl0KVxuICAvLyBtb3ZlcyB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZWRpdG9yLCBzbyB3ZSBmb3JjZSB0aGVcbiAgLy8gc2VsZWN0aW9uIGhlcmUgaW5zdGVhZCBvZiBzaW1wbHkgYWNjZXB0aW5nIGl0IGluIG9yZGVyIHRvIHByZXNlcnZlIHRoZVxuICAvLyBvbGQgY3Vyc29yIHBvc2l0aW9uLiBTZWUgaHR0cHM6Ly9jcmJ1Zy5jb20vNTQwMDA0LlxuICAvLyBCdXQgaXQgbG9va3MgbGlrZSB0aGlzIGlzIGZpeGVkIGluIENocm9tZSA2MC4wLjMwODEuMC5cbiAgLy8gT3RoZXIgYnJvd3NlcnMgYWxzbyBkb24ndCBoYXZlIHRoaXMgYnVnLCBzbyB3ZSBwcmVmZXIgdG8gYWNjZXB0U2VsZWN0aW9uXG4gIC8vIHdoZW4gcG9zc2libGUsIHRvIGVuc3VyZSB0aGF0IHVuZm9jdXNpbmcgYW5kIHJlZm9jdXNpbmcgYSBEcmFmdCBlZGl0b3JcbiAgLy8gZG9lc24ndCBwcmVzZXJ2ZSB0aGUgc2VsZWN0aW9uLCBtYXRjaGluZyBob3cgdGV4dGFyZWFzIHdvcmsuXG4gIGlmIChVc2VyQWdlbnQuaXNCcm93c2VyKCdDaHJvbWUgPCA2MC4wLjMwODEuMCcpKSB7XG4gICAgZWRpdG9yLnVwZGF0ZShFZGl0b3JTdGF0ZS5mb3JjZVNlbGVjdGlvbihlZGl0b3JTdGF0ZSwgc2VsZWN0aW9uKSk7XG4gIH0gZWxzZSB7XG4gICAgZWRpdG9yLnVwZGF0ZShFZGl0b3JTdGF0ZS5hY2NlcHRTZWxlY3Rpb24oZWRpdG9yU3RhdGUsIHNlbGVjdGlvbikpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZWRpdE9uRm9jdXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2VkaXRPbkZvY3VzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVkaXRPbklucHV0XG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEcmFmdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vRHJhZnRGZWF0dXJlRmxhZ3MnKTtcbnZhciBEcmFmdE1vZGlmaWVyID0gcmVxdWlyZSgnLi9EcmFmdE1vZGlmaWVyJyk7XG52YXIgRHJhZnRPZmZzZXRLZXkgPSByZXF1aXJlKCcuL0RyYWZ0T2Zmc2V0S2V5Jyk7XG52YXIgRWRpdG9yU3RhdGUgPSByZXF1aXJlKCcuL0VkaXRvclN0YXRlJyk7XG52YXIgVXNlckFnZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvVXNlckFnZW50Jyk7XG5cbnZhciBmaW5kQW5jZXN0b3JPZmZzZXRLZXkgPSByZXF1aXJlKCcuL2ZpbmRBbmNlc3Rvck9mZnNldEtleScpO1xudmFyIG51bGx0aHJvd3MgPSByZXF1aXJlKCdmYmpzL2xpYi9udWxsdGhyb3dzJyk7XG5cbnZhciBpc0dlY2tvID0gVXNlckFnZW50LmlzRW5naW5lKCdHZWNrbycpO1xuXG52YXIgRE9VQkxFX05FV0xJTkUgPSAnXFxuXFxuJztcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIHRvIGhhbmRsZSBzcGVsbGNoZWNrIGFuZCBhdXRvY29ycmVjdCBjaGFuZ2VzLFxuICogd2hpY2ggb2NjdXIgaW4gdGhlIERPTSBuYXRpdmVseSB3aXRob3V0IGFueSBvcHBvcnR1bml0eSB0byBvYnNlcnZlIG9yXG4gKiBpbnRlcnByZXQgdGhlIGNoYW5nZXMgYmVmb3JlIHRoZXkgb2NjdXIuXG4gKlxuICogVGhlIGBpbnB1dGAgZXZlbnQgZmlyZXMgaW4gY29udGVudEVkaXRhYmxlIGVsZW1lbnRzIHJlbGlhYmx5IGZvciBub24tSUVcbiAqIGJyb3dzZXJzLCBpbW1lZGlhdGVseSBhZnRlciBjaGFuZ2VzIG9jY3VyIHRvIHRoZSBlZGl0b3IgRE9NLiBTaW5jZSBvdXIgb3RoZXJcbiAqIGhhbmRsZXJzIG92ZXJyaWRlIG9yIG90aGVyd2lzZSBoYW5kbGUgY292ZXIgb3RoZXIgdmFyaWV0aWVzIG9mIHRleHQgaW5wdXQsXG4gKiB0aGUgRE9NIHN0YXRlIHNob3VsZCBtYXRjaCB0aGUgbW9kZWwgaW4gYWxsIGNvbnRyb2xsZWQgaW5wdXQgY2FzZXMuIFRodXMsXG4gKiB3aGVuIGFuIGBpbnB1dGAgY2hhbmdlIGxlYWRzIHRvIGEgRE9NL21vZGVsIG1pc21hdGNoLCB0aGUgY2hhbmdlIHNob3VsZCBiZVxuICogZHVlIHRvIGEgc3BlbGxjaGVjayBjaGFuZ2UsIGFuZCB3ZSBjYW4gaW5jb3Jwb3JhdGUgaXQgaW50byBvdXIgbW9kZWwuXG4gKi9cbmZ1bmN0aW9uIGVkaXRPbklucHV0KGVkaXRvcikge1xuICBpZiAoZWRpdG9yLl9wZW5kaW5nU3RhdGVGcm9tQmVmb3JlSW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGVkaXRvci51cGRhdGUoZWRpdG9yLl9wZW5kaW5nU3RhdGVGcm9tQmVmb3JlSW5wdXQpO1xuICAgIGVkaXRvci5fcGVuZGluZ1N0YXRlRnJvbUJlZm9yZUlucHV0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGRvbVNlbGVjdGlvbiA9IGdsb2JhbC5nZXRTZWxlY3Rpb24oKTtcblxuICB2YXIgYW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgaXNDb2xsYXBzZWQgPSBkb21TZWxlY3Rpb24uaXNDb2xsYXBzZWQ7XG5cbiAgdmFyIGlzTm90VGV4dE5vZGUgPSBhbmNob3JOb2RlLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERTtcbiAgdmFyIGlzTm90VGV4dE9yRWxlbWVudE5vZGUgPSBhbmNob3JOb2RlLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSAmJiBhbmNob3JOb2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERTtcblxuICBpZiAoRHJhZnRGZWF0dXJlRmxhZ3MuZHJhZnRfa2lsbHN3aXRjaF9hbGxvd19ub250ZXh0bm9kZXMpIHtcbiAgICBpZiAoaXNOb3RUZXh0Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNOb3RUZXh0T3JFbGVtZW50Tm9kZSkge1xuICAgICAgLy8gVE9ETzogKHQxNjE0OTI3MikgZmlndXJlIG91dCBjb250ZXh0IGZvciB0aGlzIGNoYW5nZVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhbmNob3JOb2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiAoYW5jaG9yTm9kZS5wcmV2aW91c1NpYmxpbmcgIT09IG51bGwgfHwgYW5jaG9yTm9kZS5uZXh0U2libGluZyAhPT0gbnVsbCkpIHtcbiAgICAvLyBXaGVuIHR5cGluZyBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgdmlzdWFsIGxpbmUsIENocm9tZSBzcGxpdHMgdGhlIHRleHRcbiAgICAvLyBub2RlcyBpbnRvIHR3by4gV2h5PyBObyBvbmUga25vd3MuIFRoaXMgY29tbWl0IGlzIHN1c3BpY2lvdXM6XG4gICAgLy8gaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy8rL2EzYjYwMDk4MTI4NmIxMzU2MzIzNzE0NzdmOTAyMjE0YzU1YTE3MjRcbiAgICAvLyBUbyB3b3JrIGFyb3VuZCwgd2UnbGwgbWVyZ2UgdGhlIHNpYmxpbmcgdGV4dCBub2RlcyBiYWNrIGludG8gdGhpcyBvbmUuXG4gICAgdmFyIHNwYW4gPSBhbmNob3JOb2RlLnBhcmVudE5vZGU7XG4gICAgYW5jaG9yTm9kZS5ub2RlVmFsdWUgPSBzcGFuLnRleHRDb250ZW50O1xuICAgIGZvciAodmFyIGNoaWxkID0gc3Bhbi5maXJzdENoaWxkOyBjaGlsZCAhPT0gbnVsbDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgaWYgKGNoaWxkICE9PSBhbmNob3JOb2RlKSB7XG4gICAgICAgIHNwYW4ucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkb21UZXh0ID0gYW5jaG9yTm9kZS50ZXh0Q29udGVudDtcbiAgdmFyIGVkaXRvclN0YXRlID0gZWRpdG9yLl9sYXRlc3RFZGl0b3JTdGF0ZTtcbiAgdmFyIG9mZnNldEtleSA9IG51bGx0aHJvd3MoZmluZEFuY2VzdG9yT2Zmc2V0S2V5KGFuY2hvck5vZGUpKTtcblxuICB2YXIgX0RyYWZ0T2Zmc2V0S2V5JGRlY29kID0gRHJhZnRPZmZzZXRLZXkuZGVjb2RlKG9mZnNldEtleSksXG4gICAgICBibG9ja0tleSA9IF9EcmFmdE9mZnNldEtleSRkZWNvZC5ibG9ja0tleSxcbiAgICAgIGRlY29yYXRvcktleSA9IF9EcmFmdE9mZnNldEtleSRkZWNvZC5kZWNvcmF0b3JLZXksXG4gICAgICBsZWFmS2V5ID0gX0RyYWZ0T2Zmc2V0S2V5JGRlY29kLmxlYWZLZXk7XG5cbiAgdmFyIF9lZGl0b3JTdGF0ZSRnZXRCbG9jayA9IGVkaXRvclN0YXRlLmdldEJsb2NrVHJlZShibG9ja0tleSkuZ2V0SW4oW2RlY29yYXRvcktleSwgJ2xlYXZlcycsIGxlYWZLZXldKSxcbiAgICAgIHN0YXJ0ID0gX2VkaXRvclN0YXRlJGdldEJsb2NrLnN0YXJ0LFxuICAgICAgZW5kID0gX2VkaXRvclN0YXRlJGdldEJsb2NrLmVuZDtcblxuICB2YXIgY29udGVudCA9IGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG4gIHZhciBibG9jayA9IGNvbnRlbnQuZ2V0QmxvY2tGb3JLZXkoYmxvY2tLZXkpO1xuICB2YXIgbW9kZWxUZXh0ID0gYmxvY2suZ2V0VGV4dCgpLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIC8vIFNwZWNpYWwtY2FzZSBzb2Z0IG5ld2xpbmVzIGhlcmUuIElmIHRoZSBET00gdGV4dCBlbmRzIGluIGEgc29mdCBuZXdsaW5lLFxuICAvLyB3ZSB3aWxsIGhhdmUgbWFudWFsbHkgaW5zZXJ0ZWQgYW4gZXh0cmEgc29mdCBuZXdsaW5lIGluIERyYWZ0RWRpdG9yTGVhZi5cbiAgLy8gV2Ugd2FudCB0byByZW1vdmUgdGhpcyBleHRyYSBuZXdsaW5lIGZvciB0aGUgcHVycG9zZSBvZiBvdXIgY29tcGFyaXNvblxuICAvLyBvZiBET00gYW5kIG1vZGVsIHRleHQuXG4gIGlmIChkb21UZXh0LmVuZHNXaXRoKERPVUJMRV9ORVdMSU5FKSkge1xuICAgIGRvbVRleHQgPSBkb21UZXh0LnNsaWNlKDAsIC0xKTtcbiAgfVxuXG4gIC8vIE5vIGNoYW5nZSAtLSB0aGUgRE9NIGlzIHVwIHRvIGRhdGUuIE5vdGhpbmcgdG8gZG8gaGVyZS5cbiAgaWYgKGRvbVRleHQgPT09IG1vZGVsVGV4dCkge1xuICAgIC8vIFRoaXMgY2FuIGJlIGJ1Z2d5IGZvciBzb21lIEFuZHJvaWQga2V5Ym9hcmRzIGJlY2F1c2UgdGhleSBkb24ndCBmaXJlXG4gICAgLy8gc3RhbmRhcmQgb25rZXlkb3duL3ByZXNzZWQgZXZlbnRzIGFuZCBvbmx5IGZpcmVkIGVkaXRPbklucHV0XG4gICAgLy8gc28gZG9tVGV4dCBpcyBhbHJlYWR5IGNoYW5nZWQgYnkgdGhlIGJyb3dzZXIgYW5kIGVuZHMgdXAgYmVpbmcgZXF1YWxcbiAgICAvLyB0byBtb2RlbFRleHQgdW5leHBlY3RlZGx5XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpO1xuXG4gIC8vIFdlJ2xsIHJlcGxhY2UgdGhlIGVudGlyZSBsZWFmIHdpdGggdGhlIHRleHQgY29udGVudCBvZiB0aGUgdGFyZ2V0LlxuICB2YXIgdGFyZ2V0UmFuZ2UgPSBzZWxlY3Rpb24ubWVyZ2Uoe1xuICAgIGFuY2hvck9mZnNldDogc3RhcnQsXG4gICAgZm9jdXNPZmZzZXQ6IGVuZCxcbiAgICBpc0JhY2t3YXJkOiBmYWxzZVxuICB9KTtcblxuICB2YXIgZW50aXR5S2V5ID0gYmxvY2suZ2V0RW50aXR5QXQoc3RhcnQpO1xuICB2YXIgZW50aXR5ID0gZW50aXR5S2V5ICYmIGNvbnRlbnQuZ2V0RW50aXR5KGVudGl0eUtleSk7XG4gIHZhciBlbnRpdHlUeXBlID0gZW50aXR5ICYmIGVudGl0eS5nZXRNdXRhYmlsaXR5KCk7XG4gIHZhciBwcmVzZXJ2ZUVudGl0eSA9IGVudGl0eVR5cGUgPT09ICdNVVRBQkxFJztcblxuICAvLyBJbW11dGFibGUgb3Igc2VnbWVudGVkIGVudGl0aWVzIGNhbm5vdCBwcm9wZXJseSBiZSBoYW5kbGVkIGJ5IHRoZVxuICAvLyBkZWZhdWx0IGJyb3dzZXIgdW5kbywgc28gd2UgaGF2ZSB0byB1c2UgYSBkaWZmZXJlbnQgY2hhbmdlIHR5cGUgdG9cbiAgLy8gZm9yY2UgdXNpbmcgb3VyIGludGVybmFsIHVuZG8gbWV0aG9kIGluc3RlYWQgb2YgZmFsbGluZyB0aHJvdWdoIHRvIHRoZVxuICAvLyBuYXRpdmUgYnJvd3NlciB1bmRvLlxuICB2YXIgY2hhbmdlVHlwZSA9IHByZXNlcnZlRW50aXR5ID8gJ3NwZWxsY2hlY2stY2hhbmdlJyA6ICdhcHBseS1lbnRpdHknO1xuXG4gIHZhciBuZXdDb250ZW50ID0gRHJhZnRNb2RpZmllci5yZXBsYWNlVGV4dChjb250ZW50LCB0YXJnZXRSYW5nZSwgZG9tVGV4dCwgYmxvY2suZ2V0SW5saW5lU3R5bGVBdChzdGFydCksIHByZXNlcnZlRW50aXR5ID8gYmxvY2suZ2V0RW50aXR5QXQoc3RhcnQpIDogbnVsbCk7XG5cbiAgdmFyIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQ7XG5cbiAgaWYgKGlzR2Vja28pIHtcbiAgICAvLyBGaXJlZm94IHNlbGVjdGlvbiBkb2VzIG5vdCBjaGFuZ2Ugd2hpbGUgdGhlIGNvbnRleHQgbWVudSBpcyBvcGVuLCBzb1xuICAgIC8vIHdlIHByZXNlcnZlIHRoZSBhbmNob3IgYW5kIGZvY3VzIHZhbHVlcyBvZiB0aGUgRE9NIHNlbGVjdGlvbi5cbiAgICBhbmNob3JPZmZzZXQgPSBkb21TZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICAgIGZvY3VzT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuICAgIHN0YXJ0T2Zmc2V0ID0gc3RhcnQgKyBNYXRoLm1pbihhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0KTtcbiAgICBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIE1hdGguYWJzKGFuY2hvck9mZnNldCAtIGZvY3VzT2Zmc2V0KTtcbiAgICBhbmNob3JPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICBmb2N1c09mZnNldCA9IGVuZE9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VycyBvdGhlciB0aGFuIEZpcmVmb3ggbWF5IGFkanVzdCBET00gc2VsZWN0aW9uIHdoaWxlIHRoZSBjb250ZXh0XG4gICAgLy8gbWVudSBpcyBvcGVuLCBhbmQgU2FmYXJpIGF1dG9jb3JyZWN0IGlzIHByb25lIHRvIHByb3ZpZGluZyBhbiBpbmFjY3VyYXRlXG4gICAgLy8gRE9NIHNlbGVjdGlvbi4gRG9uJ3QgdHJ1c3QgaXQuIEluc3RlYWQsIHVzZSBvdXIgZXhpc3RpbmcgU2VsZWN0aW9uU3RhdGVcbiAgICAvLyBhbmQgYWRqdXN0IGl0IGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjaGFuZ2VkIGR1cmluZyB0aGVcbiAgICAvLyBtdXRhdGlvbi5cbiAgICB2YXIgY2hhckRlbHRhID0gZG9tVGV4dC5sZW5ndGggLSBtb2RlbFRleHQubGVuZ3RoO1xuICAgIHN0YXJ0T2Zmc2V0ID0gc2VsZWN0aW9uLmdldFN0YXJ0T2Zmc2V0KCk7XG4gICAgZW5kT2Zmc2V0ID0gc2VsZWN0aW9uLmdldEVuZE9mZnNldCgpO1xuXG4gICAgYW5jaG9yT2Zmc2V0ID0gaXNDb2xsYXBzZWQgPyBlbmRPZmZzZXQgKyBjaGFyRGVsdGEgOiBzdGFydE9mZnNldDtcbiAgICBmb2N1c09mZnNldCA9IGVuZE9mZnNldCArIGNoYXJEZWx0YTtcbiAgfVxuXG4gIC8vIFNlZ21lbnRlZCBlbnRpdGllcyBhcmUgY29tcGxldGVseSBvciBwYXJ0aWFsbHkgcmVtb3ZlZCB3aGVuIHRoZWlyXG4gIC8vIHRleHQgY29udGVudCBjaGFuZ2VzLiBGb3IgdGhpcyBjYXNlIHdlIGRvIG5vdCB3YW50IGFueSB0ZXh0IHRvIGJlIHNlbGVjdGVkXG4gIC8vIGFmdGVyIHRoZSBjaGFuZ2UsIHNvIHdlIGFyZSBub3QgbWVyZ2luZyB0aGUgc2VsZWN0aW9uLlxuICB2YXIgY29udGVudFdpdGhBZGp1c3RlZERPTVNlbGVjdGlvbiA9IG5ld0NvbnRlbnQubWVyZ2Uoe1xuICAgIHNlbGVjdGlvbkJlZm9yZTogY29udGVudC5nZXRTZWxlY3Rpb25BZnRlcigpLFxuICAgIHNlbGVjdGlvbkFmdGVyOiBzZWxlY3Rpb24ubWVyZ2UoeyBhbmNob3JPZmZzZXQ6IGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQ6IGZvY3VzT2Zmc2V0IH0pXG4gIH0pO1xuXG4gIGVkaXRvci51cGRhdGUoRWRpdG9yU3RhdGUucHVzaChlZGl0b3JTdGF0ZSwgY29udGVudFdpdGhBZGp1c3RlZERPTVNlbGVjdGlvbiwgY2hhbmdlVHlwZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVkaXRPbklucHV0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9lZGl0T25JbnB1dC5qc1xuLy8gbW9kdWxlIGlkID0gNDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlZGl0T25LZXlEb3duXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEcmFmdE1vZGlmaWVyID0gcmVxdWlyZSgnLi9EcmFmdE1vZGlmaWVyJyk7XG52YXIgRWRpdG9yU3RhdGUgPSByZXF1aXJlKCcuL0VkaXRvclN0YXRlJyk7XG52YXIgS2V5QmluZGluZ1V0aWwgPSByZXF1aXJlKCcuL0tleUJpbmRpbmdVdGlsJyk7XG52YXIgS2V5cyA9IHJlcXVpcmUoJ2ZianMvbGliL0tleXMnKTtcbnZhciBTZWNvbmRhcnlDbGlwYm9hcmQgPSByZXF1aXJlKCcuL1NlY29uZGFyeUNsaXBib2FyZCcpO1xudmFyIFVzZXJBZ2VudCA9IHJlcXVpcmUoJ2ZianMvbGliL1VzZXJBZ2VudCcpO1xuXG52YXIgaXNFdmVudEhhbmRsZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRIYW5kbGVkJyk7XG52YXIga2V5Q29tbWFuZEJhY2tzcGFjZVRvU3RhcnRPZkxpbmUgPSByZXF1aXJlKCcuL2tleUNvbW1hbmRCYWNrc3BhY2VUb1N0YXJ0T2ZMaW5lJyk7XG52YXIga2V5Q29tbWFuZEJhY2tzcGFjZVdvcmQgPSByZXF1aXJlKCcuL2tleUNvbW1hbmRCYWNrc3BhY2VXb3JkJyk7XG52YXIga2V5Q29tbWFuZERlbGV0ZVdvcmQgPSByZXF1aXJlKCcuL2tleUNvbW1hbmREZWxldGVXb3JkJyk7XG52YXIga2V5Q29tbWFuZEluc2VydE5ld2xpbmUgPSByZXF1aXJlKCcuL2tleUNvbW1hbmRJbnNlcnROZXdsaW5lJyk7XG52YXIga2V5Q29tbWFuZE1vdmVTZWxlY3Rpb25Ub0VuZE9mQmxvY2sgPSByZXF1aXJlKCcuL2tleUNvbW1hbmRNb3ZlU2VsZWN0aW9uVG9FbmRPZkJsb2NrJyk7XG52YXIga2V5Q29tbWFuZE1vdmVTZWxlY3Rpb25Ub1N0YXJ0T2ZCbG9jayA9IHJlcXVpcmUoJy4va2V5Q29tbWFuZE1vdmVTZWxlY3Rpb25Ub1N0YXJ0T2ZCbG9jaycpO1xudmFyIGtleUNvbW1hbmRQbGFpbkJhY2tzcGFjZSA9IHJlcXVpcmUoJy4va2V5Q29tbWFuZFBsYWluQmFja3NwYWNlJyk7XG52YXIga2V5Q29tbWFuZFBsYWluRGVsZXRlID0gcmVxdWlyZSgnLi9rZXlDb21tYW5kUGxhaW5EZWxldGUnKTtcbnZhciBrZXlDb21tYW5kVHJhbnNwb3NlQ2hhcmFjdGVycyA9IHJlcXVpcmUoJy4va2V5Q29tbWFuZFRyYW5zcG9zZUNoYXJhY3RlcnMnKTtcbnZhciBrZXlDb21tYW5kVW5kbyA9IHJlcXVpcmUoJy4va2V5Q29tbWFuZFVuZG8nKTtcblxudmFyIGlzT3B0aW9uS2V5Q29tbWFuZCA9IEtleUJpbmRpbmdVdGlsLmlzT3B0aW9uS2V5Q29tbWFuZDtcblxudmFyIGlzQ2hyb21lID0gVXNlckFnZW50LmlzQnJvd3NlcignQ2hyb21lJyk7XG5cbi8qKlxuICogTWFwIGEgYERyYWZ0RWRpdG9yQ29tbWFuZGAgY29tbWFuZCB2YWx1ZSB0byBhIGNvcnJlc3BvbmRpbmcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG9uS2V5Q29tbWFuZChjb21tYW5kLCBlZGl0b3JTdGF0ZSkge1xuICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICBjYXNlICdyZWRvJzpcbiAgICAgIHJldHVybiBFZGl0b3JTdGF0ZS5yZWRvKGVkaXRvclN0YXRlKTtcbiAgICBjYXNlICdkZWxldGUnOlxuICAgICAgcmV0dXJuIGtleUNvbW1hbmRQbGFpbkRlbGV0ZShlZGl0b3JTdGF0ZSk7XG4gICAgY2FzZSAnZGVsZXRlLXdvcmQnOlxuICAgICAgcmV0dXJuIGtleUNvbW1hbmREZWxldGVXb3JkKGVkaXRvclN0YXRlKTtcbiAgICBjYXNlICdiYWNrc3BhY2UnOlxuICAgICAgcmV0dXJuIGtleUNvbW1hbmRQbGFpbkJhY2tzcGFjZShlZGl0b3JTdGF0ZSk7XG4gICAgY2FzZSAnYmFja3NwYWNlLXdvcmQnOlxuICAgICAgcmV0dXJuIGtleUNvbW1hbmRCYWNrc3BhY2VXb3JkKGVkaXRvclN0YXRlKTtcbiAgICBjYXNlICdiYWNrc3BhY2UtdG8tc3RhcnQtb2YtbGluZSc6XG4gICAgICByZXR1cm4ga2V5Q29tbWFuZEJhY2tzcGFjZVRvU3RhcnRPZkxpbmUoZWRpdG9yU3RhdGUpO1xuICAgIGNhc2UgJ3NwbGl0LWJsb2NrJzpcbiAgICAgIHJldHVybiBrZXlDb21tYW5kSW5zZXJ0TmV3bGluZShlZGl0b3JTdGF0ZSk7XG4gICAgY2FzZSAndHJhbnNwb3NlLWNoYXJhY3RlcnMnOlxuICAgICAgcmV0dXJuIGtleUNvbW1hbmRUcmFuc3Bvc2VDaGFyYWN0ZXJzKGVkaXRvclN0YXRlKTtcbiAgICBjYXNlICdtb3ZlLXNlbGVjdGlvbi10by1zdGFydC1vZi1ibG9jayc6XG4gICAgICByZXR1cm4ga2V5Q29tbWFuZE1vdmVTZWxlY3Rpb25Ub1N0YXJ0T2ZCbG9jayhlZGl0b3JTdGF0ZSk7XG4gICAgY2FzZSAnbW92ZS1zZWxlY3Rpb24tdG8tZW5kLW9mLWJsb2NrJzpcbiAgICAgIHJldHVybiBrZXlDb21tYW5kTW92ZVNlbGVjdGlvblRvRW5kT2ZCbG9jayhlZGl0b3JTdGF0ZSk7XG4gICAgY2FzZSAnc2Vjb25kYXJ5LWN1dCc6XG4gICAgICByZXR1cm4gU2Vjb25kYXJ5Q2xpcGJvYXJkLmN1dChlZGl0b3JTdGF0ZSk7XG4gICAgY2FzZSAnc2Vjb25kYXJ5LXBhc3RlJzpcbiAgICAgIHJldHVybiBTZWNvbmRhcnlDbGlwYm9hcmQucGFzdGUoZWRpdG9yU3RhdGUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcmNlcHQga2V5ZG93biBiZWhhdmlvciB0byBoYW5kbGUga2V5cyBhbmQgY29tbWFuZHMgbWFudWFsbHksIGlmIGRlc2lyZWQuXG4gKlxuICogS2V5ZG93biBjb21iaW5hdGlvbnMgbWF5IGJlIG1hcHBlZCB0byBgRHJhZnRDb21tYW5kYCB2YWx1ZXMsIHdoaWNoIG1heVxuICogY29ycmVzcG9uZCB0byBjb21tYW5kIGZ1bmN0aW9ucyB0aGF0IG1vZGlmeSB0aGUgZWRpdG9yIG9yIGl0cyBjb250ZW50cy5cbiAqXG4gKiBTZWUgYGdldERlZmF1bHRLZXlCaW5kaW5nYCBmb3IgZGVmYXVsdHMuIEFsdGVybmF0aXZlbHksIHRoZSB0b3AtbGV2ZWxcbiAqIGNvbXBvbmVudCBtYXkgcHJvdmlkZSBhIGN1c3RvbSBtYXBwaW5nIHZpYSB0aGUgYGtleUJpbmRpbmdGbmAgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZWRpdE9uS2V5RG93bihlZGl0b3IsIGUpIHtcbiAgdmFyIGtleUNvZGUgPSBlLndoaWNoO1xuICB2YXIgZWRpdG9yU3RhdGUgPSBlZGl0b3IuX2xhdGVzdEVkaXRvclN0YXRlO1xuXG4gIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgIGNhc2UgS2V5cy5SRVRVUk46XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAvLyBUaGUgdG9wLWxldmVsIGNvbXBvbmVudCBtYXkgbWFudWFsbHkgaGFuZGxlIG5ld2xpbmUgaW5zZXJ0aW9uLiBJZlxuICAgICAgLy8gbm8gc3BlY2lhbCBoYW5kbGluZyBpcyBwZXJmb3JtZWQsIGZhbGwgdGhyb3VnaCB0byBjb21tYW5kIGhhbmRsaW5nLlxuICAgICAgaWYgKGVkaXRvci5wcm9wcy5oYW5kbGVSZXR1cm4gJiYgaXNFdmVudEhhbmRsZWQoZWRpdG9yLnByb3BzLmhhbmRsZVJldHVybihlLCBlZGl0b3JTdGF0ZSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgS2V5cy5FU0M6XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlZGl0b3IucHJvcHMub25Fc2NhcGUgJiYgZWRpdG9yLnByb3BzLm9uRXNjYXBlKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgS2V5cy5UQUI6XG4gICAgICBlZGl0b3IucHJvcHMub25UYWIgJiYgZWRpdG9yLnByb3BzLm9uVGFiKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgS2V5cy5VUDpcbiAgICAgIGVkaXRvci5wcm9wcy5vblVwQXJyb3cgJiYgZWRpdG9yLnByb3BzLm9uVXBBcnJvdyhlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIEtleXMuUklHSFQ6XG4gICAgICBlZGl0b3IucHJvcHMub25SaWdodEFycm93ICYmIGVkaXRvci5wcm9wcy5vblJpZ2h0QXJyb3coZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBLZXlzLkRPV046XG4gICAgICBlZGl0b3IucHJvcHMub25Eb3duQXJyb3cgJiYgZWRpdG9yLnByb3BzLm9uRG93bkFycm93KGUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgS2V5cy5MRUZUOlxuICAgICAgZWRpdG9yLnByb3BzLm9uTGVmdEFycm93ICYmIGVkaXRvci5wcm9wcy5vbkxlZnRBcnJvdyhlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIEtleXMuU1BBQ0U6XG4gICAgICAvLyBIYW5kbGluZyBmb3IgT1NYIHdoZXJlIG9wdGlvbiArIHNwYWNlIHNjcm9sbHMuXG4gICAgICBpZiAoaXNDaHJvbWUgJiYgaXNPcHRpb25LZXlDb21tYW5kKGUpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gSW5zZXJ0IGEgbmJzcCBpbnRvIHRoZSBlZGl0b3IuXG4gICAgICAgIHZhciBjb250ZW50U3RhdGUgPSBEcmFmdE1vZGlmaWVyLnJlcGxhY2VUZXh0KGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCksIGVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpLCAnXFx4QTAnKTtcbiAgICAgICAgZWRpdG9yLnVwZGF0ZShFZGl0b3JTdGF0ZS5wdXNoKGVkaXRvclN0YXRlLCBjb250ZW50U3RhdGUsICdpbnNlcnQtY2hhcmFjdGVycycpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG5cbiAgdmFyIGNvbW1hbmQgPSBlZGl0b3IucHJvcHMua2V5QmluZGluZ0ZuKGUpO1xuXG4gIC8vIElmIG5vIGNvbW1hbmQgaXMgc3BlY2lmaWVkLCBhbGxvdyBrZXlkb3duIGV2ZW50IHRvIGNvbnRpbnVlLlxuICBpZiAoIWNvbW1hbmQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29tbWFuZCA9PT0gJ3VuZG8nKSB7XG4gICAgLy8gU2luY2UgdW5kbyByZXF1aXJlcyBzb21lIHNwZWNpYWwgdXBkYXRpbmcgYmVoYXZpb3IgdG8ga2VlcCB0aGUgZWRpdG9yXG4gICAgLy8gaW4gc3luYywgaGFuZGxlIGl0IHNlcGFyYXRlbHkuXG4gICAga2V5Q29tbWFuZFVuZG8oZSwgZWRpdG9yU3RhdGUsIGVkaXRvci51cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgdGhhdCB3ZSdyZSBoYW5kbGluZyBhIGNvbW1hbmQgb2Ygc29tZSBraW5kLCBzb1xuICAvLyB3ZSBkb24ndCB3YW50IHRvIGluc2VydCBhIGNoYXJhY3RlciBmb2xsb3dpbmcgdGhlIGtleWRvd24uXG4gIGUucHJldmVudERlZmF1bHQoKTtcblxuICAvLyBBbGxvdyBjb21wb25lbnRzIGhpZ2hlciB1cCB0aGUgdHJlZSB0byBoYW5kbGUgdGhlIGNvbW1hbmQgZmlyc3QuXG4gIGlmIChlZGl0b3IucHJvcHMuaGFuZGxlS2V5Q29tbWFuZCAmJiBpc0V2ZW50SGFuZGxlZChlZGl0b3IucHJvcHMuaGFuZGxlS2V5Q29tbWFuZChjb21tYW5kLCBlZGl0b3JTdGF0ZSkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5ld1N0YXRlID0gb25LZXlDb21tYW5kKGNvbW1hbmQsIGVkaXRvclN0YXRlKTtcbiAgaWYgKG5ld1N0YXRlICE9PSBlZGl0b3JTdGF0ZSkge1xuICAgIGVkaXRvci51cGRhdGUobmV3U3RhdGUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZWRpdE9uS2V5RG93bjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZWRpdE9uS2V5RG93bi5qc1xuLy8gbW9kdWxlIGlkID0gNDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTZWNvbmRhcnlDbGlwYm9hcmRcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERyYWZ0TW9kaWZpZXIgPSByZXF1aXJlKCcuL0RyYWZ0TW9kaWZpZXInKTtcbnZhciBFZGl0b3JTdGF0ZSA9IHJlcXVpcmUoJy4vRWRpdG9yU3RhdGUnKTtcblxudmFyIGdldENvbnRlbnRTdGF0ZUZyYWdtZW50ID0gcmVxdWlyZSgnLi9nZXRDb250ZW50U3RhdGVGcmFnbWVudCcpO1xudmFyIG51bGx0aHJvd3MgPSByZXF1aXJlKCdmYmpzL2xpYi9udWxsdGhyb3dzJyk7XG5cbnZhciBjbGlwYm9hcmQgPSBudWxsO1xuXG4vKipcbiAqIFNvbWUgc3lzdGVtcyBvZmZlciBhIFwic2Vjb25kYXJ5XCIgY2xpcGJvYXJkIHRvIGFsbG93IHF1aWNrIGludGVybmFsIGN1dFxuICogYW5kIHBhc3RlIGJlaGF2aW9yLiBGb3IgaW5zdGFuY2UsIEN0cmwrSyAoY3V0KSBhbmQgQ3RybCtZIChwYXN0ZSkuXG4gKi9cbnZhciBTZWNvbmRhcnlDbGlwYm9hcmQgPSB7XG4gIGN1dDogZnVuY3Rpb24gY3V0KGVkaXRvclN0YXRlKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBlZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpO1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKTtcbiAgICB2YXIgdGFyZ2V0UmFuZ2UgPSBudWxsO1xuXG4gICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICB2YXIgYW5jaG9yS2V5ID0gc2VsZWN0aW9uLmdldEFuY2hvcktleSgpO1xuICAgICAgdmFyIGJsb2NrRW5kID0gY29udGVudC5nZXRCbG9ja0ZvcktleShhbmNob3JLZXkpLmdldExlbmd0aCgpO1xuXG4gICAgICBpZiAoYmxvY2tFbmQgPT09IHNlbGVjdGlvbi5nZXRBbmNob3JPZmZzZXQoKSkge1xuICAgICAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldFJhbmdlID0gc2VsZWN0aW9uLnNldCgnZm9jdXNPZmZzZXQnLCBibG9ja0VuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFJhbmdlID0gc2VsZWN0aW9uO1xuICAgIH1cblxuICAgIHRhcmdldFJhbmdlID0gbnVsbHRocm93cyh0YXJnZXRSYW5nZSk7XG4gICAgY2xpcGJvYXJkID0gZ2V0Q29udGVudFN0YXRlRnJhZ21lbnQoY29udGVudCwgdGFyZ2V0UmFuZ2UpO1xuXG4gICAgdmFyIGFmdGVyUmVtb3ZhbCA9IERyYWZ0TW9kaWZpZXIucmVtb3ZlUmFuZ2UoY29udGVudCwgdGFyZ2V0UmFuZ2UsICdmb3J3YXJkJyk7XG5cbiAgICBpZiAoYWZ0ZXJSZW1vdmFsID09PSBjb250ZW50KSB7XG4gICAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIEVkaXRvclN0YXRlLnB1c2goZWRpdG9yU3RhdGUsIGFmdGVyUmVtb3ZhbCwgJ3JlbW92ZS1yYW5nZScpO1xuICB9LFxuXG4gIHBhc3RlOiBmdW5jdGlvbiBwYXN0ZShlZGl0b3JTdGF0ZSkge1xuICAgIGlmICghY2xpcGJvYXJkKSB7XG4gICAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gICAgfVxuXG4gICAgdmFyIG5ld0NvbnRlbnQgPSBEcmFmdE1vZGlmaWVyLnJlcGxhY2VXaXRoRnJhZ21lbnQoZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKSwgZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCksIGNsaXBib2FyZCk7XG5cbiAgICByZXR1cm4gRWRpdG9yU3RhdGUucHVzaChlZGl0b3JTdGF0ZSwgbmV3Q29udGVudCwgJ2luc2VydC1mcmFnbWVudCcpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlY29uZGFyeUNsaXBib2FyZDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvU2Vjb25kYXJ5Q2xpcGJvYXJkLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleUNvbW1hbmRCYWNrc3BhY2VUb1N0YXJ0T2ZMaW5lXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFZGl0b3JTdGF0ZSA9IHJlcXVpcmUoJy4vRWRpdG9yU3RhdGUnKTtcblxudmFyIGV4cGFuZFJhbmdlVG9TdGFydE9mTGluZSA9IHJlcXVpcmUoJy4vZXhwYW5kUmFuZ2VUb1N0YXJ0T2ZMaW5lJyk7XG52YXIgZ2V0RHJhZnRFZGl0b3JTZWxlY3Rpb25XaXRoTm9kZXMgPSByZXF1aXJlKCcuL2dldERyYWZ0RWRpdG9yU2VsZWN0aW9uV2l0aE5vZGVzJyk7XG52YXIgbW92ZVNlbGVjdGlvbkJhY2t3YXJkID0gcmVxdWlyZSgnLi9tb3ZlU2VsZWN0aW9uQmFja3dhcmQnKTtcbnZhciByZW1vdmVUZXh0V2l0aFN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9yZW1vdmVUZXh0V2l0aFN0cmF0ZWd5Jyk7XG5cbmZ1bmN0aW9uIGtleUNvbW1hbmRCYWNrc3BhY2VUb1N0YXJ0T2ZMaW5lKGVkaXRvclN0YXRlKSB7XG4gIHZhciBhZnRlclJlbW92YWwgPSByZW1vdmVUZXh0V2l0aFN0cmF0ZWd5KGVkaXRvclN0YXRlLCBmdW5jdGlvbiAoc3RyYXRlZ3lTdGF0ZSkge1xuICAgIHZhciBzZWxlY3Rpb24gPSBzdHJhdGVneVN0YXRlLmdldFNlbGVjdGlvbigpO1xuICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBzZWxlY3Rpb24uZ2V0QW5jaG9yT2Zmc2V0KCkgPT09IDApIHtcbiAgICAgIHJldHVybiBtb3ZlU2VsZWN0aW9uQmFja3dhcmQoc3RyYXRlZ3lTdGF0ZSwgMSk7XG4gICAgfVxuXG4gICAgdmFyIGRvbVNlbGVjdGlvbiA9IGdsb2JhbC5nZXRTZWxlY3Rpb24oKTtcbiAgICB2YXIgcmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICByYW5nZSA9IGV4cGFuZFJhbmdlVG9TdGFydE9mTGluZShyYW5nZSk7XG5cbiAgICByZXR1cm4gZ2V0RHJhZnRFZGl0b3JTZWxlY3Rpb25XaXRoTm9kZXMoc3RyYXRlZ3lTdGF0ZSwgbnVsbCwgcmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQsIHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCkuc2VsZWN0aW9uU3RhdGU7XG4gIH0sICdiYWNrd2FyZCcpO1xuXG4gIGlmIChhZnRlclJlbW92YWwgPT09IGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCkpIHtcbiAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gIH1cblxuICByZXR1cm4gRWRpdG9yU3RhdGUucHVzaChlZGl0b3JTdGF0ZSwgYWZ0ZXJSZW1vdmFsLCAncmVtb3ZlLXJhbmdlJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5Q29tbWFuZEJhY2tzcGFjZVRvU3RhcnRPZkxpbmU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2tleUNvbW1hbmRCYWNrc3BhY2VUb1N0YXJ0T2ZMaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZXhwYW5kUmFuZ2VUb1N0YXJ0T2ZMaW5lXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG52YXIgVW5pY29kZVV0aWxzID0gcmVxdWlyZSgnZmJqcy9saWIvVW5pY29kZVV0aWxzJyk7XG5cbnZhciBnZXRSYW5nZUNsaWVudFJlY3RzID0gcmVxdWlyZSgnLi9nZXRSYW5nZUNsaWVudFJlY3RzJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjb21wdXRlZCBsaW5lIGhlaWdodCwgaW4gcGl4ZWxzLCBmb3IgdGhlIHByb3ZpZGVkIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGdldExpbmVIZWlnaHRQeChlbGVtZW50KSB7XG4gIHZhciBjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnN0eWxlLmZvbnRGYW1pbHkgPSBjb21wdXRlZC5mb250RmFtaWx5O1xuICBkaXYuc3R5bGUuZm9udFNpemUgPSBjb21wdXRlZC5mb250U2l6ZTtcbiAgZGl2LnN0eWxlLmZvbnRTdHlsZSA9IGNvbXB1dGVkLmZvbnRTdHlsZTtcbiAgZGl2LnN0eWxlLmZvbnRXZWlnaHQgPSBjb21wdXRlZC5mb250V2VpZ2h0O1xuICBkaXYuc3R5bGUubGluZUhlaWdodCA9IGNvbXB1dGVkLmxpbmVIZWlnaHQ7XG4gIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGRpdi50ZXh0Q29udGVudCA9ICdNJztcblxuICB2YXIgZG9jdW1lbnRCb2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgIWRvY3VtZW50Qm9keSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNzaW5nIGRvY3VtZW50LmJvZHknKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgLy8gZm9yY2VkIGxheW91dCBoZXJlXG4gIGRvY3VtZW50Qm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICB2YXIgcmVjdCA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgZG9jdW1lbnRCb2R5LnJlbW92ZUNoaWxkKGRpdik7XG5cbiAgcmV0dXJuIHJlY3QuaGVpZ2h0O1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGV2ZXJ5IENsaWVudFJlY3QgaW4gdGhlIHByb3ZpZGVkIGxpc3QgbGllcyBvbiB0aGUgc2FtZSBsaW5lLlxuICpcbiAqIFdlIGFzc3VtZSB0aGF0IHRoZSByZWN0cyBvbiB0aGUgc2FtZSBsaW5lIGFsbCBjb250YWluIHRoZSBiYXNlbGluZSwgc28gdGhlXG4gKiBsb3dlc3QgdG9wIGxpbmUgbmVlZHMgdG8gYmUgYWJvdmUgdGhlIGhpZ2hlc3QgYm90dG9tIGxpbmUgKGkuZS4sIGlmIHlvdSB3ZXJlXG4gKiB0byBwcm9qZWN0IHRoZSByZWN0cyBvbnRvIHRoZSB5LWF4aXMsIHRoZWlyIGludGVyc2VjdGlvbiB3b3VsZCBiZSBub25lbXB0eSkuXG4gKlxuICogSW4gYWRkaXRpb24sIHdlIHJlcXVpcmUgdGhhdCBubyB0d28gYm94ZXMgYXJlIGxpbmVIZWlnaHQgKG9yIG1vcmUpIGFwYXJ0IGF0XG4gKiBlaXRoZXIgdG9wIG9yIGJvdHRvbSwgd2hpY2ggaGVscHMgcHJvdGVjdCBhZ2FpbnN0IGZhbHNlIHBvc2l0aXZlcyBmb3IgZm9udHNcbiAqIHdpdGggZXh0cmVtZWx5IGxhcmdlIGdseXBoIGhlaWdodHMgKGUuZy4sIHdpdGggYSBmb250IHNpemUgb2YgMTdweCwgWmFwZmlub1xuICogcHJvZHVjZXMgcmVjdHMgb2YgaGVpZ2h0IDU4cHghKS5cbiAqL1xuZnVuY3Rpb24gYXJlUmVjdHNPbk9uZUxpbmUocmVjdHMsIGxpbmVIZWlnaHQpIHtcbiAgdmFyIG1pblRvcCA9IEluZmluaXR5O1xuICB2YXIgbWluQm90dG9tID0gSW5maW5pdHk7XG4gIHZhciBtYXhUb3AgPSAtSW5maW5pdHk7XG4gIHZhciBtYXhCb3R0b20gPSAtSW5maW5pdHk7XG5cbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHJlY3RzLmxlbmd0aDsgaWkrKykge1xuICAgIHZhciByZWN0ID0gcmVjdHNbaWldO1xuICAgIGlmIChyZWN0LndpZHRoID09PSAwIHx8IHJlY3Qud2lkdGggPT09IDEpIHtcbiAgICAgIC8vIFdoZW4gYSByYW5nZSBzdGFydHMgb3IgZW5kcyBhIHNvZnQgd3JhcCwgbWFueSBicm93c2VycyAoQ2hyb21lLCBJRSxcbiAgICAgIC8vIFNhZmFyaSkgaW5jbHVkZSBhbiBlbXB0eSByZWN0IG9uIHRoZSBwcmV2aW91cyBvciBuZXh0IGxpbmUuIFdoZW4gdGhlXG4gICAgICAvLyB0ZXh0IGxpZXMgaW4gYSBjb250YWluZXIgd2hvc2UgcG9zaXRpb24gaXMgbm90IGludGVncmFsIChlLmcuLCBmcm9tXG4gICAgICAvLyBtYXJnaW46IGF1dG8pLCBTYWZhcmkgbWFrZXMgdGhlc2UgZW1wdHkgcmVjdHMgaGF2ZSB3aWR0aCAxIChpbnN0ZWFkIG9mXG4gICAgICAvLyAwKS4gSGF2aW5nIG9uZS1waXhlbC13aWRlIGNoYXJhY3RlcnMgc2VlbXMgdW5saWtlbHkgKGFuZCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyByZXBvcnQgd2lkdGhzIGluIHN1YnBpeGVsIHByZWNpc2lvbiBhbnl3YXkpIHNvIGl0J3MgcmVsYXRpdmVseSBzYWZlIHRvXG4gICAgICAvLyBza2lwIG92ZXIgdGhlbS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBtaW5Ub3AgPSBNYXRoLm1pbihtaW5Ub3AsIHJlY3QudG9wKTtcbiAgICBtaW5Cb3R0b20gPSBNYXRoLm1pbihtaW5Cb3R0b20sIHJlY3QuYm90dG9tKTtcbiAgICBtYXhUb3AgPSBNYXRoLm1heChtYXhUb3AsIHJlY3QudG9wKTtcbiAgICBtYXhCb3R0b20gPSBNYXRoLm1heChtYXhCb3R0b20sIHJlY3QuYm90dG9tKTtcbiAgfVxuXG4gIHJldHVybiBtYXhUb3AgPD0gbWluQm90dG9tICYmIG1heFRvcCAtIG1pblRvcCA8IGxpbmVIZWlnaHQgJiYgbWF4Qm90dG9tIC0gbWluQm90dG9tIDwgbGluZUhlaWdodDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxlbmd0aCBvZiBhIG5vZGUsIGFzIHVzZWQgYnkgUmFuZ2Ugb2Zmc2V0cy5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUxlbmd0aChub2RlKSB7XG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jY29uY2VwdC1ub2RlLWxlbmd0aFxuICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICBjYXNlIE5vZGUuRE9DVU1FTlRfVFlQRV9OT0RFOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSBOb2RlLlRFWFRfTk9ERTpcbiAgICBjYXNlIE5vZGUuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFOlxuICAgIGNhc2UgTm9kZS5DT01NRU5UX05PREU6XG4gICAgICByZXR1cm4gbm9kZS5sZW5ndGg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBjb2xsYXBzZWQgcmFuZ2UsIG1vdmUgdGhlIHN0YXJ0IHBvc2l0aW9uIGJhY2t3YXJkcyBhcyBmYXIgYXNcbiAqIHBvc3NpYmxlIHdoaWxlIHRoZSByYW5nZSBzdGlsbCBzcGFucyBvbmx5IGEgc2luZ2xlIGxpbmUuXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZFJhbmdlVG9TdGFydE9mTGluZShyYW5nZSkge1xuICAhcmFuZ2UuY29sbGFwc2VkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2V4cGFuZFJhbmdlVG9TdGFydE9mTGluZTogUHJvdmlkZWQgcmFuZ2UgaXMgbm90IGNvbGxhcHNlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJhbmdlID0gcmFuZ2UuY2xvbmVSYW5nZSgpO1xuXG4gIHZhciBjb250YWluaW5nRWxlbWVudCA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICBpZiAoY29udGFpbmluZ0VsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICBjb250YWluaW5nRWxlbWVudCA9IGNvbnRhaW5pbmdFbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgdmFyIGxpbmVIZWlnaHQgPSBnZXRMaW5lSGVpZ2h0UHgoY29udGFpbmluZ0VsZW1lbnQpO1xuXG4gIC8vIEltYWdpbmUgb3VyIHRleHQgbG9va3MgbGlrZTpcbiAgLy8gICA8ZGl2PjxzcGFuPm9uY2UgdXBvbiBhIHRpbWUsIHRoZXJlIHdhcyBhIDxlbT5ib3lcbiAgLy8gICB3aG8gbGl2ZWQ8L2VtPiA8L3NwYW4+PHE+PHN0cm9uZz51bmRlcl4gdGhlXG4gIC8vICAgc3RhaXJzPC9zdHJvbmc+IGluIGEgc21hbGwgY2xvc2V0LjwvcT48L2Rpdj5cbiAgLy8gd2hlcmUgdGhlIGNhcmV0IHJlcHJlc2VudHMgdGhlIGN1cnNvci4gRmlyc3QsIHdlIGNyYXdsIHVwIHRoZSB0cmVlIHVudGlsXG4gIC8vIHRoZSByYW5nZSBzcGFucyBtdWx0aXBsZSBsaW5lcyAoc2V0dGluZyB0aGUgc3RhcnQgcG9pbnQgdG8gYmVmb3JlXG4gIC8vIFwiPHN0cm9uZz5cIiwgdGhlbiBiZWZvcmUgXCI8ZGl2PlwiKSwgdGhlbiBhdCBlYWNoIGxldmVsIHdlIGRvIGEgc2VhcmNoIHRvXG4gIC8vIGZpbmQgdGhlIGxhdGVzdCBwb2ludCB3aGljaCBpcyBzdGlsbCBvbiBhIHByZXZpb3VzIGxpbmUuIFdlJ2xsIGZpbmQgdGhhdFxuICAvLyB0aGUgYnJlYWsgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGFuLCB0aGVuIGluc2lkZSB0aGUgPGVtPiwgdGhlbiBpbiBpdHMgdGV4dFxuICAvLyBub2RlIGNoaWxkLCB0aGUgYWN0dWFsIGJyZWFrIHBvaW50IGJlZm9yZSBcIndob1wiLlxuXG4gIHZhciBiZXN0Q29udGFpbmVyID0gcmFuZ2UuZW5kQ29udGFpbmVyO1xuICB2YXIgYmVzdE9mZnNldCA9IHJhbmdlLmVuZE9mZnNldDtcbiAgcmFuZ2Uuc2V0U3RhcnQocmFuZ2Uuc3RhcnRDb250YWluZXIsIDApO1xuXG4gIHdoaWxlIChhcmVSZWN0c09uT25lTGluZShnZXRSYW5nZUNsaWVudFJlY3RzKHJhbmdlKSwgbGluZUhlaWdodCkpIHtcbiAgICBiZXN0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgYmVzdE9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICFiZXN0Q29udGFpbmVyLnBhcmVudE5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRm91bmQgdW5leHBlY3RlZCBkZXRhY2hlZCBzdWJ0cmVlIHdoZW4gdHJhdmVyc2luZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmFuZ2Uuc2V0U3RhcnRCZWZvcmUoYmVzdENvbnRhaW5lcik7XG4gICAgaWYgKGJlc3RDb250YWluZXIubm9kZVR5cGUgPT09IDEgJiYgZ2V0Q29tcHV0ZWRTdHlsZShiZXN0Q29udGFpbmVyKS5kaXNwbGF5ICE9PSAnaW5saW5lJykge1xuICAgICAgLy8gVGhlIHN0YXJ0IG9mIHRoZSBsaW5lIGlzIG5ldmVyIGluIGEgZGlmZmVyZW50IGJsb2NrLWxldmVsIGNvbnRhaW5lci5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluIHRoZSBhYm92ZSBleGFtcGxlLCByYW5nZSBub3cgc3BhbnMgZnJvbSBcIjxkaXY+XCIgdG8gXCJ1bmRlclwiLFxuICAvLyBiZXN0Q29udGFpbmVyIGlzIDxkaXY+LCBhbmQgYmVzdE9mZnNldCBpcyAxIChpbmRleCBvZiA8cT4gaW5zaWRlIDxkaXY+KV0uXG4gIC8vIFBpY2tpbmcgb3V0IHdoaWNoIGNoaWxkIHRvIHJlY3Vyc2UgaW50byBoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHNpbmNlIHdlXG4gIC8vIGRvbid0IHdhbnQgdG8gY2hlY2sgcGFzdCA8cT4gLS0gb25jZSB3ZSBmaW5kIHRoYXQgdGhlIGZpbmFsIHJhbmdlIHN0YXJ0c1xuICAvLyBpbiA8c3Bhbj4sIHdlIGNhbiBsb29rIGF0IGFsbCBvZiBpdHMgY2hpbGRyZW4gKGFuZCBhbGwgb2YgdGhlaXIgY2hpbGRyZW4pXG4gIC8vIHRvIGZpbmQgdGhlIGJyZWFrIHBvaW50LlxuXG4gIC8vIEF0IGFsbCB0aW1lcywgKGJlc3RDb250YWluZXIsIGJlc3RPZmZzZXQpIGlzIHRoZSBsYXRlc3Qgc2luZ2xlLWxpbmUgc3RhcnRcbiAgLy8gcG9pbnQgdGhhdCB3ZSBrbm93IG9mLlxuICB2YXIgY3VycmVudENvbnRhaW5lciA9IGJlc3RDb250YWluZXI7XG4gIHZhciBtYXhJbmRleFRvQ29uc2lkZXIgPSBiZXN0T2Zmc2V0IC0gMTtcblxuICBkbyB7XG4gICAgdmFyIG5vZGVWYWx1ZSA9IGN1cnJlbnRDb250YWluZXIubm9kZVZhbHVlO1xuXG4gICAgZm9yICh2YXIgaWkgPSBtYXhJbmRleFRvQ29uc2lkZXI7IGlpID49IDA7IGlpLS0pIHtcbiAgICAgIGlmIChub2RlVmFsdWUgIT0gbnVsbCAmJiBpaSA+IDAgJiYgVW5pY29kZVV0aWxzLmlzU3Vycm9nYXRlUGFpcihub2RlVmFsdWUsIGlpIC0gMSkpIHtcbiAgICAgICAgLy8gV2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyIC0tIHNraXAgb3ZlciBzbyB3ZSBuZXZlclxuICAgICAgICAvLyByZXR1cm4gYSByYW5nZSB3aXRoIGFuIGVuZHBvaW50IGluIHRoZSBtaWRkbGUgb2YgYSBjb2RlIHBvaW50LlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmFuZ2Uuc2V0U3RhcnQoY3VycmVudENvbnRhaW5lciwgaWkpO1xuICAgICAgaWYgKGFyZVJlY3RzT25PbmVMaW5lKGdldFJhbmdlQ2xpZW50UmVjdHMocmFuZ2UpLCBsaW5lSGVpZ2h0KSkge1xuICAgICAgICBiZXN0Q29udGFpbmVyID0gY3VycmVudENvbnRhaW5lcjtcbiAgICAgICAgYmVzdE9mZnNldCA9IGlpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlpID09PSAtMSB8fCBjdXJyZW50Q29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBJZiBpaSA9PT0gLTEsIHRoZW4gKGJlc3RDb250YWluZXIsIGJlc3RPZmZzZXQpLCB3aGljaCBpcyBlcXVhbCB0b1xuICAgICAgLy8gKGN1cnJlbnRDb250YWluZXIsIDApLCB3YXMgYSBzaW5nbGUtbGluZSBzdGFydCBwb2ludCBidXQgYSBzdGFydFxuICAgICAgLy8gcG9pbnQgYmVmb3JlIGN1cnJlbnRDb250YWluZXIgd2Fzbid0LCBzbyB0aGUgbGluZSBicmVhayBzZWVtcyB0b1xuICAgICAgLy8gaGF2ZSBvY2N1cnJlZCBpbW1lZGlhdGVseSBhZnRlciBjdXJyZW50Q29udGFpbmVyJ3Mgc3RhcnQgdGFnXG4gICAgICAvL1xuICAgICAgLy8gSWYgY3VycmVudENvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCwgd2UncmUgYWxyZWFkeSBhdCBhXG4gICAgICAvLyB0ZXJtaW5hbCBub2RlIChlLmcuLCB0ZXh0IG5vZGUpIGFuZCBzaG91bGQgcmV0dXJuIG91ciBjdXJyZW50IGJlc3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjdXJyZW50Q29udGFpbmVyID0gY3VycmVudENvbnRhaW5lci5jaGlsZE5vZGVzW2lpXTtcbiAgICBtYXhJbmRleFRvQ29uc2lkZXIgPSBnZXROb2RlTGVuZ3RoKGN1cnJlbnRDb250YWluZXIpO1xuICB9IHdoaWxlICh0cnVlKTtcblxuICByYW5nZS5zZXRTdGFydChiZXN0Q29udGFpbmVyLCBiZXN0T2Zmc2V0KTtcbiAgcmV0dXJuIHJhbmdlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cGFuZFJhbmdlVG9TdGFydE9mTGluZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZXhwYW5kUmFuZ2VUb1N0YXJ0T2ZMaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleUNvbW1hbmRCYWNrc3BhY2VXb3JkXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEcmFmdFJlbW92YWJsZVdvcmQgPSByZXF1aXJlKCcuL0RyYWZ0UmVtb3ZhYmxlV29yZCcpO1xudmFyIEVkaXRvclN0YXRlID0gcmVxdWlyZSgnLi9FZGl0b3JTdGF0ZScpO1xuXG52YXIgbW92ZVNlbGVjdGlvbkJhY2t3YXJkID0gcmVxdWlyZSgnLi9tb3ZlU2VsZWN0aW9uQmFja3dhcmQnKTtcbnZhciByZW1vdmVUZXh0V2l0aFN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9yZW1vdmVUZXh0V2l0aFN0cmF0ZWd5Jyk7XG5cbi8qKlxuICogRGVsZXRlIHRoZSB3b3JkIHRoYXQgaXMgbGVmdCBvZiB0aGUgY3Vyc29yLCBhcyB3ZWxsIGFzIGFueSBzcGFjZXMgb3JcbiAqIHB1bmN0dWF0aW9uIGFmdGVyIHRoZSB3b3JkLlxuICovXG5mdW5jdGlvbiBrZXlDb21tYW5kQmFja3NwYWNlV29yZChlZGl0b3JTdGF0ZSkge1xuICB2YXIgYWZ0ZXJSZW1vdmFsID0gcmVtb3ZlVGV4dFdpdGhTdHJhdGVneShlZGl0b3JTdGF0ZSwgZnVuY3Rpb24gKHN0cmF0ZWd5U3RhdGUpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gc3RyYXRlZ3lTdGF0ZS5nZXRTZWxlY3Rpb24oKTtcbiAgICB2YXIgb2Zmc2V0ID0gc2VsZWN0aW9uLmdldFN0YXJ0T2Zmc2V0KCk7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHdvcmRzIGJlZm9yZSB0aGUgY3Vyc29yLCByZW1vdmUgdGhlIHByZWNlZGluZyBuZXdsaW5lLlxuICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgIHJldHVybiBtb3ZlU2VsZWN0aW9uQmFja3dhcmQoc3RyYXRlZ3lTdGF0ZSwgMSk7XG4gICAgfVxuICAgIHZhciBrZXkgPSBzZWxlY3Rpb24uZ2V0U3RhcnRLZXkoKTtcbiAgICB2YXIgY29udGVudCA9IHN0cmF0ZWd5U3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKTtcbiAgICB2YXIgdGV4dCA9IGNvbnRlbnQuZ2V0QmxvY2tGb3JLZXkoa2V5KS5nZXRUZXh0KCkuc2xpY2UoMCwgb2Zmc2V0KTtcbiAgICB2YXIgdG9SZW1vdmUgPSBEcmFmdFJlbW92YWJsZVdvcmQuZ2V0QmFja3dhcmQodGV4dCk7XG4gICAgcmV0dXJuIG1vdmVTZWxlY3Rpb25CYWNrd2FyZChzdHJhdGVneVN0YXRlLCB0b1JlbW92ZS5sZW5ndGggfHwgMSk7XG4gIH0sICdiYWNrd2FyZCcpO1xuXG4gIGlmIChhZnRlclJlbW92YWwgPT09IGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCkpIHtcbiAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gIH1cblxuICByZXR1cm4gRWRpdG9yU3RhdGUucHVzaChlZGl0b3JTdGF0ZSwgYWZ0ZXJSZW1vdmFsLCAncmVtb3ZlLXJhbmdlJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5Q29tbWFuZEJhY2tzcGFjZVdvcmQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2tleUNvbW1hbmRCYWNrc3BhY2VXb3JkLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBAc3R1YlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBcXHUwMGExLVxcdTAwYjFcXHUwMGI0LVxcdTAwYjhcXHUwMGJhXFx1MDBiYlxcdTAwYmZcbi8vICAgICAgICAgICAgIGlzIGxhdGluIHN1cHBsZW1lbnQgcHVuY3R1YXRpb24gZXhjZXB0IGZyYWN0aW9ucyBhbmQgc3VwZXJzY3JpcHRcbi8vICAgICAgICAgICAgIG51bWJlcnNcbi8vIFxcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA1ZVxuLy8gICAgICAgICAgICAgaXMgcHVuY3R1YXRpb24gZnJvbSB0aGUgZ2VuZXJhbCBwdW5jdHVhdGlvbiBibG9jazpcbi8vICAgICAgICAgICAgIHdlaXJkIHF1b3RlcywgY29tbWFzLCBidWxsZXRzLCBkYXNoZXMsIGV0Yy5cbi8vIFxcdTMwZmJcXHUzMDAxXFx1MzAwMlxcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxZlxuLy8gICAgICAgICAgICAgaXMgQ0pLIHB1bmN0dWF0aW9uXG4vLyBcXHVmZjFhLVxcdWZmMWZcXHVmZjAxLVxcdWZmMGZcXHVmZjNiLVxcdWZmNDBcXHVmZjViLVxcdWZmNjVcbi8vICAgICAgICAgICAgIGlzIHNvbWUgZnVsbC13aWR0aC9oYWxmLXdpZHRoIHB1bmN0dWF0aW9uXG4vLyBcXHUyRTJFXFx1MDYxZlxcdTA2NmEtXFx1MDY2Y1xcdTA2MWJcXHUwNjBjXFx1MDYwZFxcdUZEM2VcXHVGRDNGXG4vLyAgICAgICAgICAgICBpcyBzb21lIEFyYWJpYyBwdW5jdHVhdGlvbiBtYXJrc1xuLy8gXFx1MTgwMVxcdTA5NjRcXHUxMDRhXFx1MTA0YlxuLy8gICAgICAgICAgICAgaXMgbWlzYy4gb3RoZXIgbGFuZ3VhZ2UgcHVuY3R1YXRpb24gbWFya3NcblxudmFyIFBVTkNUVUFUSU9OID0gJ1suLCsqPyR8I3t9KClcXCdcXFxcXlxcXFwtXFxcXFtcXFxcXVxcXFxcXFxcXFxcXC8hQCVcIn49PD5fOjsnICsgJ1xcdTMwRkJcXHUzMDAxXFx1MzAwMlxcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdUZGMUEtXFx1RkYxRlxcdUZGMDEtXFx1RkYwRicgKyAnXFx1RkYzQi1cXHVGRjQwXFx1RkY1Qi1cXHVGRjY1XFx1MkUyRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkNcXHUwNjFCXFx1MDYwQ1xcdTA2MEQnICsgJ1xcdUZEM0VcXHVGRDNGXFx1MTgwMVxcdTA5NjRcXHUxMDRBXFx1MTA0QlxcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA1RScgKyAnXFx4QTEtXFx4QjFcXHhCNC1cXHhCOFxceEJBXFx4QkJcXHhCRl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0UHVuY3R1YXRpb246IGZ1bmN0aW9uIGdldFB1bmN0dWF0aW9uKCkge1xuICAgIHJldHVybiBQVU5DVFVBVElPTjtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9Ub2tlbml6ZVV0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDQ0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5Q29tbWFuZERlbGV0ZVdvcmRcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERyYWZ0UmVtb3ZhYmxlV29yZCA9IHJlcXVpcmUoJy4vRHJhZnRSZW1vdmFibGVXb3JkJyk7XG52YXIgRWRpdG9yU3RhdGUgPSByZXF1aXJlKCcuL0VkaXRvclN0YXRlJyk7XG5cbnZhciBtb3ZlU2VsZWN0aW9uRm9yd2FyZCA9IHJlcXVpcmUoJy4vbW92ZVNlbGVjdGlvbkZvcndhcmQnKTtcbnZhciByZW1vdmVUZXh0V2l0aFN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9yZW1vdmVUZXh0V2l0aFN0cmF0ZWd5Jyk7XG5cbi8qKlxuICogRGVsZXRlIHRoZSB3b3JkIHRoYXQgaXMgcmlnaHQgb2YgdGhlIGN1cnNvciwgYXMgd2VsbCBhcyBhbnkgc3BhY2VzIG9yXG4gKiBwdW5jdHVhdGlvbiBiZWZvcmUgdGhlIHdvcmQuXG4gKi9cbmZ1bmN0aW9uIGtleUNvbW1hbmREZWxldGVXb3JkKGVkaXRvclN0YXRlKSB7XG4gIHZhciBhZnRlclJlbW92YWwgPSByZW1vdmVUZXh0V2l0aFN0cmF0ZWd5KGVkaXRvclN0YXRlLCBmdW5jdGlvbiAoc3RyYXRlZ3lTdGF0ZSkge1xuICAgIHZhciBzZWxlY3Rpb24gPSBzdHJhdGVneVN0YXRlLmdldFNlbGVjdGlvbigpO1xuICAgIHZhciBvZmZzZXQgPSBzZWxlY3Rpb24uZ2V0U3RhcnRPZmZzZXQoKTtcbiAgICB2YXIga2V5ID0gc2VsZWN0aW9uLmdldFN0YXJ0S2V5KCk7XG4gICAgdmFyIGNvbnRlbnQgPSBzdHJhdGVneVN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG4gICAgdmFyIHRleHQgPSBjb250ZW50LmdldEJsb2NrRm9yS2V5KGtleSkuZ2V0VGV4dCgpLnNsaWNlKG9mZnNldCk7XG4gICAgdmFyIHRvUmVtb3ZlID0gRHJhZnRSZW1vdmFibGVXb3JkLmdldEZvcndhcmQodGV4dCk7XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gd29yZHMgaW4gZnJvbnQgb2YgdGhlIGN1cnNvciwgcmVtb3ZlIHRoZSBuZXdsaW5lLlxuICAgIHJldHVybiBtb3ZlU2VsZWN0aW9uRm9yd2FyZChzdHJhdGVneVN0YXRlLCB0b1JlbW92ZS5sZW5ndGggfHwgMSk7XG4gIH0sICdmb3J3YXJkJyk7XG5cbiAgaWYgKGFmdGVyUmVtb3ZhbCA9PT0gZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKSkge1xuICAgIHJldHVybiBlZGl0b3JTdGF0ZTtcbiAgfVxuXG4gIHJldHVybiBFZGl0b3JTdGF0ZS5wdXNoKGVkaXRvclN0YXRlLCBhZnRlclJlbW92YWwsICdyZW1vdmUtcmFuZ2UnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlDb21tYW5kRGVsZXRlV29yZDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIva2V5Q29tbWFuZERlbGV0ZVdvcmQuanNcbi8vIG1vZHVsZSBpZCA9IDQ0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5Q29tbWFuZEluc2VydE5ld2xpbmVcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERyYWZ0TW9kaWZpZXIgPSByZXF1aXJlKCcuL0RyYWZ0TW9kaWZpZXInKTtcbnZhciBFZGl0b3JTdGF0ZSA9IHJlcXVpcmUoJy4vRWRpdG9yU3RhdGUnKTtcblxuZnVuY3Rpb24ga2V5Q29tbWFuZEluc2VydE5ld2xpbmUoZWRpdG9yU3RhdGUpIHtcbiAgdmFyIGNvbnRlbnRTdGF0ZSA9IERyYWZ0TW9kaWZpZXIuc3BsaXRCbG9jayhlZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpLCBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKSk7XG4gIHJldHVybiBFZGl0b3JTdGF0ZS5wdXNoKGVkaXRvclN0YXRlLCBjb250ZW50U3RhdGUsICdzcGxpdC1ibG9jaycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleUNvbW1hbmRJbnNlcnROZXdsaW5lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9rZXlDb21tYW5kSW5zZXJ0TmV3bGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBrZXlDb21tYW5kTW92ZVNlbGVjdGlvblRvRW5kT2ZCbG9ja1xuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRWRpdG9yU3RhdGUgPSByZXF1aXJlKCcuL0VkaXRvclN0YXRlJyk7XG5cbi8qKlxuICogU2VlIGNvbW1lbnQgZm9yIGBtb3ZlU2VsZWN0aW9uVG9TdGFydE9mQmxvY2tgLlxuICovXG5mdW5jdGlvbiBrZXlDb21tYW5kTW92ZVNlbGVjdGlvblRvRW5kT2ZCbG9jayhlZGl0b3JTdGF0ZSkge1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBlbmRLZXkgPSBzZWxlY3Rpb24uZ2V0RW5kS2V5KCk7XG4gIHZhciBjb250ZW50ID0gZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKTtcbiAgdmFyIHRleHRMZW5ndGggPSBjb250ZW50LmdldEJsb2NrRm9yS2V5KGVuZEtleSkuZ2V0TGVuZ3RoKCk7XG4gIHJldHVybiBFZGl0b3JTdGF0ZS5zZXQoZWRpdG9yU3RhdGUsIHtcbiAgICBzZWxlY3Rpb246IHNlbGVjdGlvbi5tZXJnZSh7XG4gICAgICBhbmNob3JLZXk6IGVuZEtleSxcbiAgICAgIGFuY2hvck9mZnNldDogdGV4dExlbmd0aCxcbiAgICAgIGZvY3VzS2V5OiBlbmRLZXksXG4gICAgICBmb2N1c09mZnNldDogdGV4dExlbmd0aCxcbiAgICAgIGlzQmFja3dhcmQ6IGZhbHNlXG4gICAgfSksXG4gICAgZm9yY2VTZWxlY3Rpb246IHRydWVcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5Q29tbWFuZE1vdmVTZWxlY3Rpb25Ub0VuZE9mQmxvY2s7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2tleUNvbW1hbmRNb3ZlU2VsZWN0aW9uVG9FbmRPZkJsb2NrLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleUNvbW1hbmRNb3ZlU2VsZWN0aW9uVG9TdGFydE9mQmxvY2tcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVkaXRvclN0YXRlID0gcmVxdWlyZSgnLi9FZGl0b3JTdGF0ZScpO1xuXG4vKipcbiAqIENvbGxhcHNlIHNlbGVjdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IHNlbGVjdGVkIGJsb2NrLiBUaGlzIGlzIHVzZWRcbiAqIGZvciBGaXJlZm94IHZlcnNpb25zIHRoYXQgYXR0ZW1wdCB0byBuYXZpZ2F0ZSBmb3J3YXJkL2JhY2t3YXJkIGluc3RlYWQgb2ZcbiAqIG1vdmluZyB0aGUgY3Vyc29yLiBPdGhlciBicm93c2VycyBhcmUgYWJsZSB0byBtb3ZlIHRoZSBjdXJzb3IgbmF0aXZlbHkuXG4gKi9cbmZ1bmN0aW9uIGtleUNvbW1hbmRNb3ZlU2VsZWN0aW9uVG9TdGFydE9mQmxvY2soZWRpdG9yU3RhdGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpO1xuICB2YXIgc3RhcnRLZXkgPSBzZWxlY3Rpb24uZ2V0U3RhcnRLZXkoKTtcbiAgcmV0dXJuIEVkaXRvclN0YXRlLnNldChlZGl0b3JTdGF0ZSwge1xuICAgIHNlbGVjdGlvbjogc2VsZWN0aW9uLm1lcmdlKHtcbiAgICAgIGFuY2hvcktleTogc3RhcnRLZXksXG4gICAgICBhbmNob3JPZmZzZXQ6IDAsXG4gICAgICBmb2N1c0tleTogc3RhcnRLZXksXG4gICAgICBmb2N1c09mZnNldDogMCxcbiAgICAgIGlzQmFja3dhcmQ6IGZhbHNlXG4gICAgfSksXG4gICAgZm9yY2VTZWxlY3Rpb246IHRydWVcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5Q29tbWFuZE1vdmVTZWxlY3Rpb25Ub1N0YXJ0T2ZCbG9jaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIva2V5Q29tbWFuZE1vdmVTZWxlY3Rpb25Ub1N0YXJ0T2ZCbG9jay5qc1xuLy8gbW9kdWxlIGlkID0gNDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBrZXlDb21tYW5kUGxhaW5CYWNrc3BhY2VcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVkaXRvclN0YXRlID0gcmVxdWlyZSgnLi9FZGl0b3JTdGF0ZScpO1xudmFyIFVuaWNvZGVVdGlscyA9IHJlcXVpcmUoJ2ZianMvbGliL1VuaWNvZGVVdGlscycpO1xuXG52YXIgbW92ZVNlbGVjdGlvbkJhY2t3YXJkID0gcmVxdWlyZSgnLi9tb3ZlU2VsZWN0aW9uQmFja3dhcmQnKTtcbnZhciByZW1vdmVUZXh0V2l0aFN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9yZW1vdmVUZXh0V2l0aFN0cmF0ZWd5Jyk7XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBzZWxlY3RlZCByYW5nZS4gSWYgdGhlIGN1cnNvciBpcyBjb2xsYXBzZWQsIHJlbW92ZSB0aGUgcHJlY2VkaW5nXG4gKiBjaGFyYWN0ZXIuIFRoaXMgb3BlcmF0aW9uIGlzIFVuaWNvZGUtYXdhcmUsIHNvIHJlbW92aW5nIGEgc2luZ2xlIGNoYXJhY3RlclxuICogd2lsbCByZW1vdmUgYSBzdXJyb2dhdGUgcGFpciBwcm9wZXJseSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBrZXlDb21tYW5kUGxhaW5CYWNrc3BhY2UoZWRpdG9yU3RhdGUpIHtcbiAgdmFyIGFmdGVyUmVtb3ZhbCA9IHJlbW92ZVRleHRXaXRoU3RyYXRlZ3koZWRpdG9yU3RhdGUsIGZ1bmN0aW9uIChzdHJhdGVneVN0YXRlKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHN0cmF0ZWd5U3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG4gICAgdmFyIGNvbnRlbnQgPSBzdHJhdGVneVN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG4gICAgdmFyIGtleSA9IHNlbGVjdGlvbi5nZXRBbmNob3JLZXkoKTtcbiAgICB2YXIgb2Zmc2V0ID0gc2VsZWN0aW9uLmdldEFuY2hvck9mZnNldCgpO1xuICAgIHZhciBjaGFyQmVoaW5kID0gY29udGVudC5nZXRCbG9ja0ZvcktleShrZXkpLmdldFRleHQoKVtvZmZzZXQgLSAxXTtcbiAgICByZXR1cm4gbW92ZVNlbGVjdGlvbkJhY2t3YXJkKHN0cmF0ZWd5U3RhdGUsIGNoYXJCZWhpbmQgPyBVbmljb2RlVXRpbHMuZ2V0VVRGMTZMZW5ndGgoY2hhckJlaGluZCwgMCkgOiAxKTtcbiAgfSwgJ2JhY2t3YXJkJyk7XG5cbiAgaWYgKGFmdGVyUmVtb3ZhbCA9PT0gZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKSkge1xuICAgIHJldHVybiBlZGl0b3JTdGF0ZTtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKTtcbiAgcmV0dXJuIEVkaXRvclN0YXRlLnB1c2goZWRpdG9yU3RhdGUsIGFmdGVyUmVtb3ZhbC5zZXQoJ3NlbGVjdGlvbkJlZm9yZScsIHNlbGVjdGlvbiksIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpID8gJ2JhY2tzcGFjZS1jaGFyYWN0ZXInIDogJ3JlbW92ZS1yYW5nZScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleUNvbW1hbmRQbGFpbkJhY2tzcGFjZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIva2V5Q29tbWFuZFBsYWluQmFja3NwYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleUNvbW1hbmRQbGFpbkRlbGV0ZVxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRWRpdG9yU3RhdGUgPSByZXF1aXJlKCcuL0VkaXRvclN0YXRlJyk7XG52YXIgVW5pY29kZVV0aWxzID0gcmVxdWlyZSgnZmJqcy9saWIvVW5pY29kZVV0aWxzJyk7XG5cbnZhciBtb3ZlU2VsZWN0aW9uRm9yd2FyZCA9IHJlcXVpcmUoJy4vbW92ZVNlbGVjdGlvbkZvcndhcmQnKTtcbnZhciByZW1vdmVUZXh0V2l0aFN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9yZW1vdmVUZXh0V2l0aFN0cmF0ZWd5Jyk7XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBzZWxlY3RlZCByYW5nZS4gSWYgdGhlIGN1cnNvciBpcyBjb2xsYXBzZWQsIHJlbW92ZSB0aGUgZm9sbG93aW5nXG4gKiBjaGFyYWN0ZXIuIFRoaXMgb3BlcmF0aW9uIGlzIFVuaWNvZGUtYXdhcmUsIHNvIHJlbW92aW5nIGEgc2luZ2xlIGNoYXJhY3RlclxuICogd2lsbCByZW1vdmUgYSBzdXJyb2dhdGUgcGFpciBwcm9wZXJseSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBrZXlDb21tYW5kUGxhaW5EZWxldGUoZWRpdG9yU3RhdGUpIHtcbiAgdmFyIGFmdGVyUmVtb3ZhbCA9IHJlbW92ZVRleHRXaXRoU3RyYXRlZ3koZWRpdG9yU3RhdGUsIGZ1bmN0aW9uIChzdHJhdGVneVN0YXRlKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHN0cmF0ZWd5U3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG4gICAgdmFyIGNvbnRlbnQgPSBzdHJhdGVneVN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG4gICAgdmFyIGtleSA9IHNlbGVjdGlvbi5nZXRBbmNob3JLZXkoKTtcbiAgICB2YXIgb2Zmc2V0ID0gc2VsZWN0aW9uLmdldEFuY2hvck9mZnNldCgpO1xuICAgIHZhciBjaGFyQWhlYWQgPSBjb250ZW50LmdldEJsb2NrRm9yS2V5KGtleSkuZ2V0VGV4dCgpW29mZnNldF07XG4gICAgcmV0dXJuIG1vdmVTZWxlY3Rpb25Gb3J3YXJkKHN0cmF0ZWd5U3RhdGUsIGNoYXJBaGVhZCA/IFVuaWNvZGVVdGlscy5nZXRVVEYxNkxlbmd0aChjaGFyQWhlYWQsIDApIDogMSk7XG4gIH0sICdmb3J3YXJkJyk7XG5cbiAgaWYgKGFmdGVyUmVtb3ZhbCA9PT0gZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKSkge1xuICAgIHJldHVybiBlZGl0b3JTdGF0ZTtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKTtcblxuICByZXR1cm4gRWRpdG9yU3RhdGUucHVzaChlZGl0b3JTdGF0ZSwgYWZ0ZXJSZW1vdmFsLnNldCgnc2VsZWN0aW9uQmVmb3JlJywgc2VsZWN0aW9uKSwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgPyAnZGVsZXRlLWNoYXJhY3RlcicgOiAncmVtb3ZlLXJhbmdlJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5Q29tbWFuZFBsYWluRGVsZXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9rZXlDb21tYW5kUGxhaW5EZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5Q29tbWFuZFRyYW5zcG9zZUNoYXJhY3RlcnNcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERyYWZ0TW9kaWZpZXIgPSByZXF1aXJlKCcuL0RyYWZ0TW9kaWZpZXInKTtcbnZhciBFZGl0b3JTdGF0ZSA9IHJlcXVpcmUoJy4vRWRpdG9yU3RhdGUnKTtcblxudmFyIGdldENvbnRlbnRTdGF0ZUZyYWdtZW50ID0gcmVxdWlyZSgnLi9nZXRDb250ZW50U3RhdGVGcmFnbWVudCcpO1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgY2hhcmFjdGVycyBvbiBlaXRoZXIgc2lkZSBvZiBhIGNvbGxhcHNlZCBjdXJzb3IsIG9yXG4gKiBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGJsb2NrLCB0cmFuc3Bvc2UgdGhlIGxhc3QgdHdvXG4gKiBjaGFyYWN0ZXJzLlxuICovXG5mdW5jdGlvbiBrZXlDb21tYW5kVHJhbnNwb3NlQ2hhcmFjdGVycyhlZGl0b3JTdGF0ZSkge1xuICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gIH1cblxuICB2YXIgb2Zmc2V0ID0gc2VsZWN0aW9uLmdldEFuY2hvck9mZnNldCgpO1xuICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgcmV0dXJuIGVkaXRvclN0YXRlO1xuICB9XG5cbiAgdmFyIGJsb2NrS2V5ID0gc2VsZWN0aW9uLmdldEFuY2hvcktleSgpO1xuICB2YXIgY29udGVudCA9IGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCk7XG4gIHZhciBibG9jayA9IGNvbnRlbnQuZ2V0QmxvY2tGb3JLZXkoYmxvY2tLZXkpO1xuICB2YXIgbGVuZ3RoID0gYmxvY2suZ2V0TGVuZ3RoKCk7XG5cbiAgLy8gTm90aGluZyB0byB0cmFuc3Bvc2UgaWYgdGhlcmUgYXJlbid0IHR3byBjaGFyYWN0ZXJzLlxuICBpZiAobGVuZ3RoIDw9IDEpIHtcbiAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gIH1cblxuICB2YXIgcmVtb3ZhbFJhbmdlO1xuICB2YXIgZmluYWxTZWxlY3Rpb247XG5cbiAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgLy8gVGhlIGN1cnNvciBpcyBhdCB0aGUgZW5kIG9mIHRoZSBibG9jay4gU3dhcCB0aGUgbGFzdCB0d28gY2hhcmFjdGVycy5cbiAgICByZW1vdmFsUmFuZ2UgPSBzZWxlY3Rpb24uc2V0KCdhbmNob3JPZmZzZXQnLCBvZmZzZXQgLSAxKTtcbiAgICBmaW5hbFNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmFsUmFuZ2UgPSBzZWxlY3Rpb24uc2V0KCdmb2N1c09mZnNldCcsIG9mZnNldCArIDEpO1xuICAgIGZpbmFsU2VsZWN0aW9uID0gcmVtb3ZhbFJhbmdlLnNldCgnYW5jaG9yT2Zmc2V0Jywgb2Zmc2V0ICsgMSk7XG4gIH1cblxuICAvLyBFeHRyYWN0IHRoZSBjaGFyYWN0ZXIgdG8gbW92ZSBhcyBhIGZyYWdtZW50LiBUaGlzIHByZXNlcnZlcyBpdHNcbiAgLy8gc3R5bGluZyBhbmQgZW50aXR5LCBpZiBhbnkuXG4gIHZhciBtb3ZlZEZyYWdtZW50ID0gZ2V0Q29udGVudFN0YXRlRnJhZ21lbnQoY29udGVudCwgcmVtb3ZhbFJhbmdlKTtcbiAgdmFyIGFmdGVyUmVtb3ZhbCA9IERyYWZ0TW9kaWZpZXIucmVtb3ZlUmFuZ2UoY29udGVudCwgcmVtb3ZhbFJhbmdlLCAnYmFja3dhcmQnKTtcblxuICAvLyBBZnRlciB0aGUgcmVtb3ZhbCwgdGhlIGluc2VydGlvbiB0YXJnZXQgaXMgb25lIGNoYXJhY3RlciBiYWNrLlxuICB2YXIgc2VsZWN0aW9uQWZ0ZXIgPSBhZnRlclJlbW92YWwuZ2V0U2VsZWN0aW9uQWZ0ZXIoKTtcbiAgdmFyIHRhcmdldE9mZnNldCA9IHNlbGVjdGlvbkFmdGVyLmdldEFuY2hvck9mZnNldCgpIC0gMTtcbiAgdmFyIHRhcmdldFJhbmdlID0gc2VsZWN0aW9uQWZ0ZXIubWVyZ2Uoe1xuICAgIGFuY2hvck9mZnNldDogdGFyZ2V0T2Zmc2V0LFxuICAgIGZvY3VzT2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSk7XG5cbiAgdmFyIGFmdGVySW5zZXJ0ID0gRHJhZnRNb2RpZmllci5yZXBsYWNlV2l0aEZyYWdtZW50KGFmdGVyUmVtb3ZhbCwgdGFyZ2V0UmFuZ2UsIG1vdmVkRnJhZ21lbnQpO1xuXG4gIHZhciBuZXdFZGl0b3JTdGF0ZSA9IEVkaXRvclN0YXRlLnB1c2goZWRpdG9yU3RhdGUsIGFmdGVySW5zZXJ0LCAnaW5zZXJ0LWZyYWdtZW50Jyk7XG5cbiAgcmV0dXJuIEVkaXRvclN0YXRlLmFjY2VwdFNlbGVjdGlvbihuZXdFZGl0b3JTdGF0ZSwgZmluYWxTZWxlY3Rpb24pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleUNvbW1hbmRUcmFuc3Bvc2VDaGFyYWN0ZXJzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9rZXlDb21tYW5kVHJhbnNwb3NlQ2hhcmFjdGVycy5qc1xuLy8gbW9kdWxlIGlkID0gNDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBrZXlDb21tYW5kVW5kb1xuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRWRpdG9yU3RhdGUgPSByZXF1aXJlKCcuL0VkaXRvclN0YXRlJyk7XG5cbmZ1bmN0aW9uIGtleUNvbW1hbmRVbmRvKGUsIGVkaXRvclN0YXRlLCB1cGRhdGVGbikge1xuICB2YXIgdW5kb25lU3RhdGUgPSBFZGl0b3JTdGF0ZS51bmRvKGVkaXRvclN0YXRlKTtcblxuICAvLyBJZiB0aGUgbGFzdCBjaGFuZ2UgdG8gb2NjdXIgd2FzIGEgc3BlbGxjaGVjayBjaGFuZ2UsIGFsbG93IHRoZSB1bmRvXG4gIC8vIGV2ZW50IHRvIGZhbGwgdGhyb3VnaCB0byB0aGUgYnJvd3Nlci4gVGhpcyBhbGxvd3MgdGhlIGJyb3dzZXIgdG8gcmVjb3JkXG4gIC8vIHRoZSB1bndhbnRlZCBjaGFuZ2UsIHdoaWNoIHNob3VsZCBzb29uIGxlYWQgaXQgdG8gbGVhcm4gbm90IHRvIHN1Z2dlc3RcbiAgLy8gdGhlIGNvcnJlY3Rpb24gYWdhaW4uXG4gIGlmIChlZGl0b3JTdGF0ZS5nZXRMYXN0Q2hhbmdlVHlwZSgpID09PSAnc3BlbGxjaGVjay1jaGFuZ2UnKSB7XG4gICAgdmFyIG5hdGl2ZWx5UmVuZGVyZWRDb250ZW50ID0gdW5kb25lU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKTtcbiAgICB1cGRhdGVGbihFZGl0b3JTdGF0ZS5zZXQodW5kb25lU3RhdGUsIHsgbmF0aXZlbHlSZW5kZXJlZENvbnRlbnQ6IG5hdGl2ZWx5UmVuZGVyZWRDb250ZW50IH0pKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBPdGhlcml3c2UsIG1hbmFnZSB0aGUgdW5kbyBiZWhhdmlvciBtYW51YWxseS5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICBpZiAoIWVkaXRvclN0YXRlLmdldE5hdGl2ZWx5UmVuZGVyZWRDb250ZW50KCkpIHtcbiAgICB1cGRhdGVGbih1bmRvbmVTdGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVHJpZ2dlciBhIHJlLXJlbmRlciB3aXRoIHRoZSBjdXJyZW50IGNvbnRlbnQgc3RhdGUgdG8gZW5zdXJlIHRoYXQgdGhlXG4gIC8vIGNvbXBvbmVudCB0cmVlIGhhcyB1cC10by1kYXRlIHByb3BzIGZvciBjb21wYXJpc29uLlxuICB1cGRhdGVGbihFZGl0b3JTdGF0ZS5zZXQoZWRpdG9yU3RhdGUsIHsgbmF0aXZlbHlSZW5kZXJlZENvbnRlbnQ6IG51bGwgfSkpO1xuXG4gIC8vIFdhaXQgdG8gZW5zdXJlIHRoYXQgdGhlIHJlLXJlbmRlciBoYXMgb2NjdXJyZWQgYmVmb3JlIHBlcmZvcm1pbmdcbiAgLy8gdGhlIHVuZG8gYWN0aW9uLlxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB1cGRhdGVGbih1bmRvbmVTdGF0ZSk7XG4gIH0sIDApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleUNvbW1hbmRVbmRvO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9rZXlDb21tYW5kVW5kby5qc1xuLy8gbW9kdWxlIGlkID0gNDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlZGl0T25QYXN0ZVxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmxvY2tNYXBCdWlsZGVyID0gcmVxdWlyZSgnLi9CbG9ja01hcEJ1aWxkZXInKTtcbnZhciBDaGFyYWN0ZXJNZXRhZGF0YSA9IHJlcXVpcmUoJy4vQ2hhcmFjdGVyTWV0YWRhdGEnKTtcbnZhciBEYXRhVHJhbnNmZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9EYXRhVHJhbnNmZXInKTtcbnZhciBEcmFmdE1vZGlmaWVyID0gcmVxdWlyZSgnLi9EcmFmdE1vZGlmaWVyJyk7XG52YXIgRHJhZnRQYXN0ZVByb2Nlc3NvciA9IHJlcXVpcmUoJy4vRHJhZnRQYXN0ZVByb2Nlc3NvcicpO1xudmFyIEVkaXRvclN0YXRlID0gcmVxdWlyZSgnLi9FZGl0b3JTdGF0ZScpO1xudmFyIFJpY2hUZXh0RWRpdG9yVXRpbCA9IHJlcXVpcmUoJy4vUmljaFRleHRFZGl0b3JVdGlsJyk7XG5cbnZhciBnZXRFbnRpdHlLZXlGb3JTZWxlY3Rpb24gPSByZXF1aXJlKCcuL2dldEVudGl0eUtleUZvclNlbGVjdGlvbicpO1xudmFyIGdldFRleHRDb250ZW50RnJvbUZpbGVzID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEZyb21GaWxlcycpO1xudmFyIGlzRXZlbnRIYW5kbGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50SGFuZGxlZCcpO1xudmFyIHNwbGl0VGV4dEludG9UZXh0QmxvY2tzID0gcmVxdWlyZSgnLi9zcGxpdFRleHRJbnRvVGV4dEJsb2NrcycpO1xuXG4vKipcbiAqIFBhc3RlIGNvbnRlbnQuXG4gKi9cbmZ1bmN0aW9uIGVkaXRPblBhc3RlKGVkaXRvciwgZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIHZhciBkYXRhID0gbmV3IERhdGFUcmFuc2ZlcihlLmNsaXBib2FyZERhdGEpO1xuXG4gIC8vIEdldCBmaWxlcywgdW5sZXNzIHRoaXMgaXMgbGlrZWx5IHRvIGJlIGEgc3RyaW5nIHRoZSB1c2VyIHdhbnRzIGlubGluZS5cbiAgaWYgKCFkYXRhLmlzUmljaFRleHQoKSkge1xuICAgIHZhciBmaWxlcyA9IGRhdGEuZ2V0RmlsZXMoKTtcbiAgICB2YXIgZGVmYXVsdEZpbGVUZXh0ID0gZGF0YS5nZXRUZXh0KCk7XG4gICAgaWYgKGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEFsbG93IGN1c3RvbWl6ZWQgcGFzdGUgaGFuZGxpbmcgZm9yIGltYWdlcywgZXRjLiBPdGhlcndpc2UsIGZhbGxcbiAgICAgIC8vIHRocm91Z2ggdG8gaW5zZXJ0IHRleHQgY29udGVudHMgaW50byB0aGUgZWRpdG9yLlxuICAgICAgaWYgKGVkaXRvci5wcm9wcy5oYW5kbGVQYXN0ZWRGaWxlcyAmJiBpc0V2ZW50SGFuZGxlZChlZGl0b3IucHJvcHMuaGFuZGxlUGFzdGVkRmlsZXMoZmlsZXMpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGdldFRleHRDb250ZW50RnJvbUZpbGVzKGZpbGVzLCBmdW5jdGlvbiAoIC8qc3RyaW5nKi9maWxlVGV4dCkge1xuICAgICAgICBmaWxlVGV4dCA9IGZpbGVUZXh0IHx8IGRlZmF1bHRGaWxlVGV4dDtcbiAgICAgICAgaWYgKCFmaWxlVGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlZGl0b3JTdGF0ZSA9IGVkaXRvci5fbGF0ZXN0RWRpdG9yU3RhdGU7XG4gICAgICAgIHZhciBibG9ja3MgPSBzcGxpdFRleHRJbnRvVGV4dEJsb2NrcyhmaWxlVGV4dCk7XG4gICAgICAgIHZhciBjaGFyYWN0ZXIgPSBDaGFyYWN0ZXJNZXRhZGF0YS5jcmVhdGUoe1xuICAgICAgICAgIHN0eWxlOiBlZGl0b3JTdGF0ZS5nZXRDdXJyZW50SW5saW5lU3R5bGUoKSxcbiAgICAgICAgICBlbnRpdHk6IGdldEVudGl0eUtleUZvclNlbGVjdGlvbihlZGl0b3JTdGF0ZS5nZXRDdXJyZW50Q29udGVudCgpLCBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKSlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjdXJyZW50QmxvY2tUeXBlID0gUmljaFRleHRFZGl0b3JVdGlsLmdldEN1cnJlbnRCbG9ja1R5cGUoZWRpdG9yU3RhdGUpO1xuXG4gICAgICAgIHZhciB0ZXh0ID0gRHJhZnRQYXN0ZVByb2Nlc3Nvci5wcm9jZXNzVGV4dChibG9ja3MsIGNoYXJhY3RlciwgY3VycmVudEJsb2NrVHlwZSk7XG4gICAgICAgIHZhciBmcmFnbWVudCA9IEJsb2NrTWFwQnVpbGRlci5jcmVhdGVGcm9tQXJyYXkodGV4dCk7XG5cbiAgICAgICAgdmFyIHdpdGhJbnNlcnRlZFRleHQgPSBEcmFmdE1vZGlmaWVyLnJlcGxhY2VXaXRoRnJhZ21lbnQoZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKSwgZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCksIGZyYWdtZW50KTtcblxuICAgICAgICBlZGl0b3IudXBkYXRlKEVkaXRvclN0YXRlLnB1c2goZWRpdG9yU3RhdGUsIHdpdGhJbnNlcnRlZFRleHQsICdpbnNlcnQtZnJhZ21lbnQnKSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0ZXh0QmxvY2tzID0gW107XG4gIHZhciB0ZXh0ID0gZGF0YS5nZXRUZXh0KCk7XG4gIHZhciBodG1sID0gZGF0YS5nZXRIVE1MKCk7XG4gIHZhciBlZGl0b3JTdGF0ZSA9IGVkaXRvci5fbGF0ZXN0RWRpdG9yU3RhdGU7XG5cbiAgaWYgKGVkaXRvci5wcm9wcy5oYW5kbGVQYXN0ZWRUZXh0ICYmIGlzRXZlbnRIYW5kbGVkKGVkaXRvci5wcm9wcy5oYW5kbGVQYXN0ZWRUZXh0KHRleHQsIGh0bWwsIGVkaXRvclN0YXRlKSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGV4dCkge1xuICAgIHRleHRCbG9ja3MgPSBzcGxpdFRleHRJbnRvVGV4dEJsb2Nrcyh0ZXh0KTtcbiAgfVxuXG4gIGlmICghZWRpdG9yLnByb3BzLnN0cmlwUGFzdGVkU3R5bGVzKSB7XG4gICAgLy8gSWYgdGhlIHRleHQgZnJvbSB0aGUgcGFzdGUgZXZlbnQgaXMgcmljaCBjb250ZW50IHRoYXQgbWF0Y2hlcyB3aGF0IHdlXG4gICAgLy8gYWxyZWFkeSBoYXZlIG9uIHRoZSBpbnRlcm5hbCBjbGlwYm9hcmQsIGFzc3VtZSB0aGF0IHdlIHNob3VsZCBqdXN0IHVzZVxuICAgIC8vIHRoZSBjbGlwYm9hcmQgZnJhZ21lbnQgZm9yIHRoZSBwYXN0ZS4gVGhpcyB3aWxsIGFsbG93IHVzIHRvIHByZXNlcnZlXG4gICAgLy8gc3R5bGluZyBhbmQgZW50aXRpZXMsIGlmIGFueSBhcmUgcHJlc2VudC4gTm90ZSB0aGF0IG5ld2xpbmVzIGFyZVxuICAgIC8vIHN0cmlwcGVkIGR1cmluZyBjb21wYXJpc29uIC0tIHRoaXMgaXMgYmVjYXVzZSBjb3B5L3Bhc3RlIHdpdGhpbiB0aGVcbiAgICAvLyBlZGl0b3IgaW4gRmlyZWZveCBhbmQgSUUgd2lsbCBub3QgaW5jbHVkZSBlbXB0eSBsaW5lcy4gVGhlIHJlc3VsdGluZ1xuICAgIC8vIHBhc3RlIHdpbGwgcHJlc2VydmUgdGhlIG5ld2xpbmVzIGNvcnJlY3RseS5cbiAgICB2YXIgaW50ZXJuYWxDbGlwYm9hcmQgPSBlZGl0b3IuZ2V0Q2xpcGJvYXJkKCk7XG4gICAgaWYgKGRhdGEuaXNSaWNoVGV4dCgpICYmIGludGVybmFsQ2xpcGJvYXJkKSB7XG4gICAgICBpZiAoXG4gICAgICAvLyBJZiB0aGUgZWRpdG9yS2V5IGlzIHByZXNlbnQgaW4gdGhlIHBhc3RlZCBIVE1MLCBpdCBzaG91bGQgYmUgc2FmZSB0b1xuICAgICAgLy8gYXNzdW1lIHRoaXMgaXMgYW4gaW50ZXJuYWwgcGFzdGUuXG4gICAgICBodG1sLmluZGV4T2YoZWRpdG9yLmdldEVkaXRvcktleSgpKSAhPT0gLTEgfHxcbiAgICAgIC8vIFRoZSBjb3B5IG1heSBoYXZlIGJlZW4gbWFkZSB3aXRoaW4gYSBzaW5nbGUgYmxvY2ssIGluIHdoaWNoIGNhc2UgdGhlXG4gICAgICAvLyBlZGl0b3Iga2V5IHdvbid0IGJlIHBhcnQgb2YgdGhlIHBhc3RlLiBJbiB0aGlzIGNhc2UsIGp1c3QgY2hlY2tcbiAgICAgIC8vIHdoZXRoZXIgdGhlIHBhc3RlZCB0ZXh0IG1hdGNoZXMgdGhlIGludGVybmFsIGNsaXBib2FyZC5cbiAgICAgIHRleHRCbG9ja3MubGVuZ3RoID09PSAxICYmIGludGVybmFsQ2xpcGJvYXJkLnNpemUgPT09IDEgJiYgaW50ZXJuYWxDbGlwYm9hcmQuZmlyc3QoKS5nZXRUZXh0KCkgPT09IHRleHQpIHtcbiAgICAgICAgZWRpdG9yLnVwZGF0ZShpbnNlcnRGcmFnbWVudChlZGl0b3IuX2xhdGVzdEVkaXRvclN0YXRlLCBpbnRlcm5hbENsaXBib2FyZCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbnRlcm5hbENsaXBib2FyZCAmJiBkYXRhLnR5cGVzLmluY2x1ZGVzKCdjb20uYXBwbGUud2ViYXJjaGl2ZScpICYmICFkYXRhLnR5cGVzLmluY2x1ZGVzKCd0ZXh0L2h0bWwnKSAmJiBhcmVUZXh0QmxvY2tzQW5kQ2xpcGJvYXJkRXF1YWwodGV4dEJsb2NrcywgaW50ZXJuYWxDbGlwYm9hcmQpKSB7XG4gICAgICAvLyBTYWZhcmkgZG9lcyBub3QgcHJvcGVybHkgc3RvcmUgdGV4dC9odG1sIGluIHNvbWUgY2FzZXMuXG4gICAgICAvLyBVc2UgdGhlIGludGVybmFsQ2xpcGJvYXJkIGlmIHByZXNlbnQgYW5kIGVxdWFsIHRvIHdoYXQgaXMgb25cbiAgICAgIC8vIHRoZSBjbGlwYm9hcmQuIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk4OTMuXG4gICAgICBlZGl0b3IudXBkYXRlKGluc2VydEZyYWdtZW50KGVkaXRvci5fbGF0ZXN0RWRpdG9yU3RhdGUsIGludGVybmFsQ2xpcGJvYXJkKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgaHRtbCBwYXN0ZSBkYXRhLCB0cnkgdG8gcGFyc2UgdGhhdC5cbiAgICBpZiAoaHRtbCkge1xuICAgICAgdmFyIGh0bWxGcmFnbWVudCA9IERyYWZ0UGFzdGVQcm9jZXNzb3IucHJvY2Vzc0hUTUwoaHRtbCwgZWRpdG9yLnByb3BzLmJsb2NrUmVuZGVyTWFwKTtcbiAgICAgIGlmIChodG1sRnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRCbG9ja3MgPSBodG1sRnJhZ21lbnQuY29udGVudEJsb2NrcyxcbiAgICAgICAgICAgIGVudGl0eU1hcCA9IGh0bWxGcmFnbWVudC5lbnRpdHlNYXA7XG5cbiAgICAgICAgaWYgKGNvbnRlbnRCbG9ja3MpIHtcbiAgICAgICAgICB2YXIgaHRtbE1hcCA9IEJsb2NrTWFwQnVpbGRlci5jcmVhdGVGcm9tQXJyYXkoY29udGVudEJsb2Nrcyk7XG4gICAgICAgICAgZWRpdG9yLnVwZGF0ZShpbnNlcnRGcmFnbWVudChlZGl0b3IuX2xhdGVzdEVkaXRvclN0YXRlLCBodG1sTWFwLCBlbnRpdHlNYXApKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhIG5ldyBmcmFnbWVudCBmcm9tIG91ciBwYXN0ZWQgdGV4dC4gQWxzb1xuICAgIC8vIGVtcHR5IHRoZSBpbnRlcm5hbCBjbGlwYm9hcmQsIHNpbmNlIGl0J3Mgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIGVkaXRvci5zZXRDbGlwYm9hcmQobnVsbCk7XG4gIH1cblxuICBpZiAodGV4dEJsb2Nrcy5sZW5ndGgpIHtcbiAgICB2YXIgY2hhcmFjdGVyID0gQ2hhcmFjdGVyTWV0YWRhdGEuY3JlYXRlKHtcbiAgICAgIHN0eWxlOiBlZGl0b3JTdGF0ZS5nZXRDdXJyZW50SW5saW5lU3R5bGUoKSxcbiAgICAgIGVudGl0eTogZ2V0RW50aXR5S2V5Rm9yU2VsZWN0aW9uKGVkaXRvclN0YXRlLmdldEN1cnJlbnRDb250ZW50KCksIGVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpKVxuICAgIH0pO1xuXG4gICAgdmFyIGN1cnJlbnRCbG9ja1R5cGUgPSBSaWNoVGV4dEVkaXRvclV0aWwuZ2V0Q3VycmVudEJsb2NrVHlwZShlZGl0b3JTdGF0ZSk7XG5cbiAgICB2YXIgdGV4dEZyYWdtZW50ID0gRHJhZnRQYXN0ZVByb2Nlc3Nvci5wcm9jZXNzVGV4dCh0ZXh0QmxvY2tzLCBjaGFyYWN0ZXIsIGN1cnJlbnRCbG9ja1R5cGUpO1xuXG4gICAgdmFyIHRleHRNYXAgPSBCbG9ja01hcEJ1aWxkZXIuY3JlYXRlRnJvbUFycmF5KHRleHRGcmFnbWVudCk7XG4gICAgZWRpdG9yLnVwZGF0ZShpbnNlcnRGcmFnbWVudChlZGl0b3IuX2xhdGVzdEVkaXRvclN0YXRlLCB0ZXh0TWFwKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0RnJhZ21lbnQoZWRpdG9yU3RhdGUsIGZyYWdtZW50LCBlbnRpdHlNYXApIHtcbiAgdmFyIG5ld0NvbnRlbnQgPSBEcmFmdE1vZGlmaWVyLnJlcGxhY2VXaXRoRnJhZ21lbnQoZWRpdG9yU3RhdGUuZ2V0Q3VycmVudENvbnRlbnQoKSwgZWRpdG9yU3RhdGUuZ2V0U2VsZWN0aW9uKCksIGZyYWdtZW50KTtcbiAgLy8gVE9ETzogbWVyZ2UgdGhlIGVudGl0eSBtYXAgb25jZSB3ZSBzdG9wIHVzaW5nIERyYWZ0RW50aXR5XG4gIC8vIGxpa2UgdGhpczpcbiAgLy8gY29uc3QgbWVyZ2VkRW50aXR5TWFwID0gbmV3Q29udGVudC5nZXRFbnRpdHlNYXAoKS5tZXJnZShlbnRpdHlNYXApO1xuXG4gIHJldHVybiBFZGl0b3JTdGF0ZS5wdXNoKGVkaXRvclN0YXRlLCBuZXdDb250ZW50LnNldCgnZW50aXR5TWFwJywgZW50aXR5TWFwKSwgJ2luc2VydC1mcmFnbWVudCcpO1xufVxuXG5mdW5jdGlvbiBhcmVUZXh0QmxvY2tzQW5kQ2xpcGJvYXJkRXF1YWwodGV4dEJsb2NrcywgYmxvY2tNYXApIHtcbiAgcmV0dXJuIHRleHRCbG9ja3MubGVuZ3RoID09PSBibG9ja01hcC5zaXplICYmIGJsb2NrTWFwLnZhbHVlU2VxKCkuZXZlcnkoZnVuY3Rpb24gKGJsb2NrLCBpaSkge1xuICAgIHJldHVybiBibG9jay5nZXRUZXh0KCkgPT09IHRleHRCbG9ja3NbaWldO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlZGl0T25QYXN0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZWRpdE9uUGFzdGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRHJhZnRQYXN0ZVByb2Nlc3NvclxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9leHRlbmRzID0gX2Fzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIENoYXJhY3Rlck1ldGFkYXRhID0gcmVxdWlyZSgnLi9DaGFyYWN0ZXJNZXRhZGF0YScpO1xudmFyIENvbnRlbnRCbG9jayA9IHJlcXVpcmUoJy4vQ29udGVudEJsb2NrJyk7XG52YXIgQ29udGVudEJsb2NrTm9kZSA9IHJlcXVpcmUoJy4vQ29udGVudEJsb2NrTm9kZScpO1xudmFyIERyYWZ0RmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9EcmFmdEZlYXR1cmVGbGFncycpO1xudmFyIEltbXV0YWJsZSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xuXG52YXIgY29udmVydEZyb21IVE1MdG9Db250ZW50QmxvY2tzID0gcmVxdWlyZSgnLi9jb252ZXJ0RnJvbUhUTUxUb0NvbnRlbnRCbG9ja3MnKTtcbnZhciBnZW5lcmF0ZVJhbmRvbUtleSA9IHJlcXVpcmUoJy4vZ2VuZXJhdGVSYW5kb21LZXknKTtcbnZhciBnZXRTYWZlQm9keUZyb21IVE1MID0gcmVxdWlyZSgnLi9nZXRTYWZlQm9keUZyb21IVE1MJyk7XG52YXIgc2FuaXRpemVEcmFmdFRleHQgPSByZXF1aXJlKCcuL3Nhbml0aXplRHJhZnRUZXh0Jyk7XG5cbnZhciBMaXN0ID0gSW1tdXRhYmxlLkxpc3QsXG4gICAgUmVwZWF0ID0gSW1tdXRhYmxlLlJlcGVhdDtcblxuXG52YXIgZXhwZXJpbWVudGFsVHJlZURhdGFTdXBwb3J0ID0gRHJhZnRGZWF0dXJlRmxhZ3MuZHJhZnRfdHJlZV9kYXRhX3N1cHBvcnQ7XG52YXIgQ29udGVudEJsb2NrUmVjb3JkID0gZXhwZXJpbWVudGFsVHJlZURhdGFTdXBwb3J0ID8gQ29udGVudEJsb2NrTm9kZSA6IENvbnRlbnRCbG9jaztcblxudmFyIERyYWZ0UGFzdGVQcm9jZXNzb3IgPSB7XG4gIHByb2Nlc3NIVE1MOiBmdW5jdGlvbiBwcm9jZXNzSFRNTChodG1sLCBibG9ja1JlbmRlck1hcCkge1xuICAgIHJldHVybiBjb252ZXJ0RnJvbUhUTUx0b0NvbnRlbnRCbG9ja3MoaHRtbCwgZ2V0U2FmZUJvZHlGcm9tSFRNTCwgYmxvY2tSZW5kZXJNYXApO1xuICB9LFxuICBwcm9jZXNzVGV4dDogZnVuY3Rpb24gcHJvY2Vzc1RleHQodGV4dEJsb2NrcywgY2hhcmFjdGVyLCB0eXBlKSB7XG4gICAgcmV0dXJuIHRleHRCbG9ja3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHRleHRMaW5lLCBpbmRleCkge1xuICAgICAgdGV4dExpbmUgPSBzYW5pdGl6ZURyYWZ0VGV4dCh0ZXh0TGluZSk7XG4gICAgICB2YXIga2V5ID0gZ2VuZXJhdGVSYW5kb21LZXkoKTtcblxuICAgICAgdmFyIGJsb2NrTm9kZUNvbmZpZyA9IHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHRleHQ6IHRleHRMaW5lLFxuICAgICAgICBjaGFyYWN0ZXJMaXN0OiBMaXN0KFJlcGVhdChjaGFyYWN0ZXIsIHRleHRMaW5lLmxlbmd0aCkpXG4gICAgICB9O1xuXG4gICAgICAvLyBuZXh0IGJsb2NrIHVwZGF0ZXMgcHJldmlvdXMgYmxvY2tcbiAgICAgIGlmIChleHBlcmltZW50YWxUcmVlRGF0YVN1cHBvcnQgJiYgaW5kZXggIT09IDApIHtcbiAgICAgICAgdmFyIHByZXZTaWJsaW5nSW5kZXggPSBpbmRleCAtIDE7XG4gICAgICAgIC8vIHVwZGF0ZSBwcmV2aW91cyBibG9ja1xuICAgICAgICB2YXIgcHJldmlvdXNCbG9jayA9IGFjY1twcmV2U2libGluZ0luZGV4XSA9IGFjY1twcmV2U2libGluZ0luZGV4XS5tZXJnZSh7XG4gICAgICAgICAgbmV4dFNpYmxpbmc6IGtleVxuICAgICAgICB9KTtcbiAgICAgICAgYmxvY2tOb2RlQ29uZmlnID0gX2V4dGVuZHMoe30sIGJsb2NrTm9kZUNvbmZpZywge1xuICAgICAgICAgIHByZXZTaWJsaW5nOiBwcmV2aW91c0Jsb2NrLmdldEtleSgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBhY2MucHVzaChuZXcgQ29udGVudEJsb2NrUmVjb3JkKGJsb2NrTm9kZUNvbmZpZykpO1xuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFmdFBhc3RlUHJvY2Vzc29yO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdFBhc3RlUHJvY2Vzc29yLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFVSSSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVVJJKHVyaSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVUkkpO1xuXG4gICAgdGhpcy5fdXJpID0gdXJpO1xuICB9XG5cbiAgVVJJLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl91cmk7XG4gIH07XG5cbiAgcmV0dXJuIFVSSTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBVUkk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvVVJJLmpzXG4vLyBtb2R1bGUgaWQgPSA0NThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGFkanVzdEJsb2NrRGVwdGhGb3JDb250ZW50U3RhdGVcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYWRqdXN0QmxvY2tEZXB0aEZvckNvbnRlbnRTdGF0ZShjb250ZW50U3RhdGUsIHNlbGVjdGlvblN0YXRlLCBhZGp1c3RtZW50LCBtYXhEZXB0aCkge1xuICB2YXIgc3RhcnRLZXkgPSBzZWxlY3Rpb25TdGF0ZS5nZXRTdGFydEtleSgpO1xuICB2YXIgZW5kS2V5ID0gc2VsZWN0aW9uU3RhdGUuZ2V0RW5kS2V5KCk7XG4gIHZhciBibG9ja01hcCA9IGNvbnRlbnRTdGF0ZS5nZXRCbG9ja01hcCgpO1xuICB2YXIgYmxvY2tzID0gYmxvY2tNYXAudG9TZXEoKS5za2lwVW50aWwoZnVuY3Rpb24gKF8sIGspIHtcbiAgICByZXR1cm4gayA9PT0gc3RhcnRLZXk7XG4gIH0pLnRha2VVbnRpbChmdW5jdGlvbiAoXywgaykge1xuICAgIHJldHVybiBrID09PSBlbmRLZXk7XG4gIH0pLmNvbmNhdChbW2VuZEtleSwgYmxvY2tNYXAuZ2V0KGVuZEtleSldXSkubWFwKGZ1bmN0aW9uIChibG9jaykge1xuICAgIHZhciBkZXB0aCA9IGJsb2NrLmdldERlcHRoKCkgKyBhZGp1c3RtZW50O1xuICAgIGRlcHRoID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGVwdGgsIG1heERlcHRoKSk7XG4gICAgcmV0dXJuIGJsb2NrLnNldCgnZGVwdGgnLCBkZXB0aCk7XG4gIH0pO1xuXG4gIGJsb2NrTWFwID0gYmxvY2tNYXAubWVyZ2UoYmxvY2tzKTtcblxuICByZXR1cm4gY29udGVudFN0YXRlLm1lcmdlKHtcbiAgICBibG9ja01hcDogYmxvY2tNYXAsXG4gICAgc2VsZWN0aW9uQmVmb3JlOiBzZWxlY3Rpb25TdGF0ZSxcbiAgICBzZWxlY3Rpb25BZnRlcjogc2VsZWN0aW9uU3RhdGVcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRqdXN0QmxvY2tEZXB0aEZvckNvbnRlbnRTdGF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvYWRqdXN0QmxvY2tEZXB0aEZvckNvbnRlbnRTdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzcGxpdFRleHRJbnRvVGV4dEJsb2Nrc1xuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTkVXTElORV9SRUdFWCA9IC9cXHJcXG4/fFxcbi9nO1xuXG5mdW5jdGlvbiBzcGxpdFRleHRJbnRvVGV4dEJsb2Nrcyh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnNwbGl0KE5FV0xJTkVfUkVHRVgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNwbGl0VGV4dEludG9UZXh0QmxvY2tzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9zcGxpdFRleHRJbnRvVGV4dEJsb2Nrcy5qc1xuLy8gbW9kdWxlIGlkID0gNDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlZGl0T25TZWxlY3RcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVkaXRvclN0YXRlID0gcmVxdWlyZSgnLi9FZGl0b3JTdGF0ZScpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBnZXREcmFmdEVkaXRvclNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vZ2V0RHJhZnRFZGl0b3JTZWxlY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuZnVuY3Rpb24gZWRpdE9uU2VsZWN0KGVkaXRvcikge1xuICBpZiAoZWRpdG9yLl9ibG9ja1NlbGVjdEV2ZW50cyB8fCBlZGl0b3IuX2xhdGVzdEVkaXRvclN0YXRlICE9PSBlZGl0b3IucHJvcHMuZWRpdG9yU3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZWRpdG9yU3RhdGUgPSBlZGl0b3IucHJvcHMuZWRpdG9yU3RhdGU7XG4gIHZhciBlZGl0b3JOb2RlID0gUmVhY3RET00uZmluZERPTU5vZGUoZWRpdG9yLmVkaXRvckNvbnRhaW5lcik7XG4gICFlZGl0b3JOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc3NpbmcgZWRpdG9yTm9kZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIShlZGl0b3JOb2RlLmZpcnN0Q2hpbGQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZWRpdG9yTm9kZS5maXJzdENoaWxkIGlzIG5vdCBhbiBIVE1MRWxlbWVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIGRvY3VtZW50U2VsZWN0aW9uID0gZ2V0RHJhZnRFZGl0b3JTZWxlY3Rpb24oZWRpdG9yU3RhdGUsIGVkaXRvck5vZGUuZmlyc3RDaGlsZCk7XG4gIHZhciB1cGRhdGVkU2VsZWN0aW9uU3RhdGUgPSBkb2N1bWVudFNlbGVjdGlvbi5zZWxlY3Rpb25TdGF0ZTtcblxuICBpZiAodXBkYXRlZFNlbGVjdGlvblN0YXRlICE9PSBlZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKSkge1xuICAgIGlmIChkb2N1bWVudFNlbGVjdGlvbi5uZWVkc1JlY292ZXJ5KSB7XG4gICAgICBlZGl0b3JTdGF0ZSA9IEVkaXRvclN0YXRlLmZvcmNlU2VsZWN0aW9uKGVkaXRvclN0YXRlLCB1cGRhdGVkU2VsZWN0aW9uU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3JTdGF0ZSA9IEVkaXRvclN0YXRlLmFjY2VwdFNlbGVjdGlvbihlZGl0b3JTdGF0ZSwgdXBkYXRlZFNlbGVjdGlvblN0YXRlKTtcbiAgICB9XG4gICAgZWRpdG9yLnVwZGF0ZShlZGl0b3JTdGF0ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlZGl0T25TZWxlY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2VkaXRPblNlbGVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXREcmFmdEVkaXRvclNlbGVjdGlvblxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RHJhZnRFZGl0b3JTZWxlY3Rpb25XaXRoTm9kZXMgPSByZXF1aXJlKCcuL2dldERyYWZ0RWRpdG9yU2VsZWN0aW9uV2l0aE5vZGVzJyk7XG5cbi8qKlxuICogQ29udmVydCB0aGUgY3VycmVudCBzZWxlY3Rpb24gcmFuZ2UgdG8gYW4gYW5jaG9yL2ZvY3VzIHBhaXIgb2Ygb2Zmc2V0IGtleXNcbiAqIGFuZCB2YWx1ZXMgdGhhdCBjYW4gYmUgaW50ZXJwcmV0ZWQgYnkgY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gZ2V0RHJhZnRFZGl0b3JTZWxlY3Rpb24oZWRpdG9yU3RhdGUsIHJvb3QpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGdsb2JhbC5nZXRTZWxlY3Rpb24oKTtcblxuICAvLyBObyBhY3RpdmUgc2VsZWN0aW9uLlxuICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0aW9uU3RhdGU6IGVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpLnNldCgnaGFzRm9jdXMnLCBmYWxzZSksXG4gICAgICBuZWVkc1JlY292ZXJ5OiBmYWxzZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZ2V0RHJhZnRFZGl0b3JTZWxlY3Rpb25XaXRoTm9kZXMoZWRpdG9yU3RhdGUsIHJvb3QsIHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LCBzZWxlY3Rpb24uZm9jdXNOb2RlLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldERyYWZ0RWRpdG9yU2VsZWN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXREcmFmdEVkaXRvclNlbGVjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEcmFmdEVkaXRvclBsYWNlaG9sZGVyLnJlYWN0XG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIGN4ID0gcmVxdWlyZSgnZmJqcy9saWIvY3gnKTtcblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIHBsYWNlaG9sZGVyIHRleHQgZm9yIHRoZVxuICogYERyYWZ0RWRpdG9yYCBjb21wb25lbnQuXG4gKlxuICogT3ZlcnJpZGUgcGxhY2Vob2xkZXIgc3R5bGUgdmlhIENTUy5cbiAqL1xudmFyIERyYWZ0RWRpdG9yUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRHJhZnRFZGl0b3JQbGFjZWhvbGRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRHJhZnRFZGl0b3JQbGFjZWhvbGRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhZnRFZGl0b3JQbGFjZWhvbGRlcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIERyYWZ0RWRpdG9yUGxhY2Vob2xkZXIucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy50ZXh0ICE9PSBuZXh0UHJvcHMudGV4dCB8fCB0aGlzLnByb3BzLmVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpLmdldEhhc0ZvY3VzKCkgIT09IG5leHRQcm9wcy5lZGl0b3JTdGF0ZS5nZXRTZWxlY3Rpb24oKS5nZXRIYXNGb2N1cygpO1xuICB9O1xuXG4gIERyYWZ0RWRpdG9yUGxhY2Vob2xkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgaGFzRm9jdXMgPSB0aGlzLnByb3BzLmVkaXRvclN0YXRlLmdldFNlbGVjdGlvbigpLmdldEhhc0ZvY3VzKCk7XG5cbiAgICB2YXIgY2xhc3NOYW1lID0gY3goe1xuICAgICAgJ3B1YmxpYy9EcmFmdEVkaXRvclBsYWNlaG9sZGVyL3Jvb3QnOiB0cnVlLFxuICAgICAgJ3B1YmxpYy9EcmFmdEVkaXRvclBsYWNlaG9sZGVyL2hhc0ZvY3VzJzogaGFzRm9jdXNcbiAgICB9KTtcblxuICAgIHZhciBjb250ZW50U3R5bGUgPSB7XG4gICAgICB3aGl0ZVNwYWNlOiAncHJlLXdyYXAnXG4gICAgfTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogY3goJ3B1YmxpYy9EcmFmdEVkaXRvclBsYWNlaG9sZGVyL2lubmVyJyksXG4gICAgICAgICAgaWQ6IHRoaXMucHJvcHMuYWNjZXNzaWJpbGl0eUlELFxuICAgICAgICAgIHN0eWxlOiBjb250ZW50U3R5bGUgfSxcbiAgICAgICAgdGhpcy5wcm9wcy50ZXh0XG4gICAgICApXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gRHJhZnRFZGl0b3JQbGFjZWhvbGRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFmdEVkaXRvclBsYWNlaG9sZGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9EcmFmdEVkaXRvclBsYWNlaG9sZGVyLnJlYWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNvbnZlcnRGcm9tRHJhZnRTdGF0ZVRvUmF3XG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX2V4dGVuZHMgPSBfYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgQ29udGVudEJsb2NrID0gcmVxdWlyZSgnLi9Db250ZW50QmxvY2snKTtcbnZhciBDb250ZW50QmxvY2tOb2RlID0gcmVxdWlyZSgnLi9Db250ZW50QmxvY2tOb2RlJyk7XG52YXIgRHJhZnRTdHJpbmdLZXkgPSByZXF1aXJlKCcuL0RyYWZ0U3RyaW5nS2V5Jyk7XG5cbnZhciBlbmNvZGVFbnRpdHlSYW5nZXMgPSByZXF1aXJlKCcuL2VuY29kZUVudGl0eVJhbmdlcycpO1xudmFyIGVuY29kZUlubGluZVN0eWxlUmFuZ2VzID0gcmVxdWlyZSgnLi9lbmNvZGVJbmxpbmVTdHlsZVJhbmdlcycpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgY3JlYXRlUmF3QmxvY2sgPSBmdW5jdGlvbiBjcmVhdGVSYXdCbG9jayhibG9jaywgZW50aXR5U3RvcmFnZU1hcCkge1xuICByZXR1cm4ge1xuICAgIGtleTogYmxvY2suZ2V0S2V5KCksXG4gICAgdGV4dDogYmxvY2suZ2V0VGV4dCgpLFxuICAgIHR5cGU6IGJsb2NrLmdldFR5cGUoKSxcbiAgICBkZXB0aDogYmxvY2suZ2V0RGVwdGgoKSxcbiAgICBpbmxpbmVTdHlsZVJhbmdlczogZW5jb2RlSW5saW5lU3R5bGVSYW5nZXMoYmxvY2spLFxuICAgIGVudGl0eVJhbmdlczogZW5jb2RlRW50aXR5UmFuZ2VzKGJsb2NrLCBlbnRpdHlTdG9yYWdlTWFwKSxcbiAgICBkYXRhOiBibG9jay5nZXREYXRhKCkudG9PYmplY3QoKVxuICB9O1xufTtcblxudmFyIGluc2VydFJhd0Jsb2NrID0gZnVuY3Rpb24gaW5zZXJ0UmF3QmxvY2soYmxvY2ssIGVudGl0eU1hcCwgcmF3QmxvY2tzLCBibG9ja0NhY2hlUmVmKSB7XG4gIGlmIChibG9jayBpbnN0YW5jZW9mIENvbnRlbnRCbG9jaykge1xuICAgIHJhd0Jsb2Nrcy5wdXNoKGNyZWF0ZVJhd0Jsb2NrKGJsb2NrLCBlbnRpdHlNYXApKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAhKGJsb2NrIGluc3RhbmNlb2YgQ29udGVudEJsb2NrTm9kZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYmxvY2sgaXMgbm90IGEgQmxvY2tOb2RlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIHZhciBwYXJlbnRLZXkgPSBibG9jay5nZXRQYXJlbnRLZXkoKTtcbiAgdmFyIHJhd0Jsb2NrID0gYmxvY2tDYWNoZVJlZltibG9jay5nZXRLZXkoKV0gPSBfZXh0ZW5kcyh7fSwgY3JlYXRlUmF3QmxvY2soYmxvY2ssIGVudGl0eU1hcCksIHtcbiAgICBjaGlsZHJlbjogW11cbiAgfSk7XG5cbiAgaWYgKHBhcmVudEtleSkge1xuICAgIGJsb2NrQ2FjaGVSZWZbcGFyZW50S2V5XS5jaGlsZHJlbi5wdXNoKHJhd0Jsb2NrKTtcbiAgICByZXR1cm47XG4gIH1cblxuICByYXdCbG9ja3MucHVzaChyYXdCbG9jayk7XG59O1xuXG52YXIgZW5jb2RlUmF3QmxvY2tzID0gZnVuY3Rpb24gZW5jb2RlUmF3QmxvY2tzKGNvbnRlbnRTdGF0ZSwgcmF3U3RhdGUpIHtcbiAgdmFyIGVudGl0eU1hcCA9IHJhd1N0YXRlLmVudGl0eU1hcDtcblxuXG4gIHZhciByYXdCbG9ja3MgPSBbXTtcblxuICB2YXIgYmxvY2tDYWNoZVJlZiA9IHt9O1xuICB2YXIgZW50aXR5Q2FjaGVSZWYgPSB7fTtcbiAgdmFyIGVudGl0eVN0b3JhZ2VLZXkgPSAwO1xuXG4gIGNvbnRlbnRTdGF0ZS5nZXRCbG9ja01hcCgpLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgYmxvY2suZmluZEVudGl0eVJhbmdlcyhmdW5jdGlvbiAoY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyLmdldEVudGl0eSgpICE9PSBudWxsO1xuICAgIH0sIGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgdmFyIGVudGl0eUtleSA9IGJsb2NrLmdldEVudGl0eUF0KHN0YXJ0KTtcbiAgICAgIC8vIFN0cmluZ2lmeSB0byBtYWludGFpbiBvcmRlciBvZiBvdGhlcndpc2UgbnVtZXJpYyBrZXlzLlxuICAgICAgdmFyIHN0cmluZ2lmaWVkRW50aXR5S2V5ID0gRHJhZnRTdHJpbmdLZXkuc3RyaW5naWZ5KGVudGl0eUtleSk7XG4gICAgICAvLyBUaGlzIG1ha2VzIHRoaXMgZnVuY3Rpb24gcmVzaWxpZW50IHRvIHR3byBlbnRpdGllc1xuICAgICAgLy8gZXJyb25lb3VzbHkgaGF2aW5nIHRoZSBzYW1lIGtleVxuICAgICAgaWYgKGVudGl0eUNhY2hlUmVmW3N0cmluZ2lmaWVkRW50aXR5S2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbnRpdHlDYWNoZVJlZltzdHJpbmdpZmllZEVudGl0eUtleV0gPSBlbnRpdHlLZXk7XG4gICAgICAvLyB3ZSBuZWVkIHRoZSBgYW55YCBjYXN0aW5nIGhlcmUgc2luY2UgdGhpcyBpcyBhIHRlbXBvcmFyeSBzdGF0ZVxuICAgICAgLy8gd2hlcmUgd2Ugd2lsbCBsYXRlciBvbiBmbGlwIHRoZSBlbnRpdHkgbWFwIGFuZCBwb3B1bGF0ZSBpdCB3aXRoXG4gICAgICAvLyByZWFsIGVudGl0eSwgYXQgdGhpcyBzdGFnZSB3ZSBqdXN0IG5lZWQgdG8gbWFwIGJhY2sgdGhlIGVudGl0eVxuICAgICAgLy8ga2V5IHVzZWQgYnkgdGhlIEJsb2NrTm9kZVxuICAgICAgZW50aXR5TWFwW3N0cmluZ2lmaWVkRW50aXR5S2V5XSA9ICcnICsgZW50aXR5U3RvcmFnZUtleTtcbiAgICAgIGVudGl0eVN0b3JhZ2VLZXkrKztcbiAgICB9KTtcblxuICAgIGluc2VydFJhd0Jsb2NrKGJsb2NrLCBlbnRpdHlNYXAsIHJhd0Jsb2NrcywgYmxvY2tDYWNoZVJlZik7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgYmxvY2tzOiByYXdCbG9ja3MsXG4gICAgZW50aXR5TWFwOiBlbnRpdHlNYXBcbiAgfTtcbn07XG5cbi8vIEZsaXAgc3RvcmFnZSBtYXAgc28gdGhhdCBvdXIgc3RvcmFnZSBrZXlzIG1hcCB0byBnbG9iYWxcbi8vIERyYWZ0RW50aXR5IGtleXMuXG52YXIgZW5jb2RlUmF3RW50aXR5TWFwID0gZnVuY3Rpb24gZW5jb2RlUmF3RW50aXR5TWFwKGNvbnRlbnRTdGF0ZSwgcmF3U3RhdGUpIHtcbiAgdmFyIGJsb2NrcyA9IHJhd1N0YXRlLmJsb2NrcyxcbiAgICAgIGVudGl0eU1hcCA9IHJhd1N0YXRlLmVudGl0eU1hcDtcblxuXG4gIHZhciByYXdFbnRpdHlNYXAgPSB7fTtcblxuICBPYmplY3Qua2V5cyhlbnRpdHlNYXApLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICB2YXIgZW50aXR5ID0gY29udGVudFN0YXRlLmdldEVudGl0eShEcmFmdFN0cmluZ0tleS51bnN0cmluZ2lmeShrZXkpKTtcbiAgICByYXdFbnRpdHlNYXBbaW5kZXhdID0ge1xuICAgICAgdHlwZTogZW50aXR5LmdldFR5cGUoKSxcbiAgICAgIG11dGFiaWxpdHk6IGVudGl0eS5nZXRNdXRhYmlsaXR5KCksXG4gICAgICBkYXRhOiBlbnRpdHkuZ2V0RGF0YSgpXG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBibG9ja3M6IGJsb2NrcyxcbiAgICBlbnRpdHlNYXA6IHJhd0VudGl0eU1hcFxuICB9O1xufTtcblxudmFyIGNvbnZlcnRGcm9tRHJhZnRTdGF0ZVRvUmF3ID0gZnVuY3Rpb24gY29udmVydEZyb21EcmFmdFN0YXRlVG9SYXcoY29udGVudFN0YXRlKSB7XG4gIHZhciByYXdEcmFmdENvbnRlbnRTdGF0ZSA9IHtcbiAgICBlbnRpdHlNYXA6IHt9LFxuICAgIGJsb2NrczogW11cbiAgfTtcblxuICAvLyBhZGQgYmxvY2tzXG4gIHJhd0RyYWZ0Q29udGVudFN0YXRlID0gZW5jb2RlUmF3QmxvY2tzKGNvbnRlbnRTdGF0ZSwgcmF3RHJhZnRDb250ZW50U3RhdGUpO1xuXG4gIC8vIGFkZCBlbnRpdGllc1xuICByYXdEcmFmdENvbnRlbnRTdGF0ZSA9IGVuY29kZVJhd0VudGl0eU1hcChjb250ZW50U3RhdGUsIHJhd0RyYWZ0Q29udGVudFN0YXRlKTtcblxuICByZXR1cm4gcmF3RHJhZnRDb250ZW50U3RhdGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnRGcm9tRHJhZnRTdGF0ZVRvUmF3O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9jb252ZXJ0RnJvbURyYWZ0U3RhdGVUb1Jhdy5qc1xuLy8gbW9kdWxlIGlkID0gNDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbmNvZGVFbnRpdHlSYW5nZXNcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERyYWZ0U3RyaW5nS2V5ID0gcmVxdWlyZSgnLi9EcmFmdFN0cmluZ0tleScpO1xudmFyIFVuaWNvZGVVdGlscyA9IHJlcXVpcmUoJ2ZianMvbGliL1VuaWNvZGVVdGlscycpO1xuXG52YXIgc3RybGVuID0gVW5pY29kZVV0aWxzLnN0cmxlbjtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIFVURi04IGNoYXJhY3RlciBjb3VudHMgZm9yIHN0b3JhZ2UuXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlRW50aXR5UmFuZ2VzKGJsb2NrLCBzdG9yYWdlTWFwKSB7XG4gIHZhciBlbmNvZGVkID0gW107XG4gIGJsb2NrLmZpbmRFbnRpdHlSYW5nZXMoZnVuY3Rpb24gKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiAhIWNoYXJhY3Rlci5nZXRFbnRpdHkoKTtcbiAgfSwgZnVuY3Rpb24gKCAvKm51bWJlciovc3RhcnQsIC8qbnVtYmVyKi9lbmQpIHtcbiAgICB2YXIgdGV4dCA9IGJsb2NrLmdldFRleHQoKTtcbiAgICB2YXIga2V5ID0gYmxvY2suZ2V0RW50aXR5QXQoc3RhcnQpO1xuICAgIGVuY29kZWQucHVzaCh7XG4gICAgICBvZmZzZXQ6IHN0cmxlbih0ZXh0LnNsaWNlKDAsIHN0YXJ0KSksXG4gICAgICBsZW5ndGg6IHN0cmxlbih0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpKSxcbiAgICAgIC8vIEVuY29kZSB0aGUga2V5IGFzIGEgbnVtYmVyIGZvciByYW5nZSBzdG9yYWdlLlxuICAgICAga2V5OiBOdW1iZXIoc3RvcmFnZU1hcFtEcmFmdFN0cmluZ0tleS5zdHJpbmdpZnkoa2V5KV0pXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZW5jb2RlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVFbnRpdHlSYW5nZXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL2VuY29kZUVudGl0eVJhbmdlcy5qc1xuLy8gbW9kdWxlIGlkID0gNDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbmNvZGVJbmxpbmVTdHlsZVJhbmdlc1xuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVW5pY29kZVV0aWxzID0gcmVxdWlyZSgnZmJqcy9saWIvVW5pY29kZVV0aWxzJyk7XG5cbnZhciBmaW5kUmFuZ2VzSW1tdXRhYmxlID0gcmVxdWlyZSgnLi9maW5kUmFuZ2VzSW1tdXRhYmxlJyk7XG5cbnZhciBhcmVFcXVhbCA9IGZ1bmN0aW9uIGFyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59O1xudmFyIGlzVHJ1dGh5ID0gZnVuY3Rpb24gaXNUcnV0aHkoYSkge1xuICByZXR1cm4gISFhO1xufTtcbnZhciBFTVBUWV9BUlJBWSA9IFtdO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyBlbmNvZGVkIHN0eWxlcyBmb3IgZWFjaCBpbmxpbmUgc3R5bGUuIENvbnZlcnRcbiAqIHRvIFVURi04IGNoYXJhY3RlciBjb3VudHMgZm9yIHN0b3JhZ2UuXG4gKi9cbmZ1bmN0aW9uIGdldEVuY29kZWRJbmxpbmVzRm9yVHlwZShibG9jaywgc3R5bGVMaXN0LCBzdHlsZVRvRW5jb2RlKSB7XG4gIHZhciByYW5nZXMgPSBbXTtcblxuICAvLyBPYnRhaW4gYW4gYXJyYXkgd2l0aCByYW5nZXMgZm9yIG9ubHkgdGhlIHNwZWNpZmllZCBzdHlsZS5cbiAgdmFyIGZpbHRlcmVkSW5saW5lcyA9IHN0eWxlTGlzdC5tYXAoZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgcmV0dXJuIHN0eWxlLmhhcyhzdHlsZVRvRW5jb2RlKTtcbiAgfSkudG9MaXN0KCk7XG5cbiAgZmluZFJhbmdlc0ltbXV0YWJsZShmaWx0ZXJlZElubGluZXMsIGFyZUVxdWFsLFxuICAvLyBXZSBvbmx5IHdhbnQgdG8ga2VlcCByYW5nZXMgd2l0aCBub256ZXJvIHN0eWxlIHZhbHVlcy5cbiAgaXNUcnV0aHksIGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgdmFyIHRleHQgPSBibG9jay5nZXRUZXh0KCk7XG4gICAgcmFuZ2VzLnB1c2goe1xuICAgICAgb2Zmc2V0OiBVbmljb2RlVXRpbHMuc3RybGVuKHRleHQuc2xpY2UoMCwgc3RhcnQpKSxcbiAgICAgIGxlbmd0aDogVW5pY29kZVV0aWxzLnN0cmxlbih0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpKSxcbiAgICAgIHN0eWxlOiBzdHlsZVRvRW5jb2RlXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiByYW5nZXM7XG59XG5cbi8qXG4gKiBSZXRyaWV2ZSB0aGUgZW5jb2RlZCBhcnJheXMgb2YgaW5saW5lIHN0eWxlcywgd2l0aCBlYWNoIGluZGl2aWR1YWwgc3R5bGVcbiAqIHRyZWF0ZWQgc2VwYXJhdGVseS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlSW5saW5lU3R5bGVSYW5nZXMoYmxvY2spIHtcbiAgdmFyIHN0eWxlTGlzdCA9IGJsb2NrLmdldENoYXJhY3Rlckxpc3QoKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYy5nZXRTdHlsZSgpO1xuICB9KS50b0xpc3QoKTtcbiAgdmFyIHJhbmdlcyA9IHN0eWxlTGlzdC5mbGF0dGVuKCkudG9TZXQoKS5tYXAoZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgcmV0dXJuIGdldEVuY29kZWRJbmxpbmVzRm9yVHlwZShibG9jaywgc3R5bGVMaXN0LCBzdHlsZSk7XG4gIH0pO1xuXG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KEVNUFRZX0FSUkFZLCByYW5nZXMudG9KUygpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVJbmxpbmVTdHlsZVJhbmdlcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZW5jb2RlSW5saW5lU3R5bGVSYW5nZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQ2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY29udmVydEZyb21SYXdUb0RyYWZ0U3RhdGVcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfZXh0ZW5kcyA9IF9hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBDb250ZW50QmxvY2sgPSByZXF1aXJlKCcuL0NvbnRlbnRCbG9jaycpO1xudmFyIENvbnRlbnRCbG9ja05vZGUgPSByZXF1aXJlKCcuL0NvbnRlbnRCbG9ja05vZGUnKTtcbnZhciBDb250ZW50U3RhdGUgPSByZXF1aXJlKCcuL0NvbnRlbnRTdGF0ZScpO1xudmFyIERyYWZ0RW50aXR5ID0gcmVxdWlyZSgnLi9EcmFmdEVudGl0eScpO1xudmFyIERyYWZ0RmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9EcmFmdEZlYXR1cmVGbGFncycpO1xudmFyIERyYWZ0VHJlZUFkYXB0ZXIgPSByZXF1aXJlKCcuL0RyYWZ0VHJlZUFkYXB0ZXInKTtcbnZhciBJbW11dGFibGUgPSByZXF1aXJlKCdpbW11dGFibGUnKTtcbnZhciBTZWxlY3Rpb25TdGF0ZSA9IHJlcXVpcmUoJy4vU2VsZWN0aW9uU3RhdGUnKTtcblxudmFyIGNyZWF0ZUNoYXJhY3Rlckxpc3QgPSByZXF1aXJlKCcuL2NyZWF0ZUNoYXJhY3Rlckxpc3QnKTtcbnZhciBkZWNvZGVFbnRpdHlSYW5nZXMgPSByZXF1aXJlKCcuL2RlY29kZUVudGl0eVJhbmdlcycpO1xudmFyIGRlY29kZUlubGluZVN0eWxlUmFuZ2VzID0gcmVxdWlyZSgnLi9kZWNvZGVJbmxpbmVTdHlsZVJhbmdlcycpO1xudmFyIGdlbmVyYXRlUmFuZG9tS2V5ID0gcmVxdWlyZSgnLi9nZW5lcmF0ZVJhbmRvbUtleScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZXhwZXJpbWVudGFsVHJlZURhdGFTdXBwb3J0ID0gRHJhZnRGZWF0dXJlRmxhZ3MuZHJhZnRfdHJlZV9kYXRhX3N1cHBvcnQ7XG5cbnZhciBMaXN0ID0gSW1tdXRhYmxlLkxpc3QsXG4gICAgTWFwID0gSW1tdXRhYmxlLk1hcCxcbiAgICBPcmRlcmVkTWFwID0gSW1tdXRhYmxlLk9yZGVyZWRNYXA7XG5cblxudmFyIGRlY29kZUJsb2NrTm9kZUNvbmZpZyA9IGZ1bmN0aW9uIGRlY29kZUJsb2NrTm9kZUNvbmZpZyhibG9jaywgZW50aXR5TWFwKSB7XG4gIHZhciBrZXkgPSBibG9jay5rZXksXG4gICAgICB0eXBlID0gYmxvY2sudHlwZSxcbiAgICAgIGRhdGEgPSBibG9jay5kYXRhLFxuICAgICAgdGV4dCA9IGJsb2NrLnRleHQsXG4gICAgICBkZXB0aCA9IGJsb2NrLmRlcHRoO1xuXG5cbiAgdmFyIGJsb2NrTm9kZUNvbmZpZyA9IHtcbiAgICB0ZXh0OiB0ZXh0LFxuICAgIGRlcHRoOiBkZXB0aCB8fCAwLFxuICAgIHR5cGU6IHR5cGUgfHwgJ3Vuc3R5bGVkJyxcbiAgICBrZXk6IGtleSB8fCBnZW5lcmF0ZVJhbmRvbUtleSgpLFxuICAgIGRhdGE6IE1hcChkYXRhKSxcbiAgICBjaGFyYWN0ZXJMaXN0OiBkZWNvZGVDaGFyYWN0ZXJMaXN0KGJsb2NrLCBlbnRpdHlNYXApXG4gIH07XG5cbiAgcmV0dXJuIGJsb2NrTm9kZUNvbmZpZztcbn07XG5cbnZhciBkZWNvZGVDaGFyYWN0ZXJMaXN0ID0gZnVuY3Rpb24gZGVjb2RlQ2hhcmFjdGVyTGlzdChibG9jaywgZW50aXR5TWFwKSB7XG4gIHZhciB0ZXh0ID0gYmxvY2sudGV4dCxcbiAgICAgIHJhd0VudGl0eVJhbmdlcyA9IGJsb2NrLmVudGl0eVJhbmdlcyxcbiAgICAgIHJhd0lubGluZVN0eWxlUmFuZ2VzID0gYmxvY2suaW5saW5lU3R5bGVSYW5nZXM7XG5cblxuICB2YXIgZW50aXR5UmFuZ2VzID0gcmF3RW50aXR5UmFuZ2VzIHx8IFtdO1xuICB2YXIgaW5saW5lU3R5bGVSYW5nZXMgPSByYXdJbmxpbmVTdHlsZVJhbmdlcyB8fCBbXTtcblxuICAvLyBUcmFuc2xhdGUgZW50aXR5IHJhbmdlIGtleXMgdG8gdGhlIERyYWZ0RW50aXR5IG1hcC5cbiAgcmV0dXJuIGNyZWF0ZUNoYXJhY3Rlckxpc3QoZGVjb2RlSW5saW5lU3R5bGVSYW5nZXModGV4dCwgaW5saW5lU3R5bGVSYW5nZXMpLCBkZWNvZGVFbnRpdHlSYW5nZXModGV4dCwgZW50aXR5UmFuZ2VzLmZpbHRlcihmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICByZXR1cm4gZW50aXR5TWFwLmhhc093blByb3BlcnR5KHJhbmdlLmtleSk7XG4gIH0pLm1hcChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHJhbmdlLCB7IGtleTogZW50aXR5TWFwW3JhbmdlLmtleV0gfSk7XG4gIH0pKSk7XG59O1xuXG52YXIgYWRkS2V5SWZNaXNzaW5nID0gZnVuY3Rpb24gYWRkS2V5SWZNaXNzaW5nKGJsb2NrKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgYmxvY2ssIHtcbiAgICBrZXk6IGJsb2NrLmtleSB8fCBnZW5lcmF0ZVJhbmRvbUtleSgpXG4gIH0pO1xufTtcblxuLyoqXG4gKiBOb2RlIHN0YWNrIGlzIHJlc3BvbnNpYmxlIHRvIGVuc3VyZSB3ZSB0cmF2ZXJzZSB0aGUgdHJlZSBvbmx5IG9uY2VcbiAqIGluIGRlcHRoIG9yZGVyLCB3aGlsZSBhbHNvIHByb3ZpZGluZyBwYXJlbnQgcmVmcyB0byBpbm5lciBub2RlcyB0b1xuICogY29uc3RydWN0IHRoZWlyIGxpbmtzLlxuICovXG52YXIgdXBkYXRlTm9kZVN0YWNrID0gZnVuY3Rpb24gdXBkYXRlTm9kZVN0YWNrKHN0YWNrLCBub2RlcywgcGFyZW50UmVmKSB7XG4gIHZhciBub2Rlc1dpdGhQYXJlbnRSZWYgPSBub2Rlcy5tYXAoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBibG9jaywge1xuICAgICAgcGFyZW50UmVmOiBwYXJlbnRSZWZcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gc2luY2Ugd2UgcG9wIG5vZGVzIGZyb20gdGhlIHN0YWNrIHdlIG5lZWQgdG8gaW5zZXJ0IHRoZW0gaW4gcmV2ZXJzZVxuICByZXR1cm4gc3RhY2suY29uY2F0KG5vZGVzV2l0aFBhcmVudFJlZi5yZXZlcnNlKCkpO1xufTtcblxuLyoqXG4gKiBUaGlzIHdpbGwgYnVpbGQgYSB0cmVlIGRyYWZ0IGNvbnRlbnQgc3RhdGUgYnkgY3JlYXRpbmcgdGhlIG5vZGVcbiAqIHJlZmVyZW5jZSBsaW5rcyBpbnRvIGEgc2luZ2xlIHRyZWUgd2Fsay4gRWFjaCBub2RlIGhhcyBhIGxpbmtcbiAqIHJlZmVyZW5jZSB0byBcInBhcmVudFwiLCBcImNoaWxkcmVuXCIsIFwibmV4dFNpYmxpbmdcIiBhbmQgXCJwcmV2U2libGluZ1wiXG4gKiBibG9ja01hcCB3aWxsIGJlIGNyZWF0ZWQgdXNpbmcgZGVwdGggb3JkZXJpbmcuXG4gKi9cbnZhciBkZWNvZGVDb250ZW50QmxvY2tOb2RlcyA9IGZ1bmN0aW9uIGRlY29kZUNvbnRlbnRCbG9ja05vZGVzKGJsb2NrcywgZW50aXR5TWFwKSB7XG4gIHJldHVybiBibG9ja3NcbiAgLy8gZW5zdXJlIGNoaWxkcmVuIGhhdmUgdmFsaWQga2V5cyB0byBlbmFibGUgc2libGluZyBsaW5rc1xuICAubWFwKGFkZEtleUlmTWlzc2luZykucmVkdWNlKGZ1bmN0aW9uIChibG9ja01hcCwgYmxvY2ssIGluZGV4KSB7XG4gICAgIUFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ludmFsaWQgUmF3RHJhZnRDb250ZW50QmxvY2sgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQ29udGVudEJsb2NrTm9kZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIC8vIGVuc3VyZSBjaGlsZHJlbiBoYXZlIHZhbGlkIGtleXMgdG8gZW5hYmxlIHNpYmxpbmcgbGlua3NcbiAgICB2YXIgY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbi5tYXAoYWRkS2V5SWZNaXNzaW5nKTtcblxuICAgIC8vIHJvb3QgbGV2ZWwgbm9kZXNcbiAgICB2YXIgY29udGVudEJsb2NrTm9kZSA9IG5ldyBDb250ZW50QmxvY2tOb2RlKF9leHRlbmRzKHt9LCBkZWNvZGVCbG9ja05vZGVDb25maWcoYmxvY2ssIGVudGl0eU1hcCksIHtcbiAgICAgIHByZXZTaWJsaW5nOiBpbmRleCA9PT0gMCA/IG51bGwgOiBibG9ja3NbaW5kZXggLSAxXS5rZXksXG4gICAgICBuZXh0U2libGluZzogaW5kZXggPT09IGJsb2Nrcy5sZW5ndGggLSAxID8gbnVsbCA6IGJsb2Nrc1tpbmRleCArIDFdLmtleSxcbiAgICAgIGNoaWxkcmVuOiBMaXN0KGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLmtleTtcbiAgICAgIH0pKVxuICAgIH0pKTtcblxuICAgIC8vIHB1c2ggcm9vdCBub2RlIHRvIGJsb2NrTWFwXG4gICAgYmxvY2tNYXAgPSBibG9ja01hcC5zZXQoY29udGVudEJsb2NrTm9kZS5nZXRLZXkoKSwgY29udGVudEJsb2NrTm9kZSk7XG5cbiAgICAvLyB0aGlzIHN0YWNrIGlzIHVzZWQgdG8gZW5zdXJlIHdlIHZpc2l0IGFsbCBub2RlcyByZXNwZWN0aW5nIGRlcHRoIG9yZGVyaW5nXG4gICAgdmFyIHN0YWNrID0gdXBkYXRlTm9kZVN0YWNrKFtdLCBjaGlsZHJlbiwgY29udGVudEJsb2NrTm9kZSk7XG5cbiAgICAvLyBzdGFydCBjb21wdXRpbmcgY2hpbGRyZW4gbm9kZXNcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgLy8gd2UgcG9wIGZyb20gdGhlIHN0YWNrIGFuZCBzdGFydCBwcm9jZXNzaW5nIHRoaXMgbm9kZVxuICAgICAgdmFyIG5vZGUgPSBzdGFjay5wb3AoKTtcblxuICAgICAgLy8gcGFyZW50UmVmIGFscmVhZHkgcG9pbnRzIHRvIGEgY29udmVydGVkIENvbnRlbnRCbG9ja05vZGVcbiAgICAgIHZhciBwYXJlbnRSZWYgPSBub2RlLnBhcmVudFJlZjtcbiAgICAgIHZhciBzaWJsaW5ncyA9IHBhcmVudFJlZi5nZXRDaGlsZEtleXMoKTtcbiAgICAgIHZhciBfaW5kZXggPSBzaWJsaW5ncy5pbmRleE9mKG5vZGUua2V5KTtcbiAgICAgIHZhciBpc1ZhbGlkQmxvY2sgPSBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pO1xuXG4gICAgICBpZiAoIWlzVmFsaWRCbG9jaykge1xuICAgICAgICAhaXNWYWxpZEJsb2NrID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ludmFsaWQgUmF3RHJhZnRDb250ZW50QmxvY2sgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQ29udGVudEJsb2NrTm9kZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIGVuc3VyZSBjaGlsZHJlbiBoYXZlIHZhbGlkIGtleXMgdG8gZW5hYmxlIHNpYmxpbmcgbGlua3NcbiAgICAgIHZhciBfY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcChhZGRLZXlJZk1pc3NpbmcpO1xuXG4gICAgICB2YXIgX2NvbnRlbnRCbG9ja05vZGUgPSBuZXcgQ29udGVudEJsb2NrTm9kZShfZXh0ZW5kcyh7fSwgZGVjb2RlQmxvY2tOb2RlQ29uZmlnKG5vZGUsIGVudGl0eU1hcCksIHtcbiAgICAgICAgcGFyZW50OiBwYXJlbnRSZWYuZ2V0S2V5KCksXG4gICAgICAgIGNoaWxkcmVuOiBMaXN0KF9jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkLmtleTtcbiAgICAgICAgfSkpLFxuICAgICAgICBwcmV2U2libGluZzogX2luZGV4ID09PSAwID8gbnVsbCA6IHNpYmxpbmdzLmdldChfaW5kZXggLSAxKSxcbiAgICAgICAgbmV4dFNpYmxpbmc6IF9pbmRleCA9PT0gc2libGluZ3Muc2l6ZSAtIDEgPyBudWxsIDogc2libGluZ3MuZ2V0KF9pbmRleCArIDEpXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIHB1c2ggbm9kZSB0byBibG9ja01hcFxuICAgICAgYmxvY2tNYXAgPSBibG9ja01hcC5zZXQoX2NvbnRlbnRCbG9ja05vZGUuZ2V0S2V5KCksIF9jb250ZW50QmxvY2tOb2RlKTtcblxuICAgICAgLy8gdGhpcyBzdGFjayBpcyB1c2VkIHRvIGVuc3VyZSB3ZSB2aXNpdCBhbGwgbm9kZXMgcmVzcGVjdGluZyBkZXB0aCBvcmRlcmluZ1xuICAgICAgc3RhY2sgPSB1cGRhdGVOb2RlU3RhY2soc3RhY2ssIF9jaGlsZHJlbiwgX2NvbnRlbnRCbG9ja05vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBibG9ja01hcDtcbiAgfSwgT3JkZXJlZE1hcCgpKTtcbn07XG5cbnZhciBkZWNvZGVDb250ZW50QmxvY2tzID0gZnVuY3Rpb24gZGVjb2RlQ29udGVudEJsb2NrcyhibG9ja3MsIGVudGl0eU1hcCkge1xuICByZXR1cm4gT3JkZXJlZE1hcChibG9ja3MubWFwKGZ1bmN0aW9uIChibG9jaykge1xuICAgIHZhciBjb250ZW50QmxvY2sgPSBuZXcgQ29udGVudEJsb2NrKGRlY29kZUJsb2NrTm9kZUNvbmZpZyhibG9jaywgZW50aXR5TWFwKSk7XG4gICAgcmV0dXJuIFtjb250ZW50QmxvY2suZ2V0S2V5KCksIGNvbnRlbnRCbG9ja107XG4gIH0pKTtcbn07XG5cbnZhciBkZWNvZGVSYXdCbG9ja3MgPSBmdW5jdGlvbiBkZWNvZGVSYXdCbG9ja3MocmF3U3RhdGUsIGVudGl0eU1hcCkge1xuICB2YXIgaXNUcmVlUmF3QmxvY2sgPSBBcnJheS5pc0FycmF5KHJhd1N0YXRlLmJsb2Nrc1swXS5jaGlsZHJlbik7XG4gIHZhciByYXdCbG9ja3MgPSBleHBlcmltZW50YWxUcmVlRGF0YVN1cHBvcnQgJiYgIWlzVHJlZVJhd0Jsb2NrID8gRHJhZnRUcmVlQWRhcHRlci5mcm9tUmF3U3RhdGVUb1Jhd1RyZWVTdGF0ZShyYXdTdGF0ZSkuYmxvY2tzIDogcmF3U3RhdGUuYmxvY2tzO1xuXG4gIGlmICghZXhwZXJpbWVudGFsVHJlZURhdGFTdXBwb3J0KSB7XG4gICAgcmV0dXJuIGRlY29kZUNvbnRlbnRCbG9ja3MoaXNUcmVlUmF3QmxvY2sgPyBEcmFmdFRyZWVBZGFwdGVyLmZyb21SYXdUcmVlU3RhdGVUb1Jhd1N0YXRlKHJhd1N0YXRlKS5ibG9ja3MgOiByYXdCbG9ja3MsIGVudGl0eU1hcCk7XG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29udGVudEJsb2NrTm9kZXMocmF3QmxvY2tzLCBlbnRpdHlNYXApO1xufTtcblxudmFyIGRlY29kZVJhd0VudGl0eU1hcCA9IGZ1bmN0aW9uIGRlY29kZVJhd0VudGl0eU1hcChyYXdTdGF0ZSkge1xuICB2YXIgcmF3RW50aXR5TWFwID0gcmF3U3RhdGUuZW50aXR5TWFwO1xuXG4gIHZhciBlbnRpdHlNYXAgPSB7fTtcblxuICAvLyBUT0RPOiBVcGRhdGUgdGhpcyBvbmNlIHdlIGNvbXBsZXRlbHkgcmVtb3ZlIERyYWZ0RW50aXR5XG4gIE9iamVjdC5rZXlzKHJhd0VudGl0eU1hcCkuZm9yRWFjaChmdW5jdGlvbiAocmF3RW50aXR5S2V5KSB7XG4gICAgdmFyIF9yYXdFbnRpdHlNYXAkcmF3RW50aSA9IHJhd0VudGl0eU1hcFtyYXdFbnRpdHlLZXldLFxuICAgICAgICB0eXBlID0gX3Jhd0VudGl0eU1hcCRyYXdFbnRpLnR5cGUsXG4gICAgICAgIG11dGFiaWxpdHkgPSBfcmF3RW50aXR5TWFwJHJhd0VudGkubXV0YWJpbGl0eSxcbiAgICAgICAgZGF0YSA9IF9yYXdFbnRpdHlNYXAkcmF3RW50aS5kYXRhO1xuXG4gICAgLy8gZ2V0IHRoZSBrZXkgcmVmZXJlbmNlIHRvIGNyZWF0ZWQgZW50aXR5XG5cbiAgICBlbnRpdHlNYXBbcmF3RW50aXR5S2V5XSA9IERyYWZ0RW50aXR5Ll9fY3JlYXRlKHR5cGUsIG11dGFiaWxpdHksIGRhdGEgfHwge30pO1xuICB9KTtcblxuICByZXR1cm4gZW50aXR5TWFwO1xufTtcblxudmFyIGNvbnZlcnRGcm9tUmF3VG9EcmFmdFN0YXRlID0gZnVuY3Rpb24gY29udmVydEZyb21SYXdUb0RyYWZ0U3RhdGUocmF3U3RhdGUpIHtcbiAgIUFycmF5LmlzQXJyYXkocmF3U3RhdGUuYmxvY2tzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbnZhbGlkIFJhd0RyYWZ0Q29udGVudFN0YXRlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIC8vIGRlY29kZSBlbnRpdGllc1xuICB2YXIgZW50aXR5TWFwID0gZGVjb2RlUmF3RW50aXR5TWFwKHJhd1N0YXRlKTtcblxuICAvLyBkZWNvZGUgYmxvY2tNYXBcbiAgdmFyIGJsb2NrTWFwID0gZGVjb2RlUmF3QmxvY2tzKHJhd1N0YXRlLCBlbnRpdHlNYXApO1xuXG4gIC8vIGNyZWF0ZSBpbml0aWFsIHNlbGVjdGlvblxuICB2YXIgc2VsZWN0aW9uU3RhdGUgPSBibG9ja01hcC5pc0VtcHR5KCkgPyBuZXcgU2VsZWN0aW9uU3RhdGUoKSA6IFNlbGVjdGlvblN0YXRlLmNyZWF0ZUVtcHR5KGJsb2NrTWFwLmZpcnN0KCkuZ2V0S2V5KCkpO1xuXG4gIHJldHVybiBuZXcgQ29udGVudFN0YXRlKHtcbiAgICBibG9ja01hcDogYmxvY2tNYXAsXG4gICAgZW50aXR5TWFwOiBlbnRpdHlNYXAsXG4gICAgc2VsZWN0aW9uQmVmb3JlOiBzZWxlY3Rpb25TdGF0ZSxcbiAgICBzZWxlY3Rpb25BZnRlcjogc2VsZWN0aW9uU3RhdGVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnRGcm9tUmF3VG9EcmFmdFN0YXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9jb252ZXJ0RnJvbVJhd1RvRHJhZnRTdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9leHRlbmRzID0gX2Fzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEcmFmdFRyZWVBZGFwdGVyXG4gKiBAZm9ybWF0XG4gKiBcbiAqXG4gKiBUaGlzIGlzIHVuc3RhYmxlIGFuZCBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSSBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGJ5XG4gKiBwcm9kdWN0aW9uIHN5c3RlbXMuIFRoaXMgZmlsZSBtYXkgYmUgdXBkYXRlL3JlbW92ZWQgd2l0aG91dCBub3RpY2UuXG4gKi9cblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgdHJhdmVyc2VJbkRlcHRoT3JkZXIgPSBmdW5jdGlvbiB0cmF2ZXJzZUluRGVwdGhPcmRlcihibG9ja3MsIGZuKSB7XG4gIHZhciBzdGFjayA9IFtdLmNvbmNhdChibG9ja3MpLnJldmVyc2UoKTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgIHZhciBfYmxvY2sgPSBzdGFjay5wb3AoKTtcblxuICAgIGZuKF9ibG9jayk7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSBfYmxvY2suY2hpbGRyZW47XG5cbiAgICAhQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0cmVlIHJhdyBibG9jaycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHN0YWNrID0gc3RhY2suY29uY2F0KFtdLmNvbmNhdChjaGlsZHJlbi5yZXZlcnNlKCkpKTtcbiAgfVxufTtcblxudmFyIGlzTGlzdEJsb2NrID0gZnVuY3Rpb24gaXNMaXN0QmxvY2soYmxvY2spIHtcbiAgaWYgKCEoYmxvY2sgJiYgYmxvY2sudHlwZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSBibG9jay50eXBlO1xuXG4gIHJldHVybiB0eXBlID09PSAndW5vcmRlcmVkLWxpc3QtaXRlbScgfHwgdHlwZSA9PT0gJ29yZGVyZWQtbGlzdC1pdGVtJztcbn07XG5cbnZhciBhZGREZXB0aFRvQ2hpbGRyZW4gPSBmdW5jdGlvbiBhZGREZXB0aFRvQ2hpbGRyZW4oYmxvY2spIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pKSB7XG4gICAgYmxvY2suY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQudHlwZSA9PT0gYmxvY2sudHlwZSA/IF9leHRlbmRzKHt9LCBjaGlsZCwgeyBkZXB0aDogKGJsb2NrLmRlcHRoIHx8IDApICsgMSB9KSA6IGNoaWxkO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgYWRhcHRlciBpcyBpbnRlbmRlZCB0byBiZSBiZSB1c2VkIGFzIGFuIGFkYXB0ZXIgdG8gZHJhZnQgdHJlZSBkYXRhXG4gKlxuICogZHJhZnQgc3RhdGUgPD09PT09PiBkcmFmdCB0cmVlIHN0YXRlXG4gKi9cbnZhciBEcmFmdFRyZWVBZGFwdGVyID0ge1xuICAvKipcbiAgICogQ29udmVydHMgZnJvbSBhIHRyZWUgcmF3IHN0YXRlIGJhY2sgdG8gIGRyYWZ0IHJhdyBzdGF0ZVxuICAgKi9cbiAgZnJvbVJhd1RyZWVTdGF0ZVRvUmF3U3RhdGU6IGZ1bmN0aW9uIGZyb21SYXdUcmVlU3RhdGVUb1Jhd1N0YXRlKGRyYWZ0VHJlZVN0YXRlKSB7XG4gICAgdmFyIGJsb2NrcyA9IGRyYWZ0VHJlZVN0YXRlLmJsb2NrcztcblxuICAgIHZhciB0cmFuc2Zvcm1lZEJsb2NrcyA9IFtdO1xuXG4gICAgIUFycmF5LmlzQXJyYXkoYmxvY2tzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHJhdyBzdGF0ZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShibG9ja3MpIHx8ICFibG9ja3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZHJhZnRUcmVlU3RhdGU7XG4gICAgfVxuXG4gICAgdHJhdmVyc2VJbkRlcHRoT3JkZXIoYmxvY2tzLCBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgIHZhciBuZXdCbG9jayA9IF9leHRlbmRzKHt9LCBibG9jayk7XG5cbiAgICAgIGlmIChpc0xpc3RCbG9jayhibG9jaykpIHtcbiAgICAgICAgbmV3QmxvY2suZGVwdGggPSBuZXdCbG9jay5kZXB0aCB8fCAwO1xuICAgICAgICBhZGREZXB0aFRvQ2hpbGRyZW4oYmxvY2spO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgbmV3QmxvY2suY2hpbGRyZW47XG5cbiAgICAgIHRyYW5zZm9ybWVkQmxvY2tzLnB1c2gobmV3QmxvY2spO1xuICAgIH0pO1xuXG4gICAgZHJhZnRUcmVlU3RhdGUuYmxvY2tzID0gdHJhbnNmb3JtZWRCbG9ja3M7XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRyYWZ0VHJlZVN0YXRlLCB7XG4gICAgICBibG9ja3M6IHRyYW5zZm9ybWVkQmxvY2tzXG4gICAgfSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQ29udmVydHMgZnJvbSBkcmFmdCByYXcgc3RhdGUgdG8gdHJlZSBkcmFmdCBzdGF0ZVxuICAgKi9cbiAgZnJvbVJhd1N0YXRlVG9SYXdUcmVlU3RhdGU6IGZ1bmN0aW9uIGZyb21SYXdTdGF0ZVRvUmF3VHJlZVN0YXRlKGRyYWZ0U3RhdGUpIHtcbiAgICB2YXIgbGFzdExpc3REZXB0aENhY2hlUmVmID0ge307XG4gICAgdmFyIHRyYW5zZm9ybWVkQmxvY2tzID0gW107XG5cbiAgICBkcmFmdFN0YXRlLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgdmFyIGlzTGlzdCA9IGlzTGlzdEJsb2NrKGJsb2NrKTtcbiAgICAgIHZhciBkZXB0aCA9IGJsb2NrLmRlcHRoIHx8IDA7XG4gICAgICB2YXIgdHJlZUJsb2NrID0gX2V4dGVuZHMoe30sIGJsb2NrLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghaXNMaXN0KSB7XG4gICAgICAgIC8vIHJlc2V0IHRoZSBjYWNoZSBwYXRoXG4gICAgICAgIGxhc3RMaXN0RGVwdGhDYWNoZVJlZiA9IHt9O1xuICAgICAgICB0cmFuc2Zvcm1lZEJsb2Nrcy5wdXNoKHRyZWVCbG9jayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdXBkYXRlIG91ciBkZXB0aCBjYWNoZSByZWZlcmVuY2UgcGF0aFxuICAgICAgbGFzdExpc3REZXB0aENhY2hlUmVmW2RlcHRoXSA9IHRyZWVCbG9jaztcblxuICAgICAgLy8gaWYgd2UgYXJlIGdyZWF0ZXIgdGhhbiB6ZXJvIHdlIG11c3QgaGF2ZSBzZWVuIGEgcGFyZW50IGFscmVhZHlcbiAgICAgIGlmIChkZXB0aCA+IDApIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxhc3RMaXN0RGVwdGhDYWNoZVJlZltkZXB0aCAtIDFdO1xuXG4gICAgICAgICFwYXJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBkZXB0aCBmb3IgUmF3RHJhZnRDb250ZW50QmxvY2snKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgLy8gcHVzaCBuZXN0ZWQgbGlzdCBibG9ja3NcbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2godHJlZUJsb2NrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBwdXNoIHJvb3QgbGlzdCBibG9ja3NcbiAgICAgIHRyYW5zZm9ybWVkQmxvY2tzLnB1c2godHJlZUJsb2NrKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZHJhZnRTdGF0ZSwge1xuICAgICAgYmxvY2tzOiB0cmFuc2Zvcm1lZEJsb2Nrc1xuICAgIH0pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWZ0VHJlZUFkYXB0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnQtanMvbGliL0RyYWZ0VHJlZUFkYXB0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlQ2hhcmFjdGVyTGlzdFxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2hhcmFjdGVyTWV0YWRhdGEgPSByZXF1aXJlKCcuL0NoYXJhY3Rlck1ldGFkYXRhJyk7XG52YXIgSW1tdXRhYmxlID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG5cbnZhciBMaXN0ID0gSW1tdXRhYmxlLkxpc3Q7XG5cblxuZnVuY3Rpb24gY3JlYXRlQ2hhcmFjdGVyTGlzdChpbmxpbmVTdHlsZXMsIGVudGl0aWVzKSB7XG4gIHZhciBjaGFyYWN0ZXJBcnJheSA9IGlubGluZVN0eWxlcy5tYXAoZnVuY3Rpb24gKHN0eWxlLCBpaSkge1xuICAgIHZhciBlbnRpdHkgPSBlbnRpdGllc1tpaV07XG4gICAgcmV0dXJuIENoYXJhY3Rlck1ldGFkYXRhLmNyZWF0ZSh7IHN0eWxlOiBzdHlsZSwgZW50aXR5OiBlbnRpdHkgfSk7XG4gIH0pO1xuICByZXR1cm4gTGlzdChjaGFyYWN0ZXJBcnJheSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ2hhcmFjdGVyTGlzdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvY3JlYXRlQ2hhcmFjdGVyTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gNDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBkZWNvZGVFbnRpdHlSYW5nZXNcbiAqIEBmb3JtYXRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVuaWNvZGVVdGlscyA9IHJlcXVpcmUoJ2ZianMvbGliL1VuaWNvZGVVdGlscycpO1xuXG52YXIgc3Vic3RyID0gVW5pY29kZVV0aWxzLnN1YnN0cjtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIG5hdGl2ZSBKYXZhU2NyaXB0IHN0cmluZyBsZW5ndGhzIHRvIGRldGVybWluZSByYW5nZXMuXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlRW50aXR5UmFuZ2VzKHRleHQsIHJhbmdlcykge1xuICB2YXIgZW50aXRpZXMgPSBBcnJheSh0ZXh0Lmxlbmd0aCkuZmlsbChudWxsKTtcbiAgaWYgKHJhbmdlcykge1xuICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgLy8gVXNpbmcgVW5pY29kZS1lbmFibGVkIHN1YnN0cmluZ3MgY29udmVydGVkIHRvIEphdmFTY3JpcHQgbGVuZ3RocyxcbiAgICAgIC8vIGZpbGwgdGhlIG91dHB1dCBhcnJheSB3aXRoIGVudGl0eSBrZXlzLlxuICAgICAgdmFyIHN0YXJ0ID0gc3Vic3RyKHRleHQsIDAsIHJhbmdlLm9mZnNldCkubGVuZ3RoO1xuICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgc3Vic3RyKHRleHQsIHJhbmdlLm9mZnNldCwgcmFuZ2UubGVuZ3RoKS5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpaSA9IHN0YXJ0OyBpaSA8IGVuZDsgaWkrKykge1xuICAgICAgICBlbnRpdGllc1tpaV0gPSByYW5nZS5rZXk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVudGl0aWVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZUVudGl0eVJhbmdlcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kcmFmdC1qcy9saWIvZGVjb2RlRW50aXR5UmFuZ2VzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGRlY29kZUlubGluZVN0eWxlUmFuZ2VzXG4gKiBAZm9ybWF0XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpLFxuICAgIE9yZGVyZWRTZXQgPSBfcmVxdWlyZS5PcmRlcmVkU2V0O1xuXG52YXIgVW5pY29kZVV0aWxzID0gcmVxdWlyZSgnZmJqcy9saWIvVW5pY29kZVV0aWxzJyk7XG5cbnZhciBzdWJzdHIgPSBVbmljb2RlVXRpbHMuc3Vic3RyO1xuXG5cbnZhciBFTVBUWV9TRVQgPSBPcmRlcmVkU2V0KCk7XG5cbi8qKlxuICogQ29udmVydCB0byBuYXRpdmUgSmF2YVNjcmlwdCBzdHJpbmcgbGVuZ3RocyB0byBkZXRlcm1pbmUgcmFuZ2VzLlxuICovXG5mdW5jdGlvbiBkZWNvZGVJbmxpbmVTdHlsZVJhbmdlcyh0ZXh0LCByYW5nZXMpIHtcbiAgdmFyIHN0eWxlcyA9IEFycmF5KHRleHQubGVuZ3RoKS5maWxsKEVNUFRZX1NFVCk7XG4gIGlmIChyYW5nZXMpIHtcbiAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoIC8qb2JqZWN0Ki9yYW5nZSkge1xuICAgICAgdmFyIGN1cnNvciA9IHN1YnN0cih0ZXh0LCAwLCByYW5nZS5vZmZzZXQpLmxlbmd0aDtcbiAgICAgIHZhciBlbmQgPSBjdXJzb3IgKyBzdWJzdHIodGV4dCwgcmFuZ2Uub2Zmc2V0LCByYW5nZS5sZW5ndGgpLmxlbmd0aDtcbiAgICAgIHdoaWxlIChjdXJzb3IgPCBlbmQpIHtcbiAgICAgICAgc3R5bGVzW2N1cnNvcl0gPSBzdHlsZXNbY3Vyc29yXS5hZGQocmFuZ2Uuc3R5bGUpO1xuICAgICAgICBjdXJzb3IrKztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc3R5bGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZUlubGluZVN0eWxlUmFuZ2VzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9kZWNvZGVJbmxpbmVTdHlsZVJhbmdlcy5qc1xuLy8gbW9kdWxlIGlkID0gNDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRWaXNpYmxlU2VsZWN0aW9uUmVjdFxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0UmFuZ2VCb3VuZGluZ0NsaWVudFJlY3QgPSByZXF1aXJlKCcuL2dldFJhbmdlQm91bmRpbmdDbGllbnRSZWN0Jyk7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBib3VuZGluZyBDbGllbnRSZWN0IGZvciB0aGUgdmlzaWJsZSBET00gc2VsZWN0aW9uLCBpZiBhbnkuXG4gKiBJbiBjYXNlcyB3aGVyZSB0aGVyZSBhcmUgbm8gc2VsZWN0ZWQgcmFuZ2VzIG9yIHRoZSBib3VuZGluZyByZWN0IGlzXG4gKiB0ZW1wb3JhcmlseSBpbnZhbGlkLCByZXR1cm4gbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0VmlzaWJsZVNlbGVjdGlvblJlY3QoZ2xvYmFsKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBnbG9iYWwuZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghc2VsZWN0aW9uLnJhbmdlQ291bnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICB2YXIgYm91bmRpbmdSZWN0ID0gZ2V0UmFuZ2VCb3VuZGluZ0NsaWVudFJlY3QocmFuZ2UpO1xuICB2YXIgdG9wID0gYm91bmRpbmdSZWN0LnRvcCxcbiAgICAgIHJpZ2h0ID0gYm91bmRpbmdSZWN0LnJpZ2h0LFxuICAgICAgYm90dG9tID0gYm91bmRpbmdSZWN0LmJvdHRvbSxcbiAgICAgIGxlZnQgPSBib3VuZGluZ1JlY3QubGVmdDtcblxuICAvLyBXaGVuIGEgcmUtcmVuZGVyIGxlYWRzIHRvIGEgbm9kZSBiZWluZyByZW1vdmVkLCB0aGUgRE9NIHNlbGVjdGlvbiB3aWxsXG4gIC8vIHRlbXBvcmFyaWx5IGJlIHBsYWNlZCBvbiBhbiBhbmNlc3RvciBub2RlLCB3aGljaCBsZWFkcyB0byBhbiBpbnZhbGlkXG4gIC8vIGJvdW5kaW5nIHJlY3QuIERpc2NhcmQgdGhpcyBzdGF0ZS5cblxuICBpZiAodG9wID09PSAwICYmIHJpZ2h0ID09PSAwICYmIGJvdHRvbSA9PT0gMCAmJiBsZWZ0ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gYm91bmRpbmdSZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZpc2libGVTZWxlY3Rpb25SZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXRWaXNpYmxlU2VsZWN0aW9uUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRSYW5nZUJvdW5kaW5nQ2xpZW50UmVjdFxuICogQGZvcm1hdFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0UmFuZ2VDbGllbnRSZWN0cyA9IHJlcXVpcmUoJy4vZ2V0UmFuZ2VDbGllbnRSZWN0cycpO1xuXG4vKipcbiAqIExpa2UgcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgYnV0IG5vcm1hbGl6ZXMgZm9yIGJyb3dzZXIgYnVncy5cbiAqL1xuZnVuY3Rpb24gZ2V0UmFuZ2VCb3VuZGluZ0NsaWVudFJlY3QocmFuZ2UpIHtcbiAgLy8gXCJSZXR1cm4gYSBET01SZWN0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBzbWFsbGVzdCByZWN0YW5nbGUgdGhhdCBpbmNsdWRlc1xuICAvLyB0aGUgZmlyc3QgcmVjdGFuZ2xlIGluIGxpc3QgYW5kIGFsbCBvZiB0aGUgcmVtYWluaW5nIHJlY3RhbmdsZXMgb2Ygd2hpY2hcbiAgLy8gdGhlIGhlaWdodCBvciB3aWR0aCBpcyBub3QgemVyby5cIlxuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3NvbS12aWV3LyNkb20tcmFuZ2UtZ2V0Ym91bmRpbmdjbGllbnRyZWN0XG4gIHZhciByZWN0cyA9IGdldFJhbmdlQ2xpZW50UmVjdHMocmFuZ2UpO1xuICB2YXIgdG9wID0gMDtcbiAgdmFyIHJpZ2h0ID0gMDtcbiAgdmFyIGJvdHRvbSA9IDA7XG4gIHZhciBsZWZ0ID0gMDtcblxuICBpZiAocmVjdHMubGVuZ3RoKSB7XG4gICAgLy8gSWYgdGhlIGZpcnN0IHJlY3RhbmdsZSBoYXMgMCB3aWR0aCwgd2UgdXNlIHRoZSBzZWNvbmQsIHRoaXMgaXMgbmVlZGVkXG4gICAgLy8gYmVjYXVzZSBDaHJvbWUgcmVuZGVycyBhIDAgd2lkdGggcmVjdGFuZ2xlIHdoZW4gdGhlIHNlbGVjdGlvbiBjb250YWluc1xuICAgIC8vIGEgbGluZSBicmVhay5cbiAgICBpZiAocmVjdHMubGVuZ3RoID4gMSAmJiByZWN0c1swXS53aWR0aCA9PT0gMCkge1xuICAgICAgdmFyIF9yZWN0cyQgPSByZWN0c1sxXTtcbiAgICAgIHRvcCA9IF9yZWN0cyQudG9wO1xuICAgICAgcmlnaHQgPSBfcmVjdHMkLnJpZ2h0O1xuICAgICAgYm90dG9tID0gX3JlY3RzJC5ib3R0b207XG4gICAgICBsZWZ0ID0gX3JlY3RzJC5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3JlY3RzJDIgPSByZWN0c1swXTtcbiAgICAgIHRvcCA9IF9yZWN0cyQyLnRvcDtcbiAgICAgIHJpZ2h0ID0gX3JlY3RzJDIucmlnaHQ7XG4gICAgICBib3R0b20gPSBfcmVjdHMkMi5ib3R0b207XG4gICAgICBsZWZ0ID0gX3JlY3RzJDIubGVmdDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpaSA9IDE7IGlpIDwgcmVjdHMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgcmVjdCA9IHJlY3RzW2lpXTtcbiAgICAgIGlmIChyZWN0LmhlaWdodCAhPT0gMCAmJiByZWN0LndpZHRoICE9PSAwKSB7XG4gICAgICAgIHRvcCA9IE1hdGgubWluKHRvcCwgcmVjdC50b3ApO1xuICAgICAgICByaWdodCA9IE1hdGgubWF4KHJpZ2h0LCByZWN0LnJpZ2h0KTtcbiAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoYm90dG9tLCByZWN0LmJvdHRvbSk7XG4gICAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCByZWN0LmxlZnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiB0b3AsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIGJvdHRvbTogYm90dG9tLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICBoZWlnaHQ6IGJvdHRvbSAtIHRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhbmdlQm91bmRpbmdDbGllbnRSZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RyYWZ0LWpzL2xpYi9nZXRSYW5nZUJvdW5kaW5nQ2xpZW50UmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dChyZXF1aXJlKFwicmVhY3RcIikscmVxdWlyZShcImRyYWZ0LWpzXCIpLHJlcXVpcmUoXCJpbW11dGFibGVcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wicmVhY3RcIixcImRyYWZ0LWpzXCIsXCJpbW11dGFibGVcIl0sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5yZWFjdERyYWZ0V3lzaXd5Zz10KHJlcXVpcmUoXCJyZWFjdFwiKSxyZXF1aXJlKFwiZHJhZnQtanNcIikscmVxdWlyZShcImltbXV0YWJsZVwiKSk6ZS5yZWFjdERyYWZ0V3lzaXd5Zz10KGUucmVhY3QsZVtcImRyYWZ0LWpzXCJdLGUuaW1tdXRhYmxlKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChvKXtpZihuW29dKXJldHVybiBuW29dLmV4cG9ydHM7dmFyIGk9bltvXT17aTpvLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbb10uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsdCksaS5sPSEwLGkuZXhwb3J0c312YXIgbj17fTtyZXR1cm4gdC5tPWUsdC5jPW4sdC5kPWZ1bmN0aW9uKGUsbixvKXt0Lm8oZSxuKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0Om99KX0sdC5uPWZ1bmN0aW9uKGUpe3ZhciBuPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiB0LmQobixcImFcIixuKSxufSx0Lm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHQucD1cIlwiLHQodC5zPTEzKX0oW2Z1bmN0aW9uKHQsbil7dC5leHBvcnRzPWV9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcjtlLmV4cG9ydHM9bigxNikoKX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBvLGkscj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfTsvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4hZnVuY3Rpb24oKXtmdW5jdGlvbiBsKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgbj1hcmd1bWVudHNbdF07aWYobil7dmFyIG89dm9pZCAwPT09bj9cInVuZGVmaW5lZFwiOnIobik7aWYoXCJzdHJpbmdcIj09PW98fFwibnVtYmVyXCI9PT1vKWUucHVzaChuKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkobikpZS5wdXNoKGwuYXBwbHkobnVsbCxuKSk7ZWxzZSBpZihcIm9iamVjdFwiPT09bylmb3IodmFyIGkgaW4gbilhLmNhbGwobixpKSYmbltpXSYmZS5wdXNoKGkpfX1yZXR1cm4gZS5qb2luKFwiIFwiKX12YXIgYT17fS5oYXNPd25Qcm9wZXJ0eTt2b2lkIDAhPT1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWw6XCJvYmplY3RcIj09PXIobigxMCkpJiZuKDEwKT8obz1bXSx2b2lkIDAhPT0oaT1mdW5jdGlvbigpe3JldHVybiBsfS5hcHBseSh0LG8pKSYmKGUuZXhwb3J0cz1pKSk6d2luZG93LmNsYXNzTmFtZXM9bH0oKX0sZnVuY3Rpb24oZSxuKXtlLmV4cG9ydHM9dH0sZnVuY3Rpb24oZSx0LG4peyFmdW5jdGlvbih0LG8pe2UuZXhwb3J0cz1vKG4oMyksbig5KSl9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobyl7aWYobltvXSlyZXR1cm4gbltvXS5leHBvcnRzO3ZhciBpPW5bb109e2k6byxsOiExLGV4cG9ydHM6e319O3JldHVybiBlW29dLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLHQpLGkubD0hMCxpLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIHQubT1lLHQuYz1uLHQuZD1mdW5jdGlvbihlLG4sbyl7dC5vKGUsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpvfSl9LHQubj1mdW5jdGlvbihlKXt2YXIgbj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKG4sXCJhXCIsbiksbn0sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9XCJcIix0KHQucz0zKX0oW2Z1bmN0aW9uKHQsbil7dC5leHBvcnRzPWV9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3ZhciB0PWUuZ2V0U2VsZWN0aW9uKCksbj1lLmdldEN1cnJlbnRDb250ZW50KCksbz10LmdldFN0YXJ0S2V5KCksaT10LmdldEVuZEtleSgpLHI9bi5nZXRCbG9ja01hcCgpO3JldHVybiByLnRvU2VxKCkuc2tpcFVudGlsKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ9PT1vfSkudGFrZVVudGlsKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ9PT1pfSkuY29uY2F0KFtbaSxyLmdldChpKV1dKX1mdW5jdGlvbiBpKGUpe3JldHVybiBvKGUpLnRvTGlzdCgpfWZ1bmN0aW9uIHIoZSl7aWYoZSlyZXR1cm4gaShlKS5nZXQoMCl9ZnVuY3Rpb24gbChlKXtpZihlKXt2YXIgdD1yKGUpLG49ZS5nZXRDdXJyZW50Q29udGVudCgpLG89bi5nZXRCbG9ja01hcCgpLnRvU2VxKCkudG9MaXN0KCksaT0wO2lmKG8uZm9yRWFjaChmdW5jdGlvbihlLG4pe2UuZ2V0KFwia2V5XCIpPT09dC5nZXQoXCJrZXlcIikmJihpPW4tMSl9KSxpPi0xKXJldHVybiBvLmdldChpKX19ZnVuY3Rpb24gYShlKXtyZXR1cm4gZT9lLmdldEN1cnJlbnRDb250ZW50KCkuZ2V0QmxvY2tNYXAoKS50b0xpc3QoKTpuZXcgSS5MaXN0fWZ1bmN0aW9uIGMoZSl7dmFyIHQ9aShlKTtpZighdC5zb21lKGZ1bmN0aW9uKGUpe3JldHVybiBlLnR5cGUhPT10LmdldCgwKS50eXBlfSkpcmV0dXJuIHQuZ2V0KDApLnR5cGV9ZnVuY3Rpb24gcyhlKXt2YXIgdD1ELlJpY2hVdGlscy50cnlUb1JlbW92ZUJsb2NrU3R5bGUoZSk7cmV0dXJuIHQ/RC5FZGl0b3JTdGF0ZS5wdXNoKGUsdCxcImNoYW5nZS1ibG9jay10eXBlXCIpOmV9ZnVuY3Rpb24gTShlKXt2YXIgdD1cIlwiLG49ZS5nZXRTZWxlY3Rpb24oKSxvPW4uZ2V0QW5jaG9yT2Zmc2V0KCkscj1uLmdldEZvY3VzT2Zmc2V0KCksbD1pKGUpO2lmKGwuc2l6ZT4wKXtpZihuLmdldElzQmFja3dhcmQoKSl7dmFyIGE9bztvPXIscj1hfWZvcih2YXIgYz0wO2M8bC5zaXplO2MrPTEpe3ZhciBzPTA9PT1jP286MCxNPWM9PT1sLnNpemUtMT9yOmwuZ2V0KGMpLmdldFRleHQoKS5sZW5ndGg7dCs9bC5nZXQoYykuZ2V0VGV4dCgpLnNsaWNlKHMsTSl9fXJldHVybiB0fWZ1bmN0aW9uIHUoZSl7dmFyIHQ9ZS5nZXRDdXJyZW50Q29udGVudCgpLG49ZS5nZXRTZWxlY3Rpb24oKSxvPUQuTW9kaWZpZXIucmVtb3ZlUmFuZ2UodCxuLFwiZm9yd2FyZFwiKSxpPW8uZ2V0U2VsZWN0aW9uQWZ0ZXIoKSxyPW8uZ2V0QmxvY2tGb3JLZXkoaS5nZXRTdGFydEtleSgpKTtyZXR1cm4gbz1ELk1vZGlmaWVyLmluc2VydFRleHQobyxpLFwiXFxuXCIsci5nZXRJbmxpbmVTdHlsZUF0KGkuZ2V0U3RhcnRPZmZzZXQoKSksbnVsbCksRC5FZGl0b3JTdGF0ZS5wdXNoKGUsbyxcImluc2VydC1mcmFnbWVudFwiKX1mdW5jdGlvbiBnKGUpe3ZhciB0PUQuTW9kaWZpZXIuc3BsaXRCbG9jayhlLmdldEN1cnJlbnRDb250ZW50KCksZS5nZXRTZWxlY3Rpb24oKSk7cmV0dXJuIHMoRC5FZGl0b3JTdGF0ZS5wdXNoKGUsdCxcInNwbGl0LWJsb2NrXCIpKX1mdW5jdGlvbiBkKGUpe3ZhciB0PWUuZ2V0Q3VycmVudENvbnRlbnQoKS5nZXRCbG9ja01hcCgpLnRvTGlzdCgpLG49ZS5nZXRTZWxlY3Rpb24oKS5tZXJnZSh7YW5jaG9yS2V5OnQuZmlyc3QoKS5nZXQoXCJrZXlcIiksYW5jaG9yT2Zmc2V0OjAsZm9jdXNLZXk6dC5sYXN0KCkuZ2V0KFwia2V5XCIpLGZvY3VzT2Zmc2V0OnQubGFzdCgpLmdldExlbmd0aCgpfSksbz1ELk1vZGlmaWVyLnJlbW92ZVJhbmdlKGUuZ2V0Q3VycmVudENvbnRlbnQoKSxuLFwiZm9yd2FyZFwiKTtyZXR1cm4gRC5FZGl0b3JTdGF0ZS5wdXNoKGUsbyxcInJlbW92ZS1yYW5nZVwiKX1mdW5jdGlvbiBwKGUsdCl7dmFyIG49RC5Nb2RpZmllci5zZXRCbG9ja0RhdGEoZS5nZXRDdXJyZW50Q29udGVudCgpLGUuZ2V0U2VsZWN0aW9uKCksdCk7cmV0dXJuIEQuRWRpdG9yU3RhdGUucHVzaChlLG4sXCJjaGFuZ2UtYmxvY2stZGF0YVwiKX1mdW5jdGlvbiBOKGUpe3ZhciB0PW5ldyBJLk1hcCh7fSksbj1pKGUpO2lmKG4mJm4uc2l6ZT4wKWZvcih2YXIgbz0wO288bi5zaXplO28rPTEpe3ZhciByPWZ1bmN0aW9uKGUpe3ZhciBvPW4uZ2V0KGUpLmdldERhdGEoKTtpZighb3x8MD09PW8uc2l6ZSlyZXR1cm4gdD10LmNsZWFyKCksXCJicmVha1wiO2lmKDA9PT1lKXQ9bztlbHNlIGlmKHQuZm9yRWFjaChmdW5jdGlvbihlLG4pe28uZ2V0KG4pJiZvLmdldChuKT09PWV8fCh0PXQuZGVsZXRlKG4pKX0pLDA9PT10LnNpemUpcmV0dXJuIHQ9dC5jbGVhcigpLFwiYnJlYWtcIn0obyk7aWYoXCJicmVha1wiPT09cilicmVha31yZXR1cm4gdH1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmJsb2NrUmVuZGVyTWFwPXZvaWQgMCx0LmdldFNlbGVjdGVkQmxvY2tzTWFwPW8sdC5nZXRTZWxlY3RlZEJsb2Nrc0xpc3Q9aSx0LmdldFNlbGVjdGVkQmxvY2s9cix0LmdldEJsb2NrQmVmb3JlU2VsZWN0ZWRCbG9jaz1sLHQuZ2V0QWxsQmxvY2tzPWEsdC5nZXRTZWxlY3RlZEJsb2Nrc1R5cGU9Yyx0LnJlbW92ZVNlbGVjdGVkQmxvY2tzU3R5bGU9cyx0LmdldFNlbGVjdGlvblRleHQ9TSx0LmFkZExpbmVCcmVha1JlbW92aW5nU2VsZWN0aW9uPXUsdC5pbnNlcnROZXdVbnN0eWxlZEJsb2NrPWcsdC5jbGVhckVkaXRvckNvbnRlbnQ9ZCx0LnNldEJsb2NrRGF0YT1wLHQuZ2V0U2VsZWN0ZWRCbG9ja3NNZXRhZGF0YT1OO3ZhciBEPW4oMCksST1uKDYpLHk9KDAsSS5NYXApKHtjb2RlOntlbGVtZW50OlwicHJlXCJ9fSk7dC5ibG9ja1JlbmRlck1hcD1ELkRlZmF1bHREcmFmdEJsb2NrUmVuZGVyTWFwLm1lcmdlKHkpfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtpZihlKXt2YXIgdD1lLmdldFR5cGUoKTtyZXR1cm5cInVub3JkZXJlZC1saXN0LWl0ZW1cIj09PXR8fFwib3JkZXJlZC1saXN0LWl0ZW1cIj09PXR9cmV0dXJuITF9ZnVuY3Rpb24gaShlLHQsbil7dmFyIG89ZS5nZXRTZWxlY3Rpb24oKSxpPWUuZ2V0Q3VycmVudENvbnRlbnQoKSxyPWkuZ2V0QmxvY2tNYXAoKSxsPSgwLGEuZ2V0U2VsZWN0ZWRCbG9ja3NNYXApKGUpLm1hcChmdW5jdGlvbihlKXt2YXIgbz1lLmdldERlcHRoKCkrdDtyZXR1cm4gbz1NYXRoLm1heCgwLE1hdGgubWluKG8sbikpLGUuc2V0KFwiZGVwdGhcIixvKX0pO3JldHVybiByPXIubWVyZ2UobCksaS5tZXJnZSh7YmxvY2tNYXA6cixzZWxlY3Rpb25CZWZvcmU6byxzZWxlY3Rpb25BZnRlcjpvfSl9ZnVuY3Rpb24gcihlLHQsbil7dmFyIG89ZS5nZXRTZWxlY3Rpb24oKSxyPXZvaWQgMDtyPW8uZ2V0SXNCYWNrd2FyZCgpP28uZ2V0Rm9jdXNLZXkoKTpvLmdldEFuY2hvcktleSgpO3ZhciBhPWUuZ2V0Q3VycmVudENvbnRlbnQoKSxjPWEuZ2V0QmxvY2tGb3JLZXkocikscz1jLmdldFR5cGUoKTtpZihcInVub3JkZXJlZC1saXN0LWl0ZW1cIiE9PXMmJlwib3JkZXJlZC1saXN0LWl0ZW1cIiE9PXMpcmV0dXJuIGU7dmFyIE09YS5nZXRCbG9ja0JlZm9yZShyKTtpZighTSlyZXR1cm4gZTtpZihNLmdldFR5cGUoKSE9PXMpcmV0dXJuIGU7dmFyIHU9Yy5nZXREZXB0aCgpO2lmKDE9PT10JiZ1PT09bilyZXR1cm4gZTt2YXIgZz1NYXRoLm1pbihNLmdldERlcHRoKCkrMSxuKSxkPWkoZSx0LGcpO3JldHVybiBsLkVkaXRvclN0YXRlLnB1c2goZSxkLFwiYWRqdXN0LWRlcHRoXCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuaXNMaXN0QmxvY2s9byx0LmNoYW5nZURlcHRoPXI7dmFyIGw9bigwKSxhPW4oMSl9LGZ1bmN0aW9uKGUsdCxuKXtlLmV4cG9ydHM9big0KX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBvPW4oNSksaT1uKDEpLHI9big3KSxsPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX0ociksYT1uKDIpO2UuZXhwb3J0cz17Z2V0U2VsZWN0ZWRCbG9ja3NNYXA6aS5nZXRTZWxlY3RlZEJsb2Nrc01hcCxnZXRTZWxlY3RlZEJsb2Nrc0xpc3Q6aS5nZXRTZWxlY3RlZEJsb2Nrc0xpc3QsZ2V0U2VsZWN0ZWRCbG9jazppLmdldFNlbGVjdGVkQmxvY2ssZ2V0QmxvY2tCZWZvcmVTZWxlY3RlZEJsb2NrOmkuZ2V0QmxvY2tCZWZvcmVTZWxlY3RlZEJsb2NrLGdldEFsbEJsb2NrczppLmdldEFsbEJsb2NrcyxnZXRTZWxlY3RlZEJsb2Nrc1R5cGU6aS5nZXRTZWxlY3RlZEJsb2Nrc1R5cGUscmVtb3ZlU2VsZWN0ZWRCbG9ja3NTdHlsZTppLnJlbW92ZVNlbGVjdGVkQmxvY2tzU3R5bGUsZ2V0U2VsZWN0aW9uVGV4dDppLmdldFNlbGVjdGlvblRleHQsYWRkTGluZUJyZWFrUmVtb3ZpbmdTZWxlY3Rpb246aS5hZGRMaW5lQnJlYWtSZW1vdmluZ1NlbGVjdGlvbixpbnNlcnROZXdVbnN0eWxlZEJsb2NrOmkuaW5zZXJ0TmV3VW5zdHlsZWRCbG9jayxjbGVhckVkaXRvckNvbnRlbnQ6aS5jbGVhckVkaXRvckNvbnRlbnQsc2V0QmxvY2tEYXRhOmkuc2V0QmxvY2tEYXRhLGdldFNlbGVjdGVkQmxvY2tzTWV0YWRhdGE6aS5nZXRTZWxlY3RlZEJsb2Nrc01ldGFkYXRhLGJsb2NrUmVuZGVyTWFwOmkuYmxvY2tSZW5kZXJNYXAsZ2V0RW50aXR5UmFuZ2U6by5nZXRFbnRpdHlSYW5nZSxnZXRDdXN0b21TdHlsZU1hcDpvLmdldEN1c3RvbVN0eWxlTWFwLHRvZ2dsZUN1c3RvbUlubGluZVN0eWxlOm8udG9nZ2xlQ3VzdG9tSW5saW5lU3R5bGUsZ2V0U2VsZWN0aW9uRW50aXR5Om8uZ2V0U2VsZWN0aW9uRW50aXR5LGV4dHJhY3RJbmxpbmVTdHlsZTpvLmV4dHJhY3RJbmxpbmVTdHlsZSxyZW1vdmVBbGxJbmxpbmVTdHlsZXM6by5yZW1vdmVBbGxJbmxpbmVTdHlsZXMsZ2V0U2VsZWN0aW9uSW5saW5lU3R5bGU6by5nZXRTZWxlY3Rpb25JbmxpbmVTdHlsZSxnZXRTZWxlY3Rpb25DdXN0b21JbmxpbmVTdHlsZTpvLmdldFNlbGVjdGlvbkN1c3RvbUlubGluZVN0eWxlLGhhbmRsZU5ld0xpbmU6bC5kZWZhdWx0LGlzTGlzdEJsb2NrOmEuaXNMaXN0QmxvY2ssY2hhbmdlRGVwdGg6YS5jaGFuZ2VEZXB0aH19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX1mdW5jdGlvbiBpKGUpe3ZhciB0PWUuZ2V0U2VsZWN0aW9uKCk7aWYodC5pc0NvbGxhcHNlZCgpKXt2YXIgbj17fSxvPWUuZ2V0Q3VycmVudElubGluZVN0eWxlKCkudG9MaXN0KCkudG9KUygpO2lmKG8pcmV0dXJuW1wiQk9MRFwiLFwiSVRBTElDXCIsXCJVTkRFUkxJTkVcIixcIlNUUklLRVRIUk9VR0hcIixcIkNPREVcIixcIlNVUEVSU0NSSVBUXCIsXCJTVUJTQ1JJUFRcIl0uZm9yRWFjaChmdW5jdGlvbihlKXtuW2VdPW8uaW5kZXhPZihlKT49MH0pLG59dmFyIGk9dC5nZXRTdGFydE9mZnNldCgpLHI9dC5nZXRFbmRPZmZzZXQoKSxsPSgwLEQuZ2V0U2VsZWN0ZWRCbG9ja3NMaXN0KShlKTtpZihsLnNpemU+MCl7dmFyIGE9ZnVuY3Rpb24oKXtmb3IodmFyIGU9e0JPTEQ6ITAsSVRBTElDOiEwLFVOREVSTElORTohMCxTVFJJS0VUSFJPVUdIOiEwLENPREU6ITAsU1VQRVJTQ1JJUFQ6ITAsU1VCU0NSSVBUOiEwfSx0PTA7dDxsLnNpemU7dCs9MSl7dmFyIG49MD09PXQ/aTowLG89dD09PWwuc2l6ZS0xP3I6bC5nZXQodCkuZ2V0VGV4dCgpLmxlbmd0aDtuPT09byYmMD09PW4/KG49MSxvPTIpOm49PT1vJiYobi09MSk7Zm9yKHZhciBhPW47YTxvO2ErPTEpIWZ1bmN0aW9uKG4pe3ZhciBvPWwuZ2V0KHQpLmdldElubGluZVN0eWxlQXQobik7W1wiQk9MRFwiLFwiSVRBTElDXCIsXCJVTkRFUkxJTkVcIixcIlNUUklLRVRIUk9VR0hcIixcIkNPREVcIixcIlNVUEVSU0NSSVBUXCIsXCJTVUJTQ1JJUFRcIl0uZm9yRWFjaChmdW5jdGlvbih0KXtlW3RdPWVbdF0mJm8uZ2V0KHQpPT09dH0pfShhKX1yZXR1cm57djplfX0oKTtpZihcIm9iamVjdFwiPT09KHZvaWQgMD09PWE/XCJ1bmRlZmluZWRcIjpwKGEpKSlyZXR1cm4gYS52fXJldHVybnt9fWZ1bmN0aW9uIHIoZSl7dmFyIHQ9dm9pZCAwLG49ZS5nZXRTZWxlY3Rpb24oKSxvPW4uZ2V0U3RhcnRPZmZzZXQoKSxpPW4uZ2V0RW5kT2Zmc2V0KCk7bz09PWkmJjA9PT1vP2k9MTpvPT09aSYmKG8tPTEpO2Zvcih2YXIgcj0oMCxELmdldFNlbGVjdGVkQmxvY2spKGUpLGw9bztsPGk7bCs9MSl7dmFyIGE9ci5nZXRFbnRpdHlBdChsKTtpZighYSl7dD12b2lkIDA7YnJlYWt9aWYobD09PW8pdD1hO2Vsc2UgaWYodCE9PWEpe3Q9dm9pZCAwO2JyZWFrfX1yZXR1cm4gdH1mdW5jdGlvbiBsKGUsdCl7dmFyIG49KDAsRC5nZXRTZWxlY3RlZEJsb2NrKShlKSxvPXZvaWQgMDtyZXR1cm4gbi5maW5kRW50aXR5UmFuZ2VzKGZ1bmN0aW9uKGUpe3JldHVybiBlLmdldChcImVudGl0eVwiKT09PXR9LGZ1bmN0aW9uKGUsdCl7bz17c3RhcnQ6ZSxlbmQ6dCx0ZXh0Om4uZ2V0KFwidGV4dFwiKS5zbGljZShlLHQpfX0pLG99ZnVuY3Rpb24gYShlLHQsbil7dmFyIG89ZS5nZXRTZWxlY3Rpb24oKSxpPU9iamVjdC5rZXlzKElbdF0pLnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBOLk1vZGlmaWVyLnJlbW92ZUlubGluZVN0eWxlKGUsbyx0KX0sZS5nZXRDdXJyZW50Q29udGVudCgpKSxyPU4uRWRpdG9yU3RhdGUucHVzaChlLGksXCJjaGFuZ2VpbmxpbmUtc3R5bGVcIiksbD1lLmdldEN1cnJlbnRJbmxpbmVTdHlsZSgpO2lmKG8uaXNDb2xsYXBzZWQoKSYmKHI9bC5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gTi5SaWNoVXRpbHMudG9nZ2xlSW5saW5lU3R5bGUoZSx0KX0scikpLFwiU1VQRVJTQ1JJUFRcIj09PXR8fFwiU1VCU0NSSVBUXCI9PXQpbC5oYXMobil8fChyPU4uUmljaFV0aWxzLnRvZ2dsZUlubGluZVN0eWxlKHIsbikpO2Vsc2V7dmFyIGE9XCJiZ2NvbG9yXCI9PT10P1wiYmFja2dyb3VuZENvbG9yXCI6dDtsLmhhcyhhK1wiLVwiK24pfHwocj1OLlJpY2hVdGlscy50b2dnbGVJbmxpbmVTdHlsZShyLHQudG9Mb3dlckNhc2UoKStcIi1cIituKSx5KHQsYSxuKSl9cmV0dXJuIHJ9ZnVuY3Rpb24gYyhlKXtlJiZlLmdldEN1cnJlbnRDb250ZW50KCkuZ2V0QmxvY2tNYXAoKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0KFwiY2hhcmFjdGVyTGlzdFwiKX0pLnRvTGlzdCgpLmZsYXR0ZW4oKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UmJjA9PT1lLmluZGV4T2YoXCJjb2xvci1cIik/eShcImNvbG9yXCIsXCJjb2xvclwiLGUuc3Vic3RyKDYpKTplJiYwPT09ZS5pbmRleE9mKFwiYmdjb2xvci1cIik/eShcImJnY29sb3JcIixcImJhY2tncm91bmRDb2xvclwiLGUuc3Vic3RyKDgpKTplJiYwPT09ZS5pbmRleE9mKFwiZm9udHNpemUtXCIpP3koXCJmb250U2l6ZVwiLFwiZm9udFNpemVcIiwrZS5zdWJzdHIoOSkpOmUmJjA9PT1lLmluZGV4T2YoXCJmb250ZmFtaWx5LVwiKSYmeShcImZvbnRGYW1pbHlcIixcImZvbnRGYW1pbHlcIixlLnN1YnN0cigxMSkpfSl9ZnVuY3Rpb24gcyhlLHQsbil7dmFyIG89ZS5nZXRJbmxpbmVTdHlsZUF0KG4pLnRvTGlzdCgpLGk9by5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3RhcnRzV2l0aCh0LnRvTG93ZXJDYXNlKCkpfSk7aWYoaSYmaS5zaXplPjApcmV0dXJuIGkuZ2V0KDApfWZ1bmN0aW9uIE0oZSx0KXt2YXIgbj1lLmdldEN1cnJlbnRJbmxpbmVTdHlsZSgpLnRvTGlzdCgpLG89bi5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3RhcnRzV2l0aCh0LnRvTG93ZXJDYXNlKCkpfSk7aWYobyYmby5zaXplPjApcmV0dXJuIG8uZ2V0KDApfWZ1bmN0aW9uIHUoZSx0KXtpZihlJiZ0JiZ0Lmxlbmd0aD4wKXt2YXIgbj1mdW5jdGlvbigpe3ZhciBuPWUuZ2V0U2VsZWN0aW9uKCksbz17fTtpZihuLmlzQ29sbGFwc2VkKCkpcmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbih0KXtvW3RdPU0oZSx0KX0pLHt2Om99O3ZhciBpPW4uZ2V0U3RhcnRPZmZzZXQoKSxyPW4uZ2V0RW5kT2Zmc2V0KCksbD0oMCxELmdldFNlbGVjdGVkQmxvY2tzTGlzdCkoZSk7aWYobC5zaXplPjApe2Zvcih2YXIgYT0wO2E8bC5zaXplO2ErPTEpIWZ1bmN0aW9uKGUpe3ZhciBuPTA9PT1lP2k6MCxhPWU9PT1sLnNpemUtMT9yOmwuZ2V0KGUpLmdldFRleHQoKS5sZW5ndGg7bj09PWEmJjA9PT1uPyhuPTEsYT0yKTpuPT09YSYmKG4tPTEpO2Zvcih2YXIgYz1uO2M8YTtjKz0xKSFmdW5jdGlvbihpKXtpPT09bj90LmZvckVhY2goZnVuY3Rpb24odCl7b1t0XT1zKGwuZ2V0KGUpLHQsaSl9KTp0LmZvckVhY2goZnVuY3Rpb24odCl7b1t0XSYmb1t0XSE9PXMobC5nZXQoZSksdCxpKSYmKG9bdF09dm9pZCAwKX0pfShjKX0oYSk7cmV0dXJue3Y6b319fSgpO2lmKFwib2JqZWN0XCI9PT0odm9pZCAwPT09bj9cInVuZGVmaW5lZFwiOnAobikpKXJldHVybiBuLnZ9cmV0dXJue319ZnVuY3Rpb24gZyhlKXt2YXIgdD1lLmdldEN1cnJlbnRJbmxpbmVTdHlsZSgpLG49ZS5nZXRDdXJyZW50Q29udGVudCgpO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCl7bj1OLk1vZGlmaWVyLnJlbW92ZUlubGluZVN0eWxlKG4sZS5nZXRTZWxlY3Rpb24oKSx0KX0pLE4uRWRpdG9yU3RhdGUucHVzaChlLG4sXCJjaGFuZ2UtaW5saW5lLXN0eWxlXCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0Q3VzdG9tU3R5bGVNYXA9dm9pZCAwO3ZhciBkPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBuPWFyZ3VtZW50c1t0XTtmb3IodmFyIG8gaW4gbilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixvKSYmKGVbb109bltvXSl9cmV0dXJuIGV9LHA9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX07dC5nZXRTZWxlY3Rpb25JbmxpbmVTdHlsZT1pLHQuZ2V0U2VsZWN0aW9uRW50aXR5PXIsdC5nZXRFbnRpdHlSYW5nZT1sLHQudG9nZ2xlQ3VzdG9tSW5saW5lU3R5bGU9YSx0LmV4dHJhY3RJbmxpbmVTdHlsZT1jLHQuZ2V0U2VsZWN0aW9uQ3VzdG9tSW5saW5lU3R5bGU9dSx0LnJlbW92ZUFsbElubGluZVN0eWxlcz1nO3ZhciBOPW4oMCksRD1uKDEpLEk9e2NvbG9yOnt9LGJnY29sb3I6e30sZm9udFNpemU6e30sZm9udEZhbWlseTp7fSxDT0RFOntmb250RmFtaWx5OlwibW9ub3NwYWNlXCIsd29yZFdyYXA6XCJicmVhay13b3JkXCIsYmFja2dyb3VuZDpcIiNmMWYxZjFcIixib3JkZXJSYWRpdXM6MyxwYWRkaW5nOlwiMXB4IDNweFwifSxTVVBFUlNDUklQVDp7Zm9udFNpemU6MTEscG9zaXRpb246XCJyZWxhdGl2ZVwiLHRvcDotOCxkaXNwbGF5OlwiaW5saW5lLWZsZXhcIn0sU1VCU0NSSVBUOntmb250U2l6ZToxMSxwb3NpdGlvbjpcInJlbGF0aXZlXCIsYm90dG9tOi04LGRpc3BsYXk6XCJpbmxpbmUtZmxleFwifX0seT1mdW5jdGlvbihlLHQsbil7SVtlXVtlLnRvTG93ZXJDYXNlKCkrXCItXCIrbl09byh7fSxcIlwiK3Qsbil9O3QuZ2V0Q3VzdG9tU3R5bGVNYXA9ZnVuY3Rpb24oKXtyZXR1cm4gZCh7fSxJLmNvbG9yLEkuYmdjb2xvcixJLmZvbnRTaXplLEkuZm9udEZhbWlseSx7Q09ERTpJLkNPREUsU1VQRVJTQ1JJUFQ6SS5TVVBFUlNDUklQVCxTVUJTQ1JJUFQ6SS5TVUJTQ1JJUFR9KX19LGZ1bmN0aW9uKGUsbil7ZS5leHBvcnRzPXR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3ZhciB0PWUuZ2V0U2VsZWN0aW9uKCk7aWYodC5pc0NvbGxhcHNlZCgpKXt2YXIgbj1lLmdldEN1cnJlbnRDb250ZW50KCksbz10LmdldFN0YXJ0S2V5KCksaT1uLmdldEJsb2NrRm9yS2V5KG8pO2lmKCEoMCxjLmlzTGlzdEJsb2NrKShpKSYmXCJ1bnN0eWxlZFwiIT09aS5nZXRUeXBlKCkmJmkuZ2V0TGVuZ3RoKCk9PT10LmdldFN0YXJ0T2Zmc2V0KCkpcmV0dXJuKDAsYS5pbnNlcnROZXdVbnN0eWxlZEJsb2NrKShlKTtpZigoMCxjLmlzTGlzdEJsb2NrKShpKSYmMD09PWkuZ2V0TGVuZ3RoKCkpe3ZhciByPWkuZ2V0RGVwdGgoKTtpZigwPT09cilyZXR1cm4oMCxhLnJlbW92ZVNlbGVjdGVkQmxvY2tzU3R5bGUpKGUpO2lmKHI+MClyZXR1cm4oMCxjLmNoYW5nZURlcHRoKShlLC0xLHIpfX19ZnVuY3Rpb24gaShlKXtyZXR1cm4gMTM9PT1lLndoaWNoJiYoZS5nZXRNb2RpZmllclN0YXRlKFwiU2hpZnRcIil8fGUuZ2V0TW9kaWZpZXJTdGF0ZShcIkFsdFwiKXx8ZS5nZXRNb2RpZmllclN0YXRlKFwiQ29udHJvbFwiKSl9ZnVuY3Rpb24gcihlLHQpe3JldHVybiBpKHQpP2UuZ2V0U2VsZWN0aW9uKCkuaXNDb2xsYXBzZWQoKT9sLlJpY2hVdGlscy5pbnNlcnRTb2Z0TmV3bGluZShlKTooMCxhLmFkZExpbmVCcmVha1JlbW92aW5nU2VsZWN0aW9uKShlKTpvKGUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1yO3ZhciBsPW4oMCksYT1uKDEpLGM9bigyKX1dKX0pfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9ZnVuY3Rpb24gcihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gbChlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGEoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLHM9bigwKSxNPW8ocyksdT1uKDEpLGc9byh1KSxkPW4oMikscD1vKGQpO24oMjkpO3ZhciBOPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZSxuLG8saTtyKHRoaXMsdCk7Zm9yKHZhciBhPWFyZ3VtZW50cy5sZW5ndGgsYz1BcnJheShhKSxzPTA7czxhO3MrKyljW3NdPWFyZ3VtZW50c1tzXTtyZXR1cm4gbj1vPWwodGhpcywoZT10Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsLmFwcGx5KGUsW3RoaXNdLmNvbmNhdChjKSkpLG8ub25DbGljaz1mdW5jdGlvbigpe3ZhciBlPW8ucHJvcHMsdD1lLmRpc2FibGVkLG49ZS5vbkNsaWNrLGk9ZS52YWx1ZTt0fHxuKGkpfSxpPW4sbChvLGkpfXJldHVybiBhKHQsZSksYyh0LFt7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSx0PXRoaXMucHJvcHMsbj10LmNoaWxkcmVuLG89dC5jbGFzc05hbWUscj10LmFjdGl2ZUNsYXNzTmFtZSxsPXQuYWN0aXZlLGE9dC5kaXNhYmxlZCxjPXQudGl0bGU7cmV0dXJuIE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTooMCxwLmRlZmF1bHQpKFwicmR3LW9wdGlvbi13cmFwcGVyXCIsbywoZT17fSxpKGUsXCJyZHctb3B0aW9uLWFjdGl2ZSBcIityLGwpLGkoZSxcInJkdy1vcHRpb24tZGlzYWJsZWRcIixhKSxlKSksb25DbGljazp0aGlzLm9uQ2xpY2ssXCJhcmlhLXNlbGVjdGVkXCI6bCx0aXRsZTpjfSxuKX19XSksdH0ocy5Db21wb25lbnQpO04ucHJvcFR5cGVzPXtvbkNsaWNrOmcuZGVmYXVsdC5mdW5jLmlzUmVxdWlyZWQsY2hpbGRyZW46Zy5kZWZhdWx0LmFueSx2YWx1ZTpnLmRlZmF1bHQuc3RyaW5nLGNsYXNzTmFtZTpnLmRlZmF1bHQuc3RyaW5nLGFjdGl2ZUNsYXNzTmFtZTpnLmRlZmF1bHQuc3RyaW5nLGFjdGl2ZTpnLmRlZmF1bHQuYm9vbCxkaXNhYmxlZDpnLmRlZmF1bHQuYm9vbCx0aXRsZTpnLmRlZmF1bHQuc3RyaW5nfSx0LmRlZmF1bHQ9Tn0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSx0KXtpZihlKWZvcih2YXIgbiBpbiBlKSh7fSkuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pJiZ0KG4sZVtuXSl9ZnVuY3Rpb24gaShlLHQpe3ZhciBuPSExO2lmKGUpZm9yKHZhciBvIGluIGUpaWYoe30uaGFzT3duUHJvcGVydHkuY2FsbChlLG8pJiZ0PT09byl7bj0hMDticmVha31yZXR1cm4gbn1mdW5jdGlvbiByKGUpe3JldHVybiFlfHwhZS50cmltKCl9ZnVuY3Rpb24gbChlKXtyZXR1cm5cIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpfWZ1bmN0aW9uIGEoZSx0KXt2YXIgbj1PYmplY3Qua2V5cyhlKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIHQuaW5kZXhPZihlKTwwfSksbz17fTtyZXR1cm4gbiYmbi5sZW5ndGg+MCYmbi5mb3JFYWNoKGZ1bmN0aW9uKHQpe29bdF09ZVt0XX0pLG99ZnVuY3Rpb24gYyhlKXtlLnN0b3BQcm9wYWdhdGlvbigpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZm9yRWFjaD1vLHQuaGFzUHJvcGVydHk9aSx0LmlzRW1wdHlTdHJpbmc9cix0LmlzTWFwPWwsdC5maWx0ZXI9YSx0LnN0b3BQcm9wYWdhdGlvbj1jfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19dmFyIGk9bigzMCkscj1vKGkpLGw9bigzMiksYT1vKGwpO2UuZXhwb3J0cz17RHJvcGRvd246ci5kZWZhdWx0LERyb3Bkb3duT3B0aW9uOmEuZGVmYXVsdH19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgbz1uKDYpLGk9ZnVuY3Rpb24oZSl7cmV0dXJuIGVbZS5vcHRpb25zWzBdXS5pY29ufSxyPWZ1bmN0aW9uIGUodCxuKXtpZih0JiZ2b2lkIDA9PT1uKXJldHVybiB0O3ZhciBpPXt9O3JldHVybigwLG8uZm9yRWFjaCkodCxmdW5jdGlvbih0LHIpeygwLG8uaXNNYXApKHIpP2lbdF09ZShyLG5bdF0pOmlbdF09dm9pZCAwIT09blt0XT9uW3RdOnJ9KSxpfTtlLmV4cG9ydHM9e2dldEZpcnN0SWNvbjppLG1lcmdlUmVjdXJzaXZlOnJ9fSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1ufSxmdW5jdGlvbihlLHQpeyhmdW5jdGlvbih0KXtlLmV4cG9ydHM9dH0pLmNhbGwodCx7fSl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1bXTt0LmRlZmF1bHQ9e29uS2V5RG93bjpmdW5jdGlvbihlKXtvLmZvckVhY2goZnVuY3Rpb24odCl7dChlKX0pfSxyZWdpc3RlckNhbGxCYWNrOmZ1bmN0aW9uKGUpe28ucHVzaChlKX0sZGVyZWdpc3RlckNhbGxCYWNrOmZ1bmN0aW9uKGUpe289by5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQhPT1lfSl9fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPXZvaWQgMDt0LmRlZmF1bHQ9e29wZW46ZnVuY3Rpb24oKXtvPSEwfSxjbG9zZTpmdW5jdGlvbigpe289ITF9LGlzT3BlbjpmdW5jdGlvbigpe3JldHVybiBvfX19LGZ1bmN0aW9uKGUsdCxuKXtlLmV4cG9ydHM9bigxNCl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgbz1uKDE1KSxpPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX0obyk7ZS5leHBvcnRzPXtFZGl0b3I6aS5kZWZhdWx0fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoZSl7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciB0PTAsbj1BcnJheShlLmxlbmd0aCk7dDxlLmxlbmd0aDt0Kyspblt0XT1lW3RdO3JldHVybiBufXJldHVybiBBcnJheS5mcm9tKGUpfWZ1bmN0aW9uIHIoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGwoZSx0KXtpZighZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2U6dH1mdW5jdGlvbiBhKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHQpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsdCk6ZS5fX3Byb3RvX189dCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGM9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIG49YXJndW1lbnRzW3RdO2Zvcih2YXIgbyBpbiBuKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLG8pJiYoZVtvXT1uW29dKX1yZXR1cm4gZX0scz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLE09bigwKSx1PW8oTSksZz1uKDEpLGQ9byhnKSxwPW4oMyksTj1uKDQpLEQ9bigyKSxJPW8oRCkseT1uKDIwKSxqPW8oeSksZj1uKDIxKSx3PW8oZiksbT1uKDExKSxDPW8obSksej1uKDEyKSxBPW8oeiksVD1uKDIyKSxFPW8oVCksTD1uKDgpLHg9big2KSxPPW4oMjMpLGs9bigyNiksaD1vKGspLGI9big3OSksUz1vKGIpLHY9big4MiksVT1vKHYpLFE9big4OCksWT1vKFEpLF89big5MCksUD1vKF8pLEI9big5NCksWj1vKEIpLEc9bigxMjApLEY9byhHKTtuKDEzNSksbigxMzYpO3ZhciBSPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSl7cih0aGlzLHQpO3ZhciBuPWwodGhpcywodC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbCh0aGlzLGUpKTtXLmNhbGwobik7dmFyIG89KDAsTC5tZXJnZVJlY3Vyc2l2ZSkoWi5kZWZhdWx0LGUudG9vbGJhcik7bi5zdGF0ZT17ZWRpdG9yU3RhdGU6dm9pZCAwLGVkaXRvckZvY3VzZWQ6ITEsdG9vbGJhcjpvfTt2YXIgaT1lLndyYXBwZXJJZD9lLndyYXBwZXJJZDpNYXRoLmZsb29yKDFlNCpNYXRoLnJhbmRvbSgpKTtyZXR1cm4gbi53cmFwcGVySWQ9XCJyZHctd3JhcHBlci1cIitpLG4ubW9kYWxIYW5kbGVyPW5ldyBqLmRlZmF1bHQsbi5mb2N1c0hhbmRsZXI9bmV3IHcuZGVmYXVsdCxuLmJsb2NrUmVuZGVyZXJGbj0oMCxQLmRlZmF1bHQpKHtpc1JlYWRPbmx5Om4uaXNSZWFkT25seSxpc0ltYWdlQWxpZ25tZW50RW5hYmxlZDpuLmlzSW1hZ2VBbGlnbm1lbnRFbmFibGVkLGdldEVkaXRvclN0YXRlOm4uZ2V0RWRpdG9yU3RhdGUsb25DaGFuZ2U6bi5vbkNoYW5nZX0sZS5jdXN0b21CbG9ja1JlbmRlckZ1bmMpLG4uZWRpdG9yUHJvcHM9bi5maWx0ZXJFZGl0b3JQcm9wcyhlKSxuLmN1c3RvbVN0eWxlTWFwPSgwLE4uZ2V0Q3VzdG9tU3R5bGVNYXApKCksbn1yZXR1cm4gYSh0LGUpLHModCxbe2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jb21wb3NpdGVEZWNvcmF0b3I9dGhpcy5nZXRDb21wb3NpdGVEZWNvcmF0b3IoKTt2YXIgZT10aGlzLmNyZWF0ZUVkaXRvclN0YXRlKHRoaXMuY29tcG9zaXRlRGVjb3JhdG9yKTsoMCxOLmV4dHJhY3RJbmxpbmVTdHlsZSkoZSksdGhpcy5zZXRTdGF0ZSh7ZWRpdG9yU3RhdGU6ZX0pfX0se2tleTpcImNvbXBvbmVudERpZE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm1vZGFsSGFuZGxlci5pbml0KHRoaXMud3JhcHBlcklkKX19LHtrZXk6XCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9e307aWYodGhpcy5wcm9wcy50b29sYmFyIT09ZS50b29sYmFyKXt2YXIgbj0oMCxMLm1lcmdlUmVjdXJzaXZlKShaLmRlZmF1bHQsZS50b29sYmFyKTt0LnRvb2xiYXI9bn1pZigoMCx4Lmhhc1Byb3BlcnR5KShlLFwiZWRpdG9yU3RhdGVcIikmJnRoaXMucHJvcHMuZWRpdG9yU3RhdGUhPT1lLmVkaXRvclN0YXRlKWUuZWRpdG9yU3RhdGU/dC5lZGl0b3JTdGF0ZT1wLkVkaXRvclN0YXRlLnNldChlLmVkaXRvclN0YXRlLHtkZWNvcmF0b3I6dGhpcy5jb21wb3NpdGVEZWNvcmF0b3J9KTp0LmVkaXRvclN0YXRlPXAuRWRpdG9yU3RhdGUuY3JlYXRlRW1wdHkodGhpcy5jb21wb3NpdGVEZWNvcmF0b3IpO2Vsc2UgaWYoKDAseC5oYXNQcm9wZXJ0eSkoZSxcImNvbnRlbnRTdGF0ZVwiKSYmdGhpcy5wcm9wcy5jb250ZW50U3RhdGUhPT1lLmNvbnRlbnRTdGF0ZSlpZihlLmNvbnRlbnRTdGF0ZSl7dmFyIG89dGhpcy5jaGFuZ2VFZGl0b3JTdGF0ZShlLmNvbnRlbnRTdGF0ZSk7byYmKHQuZWRpdG9yU3RhdGU9byl9ZWxzZSB0LmVkaXRvclN0YXRlPXAuRWRpdG9yU3RhdGUuY3JlYXRlRW1wdHkodGhpcy5jb21wb3NpdGVEZWNvcmF0b3IpO2UuZWRpdG9yU3RhdGU9PT10aGlzLnByb3BzLmVkaXRvclN0YXRlJiZlLmNvbnRlbnRTdGF0ZT09PXRoaXMucHJvcHMuY29udGVudFN0YXRlfHwoMCxOLmV4dHJhY3RJbmxpbmVTdHlsZSkodC5lZGl0b3JTdGF0ZSksdGhpcy5zZXRTdGF0ZSh0KSx0aGlzLmVkaXRvclByb3BzPXRoaXMuZmlsdGVyRWRpdG9yUHJvcHMoZSksdGhpcy5jdXN0b21TdHlsZU1hcD0oMCxOLmdldEN1c3RvbVN0eWxlTWFwKSgpfX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zdGF0ZSx0PWUuZWRpdG9yU3RhdGUsbj1lLmVkaXRvckZvY3VzZWQsbz1lLnRvb2xiYXIsaT10aGlzLnByb3BzLHI9aS5sb2NhbGUsbD1pLmxvY2FsaXphdGlvbixhPWwubG9jYWxlLHM9bC50cmFuc2xhdGlvbnMsTT1pLnRvb2xiYXJDdXN0b21CdXR0b25zLGc9aS50b29sYmFyT25Gb2N1cyxkPWkudG9vbGJhckNsYXNzTmFtZSxEPWkudG9vbGJhckhpZGRlbix5PWkuZWRpdG9yQ2xhc3NOYW1lLGo9aS53cmFwcGVyQ2xhc3NOYW1lLGY9aS50b29sYmFyU3R5bGUsdz1pLmVkaXRvclN0eWxlLG09aS53cmFwcGVyU3R5bGUsej1pLnVwbG9hZENhbGxiYWNrLEE9aS5hcmlhTGFiZWwsVD17bW9kYWxIYW5kbGVyOnRoaXMubW9kYWxIYW5kbGVyLGVkaXRvclN0YXRlOnQsb25DaGFuZ2U6dGhpcy5vbkNoYW5nZSx0cmFuc2xhdGlvbnM6Yyh7fSxGLmRlZmF1bHRbcnx8YV0scyl9LEw9bnx8dGhpcy5mb2N1c0hhbmRsZXIuaXNJbnB1dEZvY3VzZWQoKXx8IWc7cmV0dXJuIHUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2lkOnRoaXMud3JhcHBlcklkLGNsYXNzTmFtZTooMCxJLmRlZmF1bHQpKGosXCJyZHctZWRpdG9yLXdyYXBwZXJcIiksc3R5bGU6bSxvbkNsaWNrOnRoaXMubW9kYWxIYW5kbGVyLm9uRWRpdG9yQ2xpY2ssb25CbHVyOnRoaXMub25XcmFwcGVyQmx1cixcImFyaWEtbGFiZWxcIjpcInJkdy13cmFwcGVyXCJ9LCFEJiZ1LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6KDAsSS5kZWZhdWx0KShcInJkdy1lZGl0b3ItdG9vbGJhclwiLGQpLHN0eWxlOmMoe3Zpc2liaWxpdHk6TD9cInZpc2libGVcIjpcImhpZGRlblwifSxmKSxvbk1vdXNlRG93bjp0aGlzLnByZXZlbnREZWZhdWx0LFwiYXJpYS1sYWJlbFwiOlwicmR3LXRvb2xiYXJcIixcImFyaWEtaGlkZGVuXCI6KCFuJiZnKS50b1N0cmluZygpLG9uRm9jdXM6dGhpcy5vblRvb2xiYXJGb2N1c30sby5vcHRpb25zLm1hcChmdW5jdGlvbihlLHQpe3ZhciBuPWguZGVmYXVsdFtlXSxpPW9bZV07cmV0dXJuXCJpbWFnZVwiPT09ZSYmeiYmKGkudXBsb2FkQ2FsbGJhY2s9eiksdS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQobixjKHtrZXk6dH0sVCx7Y29uZmlnOml9KSl9KSxNJiZNLm1hcChmdW5jdGlvbihlLHQpe3JldHVybiB1LmRlZmF1bHQuY2xvbmVFbGVtZW50KGUsYyh7a2V5OnR9LFQpKX0pKSx1LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtyZWY6dGhpcy5zZXRXcmFwcGVyUmVmZXJlbmNlLGNsYXNzTmFtZTooMCxJLmRlZmF1bHQpKHksXCJyZHctZWRpdG9yLW1haW5cIiksc3R5bGU6dyxvbkNsaWNrOnRoaXMuZm9jdXNFZGl0b3Isb25Gb2N1czp0aGlzLm9uRWRpdG9yRm9jdXMsb25CbHVyOnRoaXMub25FZGl0b3JCbHVyLG9uS2V5RG93bjpDLmRlZmF1bHQub25LZXlEb3duLG9uTW91c2VEb3duOnRoaXMub25FZGl0b3JNb3VzZURvd259LHUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHAuRWRpdG9yLGMoe3JlZjp0aGlzLnNldEVkaXRvclJlZmVyZW5jZSxvblRhYjp0aGlzLm9uVGFiLG9uVXBBcnJvdzp0aGlzLm9uVXBEb3duQXJyb3csb25Eb3duQXJyb3c6dGhpcy5vblVwRG93bkFycm93LGVkaXRvclN0YXRlOnQsb25DaGFuZ2U6dGhpcy5vbkNoYW5nZSxibG9ja1N0eWxlRm46RS5kZWZhdWx0LGN1c3RvbVN0eWxlTWFwOigwLE4uZ2V0Q3VzdG9tU3R5bGVNYXApKCksaGFuZGxlUmV0dXJuOnRoaXMuaGFuZGxlUmV0dXJuLGhhbmRsZVBhc3RlZFRleHQ6dGhpcy5oYW5kbGVQYXN0ZWRUZXh0LGJsb2NrUmVuZGVyZXJGbjp0aGlzLmJsb2NrUmVuZGVyZXJGbixoYW5kbGVLZXlDb21tYW5kOnRoaXMuaGFuZGxlS2V5Q29tbWFuZCxhcmlhTGFiZWw6QXx8XCJyZHctZWRpdG9yXCIsYmxvY2tSZW5kZXJNYXA6Ti5ibG9ja1JlbmRlck1hcH0sdGhpcy5lZGl0b3JQcm9wcykpKSl9fV0pLHR9KE0uQ29tcG9uZW50KTtSLnByb3BUeXBlcz17b25DaGFuZ2U6ZC5kZWZhdWx0LmZ1bmMsb25FZGl0b3JTdGF0ZUNoYW5nZTpkLmRlZmF1bHQuZnVuYyxvbkNvbnRlbnRTdGF0ZUNoYW5nZTpkLmRlZmF1bHQuZnVuYyxpbml0aWFsQ29udGVudFN0YXRlOmQuZGVmYXVsdC5vYmplY3QsZGVmYXVsdENvbnRlbnRTdGF0ZTpkLmRlZmF1bHQub2JqZWN0LGNvbnRlbnRTdGF0ZTpkLmRlZmF1bHQub2JqZWN0LGVkaXRvclN0YXRlOmQuZGVmYXVsdC5vYmplY3QsZGVmYXVsdEVkaXRvclN0YXRlOmQuZGVmYXVsdC5vYmplY3QsdG9vbGJhck9uRm9jdXM6ZC5kZWZhdWx0LmJvb2wsc3BlbGxDaGVjazpkLmRlZmF1bHQuYm9vbCxzdHJpcFBhc3RlZFN0eWxlczpkLmRlZmF1bHQuYm9vbCx0b29sYmFyOmQuZGVmYXVsdC5vYmplY3QsdG9vbGJhckN1c3RvbUJ1dHRvbnM6ZC5kZWZhdWx0LmFycmF5LHRvb2xiYXJDbGFzc05hbWU6ZC5kZWZhdWx0LnN0cmluZyx0b29sYmFySGlkZGVuOmQuZGVmYXVsdC5ib29sLGxvY2FsZTpkLmRlZmF1bHQuc3RyaW5nLGxvY2FsaXphdGlvbjpkLmRlZmF1bHQub2JqZWN0LGVkaXRvckNsYXNzTmFtZTpkLmRlZmF1bHQuc3RyaW5nLHdyYXBwZXJDbGFzc05hbWU6ZC5kZWZhdWx0LnN0cmluZyx0b29sYmFyU3R5bGU6ZC5kZWZhdWx0Lm9iamVjdCxlZGl0b3JTdHlsZTpkLmRlZmF1bHQub2JqZWN0LHdyYXBwZXJTdHlsZTpkLmRlZmF1bHQub2JqZWN0LHVwbG9hZENhbGxiYWNrOmQuZGVmYXVsdC5mdW5jLG9uRm9jdXM6ZC5kZWZhdWx0LmZ1bmMsb25CbHVyOmQuZGVmYXVsdC5mdW5jLG9uVGFiOmQuZGVmYXVsdC5mdW5jLG1lbnRpb246ZC5kZWZhdWx0Lm9iamVjdCxoYXNodGFnOmQuZGVmYXVsdC5vYmplY3QsdGV4dEFsaWdubWVudDpkLmRlZmF1bHQuc3RyaW5nLHJlYWRPbmx5OmQuZGVmYXVsdC5ib29sLHRhYkluZGV4OmQuZGVmYXVsdC5udW1iZXIscGxhY2Vob2xkZXI6ZC5kZWZhdWx0LnN0cmluZyxhcmlhTGFiZWw6ZC5kZWZhdWx0LnN0cmluZyxhcmlhT3duZWVJRDpkLmRlZmF1bHQuc3RyaW5nLGFyaWFBY3RpdmVEZXNjZW5kYW50SUQ6ZC5kZWZhdWx0LnN0cmluZyxhcmlhQXV0b0NvbXBsZXRlOmQuZGVmYXVsdC5zdHJpbmcsYXJpYURlc2NyaWJlZEJ5OmQuZGVmYXVsdC5zdHJpbmcsYXJpYUV4cGFuZGVkOmQuZGVmYXVsdC5zdHJpbmcsYXJpYUhhc1BvcHVwOmQuZGVmYXVsdC5zdHJpbmcsY3VzdG9tQmxvY2tSZW5kZXJGdW5jOmQuZGVmYXVsdC5mdW5jLHdyYXBwZXJJZDpkLmRlZmF1bHQubnVtYmVyLGN1c3RvbURlY29yYXRvcnM6ZC5kZWZhdWx0LmFycmF5LGVkaXRvclJlZjpkLmRlZmF1bHQuZnVuY30sUi5kZWZhdWx0UHJvcHM9e3Rvb2xiYXJPbkZvY3VzOiExLHRvb2xiYXJIaWRkZW46ITEsc3RyaXBQYXN0ZWRTdHlsZXM6ITEsbG9jYWxpemF0aW9uOntsb2NhbGU6XCJlblwiLHRyYW5zbGF0aW9uczp7fX0sY3VzdG9tRGVjb3JhdG9yczpbXX07dmFyIFc9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMub25FZGl0b3JCbHVyPWZ1bmN0aW9uKCl7ZS5zZXRTdGF0ZSh7ZWRpdG9yRm9jdXNlZDohMX0pfSx0aGlzLm9uRWRpdG9yRm9jdXM9ZnVuY3Rpb24odCl7dmFyIG49ZS5wcm9wcy5vbkZvY3VzO2Uuc2V0U3RhdGUoe2VkaXRvckZvY3VzZWQ6ITB9KTt2YXIgbz1lLmZvY3VzSGFuZGxlci5pc0VkaXRvckZvY3VzZWQoKTtuJiZvJiZuKHQpfSx0aGlzLm9uRWRpdG9yTW91c2VEb3duPWZ1bmN0aW9uKCl7ZS5mb2N1c0hhbmRsZXIub25FZGl0b3JNb3VzZURvd24oKX0sdGhpcy5vblRhYj1mdW5jdGlvbih0KXt2YXIgbj1lLnByb3BzLm9uVGFiO2lmKCFufHwhbih0KSl7dmFyIG89KDAsTi5jaGFuZ2VEZXB0aCkoZS5zdGF0ZS5lZGl0b3JTdGF0ZSx0LnNoaWZ0S2V5Py0xOjEsNCk7byYmbyE9PWUuc3RhdGUuZWRpdG9yU3RhdGUmJihlLm9uQ2hhbmdlKG8pLHQucHJldmVudERlZmF1bHQoKSl9fSx0aGlzLm9uVXBEb3duQXJyb3c9ZnVuY3Rpb24oZSl7QS5kZWZhdWx0LmlzT3BlbigpJiZlLnByZXZlbnREZWZhdWx0KCl9LHRoaXMub25Ub29sYmFyRm9jdXM9ZnVuY3Rpb24odCl7dmFyIG49ZS5wcm9wcy5vbkZvY3VzO24mJmUuZm9jdXNIYW5kbGVyLmlzVG9vbGJhckZvY3VzZWQoKSYmbih0KX0sdGhpcy5vbldyYXBwZXJCbHVyPWZ1bmN0aW9uKHQpe3ZhciBuPWUucHJvcHMub25CbHVyO24mJmUuZm9jdXNIYW5kbGVyLmlzRWRpdG9yQmx1cih0KSYmbih0LGUuZ2V0RWRpdG9yU3RhdGUoKSl9LHRoaXMub25DaGFuZ2U9ZnVuY3Rpb24odCl7dmFyIG49ZS5wcm9wcyxvPW4ucmVhZE9ubHksaT1uLm9uRWRpdG9yU3RhdGVDaGFuZ2U7b3x8XCJhdG9taWNcIj09PSgwLE4uZ2V0U2VsZWN0ZWRCbG9ja3NUeXBlKSh0KSYmdC5nZXRTZWxlY3Rpb24oKS5pc0NvbGxhcHNlZHx8KGkmJmkodCxlLnByb3BzLndyYXBwZXJJZCksKDAseC5oYXNQcm9wZXJ0eSkoZS5wcm9wcyxcImVkaXRvclN0YXRlXCIpP2UuYWZ0ZXJDaGFuZ2UodCk6ZS5zZXRTdGF0ZSh7ZWRpdG9yU3RhdGU6dH0sZS5hZnRlckNoYW5nZSh0KSkpfSx0aGlzLnNldFdyYXBwZXJSZWZlcmVuY2U9ZnVuY3Rpb24odCl7ZS53cmFwcGVyPXR9LHRoaXMuc2V0RWRpdG9yUmVmZXJlbmNlPWZ1bmN0aW9uKHQpe2UucHJvcHMuZWRpdG9yUmVmJiZlLnByb3BzLmVkaXRvclJlZih0KSxlLmVkaXRvcj10fSx0aGlzLmdldENvbXBvc2l0ZURlY29yYXRvcj1mdW5jdGlvbigpe3ZhciB0PVtdLmNvbmNhdChpKGUucHJvcHMuY3VzdG9tRGVjb3JhdG9ycyksWygwLFMuZGVmYXVsdCkoe3Nob3dPcGVuT3B0aW9uT25Ib3ZlcjplLnN0YXRlLnRvb2xiYXIubGluay5zaG93T3Blbk9wdGlvbk9uSG92ZXJ9KV0pO3JldHVybiBlLnByb3BzLm1lbnRpb24mJnQucHVzaC5hcHBseSh0LGkoKDAsVS5kZWZhdWx0KShjKHt9LGUucHJvcHMubWVudGlvbix7b25DaGFuZ2U6ZS5vbkNoYW5nZSxnZXRFZGl0b3JTdGF0ZTplLmdldEVkaXRvclN0YXRlLGdldFN1Z2dlc3Rpb25zOmUuZ2V0U3VnZ2VzdGlvbnMsZ2V0V3JhcHBlclJlZjplLmdldFdyYXBwZXJSZWYsbW9kYWxIYW5kbGVyOmUubW9kYWxIYW5kbGVyfSkpKSksZS5wcm9wcy5oYXNodGFnJiZ0LnB1c2goKDAsWS5kZWZhdWx0KShlLnByb3BzLmhhc2h0YWcpKSxuZXcgcC5Db21wb3NpdGVEZWNvcmF0b3IodCl9LHRoaXMuZ2V0V3JhcHBlclJlZj1mdW5jdGlvbigpe3JldHVybiBlLndyYXBwZXJ9LHRoaXMuZ2V0RWRpdG9yU3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gZS5zdGF0ZS5lZGl0b3JTdGF0ZX0sdGhpcy5nZXRTdWdnZXN0aW9ucz1mdW5jdGlvbigpe3JldHVybiBlLnByb3BzLm1lbnRpb24mJmUucHJvcHMubWVudGlvbi5zdWdnZXN0aW9uc30sdGhpcy5hZnRlckNoYW5nZT1mdW5jdGlvbih0KXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dmFyIG49ZS5wcm9wcyxvPW4ub25DaGFuZ2UsaT1uLm9uQ29udGVudFN0YXRlQ2hhbmdlO28mJm8oKDAscC5jb252ZXJ0VG9SYXcpKHQuZ2V0Q3VycmVudENvbnRlbnQoKSkpLGkmJmkoKDAscC5jb252ZXJ0VG9SYXcpKHQuZ2V0Q3VycmVudENvbnRlbnQoKSkpfSl9LHRoaXMuaXNSZWFkT25seT1mdW5jdGlvbigpe3JldHVybiBlLnByb3BzLnJlYWRPbmx5fSx0aGlzLmlzSW1hZ2VBbGlnbm1lbnRFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIGUuc3RhdGUudG9vbGJhci5pbWFnZS5hbGlnbm1lbnRFbmFibGVkfSx0aGlzLmNyZWF0ZUVkaXRvclN0YXRlPWZ1bmN0aW9uKHQpe3ZhciBuPXZvaWQgMDtpZigoMCx4Lmhhc1Byb3BlcnR5KShlLnByb3BzLFwiZWRpdG9yU3RhdGVcIikpZS5wcm9wcy5lZGl0b3JTdGF0ZSYmKG49cC5FZGl0b3JTdGF0ZS5zZXQoZS5wcm9wcy5lZGl0b3JTdGF0ZSx7ZGVjb3JhdG9yOnR9KSk7ZWxzZSBpZigoMCx4Lmhhc1Byb3BlcnR5KShlLnByb3BzLFwiZGVmYXVsdEVkaXRvclN0YXRlXCIpKWUucHJvcHMuZGVmYXVsdEVkaXRvclN0YXRlJiYobj1wLkVkaXRvclN0YXRlLnNldChlLnByb3BzLmRlZmF1bHRFZGl0b3JTdGF0ZSx7ZGVjb3JhdG9yOnR9KSk7ZWxzZSBpZigoMCx4Lmhhc1Byb3BlcnR5KShlLnByb3BzLFwiY29udGVudFN0YXRlXCIpKXtpZihlLnByb3BzLmNvbnRlbnRTdGF0ZSl7dmFyIG89KDAscC5jb252ZXJ0RnJvbVJhdykoZS5wcm9wcy5jb250ZW50U3RhdGUpO249cC5FZGl0b3JTdGF0ZS5jcmVhdGVXaXRoQ29udGVudChvLHQpLG49cC5FZGl0b3JTdGF0ZS5tb3ZlU2VsZWN0aW9uVG9FbmQobil9fWVsc2UgaWYoKDAseC5oYXNQcm9wZXJ0eSkoZS5wcm9wcyxcImRlZmF1bHRDb250ZW50U3RhdGVcIil8fCgwLHguaGFzUHJvcGVydHkpKGUucHJvcHMsXCJpbml0aWFsQ29udGVudFN0YXRlXCIpKXt2YXIgaT1lLnByb3BzLmRlZmF1bHRDb250ZW50U3RhdGV8fGUucHJvcHMuaW5pdGlhbENvbnRlbnRTdGF0ZTtpJiYoaT0oMCxwLmNvbnZlcnRGcm9tUmF3KShpKSxuPXAuRWRpdG9yU3RhdGUuY3JlYXRlV2l0aENvbnRlbnQoaSx0KSxuPXAuRWRpdG9yU3RhdGUubW92ZVNlbGVjdGlvblRvRW5kKG4pKX1yZXR1cm4gbnx8KG49cC5FZGl0b3JTdGF0ZS5jcmVhdGVFbXB0eSh0KSksbn0sdGhpcy5maWx0ZXJFZGl0b3JQcm9wcz1mdW5jdGlvbihlKXtyZXR1cm4oMCx4LmZpbHRlcikoZSxbXCJvbkNoYW5nZVwiLFwib25FZGl0b3JTdGF0ZUNoYW5nZVwiLFwib25Db250ZW50U3RhdGVDaGFuZ2VcIixcImluaXRpYWxDb250ZW50U3RhdGVcIixcImRlZmF1bHRDb250ZW50U3RhdGVcIixcImNvbnRlbnRTdGF0ZVwiLFwiZWRpdG9yU3RhdGVcIixcImRlZmF1bHRFZGl0b3JTdGF0ZVwiLFwibG9jYWxlXCIsXCJsb2NhbGl6YXRpb25cIixcInRvb2xiYXJPbkZvY3VzXCIsXCJ0b29sYmFyXCIsXCJ0b29sYmFyQ3VzdG9tQnV0dG9uc1wiLFwidG9vbGJhckNsYXNzTmFtZVwiLFwiZWRpdG9yQ2xhc3NOYW1lXCIsXCJ0b29sYmFySGlkZGVuXCIsXCJ3cmFwcGVyQ2xhc3NOYW1lXCIsXCJ0b29sYmFyU3R5bGVcIixcImVkaXRvclN0eWxlXCIsXCJ3cmFwcGVyU3R5bGVcIixcInVwbG9hZENhbGxiYWNrXCIsXCJvbkZvY3VzXCIsXCJvbkJsdXJcIixcIm9uVGFiXCIsXCJtZW50aW9uXCIsXCJoYXNodGFnXCIsXCJhcmlhTGFiZWxcIixcImN1c3RvbUJsb2NrUmVuZGVyRnVuY1wiLFwiY3VzdG9tRGVjb3JhdG9yc1wiLFwiaGFuZGxlUGFzdGVkVGV4dFwiXSl9LHRoaXMuY2hhbmdlRWRpdG9yU3RhdGU9ZnVuY3Rpb24odCl7dmFyIG49KDAscC5jb252ZXJ0RnJvbVJhdykodCksbz1lLnN0YXRlLmVkaXRvclN0YXRlO3JldHVybiBvPXAuRWRpdG9yU3RhdGUucHVzaChvLG4sXCJpbnNlcnQtY2hhcmFjdGVyc1wiKSxvPXAuRWRpdG9yU3RhdGUubW92ZVNlbGVjdGlvblRvRW5kKG8pfSx0aGlzLmZvY3VzRWRpdG9yPWZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe2UuZWRpdG9yLmZvY3VzKCl9KX0sdGhpcy5oYW5kbGVLZXlDb21tYW5kPWZ1bmN0aW9uKHQpe3ZhciBuPWUuc3RhdGUsbz1uLmVkaXRvclN0YXRlLGk9bi50b29sYmFyLmlubGluZTtpZihpJiZpLm9wdGlvbnMuaW5kZXhPZih0KT49MCl7dmFyIHI9cC5SaWNoVXRpbHMuaGFuZGxlS2V5Q29tbWFuZChvLHQpO2lmKHIpcmV0dXJuIGUub25DaGFuZ2UociksITB9cmV0dXJuITF9LHRoaXMuaGFuZGxlUmV0dXJuPWZ1bmN0aW9uKHQpe2lmKEEuZGVmYXVsdC5pc09wZW4oKSlyZXR1cm4hMDt2YXIgbj0oMCxOLmhhbmRsZU5ld0xpbmUpKGUuc3RhdGUuZWRpdG9yU3RhdGUsdCk7cmV0dXJuISFuJiYoZS5vbkNoYW5nZShuKSwhMCl9LHRoaXMuaGFuZGxlUGFzdGVkVGV4dD1mdW5jdGlvbih0LG4pe3ZhciBvPWUuc3RhdGUuZWRpdG9yU3RhdGU7cmV0dXJuIGUucHJvcHMuaGFuZGxlUGFzdGVkVGV4dD9lLnByb3BzLmhhbmRsZVBhc3RlZFRleHQodCxuLG8sZS5vbkNoYW5nZSk6IWUucHJvcHMuc3RyaXBQYXN0ZWRTdHlsZXMmJigwLE8uaGFuZGxlUGFzdGVkVGV4dCkodCxuLG8sZS5vbkNoYW5nZSl9LHRoaXMucHJldmVudERlZmF1bHQ9ZnVuY3Rpb24odCl7XCJJTlBVVFwiPT09dC50YXJnZXQudGFnTmFtZXx8XCJMQUJFTFwiPT09dC50YXJnZXQudGFnTmFtZT9lLmZvY3VzSGFuZGxlci5vbklucHV0TW91c2VEb3duKCk6dC5wcmV2ZW50RGVmYXVsdCgpfX07dC5kZWZhdWx0PVJ9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgbz1uKDE3KSxpPW4oMTgpLHI9bigxOSk7ZS5leHBvcnRzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQsbixvLGwsYSl7YSE9PXImJmkoITEsXCJDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiBVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiBSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzXCIpfWZ1bmN0aW9uIHQoKXtyZXR1cm4gZX1lLmlzUmVxdWlyZWQ9ZTt2YXIgbj17YXJyYXk6ZSxib29sOmUsZnVuYzplLG51bWJlcjplLG9iamVjdDplLHN0cmluZzplLHN5bWJvbDplLGFueTplLGFycmF5T2Y6dCxlbGVtZW50OmUsaW5zdGFuY2VPZjp0LG5vZGU6ZSxvYmplY3RPZjp0LG9uZU9mOnQsb25lT2ZUeXBlOnQsc2hhcGU6dCxleGFjdDp0fTtyZXR1cm4gbi5jaGVja1Byb3BUeXBlcz1vLG4uUHJvcFR5cGVzPW4sbn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlfX12YXIgaT1mdW5jdGlvbigpe307aS50aGF0UmV0dXJucz1vLGkudGhhdFJldHVybnNGYWxzZT1vKCExKSxpLnRoYXRSZXR1cm5zVHJ1ZT1vKCEwKSxpLnRoYXRSZXR1cm5zTnVsbD1vKG51bGwpLGkudGhhdFJldHVybnNUaGlzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LGkudGhhdFJldHVybnNBcmd1bWVudD1mdW5jdGlvbihlKXtyZXR1cm4gZX0sZS5leHBvcnRzPWl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUsdCxuLG8scixsLGEsYyl7aWYoaSh0KSwhZSl7dmFyIHM7aWYodm9pZCAwPT09dClzPW5ldyBFcnJvcihcIk1pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCIpO2Vsc2V7dmFyIE09W24sbyxyLGwsYSxjXSx1PTA7cz1uZXcgRXJyb3IodC5yZXBsYWNlKC8lcy9nLGZ1bmN0aW9uKCl7cmV0dXJuIE1bdSsrXX0pKSxzLm5hbWU9XCJJbnZhcmlhbnQgVmlvbGF0aW9uXCJ9dGhyb3cgcy5mcmFtZXNUb1BvcD0xLHN9fXZhciBpPWZ1bmN0aW9uKGUpe307ZS5leHBvcnRzPW99LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9XCJTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRFwifSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9ZnVuY3Rpb24gZSgpe3ZhciB0PXRoaXM7byh0aGlzLGUpLHRoaXMuY2FsbEJhY2tzPVtdLHRoaXMuc3VnZ2VzdGlvbkNhbGxiYWNrPXZvaWQgMCx0aGlzLmVkaXRvckZsYWc9ITEsdGhpcy5zdWdnZXN0aW9uRmxhZz0hMSx0aGlzLmNsb3NlQWxsTW9kYWxzPWZ1bmN0aW9uKGUpe3QuY2FsbEJhY2tzLmZvckVhY2goZnVuY3Rpb24odCl7dChlKX0pfSx0aGlzLmluaXQ9ZnVuY3Rpb24oZSl7dmFyIG49ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZSk7biYmbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixmdW5jdGlvbigpe3QuZWRpdG9yRmxhZz0hMH0pLGRvY3VtZW50JiYoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZnVuY3Rpb24oKXt0LmVkaXRvckZsYWc/dC5lZGl0b3JGbGFnPSExOih0LmNsb3NlQWxsTW9kYWxzKCksdC5zdWdnZXN0aW9uQ2FsbGJhY2smJnQuc3VnZ2VzdGlvbkNhbGxiYWNrKCkpfSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIixmdW5jdGlvbihlKXtcIkVzY2FwZVwiPT09ZS5rZXkmJnQuY2xvc2VBbGxNb2RhbHMoKX0pKX0sdGhpcy5vbkVkaXRvckNsaWNrPWZ1bmN0aW9uKCl7dC5jbG9zZU1vZGFscygpLCF0LnN1Z2dlc3Rpb25GbGFnJiZ0LnN1Z2dlc3Rpb25DYWxsYmFjaz90LnN1Z2dlc3Rpb25DYWxsYmFjaygpOnQuc3VnZ2VzdGlvbkZsYWc9ITF9LHRoaXMuY2xvc2VNb2RhbHM9ZnVuY3Rpb24oZSl7dC5jbG9zZUFsbE1vZGFscyhlKX0sdGhpcy5yZWdpc3RlckNhbGxCYWNrPWZ1bmN0aW9uKGUpe3QuY2FsbEJhY2tzLnB1c2goZSl9LHRoaXMuZGVyZWdpc3RlckNhbGxCYWNrPWZ1bmN0aW9uKGUpe3QuY2FsbEJhY2tzPXQuY2FsbEJhY2tzLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdCE9PWV9KX0sdGhpcy5zZXRTdWdnZXN0aW9uQ2FsbGJhY2s9ZnVuY3Rpb24oZSl7dC5zdWdnZXN0aW9uQ2FsbGJhY2s9ZX0sdGhpcy5yZW1vdmVTdWdnZXN0aW9uQ2FsbGJhY2s9ZnVuY3Rpb24oKXt0LnN1Z2dlc3Rpb25DYWxsYmFjaz12b2lkIDB9LHRoaXMub25TdWdnZXN0aW9uQ2xpY2s9ZnVuY3Rpb24oKXt0LnN1Z2dlc3Rpb25GbGFnPSEwfX07dC5kZWZhdWx0PWl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1mdW5jdGlvbiBlKCl7dmFyIHQ9dGhpcztvKHRoaXMsZSksdGhpcy5pbnB1dEZvY3VzZWQ9ITEsdGhpcy5lZGl0b3JNb3VzZURvd249ITEsdGhpcy5vbkVkaXRvck1vdXNlRG93bj1mdW5jdGlvbigpe3QuZWRpdG9yRm9jdXNlZD0hMH0sdGhpcy5vbklucHV0TW91c2VEb3duPWZ1bmN0aW9uKCl7dC5pbnB1dEZvY3VzZWQ9ITB9LHRoaXMuaXNFZGl0b3JCbHVyPWZ1bmN0aW9uKGUpe3JldHVyblwiSU5QVVRcIiE9PWUudGFyZ2V0LnRhZ05hbWUmJlwiTEFCRUxcIiE9PWUudGFyZ2V0LnRhZ05hbWV8fHQuZWRpdG9yRm9jdXNlZD8hKFwiSU5QVVRcIj09PWUudGFyZ2V0LnRhZ05hbWUmJlwiTEFCRUxcIj09PWUudGFyZ2V0LnRhZ05hbWV8fHQuaW5wdXRGb2N1c2VkKSYmKHQuZWRpdG9yRm9jdXNlZD0hMSwhMCk6KHQuaW5wdXRGb2N1c2VkPSExLCEwKX0sdGhpcy5pc0VkaXRvckZvY3VzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hdC5pbnB1dEZvY3VzZWR8fCh0LmlucHV0Rm9jdXNlZD0hMSwhMSl9LHRoaXMuaXNUb29sYmFyRm9jdXNlZD1mdW5jdGlvbigpe3JldHVybiF0LmVkaXRvckZvY3VzZWR8fCh0LmVkaXRvckZvY3VzZWQ9ITEsITEpfSx0aGlzLmlzSW5wdXRGb2N1c2VkPWZ1bmN0aW9uKCl7cmV0dXJuIHQuaW5wdXRGb2N1c2VkfX07dC5kZWZhdWx0PWl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3ZhciB0PWUuZ2V0RGF0YSgpJiZlLmdldERhdGEoKS5nZXQoXCJ0ZXh0LWFsaWduXCIpO3JldHVybiB0P1wicmR3LVwiK3QrXCItYWxpZ25lZC1ibG9ja1wiOlwiXCJ9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PW99LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmhhbmRsZVBhc3RlZFRleHQ9dm9pZCAwO3ZhciBvPW4oNCksaT1uKDMpLHI9bigyNCksbD1mdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19KHIpLGE9big5KTt0LmhhbmRsZVBhc3RlZFRleHQ9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGM9KDAsby5nZXRTZWxlY3RlZEJsb2NrKShuKTtpZihjJiZcImNvZGVcIj09PWMudHlwZSl7dmFyIHM9aS5Nb2RpZmllci5yZXBsYWNlVGV4dChuLmdldEN1cnJlbnRDb250ZW50KCksbi5nZXRTZWxlY3Rpb24oKSxlLG4uZ2V0Q3VycmVudElubGluZVN0eWxlKCkpO3JldHVybiByKGkuRWRpdG9yU3RhdGUucHVzaChuLHMsXCJpbnNlcnQtY2hhcmFjdGVyc1wiKSksITB9aWYodCl7dmFyIE09KDAsbC5kZWZhdWx0KSh0KSx1PW4uZ2V0Q3VycmVudENvbnRlbnQoKTtyZXR1cm4gTS5lbnRpdHlNYXAuZm9yRWFjaChmdW5jdGlvbihlLHQpe3U9dS5tZXJnZUVudGl0eURhdGEodCxlKX0pLHU9aS5Nb2RpZmllci5yZXBsYWNlV2l0aEZyYWdtZW50KHUsbi5nZXRTZWxlY3Rpb24oKSxuZXcgYS5MaXN0KE0uY29udGVudEJsb2NrcykpLHIoaS5FZGl0b3JTdGF0ZS5wdXNoKG4sdSxcImluc2VydC1jaGFyYWN0ZXJzXCIpKSwhMH1yZXR1cm4hMX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24oZSl7dmFyIG8saSxyLGw9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX07IWZ1bmN0aW9uKGEsYyl7XCJvYmplY3RcIj09bCh0KSYmXCJvYmplY3RcIj09bChlKT9lLmV4cG9ydHM9YyhuKDkpLG4oMykpOihpPVtuKDkpLG4oMyldLG89Yyx2b2lkIDAhPT0ocj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBvP28uYXBwbHkodCxpKTpvKSYmKGUuZXhwb3J0cz1yKSl9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobyl7aWYobltvXSlyZXR1cm4gbltvXS5leHBvcnRzO3ZhciBpPW5bb109e2k6byxsOiExLGV4cG9ydHM6e319O3JldHVybiBlW29dLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLHQpLGkubD0hMCxpLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIHQubT1lLHQuYz1uLHQuZD1mdW5jdGlvbihlLG4sbyl7dC5vKGUsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpvfSl9LHQubj1mdW5jdGlvbihlKXt2YXIgbj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKG4sXCJhXCIsbiksbn0sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9XCJcIix0KHQucz0yKX0oW2Z1bmN0aW9uKHQsbil7dC5leHBvcnRzPWV9LGZ1bmN0aW9uKGUsbil7ZS5leHBvcnRzPXR9LGZ1bmN0aW9uKGUsdCxuKXtlLmV4cG9ydHM9bigzKX0sZnVuY3Rpb24oZSx0LG4pe2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoZSx0LG4sbyxyLGwpe3ZhciBjPWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihsKXt2YXIgcz1sKGMsZSk7aWYocyl7dmFyIE09YS5FbnRpdHkuX19jcmVhdGUocy50eXBlLHMubXV0YWJpbGl0eSxzLmRhdGF8fHt9KTtyZXR1cm57Y2h1bms6KDAsdS5nZXRBdG9taWNCbG9ja0NodW5rKShNKX19fWlmKFwiI3RleHRcIj09PWMmJlwiXFxuXCIhPT1lLnRleHRDb250ZW50KXJldHVybigwLHUuY3JlYXRlVGV4dENodW5rKShlLHQscik7aWYoXCJiclwiPT09YylyZXR1cm57Y2h1bms6KDAsdS5nZXRTb2Z0TmV3bGluZUNodW5rKSgpfTtpZihcImltZ1wiPT09YyYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpe3ZhciBnPXt9O2cuc3JjPWUuZ2V0QXR0cmlidXRlP2UuZ2V0QXR0cmlidXRlKFwic3JjXCIpfHxlLnNyYzplLnNyYyxnLmFsdD1lLmFsdCxnLmhlaWdodD1lLnN0eWxlLmhlaWdodCxnLndpZHRoPWUuc3R5bGUud2lkdGgsZS5zdHlsZS5mbG9hdCYmKGcuYWxpZ25tZW50PWUuc3R5bGUuZmxvYXQpO3ZhciBwPWEuRW50aXR5Ll9fY3JlYXRlKFwiSU1BR0VcIixcIk1VVEFCTEVcIixnKTtyZXR1cm57Y2h1bms6KDAsdS5nZXRBdG9taWNCbG9ja0NodW5rKShwKX19aWYoXCJpZnJhbWVcIj09PWMmJmUgaW5zdGFuY2VvZiBIVE1MSUZyYW1lRWxlbWVudCl7dmFyIEQ9e307RC5zcmM9ZS5nZXRBdHRyaWJ1dGU/ZS5nZXRBdHRyaWJ1dGUoXCJzcmNcIil8fGUuc3JjOmUuc3JjLEQuaGVpZ2h0PWUuaGVpZ2h0LEQud2lkdGg9ZS53aWR0aDt2YXIgeT1hLkVudGl0eS5fX2NyZWF0ZShcIkVNQkVEREVEX0xJTktcIixcIk1VVEFCTEVcIixEKTtyZXR1cm57Y2h1bms6KDAsdS5nZXRBdG9taWNCbG9ja0NodW5rKSh5KX19dmFyIGY9KDAsZC5kZWZhdWx0KShjLG8pLHc9dm9pZCAwO2YmJihcInVsXCI9PT1jfHxcIm9sXCI9PT1jPyhvPWMsbis9MSk6KFwidW5vcmRlcmVkLWxpc3QtaXRlbVwiIT09ZiYmXCJvcmRlcmVkLWxpc3QtaXRlbVwiIT09ZiYmKG89XCJcIixuPS0xKSxtPyh3PSgwLHUuZ2V0Rmlyc3RCbG9ja0NodW5rKShmLCgwLEkuZGVmYXVsdCkoZSkpLG09ITEpOnc9KDAsdS5nZXRCbG9ja0RpdmlkZXJDaHVuaykoZixuLCgwLEkuZGVmYXVsdCkoZSkpKSksd3x8KHc9KDAsdS5nZXRFbXB0eUNodW5rKSgpKSx0PSgwLE4uZGVmYXVsdCkoYyxlLHQpO2Zvcih2YXIgQz1lLmZpcnN0Q2hpbGQ7Qzspe3ZhciB6PSgwLGouZGVmYXVsdCkoQyksQT1pKEMsdCxuLG8senx8cixsKSxUPUEuY2h1bms7dz0oMCx1LmpvaW5DaHVua3MpKHcsVCksQz1DLm5leHRTaWJsaW5nfXJldHVybntjaHVuazp3fX1mdW5jdGlvbiByKGUsdCl7dmFyIG49ZS50cmltKCkucmVwbGFjZSh3LGYpLG89KDAsTS5kZWZhdWx0KShuKTtyZXR1cm4gbz8obT0hMCx7Y2h1bms6aShvLG5ldyBjLk9yZGVyZWRTZXQsLTEsXCJcIix2b2lkIDAsdCkuY2h1bmt9KTpudWxsfWZ1bmN0aW9uIGwoZSx0KXt2YXIgbj1yKGUsdCk7aWYobil7dmFyIG89bi5jaHVuayxpPW5ldyBjLk9yZGVyZWRNYXAoe30pO28uZW50aXRpZXMmJm8uZW50aXRpZXMuZm9yRWFjaChmdW5jdGlvbihlKXtlJiYoaT1pLnNldChlLGEuRW50aXR5Ll9fZ2V0KGUpKSl9KTt2YXIgbD0wO3JldHVybntjb250ZW50QmxvY2tzOm8udGV4dC5zcGxpdChcIlxcclwiKS5tYXAoZnVuY3Rpb24oZSx0KXt2YXIgbj1sK2UubGVuZ3RoLGk9byYmby5pbmxpbmVzLnNsaWNlKGwsbikscj1vJiZvLmVudGl0aWVzLnNsaWNlKGwsbikscz1uZXcgYy5MaXN0KGkubWFwKGZ1bmN0aW9uKGUsdCl7dmFyIG49e3N0eWxlOmUsZW50aXR5Om51bGx9O3JldHVybiByW3RdJiYobi5lbnRpdHk9clt0XSksYS5DaGFyYWN0ZXJNZXRhZGF0YS5jcmVhdGUobil9KSk7cmV0dXJuIGw9bixuZXcgYS5Db250ZW50QmxvY2soe2tleTooMCxhLmdlbktleSkoKSx0eXBlOm8mJm8uYmxvY2tzW3RdJiZvLmJsb2Nrc1t0XS50eXBlfHxcInVuc3R5bGVkXCIsZGVwdGg6byYmby5ibG9ja3NbdF0mJm8uYmxvY2tzW3RdLmRlcHRoLGRhdGE6byYmby5ibG9ja3NbdF0mJm8uYmxvY2tzW3RdLmRhdGF8fG5ldyBjLk1hcCh7fSksdGV4dDplLGNoYXJhY3Rlckxpc3Q6c30pfSksZW50aXR5TWFwOml9fXJldHVybiBudWxsfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1sO3ZhciBhPW4oMSksYz1uKDApLHM9big0KSxNPW8ocyksdT1uKDUpLGc9big2KSxkPW8oZykscD1uKDcpLE49byhwKSxEPW4oOCksST1vKEQpLHk9big5KSxqPW8oeSksZj1cIiBcIix3PW5ldyBSZWdFeHAoXCImbmJzcDtcIixcImdcIiksbT0hMH0sZnVuY3Rpb24oZSx0LG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPWZ1bmN0aW9uKGUpe3ZhciB0LG49bnVsbDtyZXR1cm4gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24mJmRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCYmKHQ9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiZm9vXCIpLHQuZG9jdW1lbnRFbGVtZW50LmlubmVySFRNTD1lLG49dC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJvZHlcIilbMF0pLG59O3QuZGVmYXVsdD1vfSxmdW5jdGlvbihlLHQsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5qb2luQ2h1bmtzPXQuZ2V0QXRvbWljQmxvY2tDaHVuaz10LmdldEJsb2NrRGl2aWRlckNodW5rPXQuZ2V0Rmlyc3RCbG9ja0NodW5rPXQuZ2V0RW1wdHlDaHVuaz10LmdldFNvZnROZXdsaW5lQ2h1bms9dC5jcmVhdGVUZXh0Q2h1bms9dC5nZXRXaGl0ZXNwYWNlQ2h1bms9dm9pZCAwO3ZhciBvPW4oMCksaT10LmdldFdoaXRlc3BhY2VDaHVuaz1mdW5jdGlvbihlKXtyZXR1cm57dGV4dDpcIiBcIixpbmxpbmVzOltuZXcgby5PcmRlcmVkU2V0XSxlbnRpdGllczpbZV0sYmxvY2tzOltdfX07dC5jcmVhdGVUZXh0Q2h1bms9ZnVuY3Rpb24oZSx0LG4pe3ZhciBvPWUudGV4dENvbnRlbnQ7cmV0dXJuXCJcIj09PW8udHJpbSgpP3tjaHVuazppKG4pfTp7Y2h1bms6e3RleHQ6byxpbmxpbmVzOkFycmF5KG8ubGVuZ3RoKS5maWxsKHQpLGVudGl0aWVzOkFycmF5KG8ubGVuZ3RoKS5maWxsKG4pLGJsb2NrczpbXX19fSx0LmdldFNvZnROZXdsaW5lQ2h1bms9ZnVuY3Rpb24oKXtyZXR1cm57dGV4dDpcIlxcblwiLGlubGluZXM6W25ldyBvLk9yZGVyZWRTZXRdLGVudGl0aWVzOm5ldyBBcnJheSgxKSxibG9ja3M6W119fSx0LmdldEVtcHR5Q2h1bms9ZnVuY3Rpb24oKXtyZXR1cm57dGV4dDpcIlwiLGlubGluZXM6W10sZW50aXRpZXM6W10sYmxvY2tzOltdfX0sdC5nZXRGaXJzdEJsb2NrQ2h1bms9ZnVuY3Rpb24oZSx0KXtyZXR1cm57dGV4dDpcIlwiLGlubGluZXM6W10sZW50aXRpZXM6W10sYmxvY2tzOlt7dHlwZTplLGRlcHRoOjAsZGF0YTp0fHxuZXcgby5NYXAoe30pfV19fSx0LmdldEJsb2NrRGl2aWRlckNodW5rPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm57dGV4dDpcIlxcclwiLGlubGluZXM6W10sZW50aXRpZXM6W10sYmxvY2tzOlt7dHlwZTplLGRlcHRoOk1hdGgubWF4KDAsTWF0aC5taW4oNCx0KSksZGF0YTpufHxuZXcgby5NYXAoe30pfV19fSx0LmdldEF0b21pY0Jsb2NrQ2h1bms9ZnVuY3Rpb24oZSl7cmV0dXJue3RleHQ6XCJcXHIgXCIsaW5saW5lczpbbmV3IG8uT3JkZXJlZFNldF0sZW50aXRpZXM6W2VdLGJsb2Nrczpbe3R5cGU6XCJhdG9taWNcIixkZXB0aDowLGRhdGE6bmV3IG8uTWFwKHt9KX1dfX0sdC5qb2luQ2h1bmtzPWZ1bmN0aW9uKGUsdCl7cmV0dXJue3RleHQ6ZS50ZXh0K3QudGV4dCxpbmxpbmVzOmUuaW5saW5lcy5jb25jYXQodC5pbmxpbmVzKSxlbnRpdGllczplLmVudGl0aWVzLmNvbmNhdCh0LmVudGl0aWVzKSxibG9ja3M6ZS5ibG9ja3MuY29uY2F0KHQuYmxvY2tzKX19fSxmdW5jdGlvbihlLHQsbil7ZnVuY3Rpb24gbyhlLHQpe3ZhciBuPXIuZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiBuLmVsZW1lbnQ9PT1lJiYoIW4ud3JhcHBlcnx8bi53cmFwcGVyPT09dCl8fG4ud3JhcHBlcj09PWV8fG4uYWxpYXNlZEVsZW1lbnRzJiZuLmFsaWFzZWRFbGVtZW50cy5pbmRleE9mKGUpPi0xfSkua2V5U2VxKCkudG9TZXQoKS50b0FycmF5KCk7aWYoMT09PW4ubGVuZ3RoKXJldHVybiBuWzBdfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1vO3ZhciBpPW4oMCkscj1uZXcgaS5NYXAoe1wiaGVhZGVyLW9uZVwiOntlbGVtZW50OlwiaDFcIn0sXCJoZWFkZXItdHdvXCI6e2VsZW1lbnQ6XCJoMlwifSxcImhlYWRlci10aHJlZVwiOntlbGVtZW50OlwiaDNcIn0sXCJoZWFkZXItZm91clwiOntlbGVtZW50OlwiaDRcIn0sXCJoZWFkZXItZml2ZVwiOntlbGVtZW50OlwiaDVcIn0sXCJoZWFkZXItc2l4XCI6e2VsZW1lbnQ6XCJoNlwifSxcInVub3JkZXJlZC1saXN0LWl0ZW1cIjp7ZWxlbWVudDpcImxpXCIsd3JhcHBlcjpcInVsXCJ9LFwib3JkZXJlZC1saXN0LWl0ZW1cIjp7ZWxlbWVudDpcImxpXCIsd3JhcHBlcjpcIm9sXCJ9LGJsb2NrcXVvdGU6e2VsZW1lbnQ6XCJibG9ja3F1b3RlXCJ9LGNvZGU6e2VsZW1lbnQ6XCJwcmVcIn0sYXRvbWljOntlbGVtZW50OlwiZmlndXJlXCJ9LHVuc3R5bGVkOntlbGVtZW50OlwicFwiLGFsaWFzZWRFbGVtZW50czpbXCJkaXZcIl19fSl9LGZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiBvKGUsdCxuKXt2YXIgbz1pW2VdLHI9dm9pZCAwO2lmKG8pcj1uLmFkZChvKS50b09yZGVyZWRTZXQoKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCl7cj1uO3ZhciBsPXQ7cj1yLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oZSl7dmFyIHQ9bC5zdHlsZS5jb2xvcixuPWwuc3R5bGUuYmFja2dyb3VuZENvbG9yLG89bC5zdHlsZS5mb250U2l6ZSxpPWwuc3R5bGUuZm9udEZhbWlseS5yZXBsYWNlKC9eXCJ8XCIkL2csXCJcIik7dCYmZS5hZGQoXCJjb2xvci1cIit0LnJlcGxhY2UoLyAvZyxcIlwiKSksbiYmZS5hZGQoXCJiZ2NvbG9yLVwiK24ucmVwbGFjZSgvIC9nLFwiXCIpKSxvJiZlLmFkZChcImZvbnRzaXplLVwiK28ucmVwbGFjZSgvcHgkL2csXCJcIikpLGkmJmUuYWRkKFwiZm9udGZhbWlseS1cIitpKX0pLnRvT3JkZXJlZFNldCgpfXJldHVybiByfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1vO3ZhciBpPXtjb2RlOlwiQ09ERVwiLGRlbDpcIlNUUklLRVRIUk9VR0hcIixlbTpcIklUQUxJQ1wiLHN0cm9uZzpcIkJPTERcIixpbnM6XCJVTkRFUkxJTkVcIixzdWI6XCJTVUJTQ1JJUFRcIixzdXA6XCJTVVBFUlNDUklQVFwifX0sZnVuY3Rpb24oZSx0LG4pe2Z1bmN0aW9uIG8oZSl7aWYoZS5zdHlsZS50ZXh0QWxpZ24pcmV0dXJuIG5ldyBpLk1hcCh7XCJ0ZXh0LWFsaWduXCI6ZS5zdHlsZS50ZXh0QWxpZ259KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9bzt2YXIgaT1uKDApfSxmdW5jdGlvbihlLHQsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bigxKSxpPWZ1bmN0aW9uKGUpe3ZhciB0PXZvaWQgMDtpZihlIGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQpe3ZhciBuPXt9O2UuZGF0YXNldCYmdm9pZCAwIT09ZS5kYXRhc2V0Lm1lbnRpb24/KG4udXJsPWUuaHJlZixuLnRleHQ9ZS5pbm5lckhUTUwsbi52YWx1ZT1lLmRhdGFzZXQudmFsdWUsdD1vLkVudGl0eS5fX2NyZWF0ZShcIk1FTlRJT05cIixcIklNTVVUQUJMRVwiLG4pKToobi51cmw9ZS5nZXRBdHRyaWJ1dGU/ZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpfHxlLmhyZWY6ZS5ocmVmLG4udGl0bGU9ZS5pbm5lckhUTUwsbi50YXJnZXRPcHRpb249ZS50YXJnZXQsdD1vLkVudGl0eS5fX2NyZWF0ZShcIkxJTktcIixcIk1VVEFCTEVcIixuKSl9cmV0dXJuIHR9O3QuZGVmYXVsdD1pfV0pfSl9KS5jYWxsKHQsbigyNSkoZSkpfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBlLndlYnBhY2tQb2x5ZmlsbHx8KGUuZGVwcmVjYXRlPWZ1bmN0aW9uKCl7fSxlLnBhdGhzPVtdLGUuY2hpbGRyZW58fChlLmNoaWxkcmVuPVtdKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImxvYWRlZFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlLmx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJpZFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlLml9fSksZS53ZWJwYWNrUG9seWZpbGw9MSksZX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX12YXIgaT1uKDI3KSxyPW8oaSksbD1uKDM1KSxhPW8obCksYz1uKDM4KSxzPW8oYyksTT1uKDQxKSx1PW8oTSksZz1uKDQ0KSxkPW8oZykscD1uKDQ3KSxOPW8ocCksRD1uKDUwKSxJPW8oRCkseT1uKDUzKSxqPW8oeSksZj1uKDYyKSx3PW8oZiksbT1uKDY1KSxDPW8obSksej1uKDY4KSxBPW8oeiksVD1uKDczKSxFPW8oVCksTD1uKDc2KSx4PW8oTCk7ZS5leHBvcnRzPXtpbmxpbmU6ci5kZWZhdWx0LGJsb2NrVHlwZTphLmRlZmF1bHQsZm9udFNpemU6cy5kZWZhdWx0LGZvbnRGYW1pbHk6dS5kZWZhdWx0LGxpc3Q6ZC5kZWZhdWx0LHRleHRBbGlnbjpOLmRlZmF1bHQsY29sb3JQaWNrZXI6SS5kZWZhdWx0LGxpbms6ai5kZWZhdWx0LGVtYmVkZGVkOncuZGVmYXVsdCxlbW9qaTpDLmRlZmF1bHQsaW1hZ2U6QS5kZWZhdWx0LHJlbW92ZTpFLmRlZmF1bHQsaGlzdG9yeTp4LmRlZmF1bHR9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGwoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLGM9bigwKSxzPW8oYyksTT1uKDEpLHU9byhNKSxnPW4oNCksZD1uKDMpLHA9big2KSxOPW4oMjgpLEQ9byhOKSxJPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZSxuLG8sbDtpKHRoaXMsdCk7Zm9yKHZhciBhPWFyZ3VtZW50cy5sZW5ndGgsYz1BcnJheShhKSxzPTA7czxhO3MrKyljW3NdPWFyZ3VtZW50c1tzXTtyZXR1cm4gbj1vPXIodGhpcywoZT10Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsLmFwcGx5KGUsW3RoaXNdLmNvbmNhdChjKSkpLG8uc3RhdGU9e2N1cnJlbnRTdHlsZXM6e319LG8ub25FeHBhbmRFdmVudD1mdW5jdGlvbigpe28uc2lnbmFsRXhwYW5kZWQ9IW8uc3RhdGUuZXhwYW5kZWR9LG8uZXhwYW5kQ29sbGFwc2U9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDpvLnNpZ25hbEV4cGFuZGVkfSksby5zaWduYWxFeHBhbmRlZD0hMX0sby50b2dnbGVJbmxpbmVTdHlsZT1mdW5jdGlvbihlKXt2YXIgdD1cIm1vbm9zcGFjZVwiPT09ZT9cIkNPREVcIjplLnRvVXBwZXJDYXNlKCksbj1vLnByb3BzLGk9bi5lZGl0b3JTdGF0ZSxyPW4ub25DaGFuZ2UsbD1kLlJpY2hVdGlscy50b2dnbGVJbmxpbmVTdHlsZShpLHQpO2lmKFwic3Vic2NyaXB0XCI9PT1lfHxcInN1cGVyc2NyaXB0XCI9PT1lKXt2YXIgYT1cInN1YnNjcmlwdFwiPT09ZT9cIlNVUEVSU0NSSVBUXCI6XCJTVUJTQ1JJUFRcIixjPWQuTW9kaWZpZXIucmVtb3ZlSW5saW5lU3R5bGUobC5nZXRDdXJyZW50Q29udGVudCgpLGwuZ2V0U2VsZWN0aW9uKCksYSk7bD1kLkVkaXRvclN0YXRlLnB1c2gobCxjLFwiY2hhbmdlLWlubGluZS1zdHlsZVwiKX1sJiZyKGwpfSxvLmNoYW5nZUtleXM9ZnVuY3Rpb24oZSl7aWYoZSl7dmFyIHQ9e307cmV0dXJuKDAscC5mb3JFYWNoKShlLGZ1bmN0aW9uKGUsbil7dFtcIkNPREVcIj09PWU/XCJtb25vc3BhY2VcIjplLnRvTG93ZXJDYXNlKCldPW59KSx0fX0sby5kb0V4cGFuZD1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiEwfSl9LG8uZG9Db2xsYXBzZT1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiExfSl9LGw9bixyKG8sbCl9cmV0dXJuIGwodCxlKSxhKHQsW3trZXk6XCJjb21wb25lbnRXaWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmVkaXRvclN0YXRlLG49ZS5tb2RhbEhhbmRsZXI7dCYmdGhpcy5zZXRTdGF0ZSh7Y3VycmVudFN0eWxlczp0aGlzLmNoYW5nZUtleXMoKDAsZy5nZXRTZWxlY3Rpb25JbmxpbmVTdHlsZSkodCkpfSksbi5yZWdpc3RlckNhbGxCYWNrKHRoaXMuZXhwYW5kQ29sbGFwc2UpfX0se2tleTpcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIix2YWx1ZTpmdW5jdGlvbihlKXtlLmVkaXRvclN0YXRlJiZ0aGlzLnByb3BzLmVkaXRvclN0YXRlIT09ZS5lZGl0b3JTdGF0ZSYmdGhpcy5zZXRTdGF0ZSh7Y3VycmVudFN0eWxlczp0aGlzLmNoYW5nZUtleXMoKDAsZy5nZXRTZWxlY3Rpb25JbmxpbmVTdHlsZSkoZS5lZGl0b3JTdGF0ZSkpfSl9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMubW9kYWxIYW5kbGVyLmRlcmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNvbmZpZyxuPWUudHJhbnNsYXRpb25zLG89dGhpcy5zdGF0ZSxpPW8uZXhwYW5kZWQscj1vLmN1cnJlbnRTdHlsZXMsbD10LmNvbXBvbmVudHx8RC5kZWZhdWx0O3JldHVybiBzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChsLHtjb25maWc6dCx0cmFuc2xhdGlvbnM6bixjdXJyZW50U3RhdGU6cixleHBhbmRlZDppLG9uRXhwYW5kRXZlbnQ6dGhpcy5vbkV4cGFuZEV2ZW50LGRvRXhwYW5kOnRoaXMuZG9FeHBhbmQsZG9Db2xsYXBzZTp0aGlzLmRvQ29sbGFwc2Usb25DaGFuZ2U6dGhpcy50b2dnbGVJbmxpbmVTdHlsZX0pfX1dKSx0fShjLkNvbXBvbmVudCk7SS5wcm9wVHlwZXM9e29uQ2hhbmdlOnUuZGVmYXVsdC5mdW5jLmlzUmVxdWlyZWQsZWRpdG9yU3RhdGU6dS5kZWZhdWx0Lm9iamVjdC5pc1JlcXVpcmVkLG1vZGFsSGFuZGxlcjp1LmRlZmF1bHQub2JqZWN0LGNvbmZpZzp1LmRlZmF1bHQub2JqZWN0LHRyYW5zbGF0aW9uczp1LmRlZmF1bHQub2JqZWN0fSx0LmRlZmF1bHQ9SX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIHIoZSx0KXtpZighZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2U6dH1mdW5jdGlvbiBsKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHQpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsdCk6ZS5fX3Byb3RvX189dCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBvPXRbbl07by5lbnVtZXJhYmxlPW8uZW51bWVyYWJsZXx8ITEsby5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbyYmKG8ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG8ua2V5LG8pfX1yZXR1cm4gZnVuY3Rpb24odCxuLG8pe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLG8mJmUodCxvKSx0fX0oKSxjPW4oMCkscz1vKGMpLE09bigxKSx1PW8oTSksZz1uKDIpLGQ9byhnKSxwPW4oOCksTj1uKDUpLEQ9byhOKSxJPW4oNyk7bigzNCk7dmFyIHk9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBpKHRoaXMsdCkscih0aGlzLCh0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5hcHBseSh0aGlzLGFyZ3VtZW50cykpfXJldHVybiBsKHQsZSksYSh0LFt7a2V5OlwicmVuZGVySW5GbGF0TGlzdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcyx0PWUuY29uZmlnLG49ZS5jdXJyZW50U3RhdGUsbz1lLm9uQ2hhbmdlLGk9ZS50cmFuc2xhdGlvbnM7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTooMCxkLmRlZmF1bHQpKFwicmR3LWlubGluZS13cmFwcGVyXCIsdC5jbGFzc05hbWUpLFwiYXJpYS1sYWJlbFwiOlwicmR3LWlubGluZS1jb250cm9sXCJ9LHQub3B0aW9ucy5tYXAoZnVuY3Rpb24oZSxyKXtyZXR1cm4gcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRC5kZWZhdWx0LHtrZXk6cix2YWx1ZTplLG9uQ2xpY2s6byxjbGFzc05hbWU6KDAsZC5kZWZhdWx0KSh0W2VdLmNsYXNzTmFtZSksYWN0aXZlOiEwPT09bltlXXx8XCJNT05PU1BBQ0VcIj09PWUmJm4uQ09ERSx0aXRsZTp0W2VdLnRpdGxlfHxpW1wiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuXCIrZV19LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIse2FsdDpcIlwiLHNyYzp0W2VdLmljb259KSl9KSl9fSx7a2V5OlwicmVuZGVySW5Ecm9wRG93blwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcyx0PWUuY29uZmlnLG49ZS5leHBhbmRlZCxvPWUuZG9FeHBhbmQsaT1lLm9uRXhwYW5kRXZlbnQscj1lLmRvQ29sbGFwc2UsbD1lLmN1cnJlbnRTdGF0ZSxhPWUub25DaGFuZ2UsYz1lLnRyYW5zbGF0aW9ucyxNPXQuY2xhc3NOYW1lLHU9dC5kcm9wZG93bkNsYXNzTmFtZSxnPXQudGl0bGU7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEkuRHJvcGRvd24se2NsYXNzTmFtZTooMCxkLmRlZmF1bHQpKFwicmR3LWlubGluZS1kcm9wZG93blwiLE0pLG9wdGlvbldyYXBwZXJDbGFzc05hbWU6KDAsZC5kZWZhdWx0KSh1KSxvbkNoYW5nZTphLGV4cGFuZGVkOm4sZG9FeHBhbmQ6byxkb0NvbGxhcHNlOnIsb25FeHBhbmRFdmVudDppLFwiYXJpYS1sYWJlbFwiOlwicmR3LWlubGluZS1jb250cm9sXCIsdGl0bGU6Z30scy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIix7c3JjOigwLHAuZ2V0Rmlyc3RJY29uKSh0KSxhbHQ6XCJcIn0pLHQub3B0aW9ucy5tYXAoZnVuY3Rpb24oZSxuKXtyZXR1cm4gcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSS5Ecm9wZG93bk9wdGlvbix7a2V5Om4sdmFsdWU6ZSxjbGFzc05hbWU6KDAsZC5kZWZhdWx0KShcInJkdy1pbmxpbmUtZHJvcGRvd25vcHRpb25cIix0W2VdLmNsYXNzTmFtZSksYWN0aXZlOiEwPT09bFtlXXx8XCJNT05PU1BBQ0VcIj09PWUmJmwuQ09ERSx0aXRsZTp0W2VdLnRpdGxlfHxjW1wiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuXCIrZV19LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIse3NyYzp0W2VdLmljb24sYWx0OlwiXCJ9KSl9KSl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wcy5jb25maWcuaW5Ecm9wZG93bj90aGlzLnJlbmRlckluRHJvcERvd24oKTp0aGlzLnJlbmRlckluRmxhdExpc3QoKX19XSksdH0oYy5Db21wb25lbnQpO3kucHJvcFR5cGVzPXtleHBhbmRlZDp1LmRlZmF1bHQuYm9vbCxkb0V4cGFuZDp1LmRlZmF1bHQuZnVuYyxkb0NvbGxhcHNlOnUuZGVmYXVsdC5mdW5jLG9uRXhwYW5kRXZlbnQ6dS5kZWZhdWx0LmZ1bmMsY29uZmlnOnUuZGVmYXVsdC5vYmplY3Qsb25DaGFuZ2U6dS5kZWZhdWx0LmZ1bmMsY3VycmVudFN0YXRlOnUuZGVmYXVsdC5vYmplY3QsdHJhbnNsYXRpb25zOnUuZGVmYXVsdC5vYmplY3R9LHQuZGVmYXVsdD15fSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz17XCJyZHctb3B0aW9uLXdyYXBwZXJcIjpcInJkdy1vcHRpb24td3JhcHBlclwiLFwicmR3LW9wdGlvbi1hY3RpdmVcIjpcInJkdy1vcHRpb24tYWN0aXZlXCIsXCJyZHctb3B0aW9uLWRpc2FibGVkXCI6XCJyZHctb3B0aW9uLWRpc2FibGVkXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGwoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLGM9bigwKSxzPW8oYyksTT1uKDEpLHU9byhNKSxnPW4oMiksZD1vKGcpO24oMzEpO3ZhciBwPW4oNiksTj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7dmFyIGUsbixvLGw7aSh0aGlzLHQpO2Zvcih2YXIgYT1hcmd1bWVudHMubGVuZ3RoLGM9QXJyYXkoYSkscz0wO3M8YTtzKyspY1tzXT1hcmd1bWVudHNbc107cmV0dXJuIG49bz1yKHRoaXMsKGU9dC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbC5hcHBseShlLFt0aGlzXS5jb25jYXQoYykpKSxvLnN0YXRlPXtoaWdobGlnaHRlZDotMX0sby5vbkNoYW5nZT1mdW5jdGlvbihlKXt2YXIgdD1vLnByb3BzLm9uQ2hhbmdlO3QmJnQoZSksby50b2dnbGVFeHBhbnNpb24oKX0sby5zZXRIaWdobGlnaHRlZD1mdW5jdGlvbihlKXtvLnNldFN0YXRlKHtoaWdobGlnaHRlZDplfSl9LG8udG9nZ2xlRXhwYW5zaW9uPWZ1bmN0aW9uKCl7dmFyIGU9by5wcm9wcyx0PWUuZG9FeHBhbmQsbj1lLmRvQ29sbGFwc2U7ZS5leHBhbmRlZD9uKCk6dCgpfSxsPW4scihvLGwpfXJldHVybiBsKHQsZSksYSh0LFt7a2V5OlwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMucHJvcHMuZXhwYW5kZWQmJiFlLmV4cGFuZGVkJiZ0aGlzLnNldFN0YXRlKHtoaWdobGlnaHRlZDotMX0pfX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXRoaXMucHJvcHMsbj10LmV4cGFuZGVkLG89dC5jaGlsZHJlbixpPXQuY2xhc3NOYW1lLHI9dC5vcHRpb25XcmFwcGVyQ2xhc3NOYW1lLGw9dC5hcmlhTGFiZWwsYT10Lm9uRXhwYW5kRXZlbnQsYz10LnRpdGxlLE09dGhpcy5zdGF0ZS5oaWdobGlnaHRlZCx1PW8uc2xpY2UoMSxvLmxlbmd0aCk7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTooMCxkLmRlZmF1bHQpKFwicmR3LWRyb3Bkb3duLXdyYXBwZXJcIixpKSxcImFyaWEtZXhwYW5kZWRcIjpuLFwiYXJpYS1sYWJlbFwiOmx8fFwicmR3LWRyb3Bkb3duXCJ9LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYVwiLHtjbGFzc05hbWU6XCJyZHctZHJvcGRvd24tc2VsZWN0ZWR0ZXh0XCIsb25DbGljazphLHRpdGxlOmN9LG9bMF0scy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoe1wicmR3LWRyb3Bkb3duLWNhcmV0dG9jbG9zZVwiOm4sXCJyZHctZHJvcGRvd24tY2FyZXR0b29wZW5cIjohbn0pfSkpLG4/cy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLHtjbGFzc05hbWU6KDAsZC5kZWZhdWx0KShcInJkdy1kcm9wZG93bi1vcHRpb253cmFwcGVyXCIsciksb25DbGljazpwLnN0b3BQcm9wYWdhdGlvbn0scy5kZWZhdWx0LkNoaWxkcmVuLm1hcCh1LGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQmJnMuZGVmYXVsdC5jbG9uZUVsZW1lbnQodCx7b25TZWxlY3Q6ZS5vbkNoYW5nZSxoaWdobGlnaHRlZDpNPT09bixzZXRIaWdobGlnaHRlZDplLnNldEhpZ2hsaWdodGVkLGluZGV4Om59KX0pKTp2b2lkIDApfX1dKSx0fShjLkNvbXBvbmVudCk7Ti5wcm9wVHlwZXM9e2NoaWxkcmVuOnUuZGVmYXVsdC5hbnksb25DaGFuZ2U6dS5kZWZhdWx0LmZ1bmMsY2xhc3NOYW1lOnUuZGVmYXVsdC5zdHJpbmcsZXhwYW5kZWQ6dS5kZWZhdWx0LmJvb2wsZG9FeHBhbmQ6dS5kZWZhdWx0LmZ1bmMsZG9Db2xsYXBzZTp1LmRlZmF1bHQuZnVuYyxvbkV4cGFuZEV2ZW50OnUuZGVmYXVsdC5mdW5jLG9wdGlvbldyYXBwZXJDbGFzc05hbWU6dS5kZWZhdWx0LnN0cmluZyxhcmlhTGFiZWw6dS5kZWZhdWx0LnN0cmluZyx0aXRsZTp1LmRlZmF1bHQuc3RyaW5nfSx0LmRlZmF1bHQ9Tn0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9e1wicmR3LWRyb3Bkb3duLXdyYXBwZXJcIjpcInJkdy1kcm9wZG93bi13cmFwcGVyXCIsXCJyZHctZHJvcGRvd24tY2FyZXR0b29wZW5cIjpcInJkdy1kcm9wZG93bi1jYXJldHRvb3BlblwiLFwicmR3LWRyb3Bkb3duLWNhcmV0dG9jbG9zZVwiOlwicmR3LWRyb3Bkb3duLWNhcmV0dG9jbG9zZVwiLFwicmR3LWRyb3Bkb3duLXNlbGVjdGVkdGV4dFwiOlwicmR3LWRyb3Bkb3duLXNlbGVjdGVkdGV4dFwiLFwicmR3LWRyb3Bkb3duLW9wdGlvbndyYXBwZXJcIjpcInJkdy1kcm9wZG93bi1vcHRpb253cmFwcGVyXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9ZnVuY3Rpb24gcihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gbChlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGEoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLHM9bigwKSxNPW8ocyksdT1uKDEpLGc9byh1KSxkPW4oMikscD1vKGQpO24oMzMpO3ZhciBOPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZSxuLG8saTtyKHRoaXMsdCk7Zm9yKHZhciBhPWFyZ3VtZW50cy5sZW5ndGgsYz1BcnJheShhKSxzPTA7czxhO3MrKyljW3NdPWFyZ3VtZW50c1tzXTtyZXR1cm4gbj1vPWwodGhpcywoZT10Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsLmFwcGx5KGUsW3RoaXNdLmNvbmNhdChjKSkpLG8ub25DbGljaz1mdW5jdGlvbihlKXt2YXIgdD1vLnByb3BzLG49dC5vblNlbGVjdCxpPXQub25DbGljayxyPXQudmFsdWU7dC5kaXNhYmxlZHx8KG4mJm4ociksaSYmKGUuc3RvcFByb3BhZ2F0aW9uKCksaShyKSkpfSxvLnNldEhpZ2hsaWdodGVkPWZ1bmN0aW9uKCl7dmFyIGU9by5wcm9wczsoMCxlLnNldEhpZ2hsaWdodGVkKShlLmluZGV4KX0sby5yZXNldEhpZ2hsaWdodGVkPWZ1bmN0aW9uKCl7KDAsby5wcm9wcy5zZXRIaWdobGlnaHRlZCkoLTEpfSxpPW4sbChvLGkpfXJldHVybiBhKHQsZSksYyh0LFt7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSx0PXRoaXMucHJvcHMsbj10LmNoaWxkcmVuLG89dC5hY3RpdmUscj10LmRpc2FibGVkLGw9dC5oaWdobGlnaHRlZCxhPXQuY2xhc3NOYW1lLGM9dC5hY3RpdmVDbGFzc05hbWUscz10LmRpc2FibGVkQ2xhc3NOYW1lLHU9dC5oaWdobGlnaHRlZENsYXNzTmFtZSxnPXQudGl0bGU7cmV0dXJuIE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibGlcIix7Y2xhc3NOYW1lOigwLHAuZGVmYXVsdCkoXCJyZHctZHJvcGRvd25vcHRpb24tZGVmYXVsdFwiLGEsKGU9e30saShlLFwicmR3LWRyb3Bkb3dub3B0aW9uLWFjdGl2ZSBcIitjLG8pLGkoZSxcInJkdy1kcm9wZG93bm9wdGlvbi1oaWdobGlnaHRlZCBcIit1LGwpLGkoZSxcInJkdy1kcm9wZG93bm9wdGlvbi1kaXNhYmxlZCBcIitzLHIpLGUpKSxvbk1vdXNlRW50ZXI6dGhpcy5zZXRIaWdobGlnaHRlZCxvbk1vdXNlTGVhdmU6dGhpcy5yZXNldEhpZ2hsaWdodGVkLG9uQ2xpY2s6dGhpcy5vbkNsaWNrLHRpdGxlOmd9LG4pfX1dKSx0fShzLkNvbXBvbmVudCk7Ti5wcm9wVHlwZXM9e2NoaWxkcmVuOmcuZGVmYXVsdC5hbnksdmFsdWU6Zy5kZWZhdWx0LmFueSxvbkNsaWNrOmcuZGVmYXVsdC5mdW5jLG9uU2VsZWN0OmcuZGVmYXVsdC5mdW5jLHNldEhpZ2hsaWdodGVkOmcuZGVmYXVsdC5mdW5jLGluZGV4OmcuZGVmYXVsdC5udW1iZXIsZGlzYWJsZWQ6Zy5kZWZhdWx0LmJvb2wsYWN0aXZlOmcuZGVmYXVsdC5ib29sLGhpZ2hsaWdodGVkOmcuZGVmYXVsdC5ib29sLGNsYXNzTmFtZTpnLmRlZmF1bHQuc3RyaW5nLGFjdGl2ZUNsYXNzTmFtZTpnLmRlZmF1bHQuc3RyaW5nLGRpc2FibGVkQ2xhc3NOYW1lOmcuZGVmYXVsdC5zdHJpbmcsaGlnaGxpZ2h0ZWRDbGFzc05hbWU6Zy5kZWZhdWx0LnN0cmluZyx0aXRsZTpnLmRlZmF1bHQuc3RyaW5nfSx0LmRlZmF1bHQ9Tn0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9e1wicmR3LWRyb3Bkb3dub3B0aW9uLWRlZmF1bHRcIjpcInJkdy1kcm9wZG93bm9wdGlvbi1kZWZhdWx0XCIsXCJyZHctZHJvcGRvd25vcHRpb24taGlnaGxpZ2h0ZWRcIjpcInJkdy1kcm9wZG93bm9wdGlvbi1oaWdobGlnaHRlZFwiLFwicmR3LWRyb3Bkb3dub3B0aW9uLWFjdGl2ZVwiOlwicmR3LWRyb3Bkb3dub3B0aW9uLWFjdGl2ZVwiLFwicmR3LWRyb3Bkb3dub3B0aW9uLWRpc2FibGVkXCI6XCJyZHctZHJvcGRvd25vcHRpb24tZGlzYWJsZWRcIn19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXtcInJkdy1pbmxpbmUtd3JhcHBlclwiOlwicmR3LWlubGluZS13cmFwcGVyXCIsXCJyZHctaW5saW5lLWRyb3Bkb3duXCI6XCJyZHctaW5saW5lLWRyb3Bkb3duXCIsXCJyZHctaW5saW5lLWRyb3Bkb3dub3B0aW9uXCI6XCJyZHctaW5saW5lLWRyb3Bkb3dub3B0aW9uXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGwoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLGM9bigwKSxzPW8oYyksTT1uKDEpLHU9byhNKSxnPW4oNCksZD1uKDMpLHA9bigzNiksTj1vKHApLEQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlLG4sbyxsO2kodGhpcyx0KTtmb3IodmFyIGE9YXJndW1lbnRzLmxlbmd0aCxjPUFycmF5KGEpLHM9MDtzPGE7cysrKWNbc109YXJndW1lbnRzW3NdO3JldHVybiBuPW89cih0aGlzLChlPXQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KGMpKSksby5zdGF0ZT17ZXhwYW5kZWQ6ITEsY3VycmVudEJsb2NrVHlwZTpcInVuc3R5bGVkXCJ9LG8ub25FeHBhbmRFdmVudD1mdW5jdGlvbigpe28uc2lnbmFsRXhwYW5kZWQ9IW8uc3RhdGUuZXhwYW5kZWR9LG8uZXhwYW5kQ29sbGFwc2U9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDpvLnNpZ25hbEV4cGFuZGVkfSksby5zaWduYWxFeHBhbmRlZD0hMX0sby5ibG9ja3NUeXBlcz1be2xhYmVsOlwiTm9ybWFsXCIsc3R5bGU6XCJ1bnN0eWxlZFwifSx7bGFiZWw6XCJIMVwiLHN0eWxlOlwiaGVhZGVyLW9uZVwifSx7bGFiZWw6XCJIMlwiLHN0eWxlOlwiaGVhZGVyLXR3b1wifSx7bGFiZWw6XCJIM1wiLHN0eWxlOlwiaGVhZGVyLXRocmVlXCJ9LHtsYWJlbDpcIkg0XCIsc3R5bGU6XCJoZWFkZXItZm91clwifSx7bGFiZWw6XCJINVwiLHN0eWxlOlwiaGVhZGVyLWZpdmVcIn0se2xhYmVsOlwiSDZcIixzdHlsZTpcImhlYWRlci1zaXhcIn0se2xhYmVsOlwiQmxvY2txdW90ZVwiLHN0eWxlOlwiYmxvY2txdW90ZVwifSx7bGFiZWw6XCJDb2RlXCIsc3R5bGU6XCJjb2RlXCJ9XSxvLmRvRXhwYW5kPWZ1bmN0aW9uKCl7by5zZXRTdGF0ZSh7ZXhwYW5kZWQ6ITB9KX0sby5kb0NvbGxhcHNlPWZ1bmN0aW9uKCl7by5zZXRTdGF0ZSh7ZXhwYW5kZWQ6ITF9KX0sby50b2dnbGVCbG9ja1R5cGU9ZnVuY3Rpb24oZSl7dmFyIHQ9by5ibG9ja3NUeXBlcy5maW5kKGZ1bmN0aW9uKHQpe3JldHVybiB0LmxhYmVsPT09ZX0pLnN0eWxlLG49by5wcm9wcyxpPW4uZWRpdG9yU3RhdGUscj1uLm9uQ2hhbmdlLGw9ZC5SaWNoVXRpbHMudG9nZ2xlQmxvY2tUeXBlKGksdCk7bCYmcihsKX0sbD1uLHIobyxsKX1yZXR1cm4gbCh0LGUpLGEodCxbe2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcyx0PWUuZWRpdG9yU3RhdGUsbj1lLm1vZGFsSGFuZGxlcjt0JiZ0aGlzLnNldFN0YXRlKHtjdXJyZW50QmxvY2tUeXBlOigwLGcuZ2V0U2VsZWN0ZWRCbG9ja3NUeXBlKSh0KX0pLG4ucmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZS5lZGl0b3JTdGF0ZSYmdGhpcy5wcm9wcy5lZGl0b3JTdGF0ZSE9PWUuZWRpdG9yU3RhdGUmJnRoaXMuc2V0U3RhdGUoe2N1cnJlbnRCbG9ja1R5cGU6KDAsZy5nZXRTZWxlY3RlZEJsb2Nrc1R5cGUpKGUuZWRpdG9yU3RhdGUpfSl9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMubW9kYWxIYW5kbGVyLmRlcmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNvbmZpZyxuPWUudHJhbnNsYXRpb25zLG89dGhpcy5zdGF0ZSxpPW8uZXhwYW5kZWQscj1vLmN1cnJlbnRCbG9ja1R5cGUsbD10LmNvbXBvbmVudHx8Ti5kZWZhdWx0LGE9dGhpcy5ibG9ja3NUeXBlcy5maW5kKGZ1bmN0aW9uKGUpe3JldHVybiBlLnN0eWxlPT09cn0pO3JldHVybiBzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChsLHtjb25maWc6dCx0cmFuc2xhdGlvbnM6bixjdXJyZW50U3RhdGU6e2Jsb2NrVHlwZTphJiZhLmxhYmVsfSxvbkNoYW5nZTp0aGlzLnRvZ2dsZUJsb2NrVHlwZSxleHBhbmRlZDppLG9uRXhwYW5kRXZlbnQ6dGhpcy5vbkV4cGFuZEV2ZW50LGRvRXhwYW5kOnRoaXMuZG9FeHBhbmQsZG9Db2xsYXBzZTp0aGlzLmRvQ29sbGFwc2V9KX19XSksdH0oYy5Db21wb25lbnQpO0QucHJvcFR5cGVzPXtvbkNoYW5nZTp1LmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLGVkaXRvclN0YXRlOnUuZGVmYXVsdC5vYmplY3QsbW9kYWxIYW5kbGVyOnUuZGVmYXVsdC5vYmplY3QsY29uZmlnOnUuZGVmYXVsdC5vYmplY3QsdHJhbnNsYXRpb25zOnUuZGVmYXVsdC5vYmplY3R9LHQuZGVmYXVsdD1EfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGwoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLGM9bigwKSxzPW8oYyksTT1uKDEpLHU9byhNKSxnPW4oMiksZD1vKGcpLHA9big1KSxOPW8ocCksRD1uKDcpO24oMzcpO3ZhciBJPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSl7aSh0aGlzLHQpO3ZhciBuPXIodGhpcywodC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbCh0aGlzLGUpKTtyZXR1cm4gbi5nZXRCbG9ja1R5cGVzPWZ1bmN0aW9uKGUpe3JldHVyblt7bGFiZWw6XCJOb3JtYWxcIixkaXNwbGF5TmFtZTplW1wiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUubm9ybWFsXCJdfSx7bGFiZWw6XCJIMVwiLGRpc3BsYXlOYW1lOmVbXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oMVwiXX0se2xhYmVsOlwiSDJcIixkaXNwbGF5TmFtZTplW1wiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDJcIl19LHtsYWJlbDpcIkgzXCIsZGlzcGxheU5hbWU6ZVtcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgzXCJdfSx7bGFiZWw6XCJINFwiLGRpc3BsYXlOYW1lOmVbXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNFwiXX0se2xhYmVsOlwiSDVcIixkaXNwbGF5TmFtZTplW1wiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDVcIl19LHtsYWJlbDpcIkg2XCIsZGlzcGxheU5hbWU6ZVtcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg2XCJdfSx7bGFiZWw6XCJCbG9ja3F1b3RlXCIsZGlzcGxheU5hbWU6ZVtcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmJsb2NrcXVvdGVcIl19LHtsYWJlbDpcIkNvZGVcIixkaXNwbGF5TmFtZTplW1wiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuY29kZVwiXX1dfSxuLnN0YXRlPXtibG9ja1R5cGVzOm4uZ2V0QmxvY2tUeXBlcyhlLnRyYW5zbGF0aW9ucyl9LG59cmV0dXJuIGwodCxlKSxhKHQsW3trZXk6XCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wcm9wcy50cmFuc2xhdGlvbnMhPT1lLnRyYW5zbGF0aW9ucyYmdGhpcy5zZXRTdGF0ZSh7YmxvY2tUeXBlczp0aGlzLmdldEJsb2NrVHlwZXMoZS50cmFuc2xhdGlvbnMpfSl9fSx7a2V5OlwicmVuZGVyRmxhdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMucHJvcHMsbj10LmNvbmZpZy5jbGFzc05hbWUsbz10Lm9uQ2hhbmdlLGk9dC5jdXJyZW50U3RhdGUuYmxvY2tUeXBlO3JldHVybiBzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6KDAsZC5kZWZhdWx0KShcInJkdy1pbmxpbmUtd3JhcHBlclwiLG4pfSxlLm1hcChmdW5jdGlvbihlLHQpe3JldHVybiBzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChOLmRlZmF1bHQse2tleTp0LHZhbHVlOmUubGFiZWwsYWN0aXZlOmk9PT1lLmxhYmVsLG9uQ2xpY2s6b30sZS5kaXNwbGF5TmFtZSl9KSl9fSx7a2V5OlwicmVuZGVySW5Ecm9wZG93blwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMucHJvcHMsbj10LmNvbmZpZyxvPW4uY2xhc3NOYW1lLGk9bi5kcm9wZG93bkNsYXNzTmFtZSxyPW4udGl0bGUsbD10LmN1cnJlbnRTdGF0ZS5ibG9ja1R5cGUsYT10LmV4cGFuZGVkLGM9dC5kb0V4cGFuZCxNPXQub25FeHBhbmRFdmVudCx1PXQuZG9Db2xsYXBzZSxnPXQub25DaGFuZ2UscD10LnRyYW5zbGF0aW9ucyxOPXRoaXMuc3RhdGUuYmxvY2tUeXBlcyxJPU4uZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmxhYmVsPT09bH0pLHk9SSYmSVswXSYmSVswXS5kaXNwbGF5TmFtZTtyZXR1cm4gcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicmR3LWJsb2NrLXdyYXBwZXJcIixcImFyaWEtbGFiZWxcIjpcInJkdy1ibG9jay1jb250cm9sXCJ9LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEQuRHJvcGRvd24se2NsYXNzTmFtZTooMCxkLmRlZmF1bHQpKFwicmR3LWJsb2NrLWRyb3Bkb3duXCIsbyksb3B0aW9uV3JhcHBlckNsYXNzTmFtZTooMCxkLmRlZmF1bHQpKGkpLG9uQ2hhbmdlOmcsZXhwYW5kZWQ6YSxkb0V4cGFuZDpjLGRvQ29sbGFwc2U6dSxvbkV4cGFuZEV2ZW50Ok0sdGl0bGU6cnx8cFtcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmJsb2NrdHlwZVwiXX0scy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCx5fHxwW1wiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuYmxvY2t0eXBlXCJdKSxlLm1hcChmdW5jdGlvbihlLHQpe3JldHVybiBzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChELkRyb3Bkb3duT3B0aW9uLHthY3RpdmU6bD09PWUubGFiZWwsdmFsdWU6ZS5sYWJlbCxrZXk6dH0sZS5kaXNwbGF5TmFtZSl9KSkpfX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcy5jb25maWcsdD1lLmluRHJvcGRvd24sbj10aGlzLnN0YXRlLmJsb2NrVHlwZXMsbz1uLmZpbHRlcihmdW5jdGlvbih0KXt2YXIgbj10LmxhYmVsO3JldHVybiBlLm9wdGlvbnMuaW5jbHVkZXMobil9KTtyZXR1cm4gdD90aGlzLnJlbmRlckluRHJvcGRvd24obyk6dGhpcy5yZW5kZXJGbGF0KG8pfX1dKSx0fShjLkNvbXBvbmVudCk7SS5wcm9wVHlwZXM9e2V4cGFuZGVkOnUuZGVmYXVsdC5ib29sLG9uRXhwYW5kRXZlbnQ6dS5kZWZhdWx0LmZ1bmMsZG9FeHBhbmQ6dS5kZWZhdWx0LmZ1bmMsZG9Db2xsYXBzZTp1LmRlZmF1bHQuZnVuYyxvbkNoYW5nZTp1LmRlZmF1bHQuZnVuYyxjb25maWc6dS5kZWZhdWx0Lm9iamVjdCxjdXJyZW50U3RhdGU6dS5kZWZhdWx0Lm9iamVjdCx0cmFuc2xhdGlvbnM6dS5kZWZhdWx0Lm9iamVjdH0sdC5kZWZhdWx0PUl9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXtcInJkdy1ibG9jay13cmFwcGVyXCI6XCJyZHctYmxvY2std3JhcHBlclwiLFwicmR3LWJsb2NrLWRyb3Bkb3duXCI6XCJyZHctYmxvY2stZHJvcGRvd25cIn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiByKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gbChlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCksYz1uKDApLHM9byhjKSxNPW4oMSksdT1vKE0pLGc9big0KSxkPW4oMzkpLHA9byhkKSxOPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZSxuLG8sbDtpKHRoaXMsdCk7Zm9yKHZhciBhPWFyZ3VtZW50cy5sZW5ndGgsYz1BcnJheShhKSxzPTA7czxhO3MrKyljW3NdPWFyZ3VtZW50c1tzXTtyZXR1cm4gbj1vPXIodGhpcywoZT10Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsLmFwcGx5KGUsW3RoaXNdLmNvbmNhdChjKSkpLG8uc3RhdGU9e2V4cGFuZGVkOnZvaWQgMCxjdXJyZW50Rm9udFNpemU6dm9pZCAwfSxvLm9uRXhwYW5kRXZlbnQ9ZnVuY3Rpb24oKXtvLnNpZ25hbEV4cGFuZGVkPSFvLnN0YXRlLmV4cGFuZGVkfSxvLmV4cGFuZENvbGxhcHNlPWZ1bmN0aW9uKCl7by5zZXRTdGF0ZSh7ZXhwYW5kZWQ6by5zaWduYWxFeHBhbmRlZH0pLG8uc2lnbmFsRXhwYW5kZWQ9ITF9LG8uZG9FeHBhbmQ9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDohMH0pfSxvLmRvQ29sbGFwc2U9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDohMX0pfSxvLnRvZ2dsZUZvbnRTaXplPWZ1bmN0aW9uKGUpe3ZhciB0PW8ucHJvcHMsbj10LmVkaXRvclN0YXRlLGk9dC5vbkNoYW5nZSxyPSgwLGcudG9nZ2xlQ3VzdG9tSW5saW5lU3R5bGUpKG4sXCJmb250U2l6ZVwiLGUpO3ImJmkocil9LGw9bixyKG8sbCl9cmV0dXJuIGwodCxlKSxhKHQsW3trZXk6XCJjb21wb25lbnRXaWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmVkaXRvclN0YXRlLG49ZS5tb2RhbEhhbmRsZXI7dCYmdGhpcy5zZXRTdGF0ZSh7Y3VycmVudEZvbnRTaXplOigwLGcuZ2V0U2VsZWN0aW9uQ3VzdG9tSW5saW5lU3R5bGUpKHQsW1wiRk9OVFNJWkVcIl0pLkZPTlRTSVpFfSksbi5yZWdpc3RlckNhbGxCYWNrKHRoaXMuZXhwYW5kQ29sbGFwc2UpfX0se2tleTpcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIix2YWx1ZTpmdW5jdGlvbihlKXtlLmVkaXRvclN0YXRlJiZ0aGlzLnByb3BzLmVkaXRvclN0YXRlIT09ZS5lZGl0b3JTdGF0ZSYmdGhpcy5zZXRTdGF0ZSh7Y3VycmVudEZvbnRTaXplOigwLGcuZ2V0U2VsZWN0aW9uQ3VzdG9tSW5saW5lU3R5bGUpKGUuZWRpdG9yU3RhdGUsW1wiRk9OVFNJWkVcIl0pLkZPTlRTSVpFfSl9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMubW9kYWxIYW5kbGVyLmRlcmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNvbmZpZyxuPWUudHJhbnNsYXRpb25zLG89dGhpcy5zdGF0ZSxpPW8uZXhwYW5kZWQscj1vLmN1cnJlbnRGb250U2l6ZSxsPXQuY29tcG9uZW50fHxwLmRlZmF1bHQsYT1yJiZOdW1iZXIoci5zdWJzdHJpbmcoOSkpO3JldHVybiBzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChsLHtjb25maWc6dCx0cmFuc2xhdGlvbnM6bixjdXJyZW50U3RhdGU6e2ZvbnRTaXplOmF9LG9uQ2hhbmdlOnRoaXMudG9nZ2xlRm9udFNpemUsZXhwYW5kZWQ6aSxvbkV4cGFuZEV2ZW50OnRoaXMub25FeHBhbmRFdmVudCxkb0V4cGFuZDp0aGlzLmRvRXhwYW5kLGRvQ29sbGFwc2U6dGhpcy5kb0NvbGxhcHNlfSl9fV0pLHR9KGMuQ29tcG9uZW50KTtOLnByb3BUeXBlcz17b25DaGFuZ2U6dS5kZWZhdWx0LmZ1bmMuaXNSZXF1aXJlZCxlZGl0b3JTdGF0ZTp1LmRlZmF1bHQub2JqZWN0LG1vZGFsSGFuZGxlcjp1LmRlZmF1bHQub2JqZWN0LGNvbmZpZzp1LmRlZmF1bHQub2JqZWN0LHRyYW5zbGF0aW9uczp1LmRlZmF1bHQub2JqZWN0fSx0LmRlZmF1bHQ9Tn0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIHIoZSx0KXtpZighZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2U6dH1mdW5jdGlvbiBsKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHQpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsdCk6ZS5fX3Byb3RvX189dCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBvPXRbbl07by5lbnVtZXJhYmxlPW8uZW51bWVyYWJsZXx8ITEsby5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbyYmKG8ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG8ua2V5LG8pfX1yZXR1cm4gZnVuY3Rpb24odCxuLG8pe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLG8mJmUodCxvKSx0fX0oKSxjPW4oMCkscz1vKGMpLE09bigxKSx1PW8oTSksZz1uKDIpLGQ9byhnKSxwPW4oNyk7big0MCk7dmFyIE49ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlLG4sbyxsO2kodGhpcyx0KTtmb3IodmFyIGE9YXJndW1lbnRzLmxlbmd0aCxjPUFycmF5KGEpLHM9MDtzPGE7cysrKWNbc109YXJndW1lbnRzW3NdO3JldHVybiBuPW89cih0aGlzLChlPXQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KGMpKSksby5zdGF0ZT17ZGVmYXVsdEZvbnRTaXplOnZvaWQgMH0sbD1uLHIobyxsKX1yZXR1cm4gbCh0LGUpLGEodCxbe2tleTpcImNvbXBvbmVudERpZE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1kb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiRHJhZnRFZGl0b3Itcm9vdFwiKTtpZihlJiZlLmxlbmd0aD4wKXt2YXIgdD13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlWzBdKSxuPXQuZ2V0UHJvcGVydHlWYWx1ZShcImZvbnQtc2l6ZVwiKTtuPW4uc3Vic3RyaW5nKDAsbi5sZW5ndGgtMiksdGhpcy5zZXRTdGF0ZSh7ZGVmYXVsdEZvbnRTaXplOm59KX19fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3BzLHQ9ZS5jb25maWcsbj10Lmljb24sbz10LmNsYXNzTmFtZSxpPXQuZHJvcGRvd25DbGFzc05hbWUscj10Lm9wdGlvbnMsbD10LnRpdGxlLGE9ZS5vbkNoYW5nZSxjPWUuZXhwYW5kZWQsTT1lLmRvQ29sbGFwc2UsdT1lLm9uRXhwYW5kRXZlbnQsZz1lLmRvRXhwYW5kLE49ZS50cmFuc2xhdGlvbnMsRD10aGlzLnByb3BzLmN1cnJlbnRTdGF0ZS5mb250U2l6ZSxJPXRoaXMuc3RhdGUuZGVmYXVsdEZvbnRTaXplO3JldHVybiBJPU51bWJlcihJKSxEPUR8fHImJnIuaW5kZXhPZihJKT49MCYmSSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJyZHctZm9udHNpemUtd3JhcHBlclwiLFwiYXJpYS1sYWJlbFwiOlwicmR3LWZvbnQtc2l6ZS1jb250cm9sXCJ9LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHAuRHJvcGRvd24se2NsYXNzTmFtZTooMCxkLmRlZmF1bHQpKFwicmR3LWZvbnRzaXplLWRyb3Bkb3duXCIsbyksb3B0aW9uV3JhcHBlckNsYXNzTmFtZTooMCxkLmRlZmF1bHQpKGkpLG9uQ2hhbmdlOmEsZXhwYW5kZWQ6Yyxkb0V4cGFuZDpnLGRvQ29sbGFwc2U6TSxvbkV4cGFuZEV2ZW50OnUsdGl0bGU6bHx8TltcImNvbXBvbmVudHMuY29udHJvbHMuZm9udHNpemUuZm9udHNpemVcIl19LEQ/cy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCxEKTpzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6bixhbHQ6XCJcIn0pLHIubWFwKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHAuRHJvcGRvd25PcHRpb24se2NsYXNzTmFtZTpcInJkdy1mb250c2l6ZS1vcHRpb25cIixhY3RpdmU6RD09PWUsdmFsdWU6ZSxrZXk6dH0sZSl9KSkpfX1dKSx0fShjLkNvbXBvbmVudCk7Ti5wcm9wVHlwZXM9e2V4cGFuZGVkOnUuZGVmYXVsdC5ib29sLG9uRXhwYW5kRXZlbnQ6dS5kZWZhdWx0LmZ1bmMsZG9FeHBhbmQ6dS5kZWZhdWx0LmZ1bmMsZG9Db2xsYXBzZTp1LmRlZmF1bHQuZnVuYyxvbkNoYW5nZTp1LmRlZmF1bHQuZnVuYyxjb25maWc6dS5kZWZhdWx0Lm9iamVjdCxjdXJyZW50U3RhdGU6dS5kZWZhdWx0Lm9iamVjdCx0cmFuc2xhdGlvbnM6dS5kZWZhdWx0Lm9iamVjdH0sdC5kZWZhdWx0PU59LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXtcInJkdy1mb250c2l6ZS13cmFwcGVyXCI6XCJyZHctZm9udHNpemUtd3JhcHBlclwiLFwicmR3LWZvbnRzaXplLWRyb3Bkb3duXCI6XCJyZHctZm9udHNpemUtZHJvcGRvd25cIixcInJkdy1mb250c2l6ZS1vcHRpb25cIjpcInJkdy1mb250c2l6ZS1vcHRpb25cIn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiByKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gbChlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCksYz1uKDApLHM9byhjKSxNPW4oMSksdT1vKE0pLGc9big0KSxkPW4oNDIpLHA9byhkKSxOPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZSxuLG8sbDtpKHRoaXMsdCk7Zm9yKHZhciBhPWFyZ3VtZW50cy5sZW5ndGgsYz1BcnJheShhKSxzPTA7czxhO3MrKyljW3NdPWFyZ3VtZW50c1tzXTtyZXR1cm4gbj1vPXIodGhpcywoZT10Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsLmFwcGx5KGUsW3RoaXNdLmNvbmNhdChjKSkpLG8uc3RhdGU9e2V4cGFuZGVkOnZvaWQgMCxjdXJyZW50Rm9udEZhbWlseTp2b2lkIDB9LG8ub25FeHBhbmRFdmVudD1mdW5jdGlvbigpe28uc2lnbmFsRXhwYW5kZWQ9IW8uc3RhdGUuZXhwYW5kZWR9LG8uZXhwYW5kQ29sbGFwc2U9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDpvLnNpZ25hbEV4cGFuZGVkfSksby5zaWduYWxFeHBhbmRlZD0hMX0sby5kb0V4cGFuZD1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiEwfSl9LG8uZG9Db2xsYXBzZT1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiExfSl9LG8udG9nZ2xlRm9udEZhbWlseT1mdW5jdGlvbihlKXt2YXIgdD1vLnByb3BzLG49dC5lZGl0b3JTdGF0ZSxpPXQub25DaGFuZ2Uscj0oMCxnLnRvZ2dsZUN1c3RvbUlubGluZVN0eWxlKShuLFwiZm9udEZhbWlseVwiLGUpO3ImJmkocil9LGw9bixyKG8sbCl9cmV0dXJuIGwodCxlKSxhKHQsW3trZXk6XCJjb21wb25lbnRXaWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmVkaXRvclN0YXRlLG49ZS5tb2RhbEhhbmRsZXI7dCYmdGhpcy5zZXRTdGF0ZSh7Y3VycmVudEZvbnRGYW1pbHk6KDAsZy5nZXRTZWxlY3Rpb25DdXN0b21JbmxpbmVTdHlsZSkodCxbXCJGT05URkFNSUxZXCJdKS5GT05URkFNSUxZfSksbi5yZWdpc3RlckNhbGxCYWNrKHRoaXMuZXhwYW5kQ29sbGFwc2UpfX0se2tleTpcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIix2YWx1ZTpmdW5jdGlvbihlKXtlLmVkaXRvclN0YXRlJiZ0aGlzLnByb3BzLmVkaXRvclN0YXRlIT09ZS5lZGl0b3JTdGF0ZSYmdGhpcy5zZXRTdGF0ZSh7Y3VycmVudEZvbnRGYW1pbHk6KDAsZy5nZXRTZWxlY3Rpb25DdXN0b21JbmxpbmVTdHlsZSkoZS5lZGl0b3JTdGF0ZSxbXCJGT05URkFNSUxZXCJdKS5GT05URkFNSUxZfSl9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMubW9kYWxIYW5kbGVyLmRlcmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNvbmZpZyxuPWUudHJhbnNsYXRpb25zLG89dGhpcy5zdGF0ZSxpPW8uZXhwYW5kZWQscj1vLmN1cnJlbnRGb250RmFtaWx5LGw9dC5jb21wb25lbnR8fHAuZGVmYXVsdCxhPXImJnIuc3Vic3RyaW5nKDExKTtyZXR1cm4gcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQobCx7dHJhbnNsYXRpb25zOm4sY29uZmlnOnQsY3VycmVudFN0YXRlOntmb250RmFtaWx5OmF9LG9uQ2hhbmdlOnRoaXMudG9nZ2xlRm9udEZhbWlseSxleHBhbmRlZDppLG9uRXhwYW5kRXZlbnQ6dGhpcy5vbkV4cGFuZEV2ZW50LGRvRXhwYW5kOnRoaXMuZG9FeHBhbmQsZG9Db2xsYXBzZTp0aGlzLmRvQ29sbGFwc2V9KX19XSksdH0oYy5Db21wb25lbnQpO04ucHJvcFR5cGVzPXtvbkNoYW5nZTp1LmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLGVkaXRvclN0YXRlOnUuZGVmYXVsdC5vYmplY3QsbW9kYWxIYW5kbGVyOnUuZGVmYXVsdC5vYmplY3QsY29uZmlnOnUuZGVmYXVsdC5vYmplY3QsdHJhbnNsYXRpb25zOnUuZGVmYXVsdC5vYmplY3R9LHQuZGVmYXVsdD1OfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGwoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLGM9bigwKSxzPW8oYyksTT1uKDEpLHU9byhNKSxnPW4oMiksZD1vKGcpLHA9big3KTtuKDQzKTt2YXIgTj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7dmFyIGUsbixvLGw7aSh0aGlzLHQpO2Zvcih2YXIgYT1hcmd1bWVudHMubGVuZ3RoLGM9QXJyYXkoYSkscz0wO3M8YTtzKyspY1tzXT1hcmd1bWVudHNbc107cmV0dXJuIG49bz1yKHRoaXMsKGU9dC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbC5hcHBseShlLFt0aGlzXS5jb25jYXQoYykpKSxvLnN0YXRlPXtkZWZhdWx0Rm9udEZhbWlseTp2b2lkIDB9LGw9bixyKG8sbCl9cmV0dXJuIGwodCxlKSxhKHQsW3trZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIkRyYWZ0RWRpdG9yLXJvb3RcIik7aWYoZSYmZS5sZW5ndGg+MCl7dmFyIHQ9d2luZG93LmdldENvbXB1dGVkU3R5bGUoZVswXSksbj10LmdldFByb3BlcnR5VmFsdWUoXCJmb250LWZhbWlseVwiKTt0aGlzLnNldFN0YXRlKHtkZWZhdWx0Rm9udEZhbWlseTpufSl9fX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zdGF0ZS5kZWZhdWx0Rm9udEZhbWlseSx0PXRoaXMucHJvcHMsbj10LmNvbmZpZyxvPW4uY2xhc3NOYW1lLGk9bi5kcm9wZG93bkNsYXNzTmFtZSxyPW4ub3B0aW9ucyxsPW4udGl0bGUsYT10LnRyYW5zbGF0aW9ucyxjPXQub25DaGFuZ2UsTT10LmV4cGFuZGVkLHU9dC5kb0NvbGxhcHNlLGc9dC5vbkV4cGFuZEV2ZW50LE49dC5kb0V4cGFuZCxEPXRoaXMucHJvcHMuY3VycmVudFN0YXRlLmZvbnRGYW1pbHk7cmV0dXJuIEQ9RHx8ciYmZSYmci5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvTG93ZXJDYXNlKCk9PT1lLnRvTG93ZXJDYXNlKCl9KSYmZSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJyZHctZm9udGZhbWlseS13cmFwcGVyXCIsXCJhcmlhLWxhYmVsXCI6XCJyZHctZm9udC1mYW1pbHktY29udHJvbFwifSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChwLkRyb3Bkb3duLHtjbGFzc05hbWU6KDAsZC5kZWZhdWx0KShcInJkdy1mb250ZmFtaWx5LWRyb3Bkb3duXCIsbyksb3B0aW9uV3JhcHBlckNsYXNzTmFtZTooMCxkLmRlZmF1bHQpKFwicmR3LWZvbnRmYW1pbHktb3B0aW9ud3JhcHBlclwiLGkpLG9uQ2hhbmdlOmMsZXhwYW5kZWQ6TSxkb0V4cGFuZDpOLGRvQ29sbGFwc2U6dSxvbkV4cGFuZEV2ZW50OmcsdGl0bGU6bHx8YVtcImNvbXBvbmVudHMuY29udHJvbHMuZm9udGZhbWlseS5mb250ZmFtaWx5XCJdfSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIix7Y2xhc3NOYW1lOlwicmR3LWZvbnRmYW1pbHktcGxhY2Vob2xkZXJcIn0sRHx8YVtcImNvbXBvbmVudHMuY29udHJvbHMuZm9udGZhbWlseS5mb250ZmFtaWx5XCJdKSxyLm1hcChmdW5jdGlvbihlLHQpe3JldHVybiBzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChwLkRyb3Bkb3duT3B0aW9uLHthY3RpdmU6RD09PWUsdmFsdWU6ZSxrZXk6dH0sZSl9KSkpfX1dKSx0fShjLkNvbXBvbmVudCk7Ti5wcm9wVHlwZXM9e2V4cGFuZGVkOnUuZGVmYXVsdC5ib29sLG9uRXhwYW5kRXZlbnQ6dS5kZWZhdWx0LmZ1bmMsZG9FeHBhbmQ6dS5kZWZhdWx0LmZ1bmMsZG9Db2xsYXBzZTp1LmRlZmF1bHQuZnVuYyxvbkNoYW5nZTp1LmRlZmF1bHQuZnVuYyxjb25maWc6dS5kZWZhdWx0Lm9iamVjdCxjdXJyZW50U3RhdGU6dS5kZWZhdWx0Lm9iamVjdCx0cmFuc2xhdGlvbnM6dS5kZWZhdWx0Lm9iamVjdH0sdC5kZWZhdWx0PU59LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXtcInJkdy1mb250ZmFtaWx5LXdyYXBwZXJcIjpcInJkdy1mb250ZmFtaWx5LXdyYXBwZXJcIixcInJkdy1mb250ZmFtaWx5LWRyb3Bkb3duXCI6XCJyZHctZm9udGZhbWlseS1kcm9wZG93blwiLFwicmR3LWZvbnRmYW1pbHktcGxhY2Vob2xkZXJcIjpcInJkdy1mb250ZmFtaWx5LXBsYWNlaG9sZGVyXCIsXCJyZHctZm9udGZhbWlseS1vcHRpb253cmFwcGVyXCI6XCJyZHctZm9udGZhbWlseS1vcHRpb253cmFwcGVyXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGwoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLGM9bigwKSxzPW8oYyksTT1uKDEpLHU9byhNKSxnPW4oMyksZD1uKDQpLHA9big0NSksTj1vKHApLEQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlLG4sbyxsO2kodGhpcyx0KTtmb3IodmFyIGE9YXJndW1lbnRzLmxlbmd0aCxjPUFycmF5KGEpLHM9MDtzPGE7cysrKWNbc109YXJndW1lbnRzW3NdO3JldHVybiBuPW89cih0aGlzLChlPXQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KGMpKSksby5zdGF0ZT17ZXhwYW5kZWQ6ITEsY3VycmVudEJsb2NrOnZvaWQgMH0sby5vbkV4cGFuZEV2ZW50PWZ1bmN0aW9uKCl7by5zaWduYWxFeHBhbmRlZD0hby5zdGF0ZS5leHBhbmRlZH0sby5vbkNoYW5nZT1mdW5jdGlvbihlKXtcInVub3JkZXJlZFwiPT09ZT9vLnRvZ2dsZUJsb2NrVHlwZShcInVub3JkZXJlZC1saXN0LWl0ZW1cIik6XCJvcmRlcmVkXCI9PT1lP28udG9nZ2xlQmxvY2tUeXBlKFwib3JkZXJlZC1saXN0LWl0ZW1cIik6XCJpbmRlbnRcIj09PWU/by5hZGp1c3REZXB0aCgxKTpvLmFkanVzdERlcHRoKC0xKX0sby5leHBhbmRDb2xsYXBzZT1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOm8uc2lnbmFsRXhwYW5kZWR9KSxvLnNpZ25hbEV4cGFuZGVkPSExfSxvLmRvRXhwYW5kPWZ1bmN0aW9uKCl7by5zZXRTdGF0ZSh7ZXhwYW5kZWQ6ITB9KX0sby5kb0NvbGxhcHNlPWZ1bmN0aW9uKCl7by5zZXRTdGF0ZSh7ZXhwYW5kZWQ6ITF9KX0sby50b2dnbGVCbG9ja1R5cGU9ZnVuY3Rpb24oZSl7dmFyIHQ9by5wcm9wcyxuPXQub25DaGFuZ2UsaT10LmVkaXRvclN0YXRlLHI9Zy5SaWNoVXRpbHMudG9nZ2xlQmxvY2tUeXBlKGksZSk7ciYmbihyKX0sby5hZGp1c3REZXB0aD1mdW5jdGlvbihlKXt2YXIgdD1vLnByb3BzLG49dC5vbkNoYW5nZSxpPXQuZWRpdG9yU3RhdGUscj0oMCxkLmNoYW5nZURlcHRoKShpLGUsNCk7ciYmbihyKX0sby5pc0luZGVudERpc2FibGVkPWZ1bmN0aW9uKCl7dmFyIGU9by5wcm9wcy5lZGl0b3JTdGF0ZSx0PW8uc3RhdGUuY3VycmVudEJsb2NrLG49KDAsZC5nZXRCbG9ja0JlZm9yZVNlbGVjdGVkQmxvY2spKGUpO3JldHVybiFufHwhKDAsZC5pc0xpc3RCbG9jaykodCl8fG4uZ2V0KFwidHlwZVwiKSE9PXQuZ2V0KFwidHlwZVwiKXx8bi5nZXQoXCJkZXB0aFwiKTx0LmdldChcImRlcHRoXCIpfSxvLmlzT3V0ZGVudERpc2FibGVkPWZ1bmN0aW9uKCl7dmFyIGU9by5zdGF0ZS5jdXJyZW50QmxvY2s7cmV0dXJuIWV8fCEoMCxkLmlzTGlzdEJsb2NrKShlKXx8ZS5nZXQoXCJkZXB0aFwiKTw9MH0sbD1uLHIobyxsKX1yZXR1cm4gbCh0LGUpLGEodCxbe2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcyx0PWUuZWRpdG9yU3RhdGUsbj1lLm1vZGFsSGFuZGxlcjt0JiZ0aGlzLnNldFN0YXRlKHtjdXJyZW50QmxvY2s6KDAsZC5nZXRTZWxlY3RlZEJsb2NrKSh0KX0pLG4ucmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoZS5lZGl0b3JTdGF0ZSYmdGhpcy5wcm9wcy5lZGl0b3JTdGF0ZSE9PWUuZWRpdG9yU3RhdGUpeygwLGQuZ2V0U2VsZWN0ZWRCbG9jaykoZS5lZGl0b3JTdGF0ZSk7dGhpcy5zZXRTdGF0ZSh7Y3VycmVudEJsb2NrOigwLGQuZ2V0U2VsZWN0ZWRCbG9jaykoZS5lZGl0b3JTdGF0ZSl9KX19fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMubW9kYWxIYW5kbGVyLmRlcmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNvbmZpZyxuPWUudHJhbnNsYXRpb25zLG89dGhpcy5zdGF0ZSxpPW8uZXhwYW5kZWQscj1vLmN1cnJlbnRCbG9jayxsPXQuY29tcG9uZW50fHxOLmRlZmF1bHQsYT12b2lkIDA7XCJ1bm9yZGVyZWQtbGlzdC1pdGVtXCI9PT1yLmdldChcInR5cGVcIik/YT1cInVub3JkZXJlZFwiOlwib3JkZXJlZC1saXN0LWl0ZW1cIj09PXIuZ2V0KFwidHlwZVwiKSYmKGE9XCJvcmRlcmVkXCIpO3ZhciBjPXRoaXMuaXNJbmRlbnREaXNhYmxlZCgpLE09dGhpcy5pc091dGRlbnREaXNhYmxlZCgpO3JldHVybiBzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChsLHtjb25maWc6dCx0cmFuc2xhdGlvbnM6bixjdXJyZW50U3RhdGU6e2xpc3RUeXBlOmF9LGV4cGFuZGVkOmksb25FeHBhbmRFdmVudDp0aGlzLm9uRXhwYW5kRXZlbnQsZG9FeHBhbmQ6dGhpcy5kb0V4cGFuZCxkb0NvbGxhcHNlOnRoaXMuZG9Db2xsYXBzZSxvbkNoYW5nZTp0aGlzLm9uQ2hhbmdlLGluZGVudERpc2FibGVkOmMsb3V0ZGVudERpc2FibGVkOk19KX19XSksdH0oYy5Db21wb25lbnQpO0QucHJvcFR5cGVzPXtvbkNoYW5nZTp1LmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLGVkaXRvclN0YXRlOnUuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZCxtb2RhbEhhbmRsZXI6dS5kZWZhdWx0Lm9iamVjdCxjb25maWc6dS5kZWZhdWx0Lm9iamVjdCx0cmFuc2xhdGlvbnM6dS5kZWZhdWx0Lm9iamVjdH0sdC5kZWZhdWx0PUR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiByKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gbChlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCksYz1uKDApLHM9byhjKSxNPW4oMSksdT1vKE0pLGc9bigyKSxkPW8oZykscD1uKDgpLE49big3KSxEPW4oNSksST1vKEQpO24oNDYpO3ZhciB5PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZSxuLG8sbDtpKHRoaXMsdCk7Zm9yKHZhciBhPWFyZ3VtZW50cy5sZW5ndGgsYz1BcnJheShhKSxzPTA7czxhO3MrKyljW3NdPWFyZ3VtZW50c1tzXTtyZXR1cm4gbj1vPXIodGhpcywoZT10Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsLmFwcGx5KGUsW3RoaXNdLmNvbmNhdChjKSkpLG8ub3B0aW9ucz1bXCJ1bm9yZGVyZWRcIixcIm9yZGVyZWRcIixcImluZGVudFwiLFwib3V0ZGVudFwiXSxvLnRvZ2dsZUJsb2NrVHlwZT1mdW5jdGlvbihlKXsoMCxvLnByb3BzLm9uQ2hhbmdlKShlKX0sby5pbmRlbnQ9ZnVuY3Rpb24oKXsoMCxvLnByb3BzLm9uQ2hhbmdlKShcImluZGVudFwiKX0sby5vdXRkZW50PWZ1bmN0aW9uKCl7KDAsby5wcm9wcy5vbkNoYW5nZSkoXCJvdXRkZW50XCIpfSxsPW4scihvLGwpfXJldHVybiBsKHQsZSksYSh0LFt7a2V5OlwicmVuZGVySW5GbGF0TGlzdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcyx0PWUuY29uZmlnLG49ZS5jdXJyZW50U3RhdGUubGlzdFR5cGUsbz1lLnRyYW5zbGF0aW9ucyxpPWUuaW5kZW50RGlzYWJsZWQscj1lLm91dGRlbnREaXNhYmxlZCxsPXQub3B0aW9ucyxhPXQudW5vcmRlcmVkLGM9dC5vcmRlcmVkLE09dC5pbmRlbnQsdT10Lm91dGRlbnQsZz10LmNsYXNzTmFtZTtyZXR1cm4gcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoXCJyZHctbGlzdC13cmFwcGVyXCIsZyksXCJhcmlhLWxhYmVsXCI6XCJyZHctbGlzdC1jb250cm9sXCJ9LGwuaW5kZXhPZihcInVub3JkZXJlZFwiKT49MCYmcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSS5kZWZhdWx0LHt2YWx1ZTpcInVub3JkZXJlZFwiLG9uQ2xpY2s6dGhpcy50b2dnbGVCbG9ja1R5cGUsY2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoYS5jbGFzc05hbWUpLGFjdGl2ZTpcInVub3JkZXJlZFwiPT09bix0aXRsZTphLnRpdGxlfHxvW1wiY29tcG9uZW50cy5jb250cm9scy5saXN0LnVub3JkZXJlZFwiXX0scy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIix7c3JjOmEuaWNvbixhbHQ6XCJcIn0pKSxsLmluZGV4T2YoXCJvcmRlcmVkXCIpPj0wJiZzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChJLmRlZmF1bHQse3ZhbHVlOlwib3JkZXJlZFwiLG9uQ2xpY2s6dGhpcy50b2dnbGVCbG9ja1R5cGUsY2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoYy5jbGFzc05hbWUpLGFjdGl2ZTpcIm9yZGVyZWRcIj09PW4sdGl0bGU6Yy50aXRsZXx8b1tcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5vcmRlcmVkXCJdfSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6Yy5pY29uLGFsdDpcIlwifSkpLGwuaW5kZXhPZihcImluZGVudFwiKT49MCYmcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSS5kZWZhdWx0LHtvbkNsaWNrOnRoaXMuaW5kZW50LGRpc2FibGVkOmksY2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoTS5jbGFzc05hbWUpLHRpdGxlOk0udGl0bGV8fG9bXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3QuaW5kZW50XCJdfSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6TS5pY29uLGFsdDpcIlwifSkpLGwuaW5kZXhPZihcIm91dGRlbnRcIik+PTAmJnMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEkuZGVmYXVsdCx7b25DbGljazp0aGlzLm91dGRlbnQsZGlzYWJsZWQ6cixjbGFzc05hbWU6KDAsZC5kZWZhdWx0KSh1LmNsYXNzTmFtZSksdGl0bGU6dS50aXRsZXx8b1tcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5vdXRkZW50XCJdfSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6dS5pY29uLGFsdDpcIlwifSkpKX19LHtrZXk6XCJyZW5kZXJJbkRyb3BEb3duXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9dGhpcy5wcm9wcyxuPXQuY29uZmlnLG89dC5leHBhbmRlZCxpPXQuZG9Db2xsYXBzZSxyPXQuZG9FeHBhbmQsbD10Lm9uRXhwYW5kRXZlbnQsYT10Lm9uQ2hhbmdlLGM9dC5jdXJyZW50U3RhdGUubGlzdFR5cGUsTT10LnRyYW5zbGF0aW9ucyx1PW4ub3B0aW9ucyxnPW4uY2xhc3NOYW1lLEQ9bi5kcm9wZG93bkNsYXNzTmFtZSxJPW4udGl0bGU7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE4uRHJvcGRvd24se2NsYXNzTmFtZTooMCxkLmRlZmF1bHQpKFwicmR3LWxpc3QtZHJvcGRvd25cIixnKSxvcHRpb25XcmFwcGVyQ2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoRCksb25DaGFuZ2U6YSxleHBhbmRlZDpvLGRvRXhwYW5kOnIsZG9Db2xsYXBzZTppLG9uRXhwYW5kRXZlbnQ6bCxcImFyaWEtbGFiZWxcIjpcInJkdy1saXN0LWNvbnRyb2xcIix0aXRsZTpJfHxNW1wiY29tcG9uZW50cy5jb250cm9scy5saXN0Lmxpc3RcIl19LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIse3NyYzooMCxwLmdldEZpcnN0SWNvbikobiksYWx0OlwiXCJ9KSx0aGlzLm9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiB1LmluZGV4T2YoZSk+PTB9KS5tYXAoZnVuY3Rpb24odCxvKXtyZXR1cm4gcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTi5Ecm9wZG93bk9wdGlvbix7a2V5Om8sdmFsdWU6dCxkaXNhYmxlZDplLnByb3BzW3QrXCJEaXNhYmxlZFwiXSxjbGFzc05hbWU6KDAsZC5kZWZhdWx0KShcInJkdy1saXN0LWRyb3Bkb3duT3B0aW9uXCIsblt0XS5jbGFzc05hbWUpLGFjdGl2ZTpjPT09dCx0aXRsZTpuW3RdLnRpdGxlfHxNW1wiY29tcG9uZW50cy5jb250cm9scy5saXN0LlwiK3RdfSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6blt0XS5pY29uLGFsdDpcIlwifSkpfSkpfX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcHMuY29uZmlnLmluRHJvcGRvd24/dGhpcy5yZW5kZXJJbkRyb3BEb3duKCk6dGhpcy5yZW5kZXJJbkZsYXRMaXN0KCl9fV0pLHR9KGMuQ29tcG9uZW50KTt5LnByb3BUeXBlcz17ZXhwYW5kZWQ6dS5kZWZhdWx0LmJvb2wsZG9FeHBhbmQ6dS5kZWZhdWx0LmZ1bmMsZG9Db2xsYXBzZTp1LmRlZmF1bHQuZnVuYyxvbkV4cGFuZEV2ZW50OnUuZGVmYXVsdC5mdW5jLGNvbmZpZzp1LmRlZmF1bHQub2JqZWN0LG9uQ2hhbmdlOnUuZGVmYXVsdC5mdW5jLGN1cnJlbnRTdGF0ZTp1LmRlZmF1bHQub2JqZWN0LHRyYW5zbGF0aW9uczp1LmRlZmF1bHQub2JqZWN0LGluZGVudERpc2FibGVkOnUuZGVmYXVsdC5ib29sLG91dGRlbnREaXNhYmxlZDp1LmRlZmF1bHQuYm9vbH0sdC5kZWZhdWx0PXl9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXtcInJkdy1saXN0LXdyYXBwZXJcIjpcInJkdy1saXN0LXdyYXBwZXJcIixcInJkdy1saXN0LWRyb3Bkb3duXCI6XCJyZHctbGlzdC1kcm9wZG93blwiLFwicmR3LWxpc3QtZHJvcGRvd25PcHRpb25cIjpcInJkdy1saXN0LWRyb3Bkb3duT3B0aW9uXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGwoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLGM9bigwKSxzPW8oYyksTT1uKDEpLHU9byhNKSxnPW4oNCksZD1uKDQ4KSxwPW8oZCksTj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7dmFyIGUsbixvLGw7aSh0aGlzLHQpO2Zvcih2YXIgYT1hcmd1bWVudHMubGVuZ3RoLGM9QXJyYXkoYSkscz0wO3M8YTtzKyspY1tzXT1hcmd1bWVudHNbc107cmV0dXJuIG49bz1yKHRoaXMsKGU9dC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbC5hcHBseShlLFt0aGlzXS5jb25jYXQoYykpKSxvLnN0YXRlPXtjdXJyZW50VGV4dEFsaWdubWVudDp2b2lkIDB9LG8ub25FeHBhbmRFdmVudD1mdW5jdGlvbigpe28uc2lnbmFsRXhwYW5kZWQ9IW8uc3RhdGUuZXhwYW5kZWR9LG8uZXhwYW5kQ29sbGFwc2U9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDpvLnNpZ25hbEV4cGFuZGVkfSksby5zaWduYWxFeHBhbmRlZD0hMX0sby5kb0V4cGFuZD1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiEwfSl9LG8uZG9Db2xsYXBzZT1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiExfSl9LG8uYWRkQmxvY2tBbGlnbm1lbnREYXRhPWZ1bmN0aW9uKGUpe3ZhciB0PW8ucHJvcHMsbj10LmVkaXRvclN0YXRlLGk9dC5vbkNoYW5nZTtpKG8uc3RhdGUuY3VycmVudFRleHRBbGlnbm1lbnQhPT1lPygwLGcuc2V0QmxvY2tEYXRhKShuLHtcInRleHQtYWxpZ25cIjplfSk6KDAsZy5zZXRCbG9ja0RhdGEpKG4se1widGV4dC1hbGlnblwiOnZvaWQgMH0pKX0sbD1uLHIobyxsKX1yZXR1cm4gbCh0LGUpLGEodCxbe2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcm9wcy5tb2RhbEhhbmRsZXIucmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZS5lZGl0b3JTdGF0ZSE9PXRoaXMucHJvcHMuZWRpdG9yU3RhdGUmJnRoaXMuc2V0U3RhdGUoe2N1cnJlbnRUZXh0QWxpZ25tZW50OigwLGcuZ2V0U2VsZWN0ZWRCbG9ja3NNZXRhZGF0YSkoZS5lZGl0b3JTdGF0ZSkuZ2V0KFwidGV4dC1hbGlnblwiKX0pfX0se2tleTpcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnByb3BzLm1vZGFsSGFuZGxlci5kZXJlZ2lzdGVyQ2FsbEJhY2sodGhpcy5leHBhbmRDb2xsYXBzZSl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3BzLHQ9ZS5jb25maWcsbj1lLnRyYW5zbGF0aW9ucyxvPXRoaXMuc3RhdGUsaT1vLmV4cGFuZGVkLHI9by5jdXJyZW50VGV4dEFsaWdubWVudCxsPXQuY29tcG9uZW50fHxwLmRlZmF1bHQ7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGwse2NvbmZpZzp0LHRyYW5zbGF0aW9uczpuLGV4cGFuZGVkOmksb25FeHBhbmRFdmVudDp0aGlzLm9uRXhwYW5kRXZlbnQsZG9FeHBhbmQ6dGhpcy5kb0V4cGFuZCxkb0NvbGxhcHNlOnRoaXMuZG9Db2xsYXBzZSxjdXJyZW50U3RhdGU6e3RleHRBbGlnbm1lbnQ6cn0sb25DaGFuZ2U6dGhpcy5hZGRCbG9ja0FsaWdubWVudERhdGF9KX19XSksdH0oYy5Db21wb25lbnQpO04ucHJvcFR5cGVzPXtlZGl0b3JTdGF0ZTp1LmRlZmF1bHQub2JqZWN0LmlzUmVxdWlyZWQsb25DaGFuZ2U6dS5kZWZhdWx0LmZ1bmMuaXNSZXF1aXJlZCxtb2RhbEhhbmRsZXI6dS5kZWZhdWx0Lm9iamVjdCxjb25maWc6dS5kZWZhdWx0Lm9iamVjdCx0cmFuc2xhdGlvbnM6dS5kZWZhdWx0Lm9iamVjdH0sdC5kZWZhdWx0PU59LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiByKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gbChlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCksYz1uKDApLHM9byhjKSxNPW4oMSksdT1vKE0pLGc9bigyKSxkPW8oZykscD1uKDUpLE49byhwKSxEPW4oNyksST1uKDgpO24oNDkpO3ZhciB5PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gaSh0aGlzLHQpLHIodGhpcywodC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuYXBwbHkodGhpcyxhcmd1bWVudHMpKX1yZXR1cm4gbCh0LGUpLGEodCxbe2tleTpcInJlbmRlckluRmxhdExpc3RcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNvbmZpZyxuPXQub3B0aW9ucyxvPXQubGVmdCxpPXQuY2VudGVyLHI9dC5yaWdodCxsPXQuanVzdGlmeSxhPXQuY2xhc3NOYW1lLGM9ZS5vbkNoYW5nZSxNPWUuY3VycmVudFN0YXRlLnRleHRBbGlnbm1lbnQsdT1lLnRyYW5zbGF0aW9ucztyZXR1cm4gcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoXCJyZHctdGV4dC1hbGlnbi13cmFwcGVyXCIsYSksXCJhcmlhLWxhYmVsXCI6XCJyZHctdGV4dGFsaWduLWNvbnRyb2xcIn0sbi5pbmRleE9mKFwibGVmdFwiKT49MCYmcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTi5kZWZhdWx0LHt2YWx1ZTpcImxlZnRcIixjbGFzc05hbWU6KDAsZC5kZWZhdWx0KShvLmNsYXNzTmFtZSksYWN0aXZlOlwibGVmdFwiPT09TSxvbkNsaWNrOmMsdGl0bGU6by50aXRsZXx8dVtcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmxlZnRcIl19LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIse3NyYzpvLmljb24sYWx0OlwiXCJ9KSksbi5pbmRleE9mKFwiY2VudGVyXCIpPj0wJiZzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChOLmRlZmF1bHQse3ZhbHVlOlwiY2VudGVyXCIsY2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoaS5jbGFzc05hbWUpLGFjdGl2ZTpcImNlbnRlclwiPT09TSxvbkNsaWNrOmMsdGl0bGU6aS50aXRsZXx8dVtcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmNlbnRlclwiXX0scy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIix7c3JjOmkuaWNvbixhbHQ6XCJcIn0pKSxuLmluZGV4T2YoXCJyaWdodFwiKT49MCYmcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTi5kZWZhdWx0LHt2YWx1ZTpcInJpZ2h0XCIsY2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoci5jbGFzc05hbWUpLGFjdGl2ZTpcInJpZ2h0XCI9PT1NLG9uQ2xpY2s6Yyx0aXRsZTpyLnRpdGxlfHx1W1wiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24ucmlnaHRcIl19LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIse3NyYzpyLmljb24sYWx0OlwiXCJ9KSksbi5pbmRleE9mKFwianVzdGlmeVwiKT49MCYmcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTi5kZWZhdWx0LHt2YWx1ZTpcImp1c3RpZnlcIixjbGFzc05hbWU6KDAsZC5kZWZhdWx0KShsLmNsYXNzTmFtZSksYWN0aXZlOlwianVzdGlmeVwiPT09TSxvbkNsaWNrOmMsdGl0bGU6bC50aXRsZXx8dVtcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmp1c3RpZnlcIl19LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIse3NyYzpsLmljb24sYWx0OlwiXCJ9KSkpfX0se2tleTpcInJlbmRlckluRHJvcERvd25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNvbmZpZyxuPWUuZXhwYW5kZWQsbz1lLmRvRXhwYW5kLGk9ZS5vbkV4cGFuZEV2ZW50LHI9ZS5kb0NvbGxhcHNlLGw9ZS5jdXJyZW50U3RhdGUudGV4dEFsaWdubWVudCxhPWUub25DaGFuZ2UsYz1lLnRyYW5zbGF0aW9ucyxNPXQub3B0aW9ucyx1PXQubGVmdCxnPXQuY2VudGVyLHA9dC5yaWdodCxOPXQuanVzdGlmeSx5PXQuY2xhc3NOYW1lLGo9dC5kcm9wZG93bkNsYXNzTmFtZSxmPXQudGl0bGU7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEQuRHJvcGRvd24se2NsYXNzTmFtZTooMCxkLmRlZmF1bHQpKFwicmR3LXRleHQtYWxpZ24tZHJvcGRvd25cIix5KSxvcHRpb25XcmFwcGVyQ2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoaiksb25DaGFuZ2U6YSxleHBhbmRlZDpuLGRvRXhwYW5kOm8sZG9Db2xsYXBzZTpyLG9uRXhwYW5kRXZlbnQ6aSxcImFyaWEtbGFiZWxcIjpcInJkdy10ZXh0YWxpZ24tY29udHJvbFwiLHRpdGxlOmZ8fGNbXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi50ZXh0YWxpZ25cIl19LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIse3NyYzpsJiZ0W2xdJiZ0W2xdLmljb258fCgwLEkuZ2V0Rmlyc3RJY29uKSh0KSxhbHQ6XCJcIn0pLE0uaW5kZXhPZihcImxlZnRcIik+PTAmJnMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEQuRHJvcGRvd25PcHRpb24se3ZhbHVlOlwibGVmdFwiLGFjdGl2ZTpcImxlZnRcIj09PWwsY2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoXCJyZHctdGV4dC1hbGlnbi1kcm9wZG93bk9wdGlvblwiLHUuY2xhc3NOYW1lKSx0aXRsZTp1LnRpdGxlfHxjW1wiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24ubGVmdFwiXX0scy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIix7c3JjOnUuaWNvbixhbHQ6XCJcIn0pKSxNLmluZGV4T2YoXCJjZW50ZXJcIik+PTAmJnMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEQuRHJvcGRvd25PcHRpb24se3ZhbHVlOlwiY2VudGVyXCIsYWN0aXZlOlwiY2VudGVyXCI9PT1sLGNsYXNzTmFtZTooMCxkLmRlZmF1bHQpKFwicmR3LXRleHQtYWxpZ24tZHJvcGRvd25PcHRpb25cIixnLmNsYXNzTmFtZSksdGl0bGU6Zy50aXRsZXx8Y1tcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmNlbnRlclwiXX0scy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIix7c3JjOmcuaWNvbixhbHQ6XCJcIn0pKSxNLmluZGV4T2YoXCJyaWdodFwiKT49MCYmcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRC5Ecm9wZG93bk9wdGlvbix7dmFsdWU6XCJyaWdodFwiLGFjdGl2ZTpcInJpZ2h0XCI9PT1sLGNsYXNzTmFtZTooMCxkLmRlZmF1bHQpKFwicmR3LXRleHQtYWxpZ24tZHJvcGRvd25PcHRpb25cIixwLmNsYXNzTmFtZSksdGl0bGU6cC50aXRsZXx8Y1tcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLnJpZ2h0XCJdfSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6cC5pY29uLGFsdDpcIlwifSkpLE0uaW5kZXhPZihcImp1c3RpZnlcIik+PTAmJnMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEQuRHJvcGRvd25PcHRpb24se3ZhbHVlOlwianVzdGlmeVwiLGFjdGl2ZTpcImp1c3RpZnlcIj09PWwsY2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoXCJyZHctdGV4dC1hbGlnbi1kcm9wZG93bk9wdGlvblwiLE4uY2xhc3NOYW1lKSx0aXRsZTpOLnRpdGxlfHxjW1wiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24uanVzdGlmeVwiXX0scy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIix7c3JjOk4uaWNvbixhbHQ6XCJcIn0pKSl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wcy5jb25maWcuaW5Ecm9wZG93bj90aGlzLnJlbmRlckluRHJvcERvd24oKTp0aGlzLnJlbmRlckluRmxhdExpc3QoKX19XSksdH0oYy5Db21wb25lbnQpO3kucHJvcFR5cGVzPXtleHBhbmRlZDp1LmRlZmF1bHQuYm9vbCxkb0V4cGFuZDp1LmRlZmF1bHQuZnVuYyxkb0NvbGxhcHNlOnUuZGVmYXVsdC5mdW5jLG9uRXhwYW5kRXZlbnQ6dS5kZWZhdWx0LmZ1bmMsY29uZmlnOnUuZGVmYXVsdC5vYmplY3Qsb25DaGFuZ2U6dS5kZWZhdWx0LmZ1bmMsY3VycmVudFN0YXRlOnUuZGVmYXVsdC5vYmplY3QsdHJhbnNsYXRpb25zOnUuZGVmYXVsdC5vYmplY3R9LHQuZGVmYXVsdD15fSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz17XCJyZHctdGV4dC1hbGlnbi13cmFwcGVyXCI6XCJyZHctdGV4dC1hbGlnbi13cmFwcGVyXCIsXCJyZHctdGV4dC1hbGlnbi1kcm9wZG93blwiOlwicmR3LXRleHQtYWxpZ24tZHJvcGRvd25cIixcInJkdy10ZXh0LWFsaWduLWRyb3Bkb3duT3B0aW9uXCI6XCJyZHctdGV4dC1hbGlnbi1kcm9wZG93bk9wdGlvblwiLFwicmR3LXJpZ2h0LWFsaWduZWQtYmxvY2tcIjpcInJkdy1yaWdodC1hbGlnbmVkLWJsb2NrXCIsXCJyZHctbGVmdC1hbGlnbmVkLWJsb2NrXCI6XCJyZHctbGVmdC1hbGlnbmVkLWJsb2NrXCIsXCJyZHctY2VudGVyLWFsaWduZWQtYmxvY2tcIjpcInJkdy1jZW50ZXItYWxpZ25lZC1ibG9ja1wiLFwicmR3LWp1c3RpZnktYWxpZ25lZC1ibG9ja1wiOlwicmR3LWp1c3RpZnktYWxpZ25lZC1ibG9ja1wifX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIHIoZSx0KXtpZighZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2U6dH1mdW5jdGlvbiBsKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHQpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsdCk6ZS5fX3Byb3RvX189dCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBvPXRbbl07by5lbnVtZXJhYmxlPW8uZW51bWVyYWJsZXx8ITEsby5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbyYmKG8ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG8ua2V5LG8pfX1yZXR1cm4gZnVuY3Rpb24odCxuLG8pe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLG8mJmUodCxvKSx0fX0oKSxjPW4oMCkscz1vKGMpLE09bigxKSx1PW8oTSksZz1uKDQpLGQ9big1MSkscD1vKGQpLE49ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlLG4sbyxsO2kodGhpcyx0KTtmb3IodmFyIGE9YXJndW1lbnRzLmxlbmd0aCxjPUFycmF5KGEpLHM9MDtzPGE7cysrKWNbc109YXJndW1lbnRzW3NdO3JldHVybiBuPW89cih0aGlzLChlPXQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KGMpKSksby5zdGF0ZT17ZXhwYW5kZWQ6ITEsY3VycmVudENvbG9yOnZvaWQgMCxjdXJyZW50QmdDb2xvcjp2b2lkIDB9LG8ub25FeHBhbmRFdmVudD1mdW5jdGlvbigpe28uc2lnbmFsRXhwYW5kZWQ9IW8uc3RhdGUuZXhwYW5kZWR9LG8uZXhwYW5kQ29sbGFwc2U9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDpvLnNpZ25hbEV4cGFuZGVkfSksby5zaWduYWxFeHBhbmRlZD0hMX0sby5kb0V4cGFuZD1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiEwfSl9LG8uZG9Db2xsYXBzZT1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiExfSl9LG8udG9nZ2xlQ29sb3I9ZnVuY3Rpb24oZSx0KXt2YXIgbj1vLnByb3BzLGk9bi5lZGl0b3JTdGF0ZSxyPW4ub25DaGFuZ2UsbD0oMCxnLnRvZ2dsZUN1c3RvbUlubGluZVN0eWxlKShpLGUsdCk7bCYmcihsKSxvLmRvQ29sbGFwc2UoKX0sbD1uLHIobyxsKX1yZXR1cm4gbCh0LGUpLGEodCxbe2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcyx0PWUuZWRpdG9yU3RhdGUsbj1lLm1vZGFsSGFuZGxlcjt0JiZ0aGlzLnNldFN0YXRlKHtjdXJyZW50Q29sb3I6KDAsZy5nZXRTZWxlY3Rpb25DdXN0b21JbmxpbmVTdHlsZSkodCxbXCJDT0xPUlwiXSkuQ09MT1IsY3VycmVudEJnQ29sb3I6KDAsZy5nZXRTZWxlY3Rpb25DdXN0b21JbmxpbmVTdHlsZSkodCxbXCJCR0NPTE9SXCJdKS5CR0NPTE9SfSksbi5yZWdpc3RlckNhbGxCYWNrKHRoaXMuZXhwYW5kQ29sbGFwc2UpfX0se2tleTpcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD17fTtlLmVkaXRvclN0YXRlJiZ0aGlzLnByb3BzLmVkaXRvclN0YXRlIT09ZS5lZGl0b3JTdGF0ZSYmKHQuY3VycmVudENvbG9yPSgwLGcuZ2V0U2VsZWN0aW9uQ3VzdG9tSW5saW5lU3R5bGUpKGUuZWRpdG9yU3RhdGUsW1wiQ09MT1JcIl0pLkNPTE9SLHQuY3VycmVudEJnQ29sb3I9KDAsZy5nZXRTZWxlY3Rpb25DdXN0b21JbmxpbmVTdHlsZSkoZS5lZGl0b3JTdGF0ZSxbXCJCR0NPTE9SXCJdKS5CR0NPTE9SKSx0aGlzLnNldFN0YXRlKHQpfX0se2tleTpcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnByb3BzLm1vZGFsSGFuZGxlci5kZXJlZ2lzdGVyQ2FsbEJhY2sodGhpcy5leHBhbmRDb2xsYXBzZSl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3BzLHQ9ZS5jb25maWcsbj1lLnRyYW5zbGF0aW9ucyxvPXRoaXMuc3RhdGUsaT1vLmN1cnJlbnRDb2xvcixyPW8uY3VycmVudEJnQ29sb3IsbD1vLmV4cGFuZGVkLGE9dC5jb21wb25lbnR8fHAuZGVmYXVsdCxjPWkmJmkuc3Vic3RyaW5nKDYpLE09ciYmci5zdWJzdHJpbmcoOCk7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGEse2NvbmZpZzp0LHRyYW5zbGF0aW9uczpuLG9uQ2hhbmdlOnRoaXMudG9nZ2xlQ29sb3IsZXhwYW5kZWQ6bCxvbkV4cGFuZEV2ZW50OnRoaXMub25FeHBhbmRFdmVudCxkb0V4cGFuZDp0aGlzLmRvRXhwYW5kLGRvQ29sbGFwc2U6dGhpcy5kb0NvbGxhcHNlLGN1cnJlbnRTdGF0ZTp7Y29sb3I6YyxiZ0NvbG9yOk19fSl9fV0pLHR9KGMuQ29tcG9uZW50KTtOLnByb3BUeXBlcz17b25DaGFuZ2U6dS5kZWZhdWx0LmZ1bmMuaXNSZXF1aXJlZCxlZGl0b3JTdGF0ZTp1LmRlZmF1bHQub2JqZWN0LmlzUmVxdWlyZWQsbW9kYWxIYW5kbGVyOnUuZGVmYXVsdC5vYmplY3QsY29uZmlnOnUuZGVmYXVsdC5vYmplY3QsdHJhbnNsYXRpb25zOnUuZGVmYXVsdC5vYmplY3R9LHQuZGVmYXVsdD1OfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGwoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLGM9bigwKSxzPW8oYyksTT1uKDEpLHU9byhNKSxnPW4oMiksZD1vKGcpLHA9big2KSxOPW4oNSksRD1vKE4pO24oNTIpO3ZhciBJPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZSxuLG8sbDtpKHRoaXMsdCk7Zm9yKHZhciBhPWFyZ3VtZW50cy5sZW5ndGgsYz1BcnJheShhKSxNPTA7TTxhO00rKyljW01dPWFyZ3VtZW50c1tNXTtyZXR1cm4gbj1vPXIodGhpcywoZT10Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsLmFwcGx5KGUsW3RoaXNdLmNvbmNhdChjKSkpLG8uc3RhdGU9e2N1cnJlbnRTdHlsZTpcImNvbG9yXCJ9LG8ub25DaGFuZ2U9ZnVuY3Rpb24oZSl7KDAsby5wcm9wcy5vbkNoYW5nZSkoby5zdGF0ZS5jdXJyZW50U3R5bGUsZSl9LG8uc2V0Q3VycmVudFN0eWxlQ29sb3I9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtjdXJyZW50U3R5bGU6XCJjb2xvclwifSl9LG8uc2V0Q3VycmVudFN0eWxlQmdjb2xvcj1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2N1cnJlbnRTdHlsZTpcImJnY29sb3JcIn0pfSxvLnJlbmRlck1vZGFsPWZ1bmN0aW9uKCl7dmFyIGU9by5wcm9wcyx0PWUuY29uZmlnLG49dC5wb3B1cENsYXNzTmFtZSxpPXQuY29sb3JzLHI9ZS5jdXJyZW50U3RhdGUsbD1yLmNvbG9yLGE9ci5iZ0NvbG9yLGM9ZS50cmFuc2xhdGlvbnMsTT1vLnN0YXRlLmN1cnJlbnRTdHlsZSx1PVwiY29sb3JcIj09PU0/bDphO3JldHVybiBzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6KDAsZC5kZWZhdWx0KShcInJkdy1jb2xvcnBpY2tlci1tb2RhbFwiLG4pLG9uQ2xpY2s6cC5zdG9wUHJvcGFnYXRpb259LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtjbGFzc05hbWU6XCJyZHctY29sb3JwaWNrZXItbW9kYWwtaGVhZGVyXCJ9LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtjbGFzc05hbWU6KDAsZC5kZWZhdWx0KShcInJkdy1jb2xvcnBpY2tlci1tb2RhbC1zdHlsZS1sYWJlbFwiLHtcInJkdy1jb2xvcnBpY2tlci1tb2RhbC1zdHlsZS1sYWJlbC1hY3RpdmVcIjpcImNvbG9yXCI9PT1NfSksb25DbGljazpvLnNldEN1cnJlbnRTdHlsZUNvbG9yfSxjW1wiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci50ZXh0XCJdKSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIix7Y2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoXCJyZHctY29sb3JwaWNrZXItbW9kYWwtc3R5bGUtbGFiZWxcIix7XCJyZHctY29sb3JwaWNrZXItbW9kYWwtc3R5bGUtbGFiZWwtYWN0aXZlXCI6XCJiZ2NvbG9yXCI9PT1NfSksb25DbGljazpvLnNldEN1cnJlbnRTdHlsZUJnY29sb3J9LGNbXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLmJhY2tncm91bmRcIl0pKSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIix7Y2xhc3NOYW1lOlwicmR3LWNvbG9ycGlja2VyLW1vZGFsLW9wdGlvbnNcIn0saS5tYXAoZnVuY3Rpb24oZSx0KXtyZXR1cm4gcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRC5kZWZhdWx0LHt2YWx1ZTplLGtleTp0LGNsYXNzTmFtZTpcInJkdy1jb2xvcnBpY2tlci1vcHRpb25cIixhY3RpdmVDbGFzc05hbWU6XCJyZHctY29sb3JwaWNrZXItb3B0aW9uLWFjdGl2ZVwiLGFjdGl2ZTp1PT09ZSxvbkNsaWNrOm8ub25DaGFuZ2V9LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtzdHlsZTp7YmFja2dyb3VuZENvbG9yOmV9LGNsYXNzTmFtZTpcInJkdy1jb2xvcnBpY2tlci1jdWJlXCJ9KSl9KSkpfSxsPW4scihvLGwpfXJldHVybiBsKHQsZSksYSh0LFt7a2V5OlwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiLHZhbHVlOmZ1bmN0aW9uKGUpeyF0aGlzLnByb3BzLmV4cGFuZGVkJiZlLmV4cGFuZGVkJiZ0aGlzLnNldFN0YXRlKHtjdXJyZW50U3R5bGU6XCJjb2xvclwifSl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3BzLHQ9ZS5jb25maWcsbj10Lmljb24sbz10LmNsYXNzTmFtZSxpPXQudGl0bGUscj1lLmV4cGFuZGVkLGw9ZS5vbkV4cGFuZEV2ZW50LGE9ZS50cmFuc2xhdGlvbnM7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInJkdy1jb2xvcnBpY2tlci13cmFwcGVyXCIsXCJhcmlhLWhhc3BvcHVwXCI6XCJ0cnVlXCIsXCJhcmlhLWV4cGFuZGVkXCI6cixcImFyaWEtbGFiZWxcIjpcInJkdy1jb2xvci1waWNrZXJcIix0aXRsZTppfHxhW1wiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci5jb2xvcnBpY2tlclwiXX0scy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRC5kZWZhdWx0LHtvbkNsaWNrOmwsY2xhc3NOYW1lOigwLGQuZGVmYXVsdCkobyl9LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIse3NyYzpuLGFsdDpcIlwifSkpLHI/dGhpcy5yZW5kZXJNb2RhbCgpOnZvaWQgMCl9fV0pLHR9KGMuQ29tcG9uZW50KTtJLnByb3BUeXBlcz17ZXhwYW5kZWQ6dS5kZWZhdWx0LmJvb2wsb25FeHBhbmRFdmVudDp1LmRlZmF1bHQuZnVuYyxvbkNoYW5nZTp1LmRlZmF1bHQuZnVuYyxjb25maWc6dS5kZWZhdWx0Lm9iamVjdCxjdXJyZW50U3RhdGU6dS5kZWZhdWx0Lm9iamVjdCx0cmFuc2xhdGlvbnM6dS5kZWZhdWx0Lm9iamVjdH0sdC5kZWZhdWx0PUl9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXtcInJkdy1jb2xvcnBpY2tlci13cmFwcGVyXCI6XCJyZHctY29sb3JwaWNrZXItd3JhcHBlclwiLFwicmR3LWNvbG9ycGlja2VyLW1vZGFsXCI6XCJyZHctY29sb3JwaWNrZXItbW9kYWxcIixcInJkdy1jb2xvcnBpY2tlci1tb2RhbC1oZWFkZXJcIjpcInJkdy1jb2xvcnBpY2tlci1tb2RhbC1oZWFkZXJcIixcInJkdy1jb2xvcnBpY2tlci1tb2RhbC1zdHlsZS1sYWJlbFwiOlwicmR3LWNvbG9ycGlja2VyLW1vZGFsLXN0eWxlLWxhYmVsXCIsXCJyZHctY29sb3JwaWNrZXItbW9kYWwtc3R5bGUtbGFiZWwtYWN0aXZlXCI6XCJyZHctY29sb3JwaWNrZXItbW9kYWwtc3R5bGUtbGFiZWwtYWN0aXZlXCIsXCJyZHctY29sb3JwaWNrZXItbW9kYWwtb3B0aW9uc1wiOlwicmR3LWNvbG9ycGlja2VyLW1vZGFsLW9wdGlvbnNcIixcInJkdy1jb2xvcnBpY2tlci1jdWJlXCI6XCJyZHctY29sb3JwaWNrZXItY3ViZVwiLFwicmR3LWNvbG9ycGlja2VyLW9wdGlvblwiOlwicmR3LWNvbG9ycGlja2VyLW9wdGlvblwiLFwicmR3LWNvbG9ycGlja2VyLW9wdGlvbi1hY3RpdmVcIjpcInJkdy1jb2xvcnBpY2tlci1vcHRpb24tYWN0aXZlXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGwoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLGM9bigwKSxzPW8oYyksTT1uKDEpLHU9byhNKSxnPW4oMyksZD1uKDQpLHA9big1NCksTj1vKHApLEQ9big2MCksST1vKEQpLHk9KDAsTi5kZWZhdWx0KSgpLGo9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlLG4sbyxsO2kodGhpcyx0KTtmb3IodmFyIGE9YXJndW1lbnRzLmxlbmd0aCxjPUFycmF5KGEpLHM9MDtzPGE7cysrKWNbc109YXJndW1lbnRzW3NdO3JldHVybiBuPW89cih0aGlzLChlPXQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KGMpKSksby5zdGF0ZT17ZXhwYW5kZWQ6ITEsbGluazp2b2lkIDAsc2VsZWN0aW9uVGV4dDp2b2lkIDB9LG8ub25FeHBhbmRFdmVudD1mdW5jdGlvbigpe28uc2lnbmFsRXhwYW5kZWQ9IW8uc3RhdGUuZXhwYW5kZWR9LG8ub25DaGFuZ2U9ZnVuY3Rpb24oZSx0LG4saSl7aWYoXCJsaW5rXCI9PT1lKXt2YXIgcj15Lm1hdGNoKG4pLGw9ciYmclswXT9yWzBdLnVybDpcIlwiO28uYWRkTGluayh0LGwsaSl9ZWxzZSBvLnJlbW92ZUxpbmsoKX0sby5nZXRDdXJyZW50VmFsdWVzPWZ1bmN0aW9uKCl7dmFyIGU9by5wcm9wcy5lZGl0b3JTdGF0ZSx0PW8uc3RhdGUuY3VycmVudEVudGl0eSxuPWUuZ2V0Q3VycmVudENvbnRlbnQoKSxpPXt9O2lmKHQmJlwiTElOS1wiPT09bi5nZXRFbnRpdHkodCkuZ2V0KFwidHlwZVwiKSl7aS5saW5rPXt9O3ZhciByPXQmJigwLGQuZ2V0RW50aXR5UmFuZ2UpKGUsdCk7aS5saW5rLnRhcmdldD10JiZuLmdldEVudGl0eSh0KS5nZXQoXCJkYXRhXCIpLnVybCxpLmxpbmsudGFyZ2V0T3B0aW9uPXQmJm4uZ2V0RW50aXR5KHQpLmdldChcImRhdGFcIikudGFyZ2V0T3B0aW9uLGkubGluay50aXRsZT1yJiZyLnRleHR9cmV0dXJuIGkuc2VsZWN0aW9uVGV4dD0oMCxkLmdldFNlbGVjdGlvblRleHQpKGUpLGl9LG8uZG9FeHBhbmQ9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDohMH0pfSxvLmV4cGFuZENvbGxhcHNlPWZ1bmN0aW9uKCl7by5zZXRTdGF0ZSh7ZXhwYW5kZWQ6by5zaWduYWxFeHBhbmRlZH0pLG8uc2lnbmFsRXhwYW5kZWQ9ITF9LG8uZG9Db2xsYXBzZT1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiExfSl9LG8ucmVtb3ZlTGluaz1mdW5jdGlvbigpe3ZhciBlPW8ucHJvcHMsdD1lLmVkaXRvclN0YXRlLG49ZS5vbkNoYW5nZSxpPW8uc3RhdGUuY3VycmVudEVudGl0eSxyPXQuZ2V0U2VsZWN0aW9uKCk7aWYoaSl7dmFyIGw9KDAsZC5nZXRFbnRpdHlSYW5nZSkodCxpKTtyPXIubWVyZ2Uoe2FuY2hvck9mZnNldDpsLnN0YXJ0LGZvY3VzT2Zmc2V0OmwuZW5kfSksbihnLlJpY2hVdGlscy50b2dnbGVMaW5rKHQscixudWxsKSl9fSxvLmFkZExpbms9ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPW8ucHJvcHMscj1pLmVkaXRvclN0YXRlLGw9aS5vbkNoYW5nZSxhPW8uc3RhdGUuY3VycmVudEVudGl0eSxjPXIuZ2V0U2VsZWN0aW9uKCk7aWYoYSl7dmFyIHM9KDAsZC5nZXRFbnRpdHlSYW5nZSkocixhKTtjPWMubWVyZ2Uoe2FuY2hvck9mZnNldDpzLnN0YXJ0LGZvY3VzT2Zmc2V0OnMuZW5kfSl9dmFyIE09ci5nZXRDdXJyZW50Q29udGVudCgpLmNyZWF0ZUVudGl0eShcIkxJTktcIixcIk1VVEFCTEVcIix7dXJsOnQsdGFyZ2V0T3B0aW9uOm59KS5nZXRMYXN0Q3JlYXRlZEVudGl0eUtleSgpLHU9Zy5Nb2RpZmllci5yZXBsYWNlVGV4dChyLmdldEN1cnJlbnRDb250ZW50KCksYyxcIlwiK2Usci5nZXRDdXJyZW50SW5saW5lU3R5bGUoKSxNKSxwPWcuRWRpdG9yU3RhdGUucHVzaChyLHUsXCJpbnNlcnQtY2hhcmFjdGVyc1wiKTtjPXAuZ2V0U2VsZWN0aW9uKCkubWVyZ2Uoe2FuY2hvck9mZnNldDpjLmdldChcImFuY2hvck9mZnNldFwiKStlLmxlbmd0aCxmb2N1c09mZnNldDpjLmdldChcImFuY2hvck9mZnNldFwiKStlLmxlbmd0aH0pLHA9Zy5FZGl0b3JTdGF0ZS5hY2NlcHRTZWxlY3Rpb24ocCxjKSx1PWcuTW9kaWZpZXIuaW5zZXJ0VGV4dChwLmdldEN1cnJlbnRDb250ZW50KCksYyxcIiBcIixwLmdldEN1cnJlbnRJbmxpbmVTdHlsZSgpLHZvaWQgMCksbChnLkVkaXRvclN0YXRlLnB1c2gocCx1LFwiaW5zZXJ0LWNoYXJhY3RlcnNcIikpLG8uZG9Db2xsYXBzZSgpfSxsPW4scihvLGwpfXJldHVybiBsKHQsZSksYSh0LFt7a2V5OlwiY29tcG9uZW50V2lsbE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3BzLHQ9ZS5lZGl0b3JTdGF0ZSxuPWUubW9kYWxIYW5kbGVyO3QmJnRoaXMuc2V0U3RhdGUoe2N1cnJlbnRFbnRpdHk6KDAsZC5nZXRTZWxlY3Rpb25FbnRpdHkpKHQpfSksbi5yZWdpc3RlckNhbGxCYWNrKHRoaXMuZXhwYW5kQ29sbGFwc2UpfX0se2tleTpcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD17fTtlLmVkaXRvclN0YXRlJiZ0aGlzLnByb3BzLmVkaXRvclN0YXRlIT09ZS5lZGl0b3JTdGF0ZSYmKHQuY3VycmVudEVudGl0eT0oMCxkLmdldFNlbGVjdGlvbkVudGl0eSkoZS5lZGl0b3JTdGF0ZSkpLHRoaXMuc2V0U3RhdGUodCl9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMubW9kYWxIYW5kbGVyLmRlcmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNvbmZpZyxuPWUudHJhbnNsYXRpb25zLG89dGhpcy5zdGF0ZS5leHBhbmRlZCxpPXRoaXMuZ2V0Q3VycmVudFZhbHVlcygpLHI9aS5saW5rLGw9aS5zZWxlY3Rpb25UZXh0LGE9dC5jb21wb25lbnR8fEkuZGVmYXVsdDtyZXR1cm4gcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoYSx7Y29uZmlnOnQsdHJhbnNsYXRpb25zOm4sZXhwYW5kZWQ6byxvbkV4cGFuZEV2ZW50OnRoaXMub25FeHBhbmRFdmVudCxkb0V4cGFuZDp0aGlzLmRvRXhwYW5kLGRvQ29sbGFwc2U6dGhpcy5kb0NvbGxhcHNlLGN1cnJlbnRTdGF0ZTp7bGluazpyLHNlbGVjdGlvblRleHQ6bH0sb25DaGFuZ2U6dGhpcy5vbkNoYW5nZX0pfX1dKSx0fShjLkNvbXBvbmVudCk7ai5wcm9wVHlwZXM9e2VkaXRvclN0YXRlOnUuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZCxvbkNoYW5nZTp1LmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLG1vZGFsSGFuZGxlcjp1LmRlZmF1bHQub2JqZWN0LGNvbmZpZzp1LmRlZmF1bHQub2JqZWN0LHRyYW5zbGF0aW9uczp1LmRlZmF1bHQub2JqZWN0fSx0LmRlZmF1bHQ9an0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QmJk9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24obil7ZVtuXT10W25dfSl9KSxlfWZ1bmN0aW9uIGkoZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKX1mdW5jdGlvbiByKGUpe3JldHVyblwiW29iamVjdCBTdHJpbmddXCI9PT1pKGUpfWZ1bmN0aW9uIGwoZSl7cmV0dXJuXCJbb2JqZWN0IE9iamVjdF1cIj09PWkoZSl9ZnVuY3Rpb24gYShlKXtyZXR1cm5cIltvYmplY3QgUmVnRXhwXVwiPT09aShlKX1mdW5jdGlvbiBjKGUpe3JldHVyblwiW29iamVjdCBGdW5jdGlvbl1cIj09PWkoZSl9ZnVuY3Rpb24gcyhlKXtyZXR1cm4gZS5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csXCJcXFxcJCZcIil9ZnVuY3Rpb24gTShlKXtyZXR1cm4gT2JqZWN0LmtleXMoZXx8e30pLnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBlfHx5Lmhhc093blByb3BlcnR5KHQpfSwhMSl9ZnVuY3Rpb24gdShlKXtlLl9faW5kZXhfXz0tMSxlLl9fdGV4dF9jYWNoZV9fPVwiXCJ9ZnVuY3Rpb24gZyhlKXtyZXR1cm4gZnVuY3Rpb24odCxuKXt2YXIgbz10LnNsaWNlKG4pO3JldHVybiBlLnRlc3Qobyk/by5tYXRjaChlKVswXS5sZW5ndGg6MH19ZnVuY3Rpb24gZCgpe3JldHVybiBmdW5jdGlvbihlLHQpe3Qubm9ybWFsaXplKGUpfX1mdW5jdGlvbiBwKGUpe2Z1bmN0aW9uIHQoZSl7cmV0dXJuIGUucmVwbGFjZShcIiVUTERTJVwiLGkuc3JjX3RsZHMpfWZ1bmN0aW9uIG8oZSx0KXt0aHJvdyBuZXcgRXJyb3IoJyhMaW5raWZ5SXQpIEludmFsaWQgc2NoZW1hIFwiJytlKydcIjogJyt0KX12YXIgaT1lLnJlPW4oNTUpKGUuX19vcHRzX18pLE09ZS5fX3RsZHNfXy5zbGljZSgpO2Uub25Db21waWxlKCksZS5fX3RsZHNfcmVwbGFjZWRfX3x8TS5wdXNoKGYpLE0ucHVzaChpLnNyY194biksaS5zcmNfdGxkcz1NLmpvaW4oXCJ8XCIpLGkuZW1haWxfZnV6enk9UmVnRXhwKHQoaS50cGxfZW1haWxfZnV6enkpLFwiaVwiKSxpLmxpbmtfZnV6enk9UmVnRXhwKHQoaS50cGxfbGlua19mdXp6eSksXCJpXCIpLGkubGlua19ub19pcF9mdXp6eT1SZWdFeHAodChpLnRwbF9saW5rX25vX2lwX2Z1enp5KSxcImlcIiksaS5ob3N0X2Z1enp5X3Rlc3Q9UmVnRXhwKHQoaS50cGxfaG9zdF9mdXp6eV90ZXN0KSxcImlcIik7dmFyIHA9W107ZS5fX2NvbXBpbGVkX189e30sT2JqZWN0LmtleXMoZS5fX3NjaGVtYXNfXykuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgbj1lLl9fc2NoZW1hc19fW3RdO2lmKG51bGwhPT1uKXt2YXIgaT17dmFsaWRhdGU6bnVsbCxsaW5rOm51bGx9O3JldHVybiBlLl9fY29tcGlsZWRfX1t0XT1pLGwobik/KGEobi52YWxpZGF0ZSk/aS52YWxpZGF0ZT1nKG4udmFsaWRhdGUpOmMobi52YWxpZGF0ZSk/aS52YWxpZGF0ZT1uLnZhbGlkYXRlOm8odCxuKSx2b2lkKGMobi5ub3JtYWxpemUpP2kubm9ybWFsaXplPW4ubm9ybWFsaXplOm4ubm9ybWFsaXplP28odCxuKTppLm5vcm1hbGl6ZT1kKCkpKTpyKG4pP3ZvaWQgcC5wdXNoKHQpOnZvaWQgbyh0LG4pfX0pLHAuZm9yRWFjaChmdW5jdGlvbih0KXtlLl9fY29tcGlsZWRfX1tlLl9fc2NoZW1hc19fW3RdXSYmKGUuX19jb21waWxlZF9fW3RdLnZhbGlkYXRlPWUuX19jb21waWxlZF9fW2UuX19zY2hlbWFzX19bdF1dLnZhbGlkYXRlLGUuX19jb21waWxlZF9fW3RdLm5vcm1hbGl6ZT1lLl9fY29tcGlsZWRfX1tlLl9fc2NoZW1hc19fW3RdXS5ub3JtYWxpemUpfSksZS5fX2NvbXBpbGVkX19bXCJcIl09e3ZhbGlkYXRlOm51bGwsbm9ybWFsaXplOmQoKX07dmFyIE49T2JqZWN0LmtleXMoZS5fX2NvbXBpbGVkX18pLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdC5sZW5ndGg+MCYmZS5fX2NvbXBpbGVkX19bdF19KS5tYXAocykuam9pbihcInxcIik7ZS5yZS5zY2hlbWFfdGVzdD1SZWdFeHAoXCIoXnwoPyFfKSg/Ols+PO+9nF18XCIraS5zcmNfWlBDYytcIikpKFwiK04rXCIpXCIsXCJpXCIpLGUucmUuc2NoZW1hX3NlYXJjaD1SZWdFeHAoXCIoXnwoPyFfKSg/Ols+PO+9nF18XCIraS5zcmNfWlBDYytcIikpKFwiK04rXCIpXCIsXCJpZ1wiKSxlLnJlLnByZXRlc3Q9UmVnRXhwKFwiKFwiK2UucmUuc2NoZW1hX3Rlc3Quc291cmNlK1wiKXwoXCIrZS5yZS5ob3N0X2Z1enp5X3Rlc3Quc291cmNlK1wiKXxAXCIsXCJpXCIpLHUoZSl9ZnVuY3Rpb24gTihlLHQpe3ZhciBuPWUuX19pbmRleF9fLG89ZS5fX2xhc3RfaW5kZXhfXyxpPWUuX190ZXh0X2NhY2hlX18uc2xpY2UobixvKTt0aGlzLnNjaGVtYT1lLl9fc2NoZW1hX18udG9Mb3dlckNhc2UoKSx0aGlzLmluZGV4PW4rdCx0aGlzLmxhc3RJbmRleD1vK3QsdGhpcy5yYXc9aSx0aGlzLnRleHQ9aSx0aGlzLnVybD1pfWZ1bmN0aW9uIEQoZSx0KXt2YXIgbj1uZXcgTihlLHQpO3JldHVybiBlLl9fY29tcGlsZWRfX1tuLnNjaGVtYV0ubm9ybWFsaXplKG4sZSksbn1mdW5jdGlvbiBJKGUsdCl7aWYoISh0aGlzIGluc3RhbmNlb2YgSSkpcmV0dXJuIG5ldyBJKGUsdCk7dHx8TShlKSYmKHQ9ZSxlPXt9KSx0aGlzLl9fb3B0c19fPW8oe30seSx0KSx0aGlzLl9faW5kZXhfXz0tMSx0aGlzLl9fbGFzdF9pbmRleF9fPS0xLHRoaXMuX19zY2hlbWFfXz1cIlwiLHRoaXMuX190ZXh0X2NhY2hlX189XCJcIix0aGlzLl9fc2NoZW1hc19fPW8oe30saixlKSx0aGlzLl9fY29tcGlsZWRfXz17fSx0aGlzLl9fdGxkc19fPXcsdGhpcy5fX3RsZHNfcmVwbGFjZWRfXz0hMSx0aGlzLnJlPXt9LHAodGhpcyl9dmFyIHk9e2Z1enp5TGluazohMCxmdXp6eUVtYWlsOiEwLGZ1enp5SVA6ITF9LGo9e1wiaHR0cDpcIjp7dmFsaWRhdGU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBvPWUuc2xpY2UodCk7cmV0dXJuIG4ucmUuaHR0cHx8KG4ucmUuaHR0cD1uZXcgUmVnRXhwKFwiXlxcXFwvXFxcXC9cIituLnJlLnNyY19hdXRoK24ucmUuc3JjX2hvc3RfcG9ydF9zdHJpY3Qrbi5yZS5zcmNfcGF0aCxcImlcIikpLG4ucmUuaHR0cC50ZXN0KG8pP28ubWF0Y2gobi5yZS5odHRwKVswXS5sZW5ndGg6MH19LFwiaHR0cHM6XCI6XCJodHRwOlwiLFwiZnRwOlwiOlwiaHR0cDpcIixcIi8vXCI6e3ZhbGlkYXRlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgbz1lLnNsaWNlKHQpO3JldHVybiBuLnJlLm5vX2h0dHB8fChuLnJlLm5vX2h0dHA9bmV3IFJlZ0V4cChcIl5cIituLnJlLnNyY19hdXRoK1wiKD86bG9jYWxob3N0fCg/Oig/OlwiK24ucmUuc3JjX2RvbWFpbitcIilcXFxcLikrXCIrbi5yZS5zcmNfZG9tYWluX3Jvb3QrXCIpXCIrbi5yZS5zcmNfcG9ydCtuLnJlLnNyY19ob3N0X3Rlcm1pbmF0b3Irbi5yZS5zcmNfcGF0aCxcImlcIikpLG4ucmUubm9faHR0cC50ZXN0KG8pP3Q+PTMmJlwiOlwiPT09ZVt0LTNdPzA6dD49MyYmXCIvXCI9PT1lW3QtM10/MDpvLm1hdGNoKG4ucmUubm9faHR0cClbMF0ubGVuZ3RoOjB9fSxcIm1haWx0bzpcIjp7dmFsaWRhdGU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBvPWUuc2xpY2UodCk7cmV0dXJuIG4ucmUubWFpbHRvfHwobi5yZS5tYWlsdG89bmV3IFJlZ0V4cChcIl5cIituLnJlLnNyY19lbWFpbF9uYW1lK1wiQFwiK24ucmUuc3JjX2hvc3Rfc3RyaWN0LFwiaVwiKSksbi5yZS5tYWlsdG8udGVzdChvKT9vLm1hdGNoKG4ucmUubWFpbHRvKVswXS5sZW5ndGg6MH19fSxmPVwiYVtjZGVmZ2lsbW5vcXJzdHV3eHpdfGJbYWJkZWZnaGlqbW5vcnN0dnd5el18Y1thY2RmZ2hpa2xtbm9ydXZ3eHl6XXxkW2Vqa21vel18ZVtjZWdyc3R1XXxmW2lqa21vcl18Z1thYmRlZmdoaWxtbnBxcnN0dXd5XXxoW2ttbnJ0dV18aVtkZWxtbm9xcnN0XXxqW2Vtb3BdfGtbZWdoaW1ucHJ3eXpdfGxbYWJjaWtyc3R1dnldfG1bYWNkZWdoa2xtbm9wcXJzdHV2d3h5el18blthY2VmZ2lsb3BydXpdfG9tfHBbYWVmZ2hrbG1ucnN0d3ldfHFhfHJbZW9zdXddfHNbYWJjZGVnaGlqa2xtbm9ydHV2eHl6XXx0W2NkZmdoamtsbW5vcnR2d3pdfHVbYWdrc3l6XXx2W2FjZWdpbnVdfHdbZnNdfHlbZXRdfHpbYW13XVwiLHc9XCJiaXp8Y29tfGVkdXxnb3Z8bmV0fG9yZ3xwcm98d2VifHh4eHxhZXJvfGFzaWF8Y29vcHxpbmZvfG11c2V1bXxuYW1lfHNob3B80YDRhFwiLnNwbGl0KFwifFwiKTtJLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5fX3NjaGVtYXNfX1tlXT10LHAodGhpcyksdGhpc30sSS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9fb3B0c19fPW8odGhpcy5fX29wdHNfXyxlKSx0aGlzfSxJLnByb3RvdHlwZS50ZXN0PWZ1bmN0aW9uKGUpe2lmKHRoaXMuX190ZXh0X2NhY2hlX189ZSx0aGlzLl9faW5kZXhfXz0tMSwhZS5sZW5ndGgpcmV0dXJuITE7dmFyIHQsbixvLGkscixsLGEsYztpZih0aGlzLnJlLnNjaGVtYV90ZXN0LnRlc3QoZSkpZm9yKGE9dGhpcy5yZS5zY2hlbWFfc2VhcmNoLGEubGFzdEluZGV4PTA7bnVsbCE9PSh0PWEuZXhlYyhlKSk7KWlmKGk9dGhpcy50ZXN0U2NoZW1hQXQoZSx0WzJdLGEubGFzdEluZGV4KSl7dGhpcy5fX3NjaGVtYV9fPXRbMl0sdGhpcy5fX2luZGV4X189dC5pbmRleCt0WzFdLmxlbmd0aCx0aGlzLl9fbGFzdF9pbmRleF9fPXQuaW5kZXgrdFswXS5sZW5ndGgraTticmVha31yZXR1cm4gdGhpcy5fX29wdHNfXy5mdXp6eUxpbmsmJnRoaXMuX19jb21waWxlZF9fW1wiaHR0cDpcIl0mJihjPWUuc2VhcmNoKHRoaXMucmUuaG9zdF9mdXp6eV90ZXN0KSk+PTAmJih0aGlzLl9faW5kZXhfXzwwfHxjPHRoaXMuX19pbmRleF9fKSYmbnVsbCE9PShuPWUubWF0Y2godGhpcy5fX29wdHNfXy5mdXp6eUlQP3RoaXMucmUubGlua19mdXp6eTp0aGlzLnJlLmxpbmtfbm9faXBfZnV6enkpKSYmKHI9bi5pbmRleCtuWzFdLmxlbmd0aCwodGhpcy5fX2luZGV4X188MHx8cjx0aGlzLl9faW5kZXhfXykmJih0aGlzLl9fc2NoZW1hX189XCJcIix0aGlzLl9faW5kZXhfXz1yLHRoaXMuX19sYXN0X2luZGV4X189bi5pbmRleCtuWzBdLmxlbmd0aCkpLHRoaXMuX19vcHRzX18uZnV6enlFbWFpbCYmdGhpcy5fX2NvbXBpbGVkX19bXCJtYWlsdG86XCJdJiZlLmluZGV4T2YoXCJAXCIpPj0wJiZudWxsIT09KG89ZS5tYXRjaCh0aGlzLnJlLmVtYWlsX2Z1enp5KSkmJihyPW8uaW5kZXgrb1sxXS5sZW5ndGgsbD1vLmluZGV4K29bMF0ubGVuZ3RoLCh0aGlzLl9faW5kZXhfXzwwfHxyPHRoaXMuX19pbmRleF9ffHxyPT09dGhpcy5fX2luZGV4X18mJmw+dGhpcy5fX2xhc3RfaW5kZXhfXykmJih0aGlzLl9fc2NoZW1hX189XCJtYWlsdG86XCIsdGhpcy5fX2luZGV4X189cix0aGlzLl9fbGFzdF9pbmRleF9fPWwpKSx0aGlzLl9faW5kZXhfXz49MH0sSS5wcm90b3R5cGUucHJldGVzdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZS5wcmV0ZXN0LnRlc3QoZSl9LEkucHJvdG90eXBlLnRlc3RTY2hlbWFBdD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMuX19jb21waWxlZF9fW3QudG9Mb3dlckNhc2UoKV0/dGhpcy5fX2NvbXBpbGVkX19bdC50b0xvd2VyQ2FzZSgpXS52YWxpZGF0ZShlLG4sdGhpcyk6MH0sSS5wcm90b3R5cGUubWF0Y2g9ZnVuY3Rpb24oZSl7dmFyIHQ9MCxuPVtdO3RoaXMuX19pbmRleF9fPj0wJiZ0aGlzLl9fdGV4dF9jYWNoZV9fPT09ZSYmKG4ucHVzaChEKHRoaXMsdCkpLHQ9dGhpcy5fX2xhc3RfaW5kZXhfXyk7Zm9yKHZhciBvPXQ/ZS5zbGljZSh0KTplO3RoaXMudGVzdChvKTspbi5wdXNoKEQodGhpcyx0KSksbz1vLnNsaWNlKHRoaXMuX19sYXN0X2luZGV4X18pLHQrPXRoaXMuX19sYXN0X2luZGV4X187cmV0dXJuIG4ubGVuZ3RoP246bnVsbH0sSS5wcm90b3R5cGUudGxkcz1mdW5jdGlvbihlLHQpe3JldHVybiBlPUFycmF5LmlzQXJyYXkoZSk/ZTpbZV0sdD8odGhpcy5fX3RsZHNfXz10aGlzLl9fdGxkc19fLmNvbmNhdChlKS5zb3J0KCkuZmlsdGVyKGZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZSE9PW5bdC0xXX0pLnJldmVyc2UoKSxwKHRoaXMpLHRoaXMpOih0aGlzLl9fdGxkc19fPWUuc2xpY2UoKSx0aGlzLl9fdGxkc19yZXBsYWNlZF9fPSEwLHAodGhpcyksdGhpcyl9LEkucHJvdG90eXBlLm5vcm1hbGl6ZT1mdW5jdGlvbihlKXtlLnNjaGVtYXx8KGUudXJsPVwiaHR0cDovL1wiK2UudXJsKSxcIm1haWx0bzpcIiE9PWUuc2NoZW1hfHwvXm1haWx0bzovaS50ZXN0KGUudXJsKXx8KGUudXJsPVwibWFpbHRvOlwiK2UudXJsKX0sSS5wcm90b3R5cGUub25Db21waWxlPWZ1bmN0aW9uKCl7fSxlLmV4cG9ydHM9SX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD17fTt0LnNyY19Bbnk9big1Nikuc291cmNlLHQuc3JjX0NjPW4oNTcpLnNvdXJjZSx0LnNyY19aPW4oNTgpLnNvdXJjZSx0LnNyY19QPW4oNTkpLnNvdXJjZSx0LnNyY19aUENjPVt0LnNyY19aLHQuc3JjX1AsdC5zcmNfQ2NdLmpvaW4oXCJ8XCIpLHQuc3JjX1pDYz1bdC5zcmNfWix0LnNyY19DY10uam9pbihcInxcIik7cmV0dXJuIHQuc3JjX3BzZXVkb19sZXR0ZXI9XCIoPzooPyFbPjzvvZxdfFwiK3Quc3JjX1pQQ2MrXCIpXCIrdC5zcmNfQW55K1wiKVwiLHQuc3JjX2lwND1cIig/OigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFxcXC4pezN9KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcIix0LnNyY19hdXRoPVwiKD86KD86KD8hXCIrdC5zcmNfWkNjK1wifFtAL1xcXFxbXFxcXF0oKV0pLikrQCk/XCIsdC5zcmNfcG9ydD1cIig/OjooPzo2KD86WzAtNF1cXFxcZHszfXw1KD86WzAtNF1cXFxcZHsyfXw1KD86WzAtMl1cXFxcZHwzWzAtNV0pKSl8WzEtNV0/XFxcXGR7MSw0fSkpP1wiLHQuc3JjX2hvc3RfdGVybWluYXRvcj1cIig/PSR8Wz48772cXXxcIit0LnNyY19aUENjK1wiKSg/IS18X3w6XFxcXGR8XFxcXC4tfFxcXFwuKD8hJHxcIit0LnNyY19aUENjK1wiKSlcIix0LnNyY19wYXRoPVwiKD86Wy8/I10oPzooPyFcIit0LnNyY19aQ2MrXCJ8Wz48772cXXxbKClbXFxcXF17fS4sXFxcIic/IVxcXFwtXSkufFxcXFxbKD86KD8hXCIrdC5zcmNfWkNjK1wifFxcXFxdKS4pKlxcXFxdfFxcXFwoKD86KD8hXCIrdC5zcmNfWkNjK1wifFspXSkuKSpcXFxcKXxcXFxceyg/Oig/IVwiK3Quc3JjX1pDYysnfFt9XSkuKSpcXFxcfXxcXFxcXCIoPzooPyEnK3Quc3JjX1pDYysnfFtcIl0pLikrXFxcXFwifFxcXFxcXCcoPzooPyEnK3Quc3JjX1pDYytcInxbJ10pLikrXFxcXCd8XFxcXCcoPz1cIit0LnNyY19wc2V1ZG9fbGV0dGVyK1wifFstXSkufFxcXFwuezIsM31bYS16QS1aMC05JS9dfFxcXFwuKD8hXCIrdC5zcmNfWkNjK1wifFsuXSkufFwiKyhlJiZlW1wiLS0tXCJdP1wiXFxcXC0oPyEtLSg/OlteLV18JCkpKD86LSopfFwiOlwiXFxcXC0rfFwiKStcIlxcXFwsKD8hXCIrdC5zcmNfWkNjK1wiKS58XFxcXCEoPyFcIit0LnNyY19aQ2MrXCJ8WyFdKS58XFxcXD8oPyFcIit0LnNyY19aQ2MrXCJ8Wz9dKS4pK3xcXFxcLyk/XCIsdC5zcmNfZW1haWxfbmFtZT0nW1xcXFwtOzomPVxcXFwrXFxcXCQsXFxcXFwiXFxcXC5hLXpBLVowLTlfXSsnLHQuc3JjX3huPVwieG4tLVthLXowLTlcXFxcLV17MSw1OX1cIix0LnNyY19kb21haW5fcm9vdD1cIig/OlwiK3Quc3JjX3huK1wifFwiK3Quc3JjX3BzZXVkb19sZXR0ZXIrXCJ7MSw2M30pXCIsdC5zcmNfZG9tYWluPVwiKD86XCIrdC5zcmNfeG4rXCJ8KD86XCIrdC5zcmNfcHNldWRvX2xldHRlcitcIil8KD86XCIrdC5zcmNfcHNldWRvX2xldHRlcitcIig/Oi0oPyEtKXxcIit0LnNyY19wc2V1ZG9fbGV0dGVyK1wiKXswLDYxfVwiK3Quc3JjX3BzZXVkb19sZXR0ZXIrXCIpKVwiLHQuc3JjX2hvc3Q9XCIoPzooPzooPzooPzpcIit0LnNyY19kb21haW4rXCIpXFxcXC4pKlwiK3Quc3JjX2RvbWFpbitcIikpXCIsdC50cGxfaG9zdF9mdXp6eT1cIig/OlwiK3Quc3JjX2lwNCtcInwoPzooPzooPzpcIit0LnNyY19kb21haW4rXCIpXFxcXC4pKyg/OiVUTERTJSkpKVwiLHQudHBsX2hvc3Rfbm9faXBfZnV6enk9XCIoPzooPzooPzpcIit0LnNyY19kb21haW4rXCIpXFxcXC4pKyg/OiVUTERTJSkpXCIsdC5zcmNfaG9zdF9zdHJpY3Q9dC5zcmNfaG9zdCt0LnNyY19ob3N0X3Rlcm1pbmF0b3IsdC50cGxfaG9zdF9mdXp6eV9zdHJpY3Q9dC50cGxfaG9zdF9mdXp6eSt0LnNyY19ob3N0X3Rlcm1pbmF0b3IsdC5zcmNfaG9zdF9wb3J0X3N0cmljdD10LnNyY19ob3N0K3Quc3JjX3BvcnQrdC5zcmNfaG9zdF90ZXJtaW5hdG9yLHQudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3Q9dC50cGxfaG9zdF9mdXp6eSt0LnNyY19wb3J0K3Quc3JjX2hvc3RfdGVybWluYXRvcix0LnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0PXQudHBsX2hvc3Rfbm9faXBfZnV6enkrdC5zcmNfcG9ydCt0LnNyY19ob3N0X3Rlcm1pbmF0b3IsdC50cGxfaG9zdF9mdXp6eV90ZXN0PVwibG9jYWxob3N0fHd3d1xcXFwufFxcXFwuXFxcXGR7MSwzfVxcXFwufCg/OlxcXFwuKD86JVRMRFMlKSg/OlwiK3Quc3JjX1pQQ2MrXCJ8PnwkKSlcIix0LnRwbF9lbWFpbF9mdXp6eT1cIihefFs+PO+9nF18XFxcXCh8XCIrdC5zcmNfWkNjK1wiKShcIit0LnNyY19lbWFpbF9uYW1lK1wiQFwiK3QudHBsX2hvc3RfZnV6enlfc3RyaWN0K1wiKVwiLHQudHBsX2xpbmtfZnV6enk9XCIoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8772cXXxcIit0LnNyY19aUENjK1wiKSkoKD8hWyQrPD0+XmB8772cXSlcIit0LnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0K3Quc3JjX3BhdGgrXCIpXCIsdC50cGxfbGlua19ub19pcF9mdXp6eT1cIihefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHzvvZxdfFwiK3Quc3JjX1pQQ2MrXCIpKSgoPyFbJCs8PT5eYHzvvZxdKVwiK3QudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QrdC5zcmNfcGF0aCtcIilcIix0fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz0vW1xcMC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdL30sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz0vW1xcMC1cXHgxRlxceDdGLVxceDlGXS99LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9L1sgXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXS99LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9L1shLSMlLVxcKiwtXFwvOjtcXD9AXFxbLVxcXV9cXHtcXH1cXHhBMVxceEE3XFx4QUJcXHhCNlxceEI3XFx4QkJcXHhCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMwOC1cXHUyMzBCXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTQ0XFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV18XFx1RDgwMFtcXHVERDAwLVxcdUREMDJcXHVERjlGXFx1REZEMF18XFx1RDgwMVxcdURENkZ8XFx1RDgwMltcXHVEQzU3XFx1REQxRlxcdUREM0ZcXHVERTUwLVxcdURFNThcXHVERTdGXFx1REVGMC1cXHVERUY2XFx1REYzOS1cXHVERjNGXFx1REY5OS1cXHVERjlDXXxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzlcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDVbXFx1REM0Qi1cXHVEQzRGXFx1REM1QlxcdURDNURcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REU2MC1cXHVERTZDXFx1REYzQy1cXHVERjNFXXxcXHVEODA3W1xcdURDNDEtXFx1REM0NVxcdURDNzBcXHVEQzcxXXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgxQVtcXHVERTZFXFx1REU2RlxcdURFRjVcXHVERjM3LVxcdURGM0JcXHVERjQ0XXxcXHVEODJGXFx1REM5RnxcXHVEODM2W1xcdURFODctXFx1REU4Ql18XFx1RDgzQVtcXHVERDVFXFx1REQ1Rl0vfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9ZnVuY3Rpb24gcihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gbChlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGEoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLHM9bigwKSxNPW8ocyksdT1uKDEpLGc9byh1KSxkPW4oMikscD1vKGQpLE49big2KSxEPW4oOCksST1uKDUpLHk9byhJKSxqPW4oNyk7big2MSk7dmFyIGY9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlLG4sbyxhO3IodGhpcyx0KTtmb3IodmFyIGM9YXJndW1lbnRzLmxlbmd0aCxzPUFycmF5KGMpLE09MDtNPGM7TSsrKXNbTV09YXJndW1lbnRzW01dO3JldHVybiBuPW89bCh0aGlzLChlPXQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KHMpKSksby5zdGF0ZT17c2hvd01vZGFsOiExLGxpbmtUYXJnZXQ6XCJcIixsaW5rVGl0bGU6XCJcIixsaW5rVGFyZ2V0T3B0aW9uOm8ucHJvcHMuY29uZmlnLmRlZmF1bHRUYXJnZXRPcHRpb259LG8ucmVtb3ZlTGluaz1mdW5jdGlvbigpeygwLG8ucHJvcHMub25DaGFuZ2UpKFwidW5saW5rXCIpfSxvLmFkZExpbms9ZnVuY3Rpb24oKXt2YXIgZT1vLnByb3BzLm9uQ2hhbmdlLHQ9by5zdGF0ZTtlKFwibGlua1wiLHQubGlua1RpdGxlLHQubGlua1RhcmdldCx0LmxpbmtUYXJnZXRPcHRpb24pfSxvLnVwZGF0ZVZhbHVlPWZ1bmN0aW9uKGUpe28uc2V0U3RhdGUoaSh7fSxcIlwiK2UudGFyZ2V0Lm5hbWUsZS50YXJnZXQudmFsdWUpKX0sby51cGRhdGVUYXJnZXRPcHRpb249ZnVuY3Rpb24oZSl7by5zZXRTdGF0ZSh7bGlua1RhcmdldE9wdGlvbjplLnRhcmdldC5jaGVja2VkP1wiX2JsYW5rXCI6XCJfc2VsZlwifSl9LG8uaGlkZU1vZGFsPWZ1bmN0aW9uKCl7by5zZXRTdGF0ZSh7c2hvd01vZGFsOiExfSl9LG8uc2lnbmFsRXhwYW5kU2hvd01vZGFsPWZ1bmN0aW9uKCl7dmFyIGU9by5wcm9wcyx0PWUub25FeHBhbmRFdmVudCxuPWUuY3VycmVudFN0YXRlLGk9bi5saW5rLHI9bi5zZWxlY3Rpb25UZXh0LGw9by5zdGF0ZS5saW5rVGFyZ2V0T3B0aW9uO3QoKSxvLnNldFN0YXRlKHtzaG93TW9kYWw6ITAsbGlua1RhcmdldDppJiZpLnRhcmdldHx8XCJcIixsaW5rVGFyZ2V0T3B0aW9uOmkmJmkudGFyZ2V0T3B0aW9ufHxsLGxpbmtUaXRsZTppJiZpLnRpdGxlfHxyfSl9LG8uZm9yY2VFeHBhbmRBbmRTaG93TW9kYWw9ZnVuY3Rpb24oKXt2YXIgZT1vLnByb3BzLHQ9ZS5kb0V4cGFuZCxuPWUuY3VycmVudFN0YXRlLGk9bi5saW5rLHI9bi5zZWxlY3Rpb25UZXh0LGw9by5zdGF0ZS5saW5rVGFyZ2V0T3B0aW9uO3QoKSxvLnNldFN0YXRlKHtzaG93TW9kYWw6ITAsbGlua1RhcmdldDppJiZpLnRhcmdldCxsaW5rVGFyZ2V0T3B0aW9uOmkmJmkudGFyZ2V0T3B0aW9ufHxsLGxpbmtUaXRsZTppJiZpLnRpdGxlfHxyfSl9LGE9bixsKG8sYSl9cmV0dXJuIGEodCxlKSxjKHQsW3trZXk6XCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wcm9wcy5leHBhbmRlZCYmIWUuZXhwYW5kZWQmJnRoaXMuc2V0U3RhdGUoe3Nob3dNb2RhbDohMSxsaW5rVGFyZ2V0OlwiXCIsbGlua1RpdGxlOlwiXCIsbGlua1RhcmdldE9wdGlvbjp0aGlzLnByb3BzLmNvbmZpZy5kZWZhdWx0VGFyZ2V0T3B0aW9ufSl9fSx7a2V5OlwicmVuZGVyQWRkTGlua01vZGFsXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3BzLHQ9ZS5jb25maWcucG9wdXBDbGFzc05hbWUsbj1lLmRvQ29sbGFwc2Usbz1lLnRyYW5zbGF0aW9ucyxpPXRoaXMuc3RhdGUscj1pLmxpbmtUaXRsZSxsPWkubGlua1RhcmdldCxhPWkubGlua1RhcmdldE9wdGlvbjtyZXR1cm4gTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOigwLHAuZGVmYXVsdCkoXCJyZHctbGluay1tb2RhbFwiLHQpLG9uQ2xpY2s6Ti5zdG9wUHJvcGFnYXRpb259LE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIix7Y2xhc3NOYW1lOlwicmR3LWxpbmstbW9kYWwtbGFiZWxcIixodG1sRm9yOlwibGlua1RpdGxlXCJ9LG9bXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RpdGxlXCJdKSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImlucHV0XCIse2lkOlwibGlua1RpdGxlXCIsY2xhc3NOYW1lOlwicmR3LWxpbmstbW9kYWwtaW5wdXRcIixvbkNoYW5nZTp0aGlzLnVwZGF0ZVZhbHVlLG9uQmx1cjp0aGlzLnVwZGF0ZVZhbHVlLG5hbWU6XCJsaW5rVGl0bGVcIix2YWx1ZTpyfSksTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiLHtjbGFzc05hbWU6XCJyZHctbGluay1tb2RhbC1sYWJlbFwiLGh0bWxGb3I6XCJsaW5rVGFyZ2V0XCJ9LG9bXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RhcmdldFwiXSksTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLHtpZDpcImxpbmtUYXJnZXRcIixjbGFzc05hbWU6XCJyZHctbGluay1tb2RhbC1pbnB1dFwiLG9uQ2hhbmdlOnRoaXMudXBkYXRlVmFsdWUsb25CbHVyOnRoaXMudXBkYXRlVmFsdWUsbmFtZTpcImxpbmtUYXJnZXRcIix2YWx1ZTpsfSksTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiLHtjbGFzc05hbWU6XCJyZHctbGluay1tb2RhbC10YXJnZXQtb3B0aW9uXCIsaHRtbEZvcjpcIm9wZW5MaW5rSW5OZXdXaW5kb3dcIn0sTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLHtpZDpcIm9wZW5MaW5rSW5OZXdXaW5kb3dcIix0eXBlOlwiY2hlY2tib3hcIixkZWZhdWx0Q2hlY2tlZDpcIl9ibGFua1wiPT09YSx2YWx1ZTpcIl9ibGFua1wiLG9uQ2hhbmdlOnRoaXMudXBkYXRlVGFyZ2V0T3B0aW9ufSksTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCxvW1wiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtUYXJnZXRPcHRpb25cIl0pKSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIix7Y2xhc3NOYW1lOlwicmR3LWxpbmstbW9kYWwtYnV0dG9uc2VjdGlvblwifSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLHtjbGFzc05hbWU6XCJyZHctbGluay1tb2RhbC1idG5cIixvbkNsaWNrOnRoaXMuYWRkTGluayxkaXNhYmxlZDohbHx8IXJ9LG9bXCJnZW5lcmljLmFkZFwiXSksTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIix7Y2xhc3NOYW1lOlwicmR3LWxpbmstbW9kYWwtYnRuXCIsb25DbGljazpufSxvW1wiZ2VuZXJpYy5jYW5jZWxcIl0pKSl9fSx7a2V5OlwicmVuZGVySW5GbGF0TGlzdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcyx0PWUuY29uZmlnLG49dC5vcHRpb25zLG89dC5saW5rLGk9dC51bmxpbmsscj10LmNsYXNzTmFtZSxsPWUuY3VycmVudFN0YXRlLGE9ZS5leHBhbmRlZCxjPWUudHJhbnNsYXRpb25zLHM9dGhpcy5zdGF0ZS5zaG93TW9kYWw7cmV0dXJuIE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTooMCxwLmRlZmF1bHQpKFwicmR3LWxpbmstd3JhcHBlclwiLHIpLFwiYXJpYS1sYWJlbFwiOlwicmR3LWxpbmstY29udHJvbFwifSxuLmluZGV4T2YoXCJsaW5rXCIpPj0wJiZNLmRlZmF1bHQuY3JlYXRlRWxlbWVudCh5LmRlZmF1bHQse3ZhbHVlOlwidW5vcmRlcmVkLWxpc3QtaXRlbVwiLGNsYXNzTmFtZTooMCxwLmRlZmF1bHQpKG8uY2xhc3NOYW1lKSxvbkNsaWNrOnRoaXMuc2lnbmFsRXhwYW5kU2hvd01vZGFsLFwiYXJpYS1oYXNwb3B1cFwiOlwidHJ1ZVwiLFwiYXJpYS1leHBhbmRlZFwiOnMsdGl0bGU6by50aXRsZXx8Y1tcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rXCJdfSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6by5pY29uLGFsdDpcIlwifSkpLG4uaW5kZXhPZihcInVubGlua1wiKT49MCYmTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoeS5kZWZhdWx0LHtkaXNhYmxlZDohbC5saW5rLHZhbHVlOlwib3JkZXJlZC1saXN0LWl0ZW1cIixjbGFzc05hbWU6KDAscC5kZWZhdWx0KShpLmNsYXNzTmFtZSksb25DbGljazp0aGlzLnJlbW92ZUxpbmssdGl0bGU6aS50aXRsZXx8Y1tcImNvbXBvbmVudHMuY29udHJvbHMubGluay51bmxpbmtcIl19LE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIse3NyYzppLmljb24sYWx0OlwiXCJ9KSksYSYmcz90aGlzLnJlbmRlckFkZExpbmtNb2RhbCgpOnZvaWQgMCl9fSx7a2V5OlwicmVuZGVySW5Ecm9wRG93blwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcyx0PWUuZXhwYW5kZWQsbj1lLm9uRXhwYW5kRXZlbnQsbz1lLmRvQ29sbGFwc2UsaT1lLmRvRXhwYW5kLHI9ZS5vbkNoYW5nZSxsPWUuY29uZmlnLGE9ZS5jdXJyZW50U3RhdGUsYz1lLnRyYW5zbGF0aW9ucyxzPWwub3B0aW9ucyx1PWwubGluayxnPWwudW5saW5rLGQ9bC5jbGFzc05hbWUsTj1sLmRyb3Bkb3duQ2xhc3NOYW1lLEk9bC50aXRsZSx5PXRoaXMuc3RhdGUuc2hvd01vZGFsO3JldHVybiBNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJyZHctbGluay13cmFwcGVyXCIsXCJhcmlhLWhhc3BvcHVwXCI6XCJ0cnVlXCIsXCJhcmlhLWxhYmVsXCI6XCJyZHctbGluay1jb250cm9sXCIsXCJhcmlhLWV4cGFuZGVkXCI6dCx0aXRsZTpJfSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChqLkRyb3Bkb3duLHtjbGFzc05hbWU6KDAscC5kZWZhdWx0KShcInJkdy1saW5rLWRyb3Bkb3duXCIsZCksb3B0aW9uV3JhcHBlckNsYXNzTmFtZTooMCxwLmRlZmF1bHQpKE4pLG9uQ2hhbmdlOnIsZXhwYW5kZWQ6dCYmIXksZG9FeHBhbmQ6aSxkb0NvbGxhcHNlOm8sb25FeHBhbmRFdmVudDpufSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6KDAsRC5nZXRGaXJzdEljb24pKGwpLGFsdDpcIlwifSkscy5pbmRleE9mKFwibGlua1wiKT49MCYmTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoai5Ecm9wZG93bk9wdGlvbix7b25DbGljazp0aGlzLmZvcmNlRXhwYW5kQW5kU2hvd01vZGFsLGNsYXNzTmFtZTooMCxwLmRlZmF1bHQpKFwicmR3LWxpbmstZHJvcGRvd25vcHRpb25cIix1LmNsYXNzTmFtZSksdGl0bGU6dS50aXRsZXx8Y1tcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rXCJdfSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6dS5pY29uLGFsdDpcIlwifSkpLHMuaW5kZXhPZihcInVubGlua1wiKT49MCYmTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoai5Ecm9wZG93bk9wdGlvbix7b25DbGljazp0aGlzLnJlbW92ZUxpbmssZGlzYWJsZWQ6IWEubGluayxjbGFzc05hbWU6KDAscC5kZWZhdWx0KShcInJkdy1saW5rLWRyb3Bkb3dub3B0aW9uXCIsZy5jbGFzc05hbWUpLHRpdGxlOmcudGl0bGV8fGNbXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsudW5saW5rXCJdfSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6Zy5pY29uLGFsdDpcIlwifSkpKSx0JiZ5P3RoaXMucmVuZGVyQWRkTGlua01vZGFsKCk6dm9pZCAwKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BzLmNvbmZpZy5pbkRyb3Bkb3duP3RoaXMucmVuZGVySW5Ecm9wRG93bigpOnRoaXMucmVuZGVySW5GbGF0TGlzdCgpfX1dKSx0fShzLkNvbXBvbmVudCk7Zi5wcm9wVHlwZXM9e2V4cGFuZGVkOmcuZGVmYXVsdC5ib29sLGRvRXhwYW5kOmcuZGVmYXVsdC5mdW5jLGRvQ29sbGFwc2U6Zy5kZWZhdWx0LmZ1bmMsb25FeHBhbmRFdmVudDpnLmRlZmF1bHQuZnVuYyxjb25maWc6Zy5kZWZhdWx0Lm9iamVjdCxvbkNoYW5nZTpnLmRlZmF1bHQuZnVuYyxjdXJyZW50U3RhdGU6Zy5kZWZhdWx0Lm9iamVjdCx0cmFuc2xhdGlvbnM6Zy5kZWZhdWx0Lm9iamVjdH0sdC5kZWZhdWx0PWZ9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXtcInJkdy1saW5rLXdyYXBwZXJcIjpcInJkdy1saW5rLXdyYXBwZXJcIixcInJkdy1saW5rLWRyb3Bkb3duXCI6XCJyZHctbGluay1kcm9wZG93blwiLFwicmR3LWxpbmstZHJvcGRvd25PcHRpb25cIjpcInJkdy1saW5rLWRyb3Bkb3duT3B0aW9uXCIsXCJyZHctbGluay1kcm9wZG93blBsYWNlaG9sZGVyXCI6XCJyZHctbGluay1kcm9wZG93blBsYWNlaG9sZGVyXCIsXCJyZHctbGluay1tb2RhbFwiOlwicmR3LWxpbmstbW9kYWxcIixcInJkdy1saW5rLW1vZGFsLWxhYmVsXCI6XCJyZHctbGluay1tb2RhbC1sYWJlbFwiLFwicmR3LWxpbmstbW9kYWwtaW5wdXRcIjpcInJkdy1saW5rLW1vZGFsLWlucHV0XCIsXCJyZHctbGluay1tb2RhbC1idXR0b25zZWN0aW9uXCI6XCJyZHctbGluay1tb2RhbC1idXR0b25zZWN0aW9uXCIsXCJyZHctbGluay1tb2RhbC10YXJnZXQtb3B0aW9uXCI6XCJyZHctbGluay1tb2RhbC10YXJnZXQtb3B0aW9uXCIsXCJyZHctbGluay1tb2RhbC1idG5cIjpcInJkdy1saW5rLW1vZGFsLWJ0blwiLFwicmR3LWxpbmstZHJvcGRvd25vcHRpb25cIjpcInJkdy1saW5rLWRyb3Bkb3dub3B0aW9uXCIsXCJyZHctaGlzdG9yeS1kcm9wZG93blwiOlwicmR3LWhpc3RvcnktZHJvcGRvd25cIn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiByKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gbChlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCksYz1uKDApLHM9byhjKSxNPW4oMSksdT1vKE0pLGc9bigzKSxkPW4oNjMpLHA9byhkKSxOPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZSxuLG8sbDtpKHRoaXMsdCk7Zm9yKHZhciBhPWFyZ3VtZW50cy5sZW5ndGgsYz1BcnJheShhKSxzPTA7czxhO3MrKyljW3NdPWFyZ3VtZW50c1tzXTtyZXR1cm4gbj1vPXIodGhpcywoZT10Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsLmFwcGx5KGUsW3RoaXNdLmNvbmNhdChjKSkpLG8uc3RhdGU9e2V4cGFuZGVkOiExfSxvLm9uRXhwYW5kRXZlbnQ9ZnVuY3Rpb24oKXtvLnNpZ25hbEV4cGFuZGVkPSFvLnN0YXRlLmV4cGFuZGVkfSxvLmV4cGFuZENvbGxhcHNlPWZ1bmN0aW9uKCl7by5zZXRTdGF0ZSh7ZXhwYW5kZWQ6by5zaWduYWxFeHBhbmRlZH0pLG8uc2lnbmFsRXhwYW5kZWQ9ITF9LG8uZG9FeHBhbmQ9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDohMH0pfSxvLmRvQ29sbGFwc2U9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDohMX0pfSxvLmFkZEVtYmVkZGVkTGluaz1mdW5jdGlvbihlLHQsbil7dmFyIGk9by5wcm9wcyxyPWkuZWRpdG9yU3RhdGUsbD1pLm9uQ2hhbmdlLGE9ci5nZXRDdXJyZW50Q29udGVudCgpLmNyZWF0ZUVudGl0eShcIkVNQkVEREVEX0xJTktcIixcIk1VVEFCTEVcIix7c3JjOmUsaGVpZ2h0OnQsd2lkdGg6bn0pLmdldExhc3RDcmVhdGVkRW50aXR5S2V5KCk7bChnLkF0b21pY0Jsb2NrVXRpbHMuaW5zZXJ0QXRvbWljQmxvY2socixhLFwiIFwiKSksby5kb0NvbGxhcHNlKCl9LGw9bixyKG8sbCl9cmV0dXJuIGwodCxlKSxhKHQsW3trZXk6XCJjb21wb25lbnRXaWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMubW9kYWxIYW5kbGVyLnJlZ2lzdGVyQ2FsbEJhY2sodGhpcy5leHBhbmRDb2xsYXBzZSl9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMubW9kYWxIYW5kbGVyLmRlcmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNvbmZpZyxuPWUudHJhbnNsYXRpb25zLG89dGhpcy5zdGF0ZS5leHBhbmRlZCxpPXQuY29tcG9uZW50fHxwLmRlZmF1bHQ7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGkse2NvbmZpZzp0LHRyYW5zbGF0aW9uczpuLG9uQ2hhbmdlOnRoaXMuYWRkRW1iZWRkZWRMaW5rLGV4cGFuZGVkOm8sb25FeHBhbmRFdmVudDp0aGlzLm9uRXhwYW5kRXZlbnQsZG9FeHBhbmQ6dGhpcy5kb0V4cGFuZCxkb0NvbGxhcHNlOnRoaXMuZG9Db2xsYXBzZX0pfX1dKSx0fShjLkNvbXBvbmVudCk7Ti5wcm9wVHlwZXM9e2VkaXRvclN0YXRlOnUuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZCxvbkNoYW5nZTp1LmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLG1vZGFsSGFuZGxlcjp1LmRlZmF1bHQub2JqZWN0LGNvbmZpZzp1LmRlZmF1bHQub2JqZWN0LHRyYW5zbGF0aW9uczp1LmRlZmF1bHQub2JqZWN0fSx0LmRlZmF1bHQ9Tn0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfWZ1bmN0aW9uIHIoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGwoZSx0KXtpZighZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2U6dH1mdW5jdGlvbiBhKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHQpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsdCk6ZS5fX3Byb3RvX189dCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBvPXRbbl07by5lbnVtZXJhYmxlPW8uZW51bWVyYWJsZXx8ITEsby5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbyYmKG8ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG8ua2V5LG8pfX1yZXR1cm4gZnVuY3Rpb24odCxuLG8pe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLG8mJmUodCxvKSx0fX0oKSxzPW4oMCksTT1vKHMpLHU9bigxKSxnPW8odSksZD1uKDIpLHA9byhkKSxOPW4oNiksRD1uKDUpLEk9byhEKTtuKDY0KTt2YXIgeT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7dmFyIGUsbixvLGE7cih0aGlzLHQpO2Zvcih2YXIgYz1hcmd1bWVudHMubGVuZ3RoLHM9QXJyYXkoYyksTT0wO008YztNKyspc1tNXT1hcmd1bWVudHNbTV07cmV0dXJuIG49bz1sKHRoaXMsKGU9dC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbC5hcHBseShlLFt0aGlzXS5jb25jYXQocykpKSxvLnN0YXRlPXtlbWJlZGRlZExpbms6XCJcIixoZWlnaHQ6by5wcm9wcy5jb25maWcuZGVmYXVsdFNpemUuaGVpZ2h0LHdpZHRoOm8ucHJvcHMuY29uZmlnLmRlZmF1bHRTaXplLndpZHRofSxvLm9uQ2hhbmdlPWZ1bmN0aW9uKCl7dmFyIGU9by5wcm9wcy5vbkNoYW5nZSx0PW8uc3RhdGU7ZSh0LmVtYmVkZGVkTGluayx0LmhlaWdodCx0LndpZHRoKX0sby51cGRhdGVWYWx1ZT1mdW5jdGlvbihlKXtvLnNldFN0YXRlKGkoe30sXCJcIitlLnRhcmdldC5uYW1lLGUudGFyZ2V0LnZhbHVlKSl9LGE9bixsKG8sYSl9cmV0dXJuIGEodCxlKSxjKHQsW3trZXk6XCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYodGhpcy5wcm9wcy5leHBhbmRlZCYmIWUuZXhwYW5kZWQpe3ZhciB0PXRoaXMucHJvcHMuY29uZmlnLmRlZmF1bHRTaXplLG49dC5oZWlnaHQsbz10LndpZHRoO3RoaXMuc2V0U3RhdGUoe2VtYmVkZGVkTGluazpcIlwiLGhlaWdodDpuLHdpZHRoOm99KX19fSx7a2V5OlwicmVuZGVFbWJlZGRlZExpbmtNb2RhbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zdGF0ZSx0PWUuZW1iZWRkZWRMaW5rLG49ZS5oZWlnaHQsbz1lLndpZHRoLGk9dGhpcy5wcm9wcyxyPWkuY29uZmlnLnBvcHVwQ2xhc3NOYW1lLGw9aS5kb0NvbGxhcHNlLGE9aS50cmFuc2xhdGlvbnM7cmV0dXJuIE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTooMCxwLmRlZmF1bHQpKFwicmR3LWVtYmVkZGVkLW1vZGFsXCIsciksb25DbGljazpOLnN0b3BQcm9wYWdhdGlvbn0sTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicmR3LWVtYmVkZGVkLW1vZGFsLWhlYWRlclwifSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIix7Y2xhc3NOYW1lOlwicmR3LWVtYmVkZGVkLW1vZGFsLWhlYWRlci1vcHRpb25cIn0sYVtcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW1iZWRkZWRsaW5rXCJdLE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtjbGFzc05hbWU6XCJyZHctZW1iZWRkZWQtbW9kYWwtaGVhZGVyLWxhYmVsXCJ9KSkpLE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInJkdy1lbWJlZGRlZC1tb2RhbC1saW5rLXNlY3Rpb25cIn0sTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse2NsYXNzTmFtZTpcInJkdy1lbWJlZGRlZC1tb2RhbC1saW5rLWlucHV0LXdyYXBwZXJcIn0sTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLHtjbGFzc05hbWU6XCJyZHctZW1iZWRkZWQtbW9kYWwtbGluay1pbnB1dFwiLHBsYWNlaG9sZGVyOmFbXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVudGVybGlua1wiXSxvbkNoYW5nZTp0aGlzLnVwZGF0ZVZhbHVlLG9uQmx1cjp0aGlzLnVwZGF0ZVZhbHVlLHZhbHVlOnQsbmFtZTpcImVtYmVkZGVkTGlua1wifSksTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse2NsYXNzTmFtZTpcInJkdy1pbWFnZS1tYW5kYXRvcnktc2lnblwifSxcIipcIikpLE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInJkdy1lbWJlZGRlZC1tb2RhbC1zaXplXCJ9LE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLG51bGwsTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLHtvbkNoYW5nZTp0aGlzLnVwZGF0ZVZhbHVlLG9uQmx1cjp0aGlzLnVwZGF0ZVZhbHVlLHZhbHVlOm4sbmFtZTpcImhlaWdodFwiLGNsYXNzTmFtZTpcInJkdy1lbWJlZGRlZC1tb2RhbC1zaXplLWlucHV0XCIscGxhY2Vob2xkZXI6XCJIZWlnaHRcIn0pLE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtjbGFzc05hbWU6XCJyZHctaW1hZ2UtbWFuZGF0b3J5LXNpZ25cIn0sXCIqXCIpKSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIixudWxsLE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIix7b25DaGFuZ2U6dGhpcy51cGRhdGVWYWx1ZSxvbkJsdXI6dGhpcy51cGRhdGVWYWx1ZSx2YWx1ZTpvLG5hbWU6XCJ3aWR0aFwiLGNsYXNzTmFtZTpcInJkdy1lbWJlZGRlZC1tb2RhbC1zaXplLWlucHV0XCIscGxhY2Vob2xkZXI6XCJXaWR0aFwifSksTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse2NsYXNzTmFtZTpcInJkdy1pbWFnZS1tYW5kYXRvcnktc2lnblwifSxcIipcIikpKSksTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse2NsYXNzTmFtZTpcInJkdy1lbWJlZGRlZC1tb2RhbC1idG4tc2VjdGlvblwifSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLHt0eXBlOlwiYnV0dG9uXCIsY2xhc3NOYW1lOlwicmR3LWVtYmVkZGVkLW1vZGFsLWJ0blwiLG9uQ2xpY2s6dGhpcy5vbkNoYW5nZSxkaXNhYmxlZDohdHx8IW58fCFvfSxhW1wiZ2VuZXJpYy5hZGRcIl0pLE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIse3R5cGU6XCJidXR0b25cIixjbGFzc05hbWU6XCJyZHctZW1iZWRkZWQtbW9kYWwtYnRuXCIsb25DbGljazpsfSxhW1wiZ2VuZXJpYy5jYW5jZWxcIl0pKSl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3BzLHQ9ZS5jb25maWcsbj10Lmljb24sbz10LmNsYXNzTmFtZSxpPXQudGl0bGUscj1lLmV4cGFuZGVkLGw9ZS5vbkV4cGFuZEV2ZW50LGE9ZS50cmFuc2xhdGlvbnM7cmV0dXJuIE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInJkdy1lbWJlZGRlZC13cmFwcGVyXCIsXCJhcmlhLWhhc3BvcHVwXCI6XCJ0cnVlXCIsXCJhcmlhLWV4cGFuZGVkXCI6cixcImFyaWEtbGFiZWxcIjpcInJkdy1lbWJlZGRlZC1jb250cm9sXCJ9LE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KEkuZGVmYXVsdCx7Y2xhc3NOYW1lOigwLHAuZGVmYXVsdCkobyksdmFsdWU6XCJ1bm9yZGVyZWQtbGlzdC1pdGVtXCIsb25DbGljazpsLHRpdGxlOml8fGFbXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVtYmVkZGVkXCJdfSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6bixhbHQ6XCJcIn0pKSxyP3RoaXMucmVuZGVFbWJlZGRlZExpbmtNb2RhbCgpOnZvaWQgMCl9fV0pLHR9KHMuQ29tcG9uZW50KTt5LnByb3BUeXBlcz17ZXhwYW5kZWQ6Zy5kZWZhdWx0LmJvb2wsb25FeHBhbmRFdmVudDpnLmRlZmF1bHQuZnVuYyxvbkNoYW5nZTpnLmRlZmF1bHQuZnVuYyxjb25maWc6Zy5kZWZhdWx0Lm9iamVjdCx0cmFuc2xhdGlvbnM6Zy5kZWZhdWx0Lm9iamVjdCxkb0NvbGxhcHNlOmcuZGVmYXVsdC5mdW5jfSx0LmRlZmF1bHQ9eX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9e1wicmR3LWVtYmVkZGVkLXdyYXBwZXJcIjpcInJkdy1lbWJlZGRlZC13cmFwcGVyXCIsXCJyZHctZW1iZWRkZWQtbW9kYWxcIjpcInJkdy1lbWJlZGRlZC1tb2RhbFwiLFwicmR3LWVtYmVkZGVkLW1vZGFsLWhlYWRlclwiOlwicmR3LWVtYmVkZGVkLW1vZGFsLWhlYWRlclwiLFwicmR3LWVtYmVkZGVkLW1vZGFsLWhlYWRlci1vcHRpb25cIjpcInJkdy1lbWJlZGRlZC1tb2RhbC1oZWFkZXItb3B0aW9uXCIsXCJyZHctZW1iZWRkZWQtbW9kYWwtaGVhZGVyLWxhYmVsXCI6XCJyZHctZW1iZWRkZWQtbW9kYWwtaGVhZGVyLWxhYmVsXCIsXCJyZHctZW1iZWRkZWQtbW9kYWwtbGluay1zZWN0aW9uXCI6XCJyZHctZW1iZWRkZWQtbW9kYWwtbGluay1zZWN0aW9uXCIsXCJyZHctZW1iZWRkZWQtbW9kYWwtbGluay1pbnB1dFwiOlwicmR3LWVtYmVkZGVkLW1vZGFsLWxpbmstaW5wdXRcIixcInJkdy1lbWJlZGRlZC1tb2RhbC1saW5rLWlucHV0LXdyYXBwZXJcIjpcInJkdy1lbWJlZGRlZC1tb2RhbC1saW5rLWlucHV0LXdyYXBwZXJcIixcInJkdy1lbWJlZGRlZC1tb2RhbC1idG4tc2VjdGlvblwiOlwicmR3LWVtYmVkZGVkLW1vZGFsLWJ0bi1zZWN0aW9uXCIsXCJyZHctZW1iZWRkZWQtbW9kYWwtYnRuXCI6XCJyZHctZW1iZWRkZWQtbW9kYWwtYnRuXCIsXCJyZHctZW1iZWRkZWQtbW9kYWwtc2l6ZVwiOlwicmR3LWVtYmVkZGVkLW1vZGFsLXNpemVcIixcInJkdy1lbWJlZGRlZC1tb2RhbC1zaXplLWlucHV0XCI6XCJyZHctZW1iZWRkZWQtbW9kYWwtc2l6ZS1pbnB1dFwifX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIHIoZSx0KXtpZighZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2U6dH1mdW5jdGlvbiBsKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHQpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsdCk6ZS5fX3Byb3RvX189dCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBvPXRbbl07by5lbnVtZXJhYmxlPW8uZW51bWVyYWJsZXx8ITEsby5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbyYmKG8ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG8ua2V5LG8pfX1yZXR1cm4gZnVuY3Rpb24odCxuLG8pe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLG8mJmUodCxvKSx0fX0oKSxjPW4oMCkscz1vKGMpLE09bigxKSx1PW8oTSksZz1uKDMpLGQ9big2NikscD1vKGQpLE49ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlLG4sbyxsO2kodGhpcyx0KTtmb3IodmFyIGE9YXJndW1lbnRzLmxlbmd0aCxjPUFycmF5KGEpLHM9MDtzPGE7cysrKWNbc109YXJndW1lbnRzW3NdO3JldHVybiBuPW89cih0aGlzLChlPXQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KGMpKSksby5zdGF0ZT17ZXhwYW5kZWQ6ITF9LG8ub25FeHBhbmRFdmVudD1mdW5jdGlvbigpe28uc2lnbmFsRXhwYW5kZWQ9IW8uc3RhdGUuZXhwYW5kZWR9LG8uZXhwYW5kQ29sbGFwc2U9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDpvLnNpZ25hbEV4cGFuZGVkfSksby5zaWduYWxFeHBhbmRlZD0hMX0sby5kb0V4cGFuZD1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiEwfSl9LG8uZG9Db2xsYXBzZT1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiExfSl9LG8uYWRkRW1vamk9ZnVuY3Rpb24oZSl7dmFyIHQ9by5wcm9wcyxuPXQuZWRpdG9yU3RhdGUsaT10Lm9uQ2hhbmdlLHI9Zy5Nb2RpZmllci5yZXBsYWNlVGV4dChuLmdldEN1cnJlbnRDb250ZW50KCksbi5nZXRTZWxlY3Rpb24oKSxlLG4uZ2V0Q3VycmVudElubGluZVN0eWxlKCkpO2koZy5FZGl0b3JTdGF0ZS5wdXNoKG4scixcImluc2VydC1jaGFyYWN0ZXJzXCIpKSxvLmRvQ29sbGFwc2UoKX0sbD1uLHIobyxsKX1yZXR1cm4gbCh0LGUpLGEodCxbe2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcm9wcy5tb2RhbEhhbmRsZXIucmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJjb21wb25lbnRXaWxsVW5tb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcm9wcy5tb2RhbEhhbmRsZXIuZGVyZWdpc3RlckNhbGxCYWNrKHRoaXMuZXhwYW5kQ29sbGFwc2UpfX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcyx0PWUuY29uZmlnLG49ZS50cmFuc2xhdGlvbnMsbz10aGlzLnN0YXRlLmV4cGFuZGVkLGk9dC5jb21wb25lbnR8fHAuZGVmYXVsdDtyZXR1cm4gcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoaSx7Y29uZmlnOnQsdHJhbnNsYXRpb25zOm4sb25DaGFuZ2U6dGhpcy5hZGRFbW9qaSxleHBhbmRlZDpvLG9uRXhwYW5kRXZlbnQ6dGhpcy5vbkV4cGFuZEV2ZW50LGRvRXhwYW5kOnRoaXMuZG9FeHBhbmQsZG9Db2xsYXBzZTp0aGlzLmRvQ29sbGFwc2Usb25Db2xscGFzZTp0aGlzLmNsb3NlTW9kYWx9KX19XSksdH0oYy5Db21wb25lbnQpO04ucHJvcFR5cGVzPXtlZGl0b3JTdGF0ZTp1LmRlZmF1bHQub2JqZWN0LmlzUmVxdWlyZWQsb25DaGFuZ2U6dS5kZWZhdWx0LmZ1bmMuaXNSZXF1aXJlZCxtb2RhbEhhbmRsZXI6dS5kZWZhdWx0Lm9iamVjdCxjb25maWc6dS5kZWZhdWx0Lm9iamVjdCx0cmFuc2xhdGlvbnM6dS5kZWZhdWx0Lm9iamVjdH0sdC5kZWZhdWx0PU59LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiByKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gbChlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCksYz1uKDApLHM9byhjKSxNPW4oMSksdT1vKE0pLGc9bigyKSxkPW8oZykscD1uKDYpLE49big1KSxEPW8oTik7big2Nyk7dmFyIEk9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlLG4sbyxsO2kodGhpcyx0KTtmb3IodmFyIGE9YXJndW1lbnRzLmxlbmd0aCxjPUFycmF5KGEpLHM9MDtzPGE7cysrKWNbc109YXJndW1lbnRzW3NdO3JldHVybiBuPW89cih0aGlzLChlPXQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KGMpKSksby5vbkNoYW5nZT1mdW5jdGlvbihlKXsoMCxvLnByb3BzLm9uQ2hhbmdlKShlLnRhcmdldC5pbm5lckhUTUwpfSxsPW4scihvLGwpfXJldHVybiBsKHQsZSksYSh0LFt7a2V5OlwicmVuZGVyRW1vamlNb2RhbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXRoaXMucHJvcHMuY29uZmlnLG49dC5wb3B1cENsYXNzTmFtZSxvPXQuZW1vamlzO3JldHVybiBzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6KDAsZC5kZWZhdWx0KShcInJkdy1lbW9qaS1tb2RhbFwiLG4pLG9uQ2xpY2s6cC5zdG9wUHJvcGFnYXRpb259LG8ubWFwKGZ1bmN0aW9uKHQsbil7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtrZXk6bixjbGFzc05hbWU6XCJyZHctZW1vamktaWNvblwiLGFsdDpcIlwiLG9uQ2xpY2s6ZS5vbkNoYW5nZX0sdCl9KSl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3BzLHQ9ZS5jb25maWcsbj10Lmljb24sbz10LmNsYXNzTmFtZSxpPXQudGl0bGUscj1lLmV4cGFuZGVkLGw9ZS5vbkV4cGFuZEV2ZW50LGE9ZS50cmFuc2xhdGlvbnM7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInJkdy1lbW9qaS13cmFwcGVyXCIsXCJhcmlhLWhhc3BvcHVwXCI6XCJ0cnVlXCIsXCJhcmlhLWxhYmVsXCI6XCJyZHctZW1vamktY29udHJvbFwiLFwiYXJpYS1leHBhbmRlZFwiOnIsdGl0bGU6aXx8YVtcImNvbXBvbmVudHMuY29udHJvbHMuZW1vamkuZW1vamlcIl19LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEQuZGVmYXVsdCx7Y2xhc3NOYW1lOigwLGQuZGVmYXVsdCkobyksdmFsdWU6XCJ1bm9yZGVyZWQtbGlzdC1pdGVtXCIsb25DbGljazpsfSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6bixhbHQ6XCJcIn0pKSxyP3RoaXMucmVuZGVyRW1vamlNb2RhbCgpOnZvaWQgMCl9fV0pLHR9KGMuQ29tcG9uZW50KTtJLnByb3BUeXBlcz17ZXhwYW5kZWQ6dS5kZWZhdWx0LmJvb2wsb25FeHBhbmRFdmVudDp1LmRlZmF1bHQuZnVuYyxvbkNoYW5nZTp1LmRlZmF1bHQuZnVuYyxjb25maWc6dS5kZWZhdWx0Lm9iamVjdCx0cmFuc2xhdGlvbnM6dS5kZWZhdWx0Lm9iamVjdH0sdC5kZWZhdWx0PUl9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXtcInJkdy1lbW9qaS13cmFwcGVyXCI6XCJyZHctZW1vamktd3JhcHBlclwiLFwicmR3LWVtb2ppLW1vZGFsXCI6XCJyZHctZW1vamktbW9kYWxcIixcInJkdy1lbW9qaS1pY29uXCI6XCJyZHctZW1vamktaWNvblwifX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIHIoZSx0KXtpZighZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2U6dH1mdW5jdGlvbiBsKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHQpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsdCk6ZS5fX3Byb3RvX189dCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBvPXRbbl07by5lbnVtZXJhYmxlPW8uZW51bWVyYWJsZXx8ITEsby5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbyYmKG8ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG8ua2V5LG8pfX1yZXR1cm4gZnVuY3Rpb24odCxuLG8pe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLG8mJmUodCxvKSx0fX0oKSxjPW4oMCkscz1vKGMpLE09bigxKSx1PW8oTSksZz1uKDMpLGQ9big2OSkscD1vKGQpLE49ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlLG4sbyxsO2kodGhpcyx0KTtmb3IodmFyIGE9YXJndW1lbnRzLmxlbmd0aCxjPUFycmF5KGEpLHM9MDtzPGE7cysrKWNbc109YXJndW1lbnRzW3NdO3JldHVybiBuPW89cih0aGlzLChlPXQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KGMpKSksby5zdGF0ZT17ZXhwYW5kZWQ6ITF9LG8ub25FeHBhbmRFdmVudD1mdW5jdGlvbigpe28uc2lnbmFsRXhwYW5kZWQ9IW8uc3RhdGUuZXhwYW5kZWR9LG8uZG9FeHBhbmQ9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDohMH0pfSxvLmRvQ29sbGFwc2U9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDohMX0pfSxvLmV4cGFuZENvbGxhcHNlPWZ1bmN0aW9uKCl7by5zZXRTdGF0ZSh7ZXhwYW5kZWQ6by5zaWduYWxFeHBhbmRlZH0pLG8uc2lnbmFsRXhwYW5kZWQ9ITF9LG8uYWRkSW1hZ2U9ZnVuY3Rpb24oZSx0LG4saSl7dmFyIHI9by5wcm9wcyxsPXIuZWRpdG9yU3RhdGUsYT1yLm9uQ2hhbmdlLGM9ci5jb25maWcscz17c3JjOmUsaGVpZ2h0OnQsd2lkdGg6bn07Yy5hbHQucHJlc2VudCYmKHMuYWx0PWkpO3ZhciBNPWwuZ2V0Q3VycmVudENvbnRlbnQoKS5jcmVhdGVFbnRpdHkoXCJJTUFHRVwiLFwiTVVUQUJMRVwiLHMpLmdldExhc3RDcmVhdGVkRW50aXR5S2V5KCk7YShnLkF0b21pY0Jsb2NrVXRpbHMuaW5zZXJ0QXRvbWljQmxvY2sobCxNLFwiIFwiKSksby5kb0NvbGxhcHNlKCl9LGw9bixyKG8sbCl9cmV0dXJuIGwodCxlKSxhKHQsW3trZXk6XCJjb21wb25lbnRXaWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMubW9kYWxIYW5kbGVyLnJlZ2lzdGVyQ2FsbEJhY2sodGhpcy5leHBhbmRDb2xsYXBzZSl9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMubW9kYWxIYW5kbGVyLmRlcmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNvbmZpZyxuPWUudHJhbnNsYXRpb25zLG89dGhpcy5zdGF0ZS5leHBhbmRlZCxpPXQuY29tcG9uZW50fHxwLmRlZmF1bHQ7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGkse2NvbmZpZzp0LHRyYW5zbGF0aW9uczpuLG9uQ2hhbmdlOnRoaXMuYWRkSW1hZ2UsZXhwYW5kZWQ6byxvbkV4cGFuZEV2ZW50OnRoaXMub25FeHBhbmRFdmVudCxkb0V4cGFuZDp0aGlzLmRvRXhwYW5kLGRvQ29sbGFwc2U6dGhpcy5kb0NvbGxhcHNlfSl9fV0pLHR9KGMuQ29tcG9uZW50KTtOLnByb3BUeXBlcz17ZWRpdG9yU3RhdGU6dS5kZWZhdWx0Lm9iamVjdC5pc1JlcXVpcmVkLG9uQ2hhbmdlOnUuZGVmYXVsdC5mdW5jLmlzUmVxdWlyZWQsbW9kYWxIYW5kbGVyOnUuZGVmYXVsdC5vYmplY3QsY29uZmlnOnUuZGVmYXVsdC5vYmplY3QsdHJhbnNsYXRpb25zOnUuZGVmYXVsdC5vYmplY3R9LHQuZGVmYXVsdD1OfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9ZnVuY3Rpb24gcihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gbChlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGEoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLHM9bigwKSxNPW8ocyksdT1uKDEpLGc9byh1KSxkPW4oMikscD1vKGQpLE49big1KSxEPW8oTiksST1uKDcwKSx5PW8oSSk7big3Mik7dmFyIGo9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlLG4sbyxhO3IodGhpcyx0KTtmb3IodmFyIGM9YXJndW1lbnRzLmxlbmd0aCxzPUFycmF5KGMpLE09MDtNPGM7TSsrKXNbTV09YXJndW1lbnRzW01dO3JldHVybiBuPW89bCh0aGlzLChlPXQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KHMpKSksby5zdGF0ZT17aW1nU3JjOlwiXCIsZHJhZ0VudGVyOiExLHVwbG9hZEhpZ2hsaWdodGVkOm8ucHJvcHMuY29uZmlnLnVwbG9hZEVuYWJsZWQmJiEhby5wcm9wcy5jb25maWcudXBsb2FkQ2FsbGJhY2ssc2hvd0ltYWdlTG9hZGluZzohMSxoZWlnaHQ6by5wcm9wcy5jb25maWcuZGVmYXVsdFNpemUuaGVpZ2h0LHdpZHRoOm8ucHJvcHMuY29uZmlnLmRlZmF1bHRTaXplLndpZHRoLGFsdDpcIlwifSxvLm9uRHJhZ0VudGVyPWZ1bmN0aW9uKGUpe28uc3RvcFByb3BhZ2F0aW9uKGUpLG8uc2V0U3RhdGUoe2RyYWdFbnRlcjohMH0pfSxvLm9uSW1hZ2VEcm9wPWZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKSxlLnN0b3BQcm9wYWdhdGlvbigpLG8uc2V0U3RhdGUoe2RyYWdFbnRlcjohMX0pO3ZhciB0PXZvaWQgMCxuPXZvaWQgMDtlLmRhdGFUcmFuc2Zlci5pdGVtcz8odD1lLmRhdGFUcmFuc2Zlci5pdGVtcyxuPSEwKToodD1lLmRhdGFUcmFuc2Zlci5maWxlcyxuPSExKTtmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krPTEpaWYoKCFufHxcImZpbGVcIj09PXRbaV0ua2luZCkmJnRbaV0udHlwZS5tYXRjaChcIl5pbWFnZS9cIikpe3ZhciByPW4/dFtpXS5nZXRBc0ZpbGUoKTp0W2ldO28udXBsb2FkSW1hZ2Uocil9fSxvLnNob3dJbWFnZVVwbG9hZE9wdGlvbj1mdW5jdGlvbigpe28uc2V0U3RhdGUoe3VwbG9hZEhpZ2hsaWdodGVkOiEwfSl9LG8uYWRkSW1hZ2VGcm9tU3RhdGU9ZnVuY3Rpb24oKXt2YXIgZT1vLnN0YXRlLHQ9ZS5pbWdTcmMsbj1lLmFsdCxpPW8uc3RhdGUscj1pLmhlaWdodCxsPWkud2lkdGgsYT1vLnByb3BzLm9uQ2hhbmdlO2lzTmFOKHIpfHwocis9XCJweFwiKSxpc05hTihsKXx8KGwrPVwicHhcIiksYSh0LHIsbCxuKX0sby5zaG93SW1hZ2VVUkxPcHRpb249ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHt1cGxvYWRIaWdobGlnaHRlZDohMX0pfSxvLnRvZ2dsZVNob3dJbWFnZUxvYWRpbmc9ZnVuY3Rpb24oKXt2YXIgZT0hby5zdGF0ZS5zaG93SW1hZ2VMb2FkaW5nO28uc2V0U3RhdGUoe3Nob3dJbWFnZUxvYWRpbmc6ZX0pfSxvLnVwZGF0ZVZhbHVlPWZ1bmN0aW9uKGUpe28uc2V0U3RhdGUoaSh7fSxcIlwiK2UudGFyZ2V0Lm5hbWUsZS50YXJnZXQudmFsdWUpKX0sby5zZWxlY3RJbWFnZT1mdW5jdGlvbihlKXtlLnRhcmdldC5maWxlcyYmZS50YXJnZXQuZmlsZXMubGVuZ3RoPjAmJm8udXBsb2FkSW1hZ2UoZS50YXJnZXQuZmlsZXNbMF0pfSxvLnVwbG9hZEltYWdlPWZ1bmN0aW9uKGUpe28udG9nZ2xlU2hvd0ltYWdlTG9hZGluZygpLCgwLG8ucHJvcHMuY29uZmlnLnVwbG9hZENhbGxiYWNrKShlKS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0PWUuZGF0YTtvLnNldFN0YXRlKHtzaG93SW1hZ2VMb2FkaW5nOiExLGRyYWdFbnRlcjohMSxpbWdTcmM6dC5saW5rfSksby5maWxlVXBsb2FkPSExfSkuY2F0Y2goZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtzaG93SW1hZ2VMb2FkaW5nOiExLGRyYWdFbnRlcjohMX0pfSl9LG8uZmlsZVVwbG9hZENsaWNrPWZ1bmN0aW9uKGUpe28uZmlsZVVwbG9hZD0hMCxlLnN0b3BQcm9wYWdhdGlvbigpfSxvLnN0b3BQcm9wYWdhdGlvbj1mdW5jdGlvbihlKXtvLmZpbGVVcGxvYWQ/by5maWxlVXBsb2FkPSExOihlLnByZXZlbnREZWZhdWx0KCksZS5zdG9wUHJvcGFnYXRpb24oKSl9LGE9bixsKG8sYSl9cmV0dXJuIGEodCxlKSxjKHQsW3trZXk6XCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wcm9wcy5leHBhbmRlZCYmIWUuZXhwYW5kZWQ/dGhpcy5zZXRTdGF0ZSh7aW1nU3JjOlwiXCIsZHJhZ0VudGVyOiExLHVwbG9hZEhpZ2hsaWdodGVkOnRoaXMucHJvcHMuY29uZmlnLnVwbG9hZEVuYWJsZWQmJiEhdGhpcy5wcm9wcy5jb25maWcudXBsb2FkQ2FsbGJhY2ssc2hvd0ltYWdlTG9hZGluZzohMSxoZWlnaHQ6dGhpcy5wcm9wcy5jb25maWcuZGVmYXVsdFNpemUuaGVpZ2h0LHdpZHRoOnRoaXMucHJvcHMuY29uZmlnLmRlZmF1bHRTaXplLndpZHRoLGFsdDpcIlwifSk6ZS5jb25maWcudXBsb2FkQ2FsbGJhY2s9PT10aGlzLnByb3BzLmNvbmZpZy51cGxvYWRDYWxsYmFjayYmZS5jb25maWcudXBsb2FkRW5hYmxlZD09PXRoaXMucHJvcHMuY29uZmlnLnVwbG9hZEVuYWJsZWR8fHRoaXMuc2V0U3RhdGUoe3VwbG9hZEhpZ2hsaWdodGVkOmUuY29uZmlnLnVwbG9hZEVuYWJsZWQmJiEhZS5jb25maWcudXBsb2FkQ2FsbGJhY2t9KX19LHtrZXk6XCJyZW5kZXJBZGRJbWFnZU1vZGFsXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnN0YXRlLHQ9ZS5pbWdTcmMsbj1lLnVwbG9hZEhpZ2hsaWdodGVkLG89ZS5zaG93SW1hZ2VMb2FkaW5nLGk9ZS5kcmFnRW50ZXIscj1lLmhlaWdodCxsPWUud2lkdGgsYT1lLmFsdCxjPXRoaXMucHJvcHMscz1jLmNvbmZpZyx1PXMucG9wdXBDbGFzc05hbWUsZz1zLnVwbG9hZENhbGxiYWNrLGQ9cy51cGxvYWRFbmFibGVkLE49cy51cmxFbmFibGVkLEQ9cy5wcmV2aWV3SW1hZ2UsST1zLmlucHV0QWNjZXB0LGo9cy5hbHQsZj1jLmRvQ29sbGFwc2Usdz1jLnRyYW5zbGF0aW9ucztyZXR1cm4gTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOigwLHAuZGVmYXVsdCkoXCJyZHctaW1hZ2UtbW9kYWxcIix1KSxvbkNsaWNrOnRoaXMuc3RvcFByb3BhZ2F0aW9ufSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJyZHctaW1hZ2UtbW9kYWwtaGVhZGVyXCJ9LGQmJmcmJk0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtvbkNsaWNrOnRoaXMuc2hvd0ltYWdlVXBsb2FkT3B0aW9uLGNsYXNzTmFtZTpcInJkdy1pbWFnZS1tb2RhbC1oZWFkZXItb3B0aW9uXCJ9LHdbXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmZpbGVVcGxvYWRcIl0sTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse2NsYXNzTmFtZTooMCxwLmRlZmF1bHQpKFwicmR3LWltYWdlLW1vZGFsLWhlYWRlci1sYWJlbFwiLHtcInJkdy1pbWFnZS1tb2RhbC1oZWFkZXItbGFiZWwtaGlnaGxpZ2h0ZWRcIjpufSl9KSksTiYmTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse29uQ2xpY2s6dGhpcy5zaG93SW1hZ2VVUkxPcHRpb24sY2xhc3NOYW1lOlwicmR3LWltYWdlLW1vZGFsLWhlYWRlci1vcHRpb25cIn0sd1tcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuYnlVUkxcIl0sTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse2NsYXNzTmFtZTooMCxwLmRlZmF1bHQpKFwicmR3LWltYWdlLW1vZGFsLWhlYWRlci1sYWJlbFwiLHtcInJkdy1pbWFnZS1tb2RhbC1oZWFkZXItbGFiZWwtaGlnaGxpZ2h0ZWRcIjohbn0pfSkpKSxuP00uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse29uQ2xpY2s6dGhpcy5maWxlVXBsb2FkQ2xpY2t9LE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse29uRHJhZ0VudGVyOnRoaXMub25EcmFnRW50ZXIsb25EcmFnT3Zlcjp0aGlzLnN0b3BQcm9wYWdhdGlvbixvbkRyb3A6dGhpcy5vbkltYWdlRHJvcCxjbGFzc05hbWU6KDAscC5kZWZhdWx0KShcInJkdy1pbWFnZS1tb2RhbC11cGxvYWQtb3B0aW9uXCIse1wicmR3LWltYWdlLW1vZGFsLXVwbG9hZC1vcHRpb24taGlnaGxpZ2h0ZWRcIjppfSl9LE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIix7aHRtbEZvcjpcImZpbGVcIixjbGFzc05hbWU6XCJyZHctaW1hZ2UtbW9kYWwtdXBsb2FkLW9wdGlvbi1sYWJlbFwifSxEJiZ0P00uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIse3NyYzp0LGFsdDp0LGNsYXNzTmFtZTpcInJkdy1pbWFnZS1tb2RhbC11cGxvYWQtb3B0aW9uLWltYWdlLXByZXZpZXdcIn0pOnR8fHdbXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmRyb3BGaWxlVGV4dFwiXSkpLE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIix7dHlwZTpcImZpbGVcIixpZDpcImZpbGVcIixhY2NlcHQ6SSxvbkNoYW5nZTp0aGlzLnNlbGVjdEltYWdlLGNsYXNzTmFtZTpcInJkdy1pbWFnZS1tb2RhbC11cGxvYWQtb3B0aW9uLWlucHV0XCJ9KSk6TS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicmR3LWltYWdlLW1vZGFsLXVybC1zZWN0aW9uXCJ9LE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIix7Y2xhc3NOYW1lOlwicmR3LWltYWdlLW1vZGFsLXVybC1pbnB1dFwiLHBsYWNlaG9sZGVyOndbXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmVudGVybGlua1wiXSxuYW1lOlwiaW1nU3JjXCIsb25DaGFuZ2U6dGhpcy51cGRhdGVWYWx1ZSxvbkJsdXI6dGhpcy51cGRhdGVWYWx1ZSx2YWx1ZTp0fSksTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse2NsYXNzTmFtZTpcInJkdy1pbWFnZS1tYW5kYXRvcnktc2lnblwifSxcIipcIikpLGoucHJlc2VudCYmTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicmR3LWltYWdlLW1vZGFsLXNpemVcIn0sTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse2NsYXNzTmFtZTpcInJkdy1pbWFnZS1tb2RhbC1hbHQtbGJsXCJ9LFwiQWx0IFRleHRcIiksTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLHtvbkNoYW5nZTp0aGlzLnVwZGF0ZVZhbHVlLG9uQmx1cjp0aGlzLnVwZGF0ZVZhbHVlLHZhbHVlOmEsbmFtZTpcImFsdFwiLGNsYXNzTmFtZTpcInJkdy1pbWFnZS1tb2RhbC1hbHQtaW5wdXRcIixwbGFjZWhvbGRlcjpcImFsdFwifSksTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse2NsYXNzTmFtZTpcInJkdy1pbWFnZS1tYW5kYXRvcnktc2lnblwifSxqLm1hbmRhdG9yeSYmXCIqXCIpKSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJyZHctaW1hZ2UtbW9kYWwtc2l6ZVwifSxcIuKGlcKgXCIsTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLHtvbkNoYW5nZTp0aGlzLnVwZGF0ZVZhbHVlLG9uQmx1cjp0aGlzLnVwZGF0ZVZhbHVlLHZhbHVlOnIsbmFtZTpcImhlaWdodFwiLGNsYXNzTmFtZTpcInJkdy1pbWFnZS1tb2RhbC1zaXplLWlucHV0XCIscGxhY2Vob2xkZXI6XCJIZWlnaHRcIn0pLE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtjbGFzc05hbWU6XCJyZHctaW1hZ2UtbWFuZGF0b3J5LXNpZ25cIn0sXCIqXCIpLFwiwqDihpTCoFwiLE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIix7b25DaGFuZ2U6dGhpcy51cGRhdGVWYWx1ZSxvbkJsdXI6dGhpcy51cGRhdGVWYWx1ZSx2YWx1ZTpsLG5hbWU6XCJ3aWR0aFwiLGNsYXNzTmFtZTpcInJkdy1pbWFnZS1tb2RhbC1zaXplLWlucHV0XCIscGxhY2Vob2xkZXI6XCJXaWR0aFwifSksTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse2NsYXNzTmFtZTpcInJkdy1pbWFnZS1tYW5kYXRvcnktc2lnblwifSxcIipcIikpLE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtjbGFzc05hbWU6XCJyZHctaW1hZ2UtbW9kYWwtYnRuLXNlY3Rpb25cIn0sTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIix7Y2xhc3NOYW1lOlwicmR3LWltYWdlLW1vZGFsLWJ0blwiLG9uQ2xpY2s6dGhpcy5hZGRJbWFnZUZyb21TdGF0ZSxkaXNhYmxlZDohdHx8IXJ8fCFsfHxqLm1hbmRhdG9yeSYmIWF9LHdbXCJnZW5lcmljLmFkZFwiXSksTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIix7Y2xhc3NOYW1lOlwicmR3LWltYWdlLW1vZGFsLWJ0blwiLG9uQ2xpY2s6Zn0sd1tcImdlbmVyaWMuY2FuY2VsXCJdKSksbz9NLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJyZHctaW1hZ2UtbW9kYWwtc3Bpbm5lclwifSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudCh5LmRlZmF1bHQsbnVsbCkpOnZvaWQgMCl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3BzLHQ9ZS5jb25maWcsbj10Lmljb24sbz10LmNsYXNzTmFtZSxpPXQudGl0bGUscj1lLmV4cGFuZGVkLGw9ZS5vbkV4cGFuZEV2ZW50LGE9ZS50cmFuc2xhdGlvbnM7cmV0dXJuIE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInJkdy1pbWFnZS13cmFwcGVyXCIsXCJhcmlhLWhhc3BvcHVwXCI6XCJ0cnVlXCIsXCJhcmlhLWV4cGFuZGVkXCI6cixcImFyaWEtbGFiZWxcIjpcInJkdy1pbWFnZS1jb250cm9sXCJ9LE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KEQuZGVmYXVsdCx7Y2xhc3NOYW1lOigwLHAuZGVmYXVsdCkobyksdmFsdWU6XCJ1bm9yZGVyZWQtbGlzdC1pdGVtXCIsb25DbGljazpsLHRpdGxlOml8fGFbXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmltYWdlXCJdfSxNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6bixhbHQ6XCJcIn0pKSxyP3RoaXMucmVuZGVyQWRkSW1hZ2VNb2RhbCgpOnZvaWQgMCl9fV0pLHR9KHMuQ29tcG9uZW50KTtqLnByb3BUeXBlcz17ZXhwYW5kZWQ6Zy5kZWZhdWx0LmJvb2wsb25FeHBhbmRFdmVudDpnLmRlZmF1bHQuZnVuYyxkb0NvbGxhcHNlOmcuZGVmYXVsdC5mdW5jLG9uQ2hhbmdlOmcuZGVmYXVsdC5mdW5jLGNvbmZpZzpnLmRlZmF1bHQub2JqZWN0LHRyYW5zbGF0aW9uczpnLmRlZmF1bHQub2JqZWN0fSx0LmRlZmF1bHQ9an0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oMCksaT1mdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19KG8pO24oNzEpLHQuZGVmYXVsdD1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJyZHctc3Bpbm5lclwifSxpLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJyZHctYm91bmNlMVwifSksaS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwicmR3LWJvdW5jZTJcIn0pLGkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcInJkdy1ib3VuY2UzXCJ9KSl9fSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz17XCJyZHctc3Bpbm5lclwiOlwicmR3LXNwaW5uZXJcIixcInNrLWJvdW5jZWRlbGF5XCI6XCJzay1ib3VuY2VkZWxheVwiLFwicmR3LWJvdW5jZTFcIjpcInJkdy1ib3VuY2UxXCIsXCJyZHctYm91bmNlMlwiOlwicmR3LWJvdW5jZTJcIn19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXtcInJkdy1pbWFnZS13cmFwcGVyXCI6XCJyZHctaW1hZ2Utd3JhcHBlclwiLFwicmR3LWltYWdlLW1vZGFsXCI6XCJyZHctaW1hZ2UtbW9kYWxcIixcInJkdy1pbWFnZS1tb2RhbC1oZWFkZXJcIjpcInJkdy1pbWFnZS1tb2RhbC1oZWFkZXJcIixcInJkdy1pbWFnZS1tb2RhbC1oZWFkZXItb3B0aW9uXCI6XCJyZHctaW1hZ2UtbW9kYWwtaGVhZGVyLW9wdGlvblwiLFwicmR3LWltYWdlLW1vZGFsLWhlYWRlci1sYWJlbFwiOlwicmR3LWltYWdlLW1vZGFsLWhlYWRlci1sYWJlbFwiLFwicmR3LWltYWdlLW1vZGFsLWhlYWRlci1sYWJlbC1oaWdobGlnaHRlZFwiOlwicmR3LWltYWdlLW1vZGFsLWhlYWRlci1sYWJlbC1oaWdobGlnaHRlZFwiLFwicmR3LWltYWdlLW1vZGFsLXVwbG9hZC1vcHRpb25cIjpcInJkdy1pbWFnZS1tb2RhbC11cGxvYWQtb3B0aW9uXCIsXCJyZHctaW1hZ2UtbW9kYWwtdXBsb2FkLW9wdGlvbi1oaWdobGlnaHRlZFwiOlwicmR3LWltYWdlLW1vZGFsLXVwbG9hZC1vcHRpb24taGlnaGxpZ2h0ZWRcIixcInJkdy1pbWFnZS1tb2RhbC11cGxvYWQtb3B0aW9uLWxhYmVsXCI6XCJyZHctaW1hZ2UtbW9kYWwtdXBsb2FkLW9wdGlvbi1sYWJlbFwiLFwicmR3LWltYWdlLW1vZGFsLXVwbG9hZC1vcHRpb24taW1hZ2UtcHJldmlld1wiOlwicmR3LWltYWdlLW1vZGFsLXVwbG9hZC1vcHRpb24taW1hZ2UtcHJldmlld1wiLFwicmR3LWltYWdlLW1vZGFsLXVwbG9hZC1vcHRpb24taW5wdXRcIjpcInJkdy1pbWFnZS1tb2RhbC11cGxvYWQtb3B0aW9uLWlucHV0XCIsXCJyZHctaW1hZ2UtbW9kYWwtdXJsLXNlY3Rpb25cIjpcInJkdy1pbWFnZS1tb2RhbC11cmwtc2VjdGlvblwiLFwicmR3LWltYWdlLW1vZGFsLXVybC1pbnB1dFwiOlwicmR3LWltYWdlLW1vZGFsLXVybC1pbnB1dFwiLFwicmR3LWltYWdlLW1vZGFsLWJ0bi1zZWN0aW9uXCI6XCJyZHctaW1hZ2UtbW9kYWwtYnRuLXNlY3Rpb25cIixcInJkdy1pbWFnZS1tb2RhbC1idG5cIjpcInJkdy1pbWFnZS1tb2RhbC1idG5cIixcInJkdy1pbWFnZS1tb2RhbC1zcGlubmVyXCI6XCJyZHctaW1hZ2UtbW9kYWwtc3Bpbm5lclwiLFwicmR3LWltYWdlLW1vZGFsLWFsdC1pbnB1dFwiOlwicmR3LWltYWdlLW1vZGFsLWFsdC1pbnB1dFwiLFwicmR3LWltYWdlLW1vZGFsLWFsdC1sYmxcIjpcInJkdy1pbWFnZS1tb2RhbC1hbHQtbGJsXCIsXCJyZHctaW1hZ2UtbW9kYWwtc2l6ZVwiOlwicmR3LWltYWdlLW1vZGFsLXNpemVcIixcInJkdy1pbWFnZS1tb2RhbC1zaXplLWlucHV0XCI6XCJyZHctaW1hZ2UtbW9kYWwtc2l6ZS1pbnB1dFwiLFwicmR3LWltYWdlLW1hbmRhdG9yeS1zaWduXCI6XCJyZHctaW1hZ2UtbWFuZGF0b3J5LXNpZ25cIn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiByKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gbChlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCksYz1uKDApLHM9byhjKSxNPW4oMSksdT1vKE0pLGc9bigzKSxkPW4oNCkscD1uKDYpLE49big3NCksRD1vKE4pLEk9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlLG4sbyxsO2kodGhpcyx0KTtmb3IodmFyIGE9YXJndW1lbnRzLmxlbmd0aCxjPUFycmF5KGEpLHM9MDtzPGE7cysrKWNbc109YXJndW1lbnRzW3NdO3JldHVybiBuPW89cih0aGlzLChlPXQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KGMpKSksby5zdGF0ZT17ZXhwYW5kZWQ6ITF9LG8ub25FeHBhbmRFdmVudD1mdW5jdGlvbigpe28uc2lnbmFsRXhwYW5kZWQ9IW8uc3RhdGUuZXhwYW5kZWR9LG8uZXhwYW5kQ29sbGFwc2U9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDpvLnNpZ25hbEV4cGFuZGVkfSksby5zaWduYWxFeHBhbmRlZD0hMX0sby5yZW1vdmVJbmxpbmVTdHlsZXM9ZnVuY3Rpb24oKXt2YXIgZT1vLnByb3BzLHQ9ZS5lZGl0b3JTdGF0ZTsoMCxlLm9uQ2hhbmdlKShvLnJlbW92ZUFsbElubGluZVN0eWxlcyh0KSl9LG8ucmVtb3ZlQWxsSW5saW5lU3R5bGVzPWZ1bmN0aW9uKGUpe3ZhciB0PWUuZ2V0Q3VycmVudENvbnRlbnQoKTtbXCJCT0xEXCIsXCJJVEFMSUNcIixcIlVOREVSTElORVwiLFwiU1RSSUtFVEhST1VHSFwiLFwiTU9OT1NQQUNFXCIsXCJTVVBFUlNDUklQVFwiLFwiU1VCU0NSSVBUXCJdLmZvckVhY2goZnVuY3Rpb24obil7dD1nLk1vZGlmaWVyLnJlbW92ZUlubGluZVN0eWxlKHQsZS5nZXRTZWxlY3Rpb24oKSxuKX0pO3ZhciBuPSgwLGQuZ2V0U2VsZWN0aW9uQ3VzdG9tSW5saW5lU3R5bGUpKGUsW1wiRk9OVFNJWkVcIixcIkZPTlRGQU1JTFlcIixcIkNPTE9SXCIsXCJCR0NPTE9SXCJdKTtyZXR1cm4oMCxwLmZvckVhY2gpKG4sZnVuY3Rpb24obixvKXtvJiYodD1nLk1vZGlmaWVyLnJlbW92ZUlubGluZVN0eWxlKHQsZS5nZXRTZWxlY3Rpb24oKSxvKSl9KSxnLkVkaXRvclN0YXRlLnB1c2goZSx0LFwiY2hhbmdlLWlubGluZS1zdHlsZVwiKX0sby5kb0V4cGFuZD1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiEwfSl9LG8uZG9Db2xsYXBzZT1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiExfSl9LGw9bixyKG8sbCl9cmV0dXJuIGwodCxlKSxhKHQsW3trZXk6XCJjb21wb25lbnRXaWxsTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMubW9kYWxIYW5kbGVyLnJlZ2lzdGVyQ2FsbEJhY2sodGhpcy5leHBhbmRDb2xsYXBzZSl9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMubW9kYWxIYW5kbGVyLmRlcmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNvbmZpZyxuPWUudHJhbnNsYXRpb25zLG89dGhpcy5zdGF0ZS5leHBhbmRlZCxpPXQuY29tcG9uZW50fHxELmRlZmF1bHQ7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGkse2NvbmZpZzp0LHRyYW5zbGF0aW9uczpuLGV4cGFuZGVkOm8sb25FeHBhbmRFdmVudDp0aGlzLm9uRXhwYW5kRXZlbnQsZG9FeHBhbmQ6dGhpcy5kb0V4cGFuZCxkb0NvbGxhcHNlOnRoaXMuZG9Db2xsYXBzZSxvbkNoYW5nZTp0aGlzLnJlbW92ZUlubGluZVN0eWxlc30pfX1dKSx0fShjLkNvbXBvbmVudCk7SS5wcm9wVHlwZXM9e29uQ2hhbmdlOnUuZGVmYXVsdC5mdW5jLmlzUmVxdWlyZWQsZWRpdG9yU3RhdGU6dS5kZWZhdWx0Lm9iamVjdC5pc1JlcXVpcmVkLGNvbmZpZzp1LmRlZmF1bHQub2JqZWN0LHRyYW5zbGF0aW9uczp1LmRlZmF1bHQub2JqZWN0LG1vZGFsSGFuZGxlcjp1LmRlZmF1bHQub2JqZWN0fSx0LmRlZmF1bHQ9SX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPW4oMCkscj1vKGkpLGw9bigxKSxhPW8obCksYz1uKDIpLHM9byhjKSxNPW4oNSksdT1vKE0pO24oNzUpO3ZhciBnPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY29uZmlnLG49ZS5vbkNoYW5nZSxvPWUudHJhbnNsYXRpb25zLGk9dC5pY29uLGw9dC5jbGFzc05hbWUsYT10LnRpdGxlO3JldHVybiByLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJyZHctcmVtb3ZlLXdyYXBwZXJcIixcImFyaWEtbGFiZWxcIjpcInJkdy1yZW1vdmUtY29udHJvbFwifSxyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCh1LmRlZmF1bHQse2NsYXNzTmFtZTooMCxzLmRlZmF1bHQpKGwpLG9uQ2xpY2s6bix0aXRsZTphfHxvW1wiY29tcG9uZW50cy5jb250cm9scy5yZW1vdmUucmVtb3ZlXCJdfSxyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6aSxhbHQ6XCJcIn0pKSl9O2cucHJvcFR5cGVzPXtvbkNoYW5nZTphLmRlZmF1bHQuZnVuYyxjb25maWc6YS5kZWZhdWx0Lm9iamVjdCx0cmFuc2xhdGlvbnM6YS5kZWZhdWx0Lm9iamVjdH0sdC5kZWZhdWx0PWd9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXtcInJkdy1yZW1vdmUtd3JhcHBlclwiOlwicmR3LXJlbW92ZS13cmFwcGVyXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGwoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLGM9bigwKSxzPW8oYyksTT1uKDEpLHU9byhNKSxnPW4oMyksZD1uKDc3KSxwPW8oZCksTj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7dmFyIGUsbixvLGw7aSh0aGlzLHQpO2Zvcih2YXIgYT1hcmd1bWVudHMubGVuZ3RoLGM9QXJyYXkoYSkscz0wO3M8YTtzKyspY1tzXT1hcmd1bWVudHNbc107cmV0dXJuIG49bz1yKHRoaXMsKGU9dC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbC5hcHBseShlLFt0aGlzXS5jb25jYXQoYykpKSxvLnN0YXRlPXtleHBhbmRlZDohMSx1bmRvRGlzYWJsZWQ6ITEscmVkb0Rpc2FibGVkOiExfSxvLm9uRXhwYW5kRXZlbnQ9ZnVuY3Rpb24oKXtvLnNpZ25hbEV4cGFuZGVkPSFvLnN0YXRlLmV4cGFuZGVkfSxvLm9uQ2hhbmdlPWZ1bmN0aW9uKGUpe3ZhciB0PW8ucHJvcHMsbj10LmVkaXRvclN0YXRlLGk9dC5vbkNoYW5nZSxyPWcuRWRpdG9yU3RhdGVbZV0obik7ciYmaShyKX0sby5kb0V4cGFuZD1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiEwfSl9LG8uZG9Db2xsYXBzZT1mdW5jdGlvbigpe28uc2V0U3RhdGUoe2V4cGFuZGVkOiExfSl9LG8uZXhwYW5kQ29sbGFwc2U9ZnVuY3Rpb24oKXtvLnNldFN0YXRlKHtleHBhbmRlZDpvLnNpZ25hbEV4cGFuZGVkfSksby5zaWduYWxFeHBhbmRlZD0hMX0sbD1uLHIobyxsKX1yZXR1cm4gbCh0LGUpLGEodCxbe2tleTpcImNvbXBvbmVudFdpbGxNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcyx0PWUuZWRpdG9yU3RhdGUsbj1lLm1vZGFsSGFuZGxlcjt0JiZ0aGlzLnNldFN0YXRlKHt1bmRvRGlzYWJsZWQ6MD09PXQuZ2V0VW5kb1N0YWNrKCkuc2l6ZSxyZWRvRGlzYWJsZWQ6MD09PXQuZ2V0UmVkb1N0YWNrKCkuc2l6ZX0pLG4ucmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZS5lZGl0b3JTdGF0ZSYmdGhpcy5wcm9wcy5lZGl0b3JTdGF0ZSE9PWUuZWRpdG9yU3RhdGUmJnRoaXMuc2V0U3RhdGUoe3VuZG9EaXNhYmxlZDowPT09ZS5lZGl0b3JTdGF0ZS5nZXRVbmRvU3RhY2soKS5zaXplLHJlZG9EaXNhYmxlZDowPT09ZS5lZGl0b3JTdGF0ZS5nZXRSZWRvU3RhY2soKS5zaXplfSl9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcHMubW9kYWxIYW5kbGVyLmRlcmVnaXN0ZXJDYWxsQmFjayh0aGlzLmV4cGFuZENvbGxhcHNlKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNvbmZpZyxuPWUudHJhbnNsYXRpb25zLG89dGhpcy5zdGF0ZSxpPW8udW5kb0Rpc2FibGVkLHI9by5yZWRvRGlzYWJsZWQsbD1vLmV4cGFuZGVkLGE9dC5jb21wb25lbnR8fHAuZGVmYXVsdDtyZXR1cm4gcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoYSx7Y29uZmlnOnQsdHJhbnNsYXRpb25zOm4sY3VycmVudFN0YXRlOnt1bmRvRGlzYWJsZWQ6aSxyZWRvRGlzYWJsZWQ6cn0sZXhwYW5kZWQ6bCxvbkV4cGFuZEV2ZW50OnRoaXMub25FeHBhbmRFdmVudCxkb0V4cGFuZDp0aGlzLmRvRXhwYW5kLGRvQ29sbGFwc2U6dGhpcy5kb0NvbGxhcHNlLG9uQ2hhbmdlOnRoaXMub25DaGFuZ2V9KX19XSksdH0oYy5Db21wb25lbnQpO04ucHJvcFR5cGVzPXtvbkNoYW5nZTp1LmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLGVkaXRvclN0YXRlOnUuZGVmYXVsdC5vYmplY3QsbW9kYWxIYW5kbGVyOnUuZGVmYXVsdC5vYmplY3QsY29uZmlnOnUuZGVmYXVsdC5vYmplY3QsdHJhbnNsYXRpb25zOnUuZGVmYXVsdC5vYmplY3R9LHQuZGVmYXVsdD1OfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGwoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLGM9bigwKSxzPW8oYyksTT1uKDEpLHU9byhNKSxnPW4oMiksZD1vKGcpLHA9big4KSxOPW4oNSksRD1vKE4pLEk9big3KTtuKDc4KTt2YXIgeT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7dmFyIGUsbixvLGw7aSh0aGlzLHQpO2Zvcih2YXIgYT1hcmd1bWVudHMubGVuZ3RoLGM9QXJyYXkoYSkscz0wO3M8YTtzKyspY1tzXT1hcmd1bWVudHNbc107cmV0dXJuIG49bz1yKHRoaXMsKGU9dC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbC5hcHBseShlLFt0aGlzXS5jb25jYXQoYykpKSxvLm9uQ2hhbmdlPWZ1bmN0aW9uKGUpeygwLG8ucHJvcHMub25DaGFuZ2UpKGUpfSxsPW4scihvLGwpfXJldHVybiBsKHQsZSksYSh0LFt7a2V5OlwicmVuZGVySW5Ecm9wRG93blwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcyx0PWUuY29uZmlnLG49ZS5leHBhbmRlZCxvPWUuZG9FeHBhbmQsaT1lLm9uRXhwYW5kRXZlbnQscj1lLmRvQ29sbGFwc2UsbD1lLmN1cnJlbnRTdGF0ZSxhPWwudW5kb0Rpc2FibGVkLGM9bC5yZWRvRGlzYWJsZWQsTT1lLnRyYW5zbGF0aW9ucyx1PXQub3B0aW9ucyxnPXQudW5kbyxOPXQucmVkbyxEPXQuY2xhc3NOYW1lLHk9dC5kcm9wZG93bkNsYXNzTmFtZSxqPXQudGl0bGU7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEkuRHJvcGRvd24se2NsYXNzTmFtZTooMCxkLmRlZmF1bHQpKFwicmR3LWhpc3RvcnktZHJvcGRvd25cIixEKSxvcHRpb25XcmFwcGVyQ2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoeSksZXhwYW5kZWQ6bixkb0V4cGFuZDpvLGRvQ29sbGFwc2U6cixvbkV4cGFuZEV2ZW50OmksXCJhcmlhLWxhYmVsXCI6XCJyZHctaGlzdG9yeS1jb250cm9sXCIsdGl0bGU6anx8TVtcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS5oaXN0b3J5XCJdfSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6KDAscC5nZXRGaXJzdEljb24pKHQpLGFsdDpcIlwifSksdS5pbmRleE9mKFwidW5kb1wiKT49MCYmcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSS5Ecm9wZG93bk9wdGlvbix7dmFsdWU6XCJ1bmRvXCIsb25DbGljazp0aGlzLm9uQ2hhbmdlLGRpc2FibGVkOmEsY2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoXCJyZHctaGlzdG9yeS1kcm9wZG93bm9wdGlvblwiLGcuY2xhc3NOYW1lKSx0aXRsZTpnLnRpdGxlfHxNW1wiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5LnVuZG9cIl19LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIse3NyYzpnLmljb24sYWx0OlwiXCJ9KSksdS5pbmRleE9mKFwicmVkb1wiKT49MCYmcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSS5Ecm9wZG93bk9wdGlvbix7dmFsdWU6XCJyZWRvXCIsb25DbGljazp0aGlzLm9uQ2hhbmdlLGRpc2FibGVkOmMsY2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoXCJyZHctaGlzdG9yeS1kcm9wZG93bm9wdGlvblwiLE4uY2xhc3NOYW1lKSx0aXRsZTpOLnRpdGxlfHxNW1wiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5LnJlZG9cIl19LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIse3NyYzpOLmljb24sYWx0OlwiXCJ9KSkpfX0se2tleTpcInJlbmRlckluRmxhdExpc3RcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNvbmZpZyxuPXQub3B0aW9ucyxvPXQudW5kbyxpPXQucmVkbyxyPXQuY2xhc3NOYW1lLGw9ZS5jdXJyZW50U3RhdGUsYT1sLnVuZG9EaXNhYmxlZCxjPWwucmVkb0Rpc2FibGVkLE09ZS50cmFuc2xhdGlvbnM7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTooMCxkLmRlZmF1bHQpKFwicmR3LWhpc3Rvcnktd3JhcHBlclwiLHIpLFwiYXJpYS1sYWJlbFwiOlwicmR3LWhpc3RvcnktY29udHJvbFwifSxuLmluZGV4T2YoXCJ1bmRvXCIpPj0wJiZzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChELmRlZmF1bHQse3ZhbHVlOlwidW5kb1wiLG9uQ2xpY2s6dGhpcy5vbkNoYW5nZSxjbGFzc05hbWU6KDAsZC5kZWZhdWx0KShvLmNsYXNzTmFtZSksZGlzYWJsZWQ6YSx0aXRsZTpvLnRpdGxlfHxNW1wiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5LnVuZG9cIl19LHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIse3NyYzpvLmljb24sYWx0OlwiXCJ9KSksbi5pbmRleE9mKFwicmVkb1wiKT49MCYmcy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRC5kZWZhdWx0LHt2YWx1ZTpcInJlZG9cIixvbkNsaWNrOnRoaXMub25DaGFuZ2UsY2xhc3NOYW1lOigwLGQuZGVmYXVsdCkoaS5jbGFzc05hbWUpLGRpc2FibGVkOmMsdGl0bGU6aS50aXRsZXx8TVtcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS5yZWRvXCJdfSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6aS5pY29uLGFsdDpcIlwifSkpKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BzLmNvbmZpZy5pbkRyb3Bkb3duP3RoaXMucmVuZGVySW5Ecm9wRG93bigpOnRoaXMucmVuZGVySW5GbGF0TGlzdCgpfX1dKSx0fShjLkNvbXBvbmVudCk7eS5wcm9wVHlwZXM9e2V4cGFuZGVkOnUuZGVmYXVsdC5ib29sLGRvRXhwYW5kOnUuZGVmYXVsdC5mdW5jLGRvQ29sbGFwc2U6dS5kZWZhdWx0LmZ1bmMsb25FeHBhbmRFdmVudDp1LmRlZmF1bHQuZnVuYyxjb25maWc6dS5kZWZhdWx0Lm9iamVjdCxvbkNoYW5nZTp1LmRlZmF1bHQuZnVuYyxjdXJyZW50U3RhdGU6dS5kZWZhdWx0Lm9iamVjdCx0cmFuc2xhdGlvbnM6dS5kZWZhdWx0Lm9iamVjdH0sdC5kZWZhdWx0PXl9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXtcInJkdy1oaXN0b3J5LXdyYXBwZXJcIjpcInJkdy1oaXN0b3J5LXdyYXBwZXJcIixcInJkdy1oaXN0b3J5LWRyb3Bkb3dub3B0aW9uXCI6XCJyZHctaGlzdG9yeS1kcm9wZG93bm9wdGlvblwiLFwicmR3LWhpc3RvcnktZHJvcGRvd25cIjpcInJkdy1oaXN0b3J5LWRyb3Bkb3duXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIGwoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1mdW5jdGlvbiBhKGUsdCxuKXtlLmZpbmRFbnRpdHlSYW5nZXMoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5nZXRFbnRpdHkoKTtyZXR1cm4gbnVsbCE9PXQmJlwiTElOS1wiPT09bi5nZXRFbnRpdHkodCkuZ2V0VHlwZSgpfSx0KX1mdW5jdGlvbiBjKGUpe3ZhciB0LG4sbz1lLnNob3dPcGVuT3B0aW9uT25Ib3ZlcjtyZXR1cm4gbj10PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZSxuLG8sbDtpKHRoaXMsdCk7Zm9yKHZhciBhPWFyZ3VtZW50cy5sZW5ndGgsYz1BcnJheShhKSxzPTA7czxhO3MrKyljW3NdPWFyZ3VtZW50c1tzXTtyZXR1cm4gbj1vPXIodGhpcywoZT10Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsLmFwcGx5KGUsW3RoaXNdLmNvbmNhdChjKSkpLG8uc3RhdGU9e3Nob3dQb3BPdmVyOiExfSxvLm9wZW5MaW5rPWZ1bmN0aW9uKCl7dmFyIGU9by5wcm9wcyx0PWUuZW50aXR5S2V5LG49ZS5jb250ZW50U3RhdGUsaT1uLmdldEVudGl0eSh0KS5nZXREYXRhKCkscj1pLnVybCxsPXdpbmRvdy5vcGVuKHIsXCJibGFua1wiKTtsJiZsLmZvY3VzKCl9LG8udG9nZ2xlU2hvd1BvcE92ZXI9ZnVuY3Rpb24oKXt2YXIgZT0hby5zdGF0ZS5zaG93UG9wT3ZlcjtvLnNldFN0YXRlKHtzaG93UG9wT3ZlcjplfSl9LGw9bixyKG8sbCl9cmV0dXJuIGwodCxlKSxzKHQsW3trZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLmNoaWxkcmVuLG49ZS5lbnRpdHlLZXksaT1lLmNvbnRlbnRTdGF0ZSxyPWkuZ2V0RW50aXR5KG4pLmdldERhdGEoKSxsPXIudXJsLGE9ci50YXJnZXRPcHRpb24sYz10aGlzLnN0YXRlLnNob3dQb3BPdmVyO3JldHVybiB1LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIix7Y2xhc3NOYW1lOlwicmR3LWxpbmstZGVjb3JhdG9yLXdyYXBwZXJcIixvbk1vdXNlRW50ZXI6dGhpcy50b2dnbGVTaG93UG9wT3Zlcixvbk1vdXNlTGVhdmU6dGhpcy50b2dnbGVTaG93UG9wT3Zlcn0sdS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJhXCIse2hyZWY6bCx0YXJnZXQ6YX0sdCksYyYmbz91LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLHtzcmM6Ti5kZWZhdWx0LGFsdDpcIlwiLG9uQ2xpY2s6dGhpcy5vcGVuTGluayxjbGFzc05hbWU6XCJyZHctbGluay1kZWNvcmF0b3ItaWNvblwifSk6dm9pZCAwKX19XSksdH0oTS5Db21wb25lbnQpLHQucHJvcFR5cGVzPXtlbnRpdHlLZXk6ZC5kZWZhdWx0LnN0cmluZy5pc1JlcXVpcmVkLGNoaWxkcmVuOmQuZGVmYXVsdC5hcnJheSxjb250ZW50U3RhdGU6ZC5kZWZhdWx0Lm9iamVjdH0sbn1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLE09bigwKSx1PW8oTSksZz1uKDEpLGQ9byhnKSxwPW4oODApLE49byhwKTtuKDgxKSx0LmRlZmF1bHQ9ZnVuY3Rpb24oZSl7cmV0dXJue3N0cmF0ZWd5OmEsY29tcG9uZW50OmMoZSl9fX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9XCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlWVlJHTFRnaUlITjBZVzVrWVd4dmJtVTlJbTV2SWo4K0NqeHpkbWNnZDJsa2RHZzlJakUxY0hnaUlHaGxhV2RvZEQwaU1UVndlQ0lnZG1sbGQwSnZlRDBpTUNBd0lERTFJREUxSWlCMlpYSnphVzl1UFNJeExqRWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaVBnb2dJQ0FnUENFdExTQkhaVzVsY21GMGIzSTZJRk5yWlhSamFDQTBNQzR6SUNnek16Z3pPU2tnTFNCb2RIUndPaTh2ZDNkM0xtSnZhR1Z0YVdGdVkyOWthVzVuTG1OdmJTOXphMlYwWTJnZ0xTMCtDaUFnSUNBOGRHbDBiR1UrYjNCbGJteHBibXM4TDNScGRHeGxQZ29nSUNBZ1BHUmxjMk0rUTNKbFlYUmxaQ0IzYVhSb0lGTnJaWFJqYUM0OEwyUmxjMk0rQ2lBZ0lDQThaR1ZtY3o0OEwyUmxabk0rQ2lBZ0lDQThaeUJwWkQwaVVHRm5aUzB4SWlCemRISnZhMlU5SW01dmJtVWlJSE4wY205clpTMTNhV1IwYUQwaU1TSWdabWxzYkQwaWJtOXVaU0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWo0S0lDQWdJQ0FnSUNBOFp5QnBaRDBpYjNCbGJteHBibXNpSUdacGJHdzlJaU13TURBd01EQWlQZ29nSUNBZ0lDQWdJQ0FnSUNBOFp5QnBaRDBpUTJGd1lWOHhJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHhuSUdsa1BTSkhjbTkxY0NJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEJoZEdnZ1pEMGlUVEUwTGpBM01UVTRORFVzTUNCTU9DNDVNVFV6TXpRMU1Td3dJRU00TGpRd05UWTFNVFF4TERBZ055NDVPVEV3TXpnM015d3dMalF4TkRZMk5UUTVNeUEzTGprNU1UQXpPRGN6TERBdU9USTBNamsxTnpjMUlFTTNMams1TVRBek9EY3pMREV1TkRNek9USTJNRFlnT0M0ME1EVTJOVEUwTVN3eExqZzBPRFU1TVRVMUlEZ3VPVEUxTXpNME5URXNNUzQ0TkRnMU9URTFOU0JNTVRFdU9EUXdNVGMyTVN3eExqZzBPRFU1TVRVMUlFdzJMamsyTVRJeE5EYzVMRFl1TnpJM05TQkROaTQzT0RZMU5Ea3pMRFl1T1RBeU1EVTVPRFlnTmk0Mk9UQTBNakkxTkN3M0xqRXpOREV6TnpNeUlEWXVOamt3TkRJeU5UUXNOeTR6T0RFeE1Ea3hOU0JETmk0Mk9UQTBNakkxTkN3M0xqWXlPREE0TURrNUlEWXVOemcyTkRrMk5EZ3NOeTQ0TmpBeE1EVTJNeUEyTGprMk1URXdPVEUxTERndU1ETTBOVEEzTURRZ1F6Y3VNVE0xTnpJeE9ETXNPQzR5TURreU56Z3hOeUEzTGpNMk56YzBOalE0TERndU16QTFORFUzTnpVZ055NDJNVFEzTVRnek1TdzRMak13TlRRMU56YzFJRU0zTGpnMk1UVTRORFV4TERndU16QTFORFUzTnpVZ09DNHdPVE0zTVRRM09TdzRMakl3T1RNek1EazVJRGd1TWpZNE16Z3dNamdzT0M0d016UTJOalUwT1NCTU1UTXVNVFEzTWpnNE55d3pMakUxTlRjd05ESXpJRXd4TXk0eE5EY3lPRGczTERZdU1EZ3dOVFExTnpjZ1F6RXpMakUwTnpJNE9EY3NOaTQxT1RBeE56WXdOaUF4TXk0MU5qRTVOVFF5TERjdU1EQTBPRFF4TlRVZ01UUXVNRGN4TlRnME5TdzNMakF3TkRnME1UVTFJRU14TkM0MU9ERXlNVFE0TERjdU1EQTBPRFF4TlRVZ01UUXVPVGsxT0Rnd015dzJMalU1TURFM05qQTJJREUwTGprNU5UZzRNRE1zTmk0d09EQTFORFUzTnlCTU1UUXVPVGsxT0Rnd015d3dMamt5TkRJNU5UYzNOU0JETVRRdU9UazFPRGd3TXl3d0xqUXhORFkyTlRRNU15QXhOQzQxT0RFeU1UUTRMREFnTVRRdU1EY3hOVGcwTlN3d0lFd3hOQzR3TnpFMU9EUTFMREFnV2lJZ2FXUTlJbE5vWVhCbElqNDhMM0JoZEdnK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEJoZEdnZ1pEMGlUVEV3TGpZeU16UXpNekVzTVRNdU5ERXhNemN6TWlCTU1TNDFPRFExTURjd05Dd3hNeTQwTVRFek56TXlJRXd4TGpVNE5EVXdOekEwTERRdU16Y3lORFEzTVRnZ1REZ3VNemd5TmpJek1qUXNOQzR6TnpJME5EY3hPQ0JNT1M0NU5qY3hNekF5T0N3eUxqYzROemswTURFMElFd3dMamM1TWpJMU16VXlNU3d5TGpjNE56azBNREUwSUVNd0xqTTFORGN4T0RNeExESXVOemczT1RRd01UUWdNQ3d6TGpFME1qWTFPRFExSURBc015NDFPREF4T1RNMk5pQk1NQ3d4TkM0eU1ETTJNalk0SUVNd0xERTBMalkwTVRFMk1pQXdMak0xTkRjeE9ETXhMREUwTGprNU5UZzRNRE1nTUM0M09USXlOVE0xTWpFc01UUXVPVGsxT0Rnd015Qk1NVEV1TkRFMU5qZzJOaXd4TkM0NU9UVTRPREF6SUVNeE1TNDROVE15TWpFNExERTBMams1TlRnNE1ETWdNVEl1TWpBM09UUXdNU3d4TkM0Mk5ERXhOaklnTVRJdU1qQTNPVFF3TVN3eE5DNHlNRE0yTWpZNElFd3hNaTR5TURjNU5EQXhMRFV1TURJNE56VWdUREV3TGpZeU16UXpNekVzTmk0Mk1UTXlOVGN3TkNCTU1UQXVOakl6TkRNek1Td3hNeTQwTVRFek56TXlJRXd4TUM0Mk1qTTBNek14TERFekxqUXhNVE0zTXpJZ1dpSWdhV1E5SWxOb1lYQmxJajQ4TDNCaGRHZytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThMMmMrQ2lBZ0lDQWdJQ0FnSUNBZ0lEd3ZaejRLSUNBZ0lDQWdJQ0E4TDJjK0NpQWdJQ0E4TDJjK0Nqd3ZjM1puUGc9PVwifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz17XCJyZHctbGluay1kZWNvcmF0b3Itd3JhcHBlclwiOlwicmR3LWxpbmstZGVjb3JhdG9yLXdyYXBwZXJcIixcInJkdy1saW5rLWRlY29yYXRvci1pY29uXCI6XCJyZHctbGluay1kZWNvcmF0b3ItaWNvblwifX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fXZhciBpPW4oODMpLHI9byhpKSxsPW4oODUpLGE9byhsKSxjPWZ1bmN0aW9uKGUpe3JldHVybltuZXcgci5kZWZhdWx0KGUubWVudGlvbkNsYXNzTmFtZSkuZ2V0TWVudGlvbkRlY29yYXRvcigpLG5ldyBhLmRlZmF1bHQoZSkuZ2V0U3VnZ2VzdGlvbkRlY29yYXRvcigpXX07ZS5leHBvcnRzPWN9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX12YXIgcj1uKDApLGw9byhyKSxhPW4oMSksYz1vKGEpLHM9bigyKSxNPW8ocyk7big4NCk7dmFyIHU9ZnVuY3Rpb24gZSh0KXtpKHRoaXMsZSksZy5jYWxsKHRoaXMpLHRoaXMuY2xhc3NOYW1lPXR9LGc9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuZ2V0TWVudGlvbkNvbXBvbmVudD1mdW5jdGlvbigpe3ZhciB0PWUuY2xhc3NOYW1lLG49ZnVuY3Rpb24oZSl7dmFyIG49ZS5lbnRpdHlLZXksbz1lLmNoaWxkcmVuLGk9ZS5jb250ZW50U3RhdGUscj1pLmdldEVudGl0eShuKS5nZXREYXRhKCksYT1yLnVybCxjPXIudmFsdWU7cmV0dXJuIGwuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYVwiLHtocmVmOmF8fGMsY2xhc3NOYW1lOigwLE0uZGVmYXVsdCkoXCJyZHctbWVudGlvbi1saW5rXCIsdCl9LG8pfTtyZXR1cm4gbi5wcm9wVHlwZXM9e2VudGl0eUtleTpjLmRlZmF1bHQubnVtYmVyLGNoaWxkcmVuOmMuZGVmYXVsdC5hcnJheSxjb250ZW50U3RhdGU6Yy5kZWZhdWx0Lm9iamVjdH0sbn0sdGhpcy5nZXRNZW50aW9uRGVjb3JhdG9yPWZ1bmN0aW9uKCl7cmV0dXJue3N0cmF0ZWd5OmUuZmluZE1lbnRpb25FbnRpdGllcyxjb21wb25lbnQ6ZS5nZXRNZW50aW9uQ29tcG9uZW50KCl9fX07dS5wcm90b3R5cGUuZmluZE1lbnRpb25FbnRpdGllcz1mdW5jdGlvbihlLHQsbil7ZS5maW5kRW50aXR5UmFuZ2VzKGZ1bmN0aW9uKGUpe3ZhciB0PWUuZ2V0RW50aXR5KCk7cmV0dXJuIG51bGwhPT10JiZcIk1FTlRJT05cIj09PW4uZ2V0RW50aXR5KHQpLmdldFR5cGUoKX0sdCl9LGUuZXhwb3J0cz11fSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz17XCJyZHctbWVudGlvbi1saW5rXCI6XCJyZHctbWVudGlvbi1saW5rXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIHIoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1mdW5jdGlvbiBsKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBhKCl7dmFyIGUsdCxuPXRoaXMuY29uZmlnO3JldHVybiB0PWU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlLG8scixhO2wodGhpcyx0KTtmb3IodmFyIGM9YXJndW1lbnRzLmxlbmd0aCxzPUFycmF5KGMpLE09MDtNPGM7TSsrKXNbTV09YXJndW1lbnRzW01dO3JldHVybiBvPXI9aSh0aGlzLChlPXQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KHMpKSksci5zdGF0ZT17c3R5bGU6e2xlZnQ6MTV9LGFjdGl2ZU9wdGlvbjotMSxzaG93U3VnZ2VzdGlvbnM6ITB9LHIub25FZGl0b3JLZXlEb3duPWZ1bmN0aW9uKGUpe3ZhciB0PXIuc3RhdGUuYWN0aXZlT3B0aW9uLG49e307XCJBcnJvd0Rvd25cIj09PWUua2V5PyhlLnByZXZlbnREZWZhdWx0KCksdD09PXIuZmlsdGVyZWRTdWdnZXN0aW9ucy5sZW5ndGgtMT9uLmFjdGl2ZU9wdGlvbj0wOm4uYWN0aXZlT3B0aW9uPXQrMSk6XCJBcnJvd1VwXCI9PT1lLmtleT9uLmFjdGl2ZU9wdGlvbj10PD0wP3IuZmlsdGVyZWRTdWdnZXN0aW9ucy5sZW5ndGgtMTp0LTE6XCJFc2NhcGVcIj09PWUua2V5PyhuLnNob3dTdWdnZXN0aW9ucz0hMSxmLmRlZmF1bHQuY2xvc2UoKSk6XCJFbnRlclwiPT09ZS5rZXkmJnIuYWRkTWVudGlvbigpLHIuc2V0U3RhdGUobil9LHIub25PcHRpb25Nb3VzZUVudGVyPWZ1bmN0aW9uKGUpe3ZhciB0PWUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtaW5kZXhcIik7ci5zZXRTdGF0ZSh7YWN0aXZlT3B0aW9uOnR9KX0sci5vbk9wdGlvbk1vdXNlTGVhdmU9ZnVuY3Rpb24oKXtyLnNldFN0YXRlKHthY3RpdmVPcHRpb246LTF9KX0sci5zZXRTdWdnZXN0aW9uUmVmZXJlbmNlPWZ1bmN0aW9uKGUpe3Iuc3VnZ2VzdGlvbj1lfSxyLnNldERyb3Bkb3duUmVmZXJlbmNlPWZ1bmN0aW9uKGUpe3IuZHJvcGRvd249ZX0sci5jbG9zZVN1Z2dlc3Rpb25Ecm9wZG93bj1mdW5jdGlvbigpe3Iuc2V0U3RhdGUoe3Nob3dTdWdnZXN0aW9uczohMX0pfSxyLmZpbHRlcmVkU3VnZ2VzdGlvbnM9W10sci5maWx0ZXJTdWdnZXN0aW9ucz1mdW5jdGlvbihlKXt2YXIgdD1lLmNoaWxkcmVuWzBdLnByb3BzLnRleHQuc3Vic3RyKDEpLG89bi5nZXRTdWdnZXN0aW9ucygpO3IuZmlsdGVyZWRTdWdnZXN0aW9ucz1vJiZvLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4hdHx8MD09PXQubGVuZ3RofHwobi5jYXNlU2Vuc2l0aXZlP2UudmFsdWUuaW5kZXhPZih0KT49MDplLnZhbHVlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0JiZ0LnRvTG93ZXJDYXNlKCkpPj0wKX0pfSxyLmFkZE1lbnRpb249ZnVuY3Rpb24oKXt2YXIgZT1yLnN0YXRlLmFjdGl2ZU9wdGlvbix0PW4uZ2V0RWRpdG9yU3RhdGUoKSxvPW4ub25DaGFuZ2UsaT1uLnNlcGFyYXRvcixsPW4udHJpZ2dlcixhPXIuZmlsdGVyZWRTdWdnZXN0aW9uc1tlXTthJiYoMCxELmRlZmF1bHQpKHQsbyxpLGwsYSl9LGE9byxpKHIsYSl9cmV0dXJuIHIodCxlKSxjKHQsW3trZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9bi5nZXRXcmFwcGVyUmVmKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksdD10aGlzLnN1Z2dlc3Rpb24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbz10aGlzLmRyb3Bkb3duLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGk9dm9pZCAwLHI9dm9pZCAwLGw9dm9pZCAwO2Uud2lkdGg8dC5sZWZ0LWUubGVmdCtvLndpZHRoP3I9MTU6aT0xNSxlLmJvdHRvbTxvLmJvdHRvbSYmKGw9MCksdGhpcy5zZXRTdGF0ZSh7c3R5bGU6e2xlZnQ6aSxyaWdodDpyLGJvdHRvbTpsfX0pLHkuZGVmYXVsdC5yZWdpc3RlckNhbGxCYWNrKHRoaXMub25FZGl0b3JLZXlEb3duKSxmLmRlZmF1bHQub3BlbigpLG4ubW9kYWxIYW5kbGVyLnNldFN1Z2dlc3Rpb25DYWxsYmFjayh0aGlzLmNsb3NlU3VnZ2VzdGlvbkRyb3Bkb3duKSx0aGlzLmZpbHRlclN1Z2dlc3Rpb25zKHRoaXMucHJvcHMpfX0se2tleTpcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnByb3BzLmNoaWxkcmVuIT09ZS5jaGlsZHJlbiYmKHRoaXMuZmlsdGVyU3VnZ2VzdGlvbnMoZSksdGhpcy5zZXRTdGF0ZSh7c2hvd1N1Z2dlc3Rpb25zOiEwfSkpfX0se2tleTpcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt5LmRlZmF1bHQuZGVyZWdpc3RlckNhbGxCYWNrKHRoaXMub25FZGl0b3JLZXlEb3duKSxmLmRlZmF1bHQuY2xvc2UoKSxuLm1vZGFsSGFuZGxlci5yZW1vdmVTdWdnZXN0aW9uQ2FsbGJhY2soKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLnByb3BzLmNoaWxkcmVuLG89dGhpcy5zdGF0ZSxpPW8uYWN0aXZlT3B0aW9uLHI9by5zaG93U3VnZ2VzdGlvbnMsbD1uLmRyb3Bkb3duQ2xhc3NOYW1lLGE9bi5vcHRpb25DbGFzc05hbWU7cmV0dXJuIE0uZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtjbGFzc05hbWU6XCJyZHctc3VnZ2VzdGlvbi13cmFwcGVyXCIscmVmOnRoaXMuc2V0U3VnZ2VzdGlvblJlZmVyZW5jZSxvbkNsaWNrOm4ubW9kYWxIYW5kbGVyLm9uU3VnZ2VzdGlvbkNsaWNrLFwiYXJpYS1oYXNwb3B1cFwiOlwidHJ1ZVwiLFwiYXJpYS1sYWJlbFwiOlwicmR3LXN1Z2dlc3Rpb24tcG9wdXBcIn0sTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCx0KSxyJiZNLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIix7Y2xhc3NOYW1lOigwLHAuZGVmYXVsdCkoXCJyZHctc3VnZ2VzdGlvbi1kcm9wZG93blwiLGwpLGNvbnRlbnRFZGl0YWJsZTpcImZhbHNlXCIsc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiEwLHN0eWxlOnRoaXMuc3RhdGUuc3R5bGUscmVmOnRoaXMuc2V0RHJvcGRvd25SZWZlcmVuY2V9LHRoaXMuZmlsdGVyZWRTdWdnZXN0aW9ucy5tYXAoZnVuY3Rpb24odCxuKXtyZXR1cm4gTS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse2tleTpuLHNwZWxsQ2hlY2s6ITEsb25DbGljazplLmFkZE1lbnRpb24sXCJkYXRhLWluZGV4XCI6bixvbk1vdXNlRW50ZXI6ZS5vbk9wdGlvbk1vdXNlRW50ZXIsb25Nb3VzZUxlYXZlOmUub25PcHRpb25Nb3VzZUxlYXZlLGNsYXNzTmFtZTooMCxwLmRlZmF1bHQpKFwicmR3LXN1Z2dlc3Rpb24tb3B0aW9uXCIsYSx7XCJyZHctc3VnZ2VzdGlvbi1vcHRpb24tYWN0aXZlXCI6bj09PWl9KX0sdC50ZXh0KX0pKSl9fV0pLHR9KHMuQ29tcG9uZW50KSxlLnByb3BUeXBlcz17Y2hpbGRyZW46Zy5kZWZhdWx0LmFycmF5fSx0fXZhciBjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCkscz1uKDApLE09byhzKSx1PW4oMSksZz1vKHUpLGQ9bigyKSxwPW8oZCksTj1uKDg2KSxEPW8oTiksST1uKDExKSx5PW8oSSksaj1uKDEyKSxmPW8oaik7big4Nyk7dmFyIHc9ZnVuY3Rpb24gZSh0KXtsKHRoaXMsZSksbS5jYWxsKHRoaXMpO3ZhciBuPXQuc2VwYXJhdG9yLG89dC50cmlnZ2VyLGk9dC5nZXRTdWdnZXN0aW9ucyxyPXQub25DaGFuZ2UsYT10LmdldEVkaXRvclN0YXRlLGM9dC5nZXRXcmFwcGVyUmVmLHM9dC5jYXNlU2Vuc2l0aXZlLE09dC5kcm9wZG93bkNsYXNzTmFtZSx1PXQub3B0aW9uQ2xhc3NOYW1lLGc9dC5tb2RhbEhhbmRsZXI7dGhpcy5jb25maWc9e3NlcGFyYXRvcjpuLHRyaWdnZXI6byxnZXRTdWdnZXN0aW9uczppLG9uQ2hhbmdlOnIsZ2V0RWRpdG9yU3RhdGU6YSxnZXRXcmFwcGVyUmVmOmMsY2FzZVNlbnNpdGl2ZTpzLGRyb3Bkb3duQ2xhc3NOYW1lOk0sb3B0aW9uQ2xhc3NOYW1lOnUsbW9kYWxIYW5kbGVyOmd9fSxtPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLmZpbmRTdWdnZXN0aW9uRW50aXRpZXM9ZnVuY3Rpb24odCxuKXtpZihlLmNvbmZpZy5nZXRFZGl0b3JTdGF0ZSgpKXt2YXIgbz1lLmNvbmZpZyxpPW8uc2VwYXJhdG9yLHI9by50cmlnZ2VyLGw9by5nZXRTdWdnZXN0aW9ucyxhPW8uZ2V0RWRpdG9yU3RhdGUsYz1hKCkuZ2V0U2VsZWN0aW9uKCk7aWYoYy5nZXQoXCJhbmNob3JLZXlcIik9PT10LmdldChcImtleVwiKSYmYy5nZXQoXCJhbmNob3JLZXlcIik9PT1jLmdldChcImZvY3VzS2V5XCIpKXt2YXIgcz10LmdldFRleHQoKTtzPXMuc3Vic3RyKDAsYy5nZXQoXCJmb2N1c09mZnNldFwiKT09PXMubGVuZ3RoLTE/cy5sZW5ndGg6Yy5nZXQoXCJmb2N1c09mZnNldFwiKSsxKTt2YXIgTT1zLmxhc3RJbmRleE9mKGkrciksdT1pK3I7aWYoKHZvaWQgMD09PU18fE08MCkmJnNbMF09PT1yJiYoTT0wLHU9ciksTT49MCl7dmFyIGc9cy5zdWJzdHIoTSt1Lmxlbmd0aCxzLmxlbmd0aCk7bCgpLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuISF0LnZhbHVlJiYoZS5jb25maWcuY2FzZVNlbnNpdGl2ZT90LnZhbHVlLmluZGV4T2YoZyk+PTA6dC52YWx1ZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoZyYmZy50b0xvd2VyQ2FzZSgpKT49MCl9KSYmbigwPT09TT8wOk0rMSxzLmxlbmd0aCl9fX19LHRoaXMuZ2V0U3VnZ2VzdGlvbkNvbXBvbmVudD1hLmJpbmQodGhpcyksdGhpcy5nZXRTdWdnZXN0aW9uRGVjb3JhdG9yPWZ1bmN0aW9uKCl7cmV0dXJue3N0cmF0ZWd5OmUuZmluZFN1Z2dlc3Rpb25FbnRpdGllcyxjb21wb25lbnQ6ZS5nZXRTdWdnZXN0aW9uQ29tcG9uZW50KCl9fX07ZS5leHBvcnRzPXd9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUsdCxuLG8sbCl7dmFyIGE9bC52YWx1ZSxjPWwudXJsLHM9ZS5nZXRDdXJyZW50Q29udGVudCgpLmNyZWF0ZUVudGl0eShcIk1FTlRJT05cIixcIklNTVVUQUJMRVwiLHt0ZXh0OlwiXCIrbythLHZhbHVlOmEsdXJsOmN9KS5nZXRMYXN0Q3JlYXRlZEVudGl0eUtleSgpLE09KDAsci5nZXRTZWxlY3RlZEJsb2NrKShlKSx1PU0uZ2V0VGV4dCgpLGc9ZS5nZXRTZWxlY3Rpb24oKS5mb2N1c09mZnNldCxkPSh1Lmxhc3RJbmRleE9mKG4rbyxnKXx8MCkrMSxwPSExO3UubGVuZ3RoPT09ZCsxJiYoZz11Lmxlbmd0aCksXCIgXCI9PT11W2ddJiYocD0hMCk7dmFyIE49ZS5nZXRTZWxlY3Rpb24oKS5tZXJnZSh7YW5jaG9yT2Zmc2V0OmQsZm9jdXNPZmZzZXQ6Z30pLEQ9aS5FZGl0b3JTdGF0ZS5hY2NlcHRTZWxlY3Rpb24oZSxOKSxJPWkuTW9kaWZpZXIucmVwbGFjZVRleHQoRC5nZXRDdXJyZW50Q29udGVudCgpLE4sXCJcIitvK2EsRC5nZXRDdXJyZW50SW5saW5lU3R5bGUoKSxzKTtEPWkuRWRpdG9yU3RhdGUucHVzaChELEksXCJpbnNlcnQtY2hhcmFjdGVyc1wiKSxwfHwoTj1ELmdldFNlbGVjdGlvbigpLm1lcmdlKHthbmNob3JPZmZzZXQ6ZCthLmxlbmd0aCtvLmxlbmd0aCxmb2N1c09mZnNldDpkK2EubGVuZ3RoK28ubGVuZ3RofSksRD1pLkVkaXRvclN0YXRlLmFjY2VwdFNlbGVjdGlvbihELE4pLEk9aS5Nb2RpZmllci5pbnNlcnRUZXh0KEQuZ2V0Q3VycmVudENvbnRlbnQoKSxOLFwiIFwiLEQuZ2V0Q3VycmVudElubGluZVN0eWxlKCksdm9pZCAwKSksdChpLkVkaXRvclN0YXRlLnB1c2goRCxJLFwiaW5zZXJ0LWNoYXJhY3RlcnNcIikpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1vO3ZhciBpPW4oMykscj1uKDQpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz17XCJyZHctc3VnZ2VzdGlvbi13cmFwcGVyXCI6XCJyZHctc3VnZ2VzdGlvbi13cmFwcGVyXCIsXCJyZHctc3VnZ2VzdGlvbi1kcm9wZG93blwiOlwicmR3LXN1Z2dlc3Rpb24tZHJvcGRvd25cIixcInJkdy1zdWdnZXN0aW9uLW9wdGlvblwiOlwicmR3LXN1Z2dlc3Rpb24tb3B0aW9uXCIsXCJyZHctc3VnZ2VzdGlvbi1vcHRpb24tYWN0aXZlXCI6XCJyZHctc3VnZ2VzdGlvbi1vcHRpb24tYWN0aXZlXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9dmFyIHI9bigwKSxsPW8ociksYT1uKDEpLGM9byhhKSxzPW4oMiksTT1vKHMpO24oODkpO3ZhciB1PWZ1bmN0aW9uIGUodCl7dmFyIG49dGhpcztpKHRoaXMsZSksdGhpcy5nZXRIYXNodGFnQ29tcG9uZW50PWZ1bmN0aW9uKCl7dmFyIGU9bi5jbGFzc05hbWUsdD1mdW5jdGlvbih0KXt2YXIgbj10LmNoaWxkcmVuLG89blswXS5wcm9wcy50ZXh0O3JldHVybiBsLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIix7aHJlZjpvLGNsYXNzTmFtZTooMCxNLmRlZmF1bHQpKFwicmR3LWhhc2h0YWctbGlua1wiLGUpfSxuKX07cmV0dXJuIHQucHJvcFR5cGVzPXtjaGlsZHJlbjpjLmRlZmF1bHQub2JqZWN0fSx0fSx0aGlzLmZpbmRIYXNodGFnRW50aXRpZXM9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG89ZS5nZXRUZXh0KCksaT0wLHI9MDtvLmxlbmd0aD4wJiZpPj0wOylpZihvWzBdPT09bi5oYXNoQ2hhcmFjdGVyPyhpPTAscj0wLG89by5zdWJzdHIobi5oYXNoQ2hhcmFjdGVyLmxlbmd0aCkpOihpPW8uaW5kZXhPZihuLnNlcGFyYXRvcituLmhhc2hDaGFyYWN0ZXIpKT49MCYmKG89by5zdWJzdHIoaSsobi5zZXBhcmF0b3Irbi5oYXNoQ2hhcmFjdGVyKS5sZW5ndGgpLHIrPWkrbi5zZXBhcmF0b3IubGVuZ3RoKSxpPj0wKXt2YXIgbD1vLmluZGV4T2Yobi5zZXBhcmF0b3IpPj0wP28uaW5kZXhPZihuLnNlcGFyYXRvcik6by5sZW5ndGgsYT1vLnN1YnN0cigwLGwpO2EmJmEubGVuZ3RoPjAmJih0KHIscithLmxlbmd0aCtuLmhhc2hDaGFyYWN0ZXIubGVuZ3RoKSxyKz1uLmhhc2hDaGFyYWN0ZXIubGVuZ3RoKX19LHRoaXMuZ2V0SGFzaHRhZ0RlY29yYXRvcj1mdW5jdGlvbigpe3JldHVybntzdHJhdGVneTpuLmZpbmRIYXNodGFnRW50aXRpZXMsY29tcG9uZW50Om4uZ2V0SGFzaHRhZ0NvbXBvbmVudCgpfX0sdGhpcy5jbGFzc05hbWU9dC5jbGFzc05hbWUsdGhpcy5oYXNoQ2hhcmFjdGVyPXQuaGFzaENoYXJhY3Rlcnx8XCIjXCIsdGhpcy5zZXBhcmF0b3I9dC5zZXBhcmF0b3J8fFwiIFwifSxnPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdShlKS5nZXRIYXNodGFnRGVjb3JhdG9yKCl9O2UuZXhwb3J0cz1nfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz17XCJyZHctaGFzaHRhZy1saW5rXCI6XCJyZHctaGFzaHRhZy1saW5rXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9big5MSkscj1vKGkpLGw9big5MiksYT1vKGwpLGM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24obil7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdCl7dmFyIG89dChuLGUsZS5nZXRFZGl0b3JTdGF0ZSk7aWYobylyZXR1cm4gb31pZihcImF0b21pY1wiPT09bi5nZXRUeXBlKCkpe3ZhciBpPWUuZ2V0RWRpdG9yU3RhdGUoKS5nZXRDdXJyZW50Q29udGVudCgpLGw9aS5nZXRFbnRpdHkobi5nZXRFbnRpdHlBdCgwKSk7aWYobCYmXCJJTUFHRVwiPT09bC50eXBlKXJldHVybntjb21wb25lbnQ6KDAsYS5kZWZhdWx0KShlKSxlZGl0YWJsZTohMX07aWYobCYmXCJFTUJFRERFRF9MSU5LXCI9PT1sLnR5cGUpcmV0dXJue2NvbXBvbmVudDpyLmRlZmF1bHQsZWRpdGFibGU6ITF9fX19O3QuZGVmYXVsdD1jfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9bigwKSxyPW8oaSksbD1uKDEpLGE9byhsKSxjPWZ1bmN0aW9uKGUpe3ZhciB0PWUuYmxvY2ssbj1lLmNvbnRlbnRTdGF0ZSxvPW4uZ2V0RW50aXR5KHQuZ2V0RW50aXR5QXQoMCkpLGk9by5nZXREYXRhKCksbD1pLnNyYyxhPWkuaGVpZ2h0LGM9aS53aWR0aDtyZXR1cm4gci5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIix7aGVpZ2h0OmEsd2lkdGg6YyxzcmM6bCxmcmFtZUJvcmRlcjpcIjBcIixhbGxvd0Z1bGxTY3JlZW46ITAsdGl0bGU6XCJXeXNpd3lnIEVtYmVkZGVkIENvbnRlbnRcIn0pfTtjLnByb3BUeXBlcz17YmxvY2s6YS5kZWZhdWx0Lm9iamVjdCxjb250ZW50U3RhdGU6YS5kZWZhdWx0Lm9iamVjdH0sdC5kZWZhdWx0PWN9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiByKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gbChlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCksYz1uKDApLHM9byhjKSxNPW4oMSksdT1vKE0pLGc9bigzKSxkPW4oMikscD1vKGQpLE49big1KSxEPW8oTik7big5Myk7dmFyIEk9ZnVuY3Rpb24oZSl7dmFyIHQsbjtyZXR1cm4gbj10PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oKXt2YXIgdCxvLGwsYTtpKHRoaXMsbik7Zm9yKHZhciBjPWFyZ3VtZW50cy5sZW5ndGgscz1BcnJheShjKSxNPTA7TTxjO00rKylzW01dPWFyZ3VtZW50c1tNXTtyZXR1cm4gbz1sPXIodGhpcywodD1uLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKG4pKS5jYWxsLmFwcGx5KHQsW3RoaXNdLmNvbmNhdChzKSkpLGwuc3RhdGU9e2hvdmVyZWQ6ITF9LGwuc2V0RW50aXR5QWxpZ25tZW50TGVmdD1mdW5jdGlvbigpe2wuc2V0RW50aXR5QWxpZ25tZW50KFwibGVmdFwiKX0sbC5zZXRFbnRpdHlBbGlnbm1lbnRSaWdodD1mdW5jdGlvbigpe2wuc2V0RW50aXR5QWxpZ25tZW50KFwicmlnaHRcIil9LGwuc2V0RW50aXR5QWxpZ25tZW50Q2VudGVyPWZ1bmN0aW9uKCl7bC5zZXRFbnRpdHlBbGlnbm1lbnQoXCJub25lXCIpfSxsLnNldEVudGl0eUFsaWdubWVudD1mdW5jdGlvbih0KXt2YXIgbj1sLnByb3BzLG89bi5ibG9jayxpPW4uY29udGVudFN0YXRlLHI9by5nZXRFbnRpdHlBdCgwKTtpLm1lcmdlRW50aXR5RGF0YShyLHthbGlnbm1lbnQ6dH0pLGUub25DaGFuZ2UoZy5FZGl0b3JTdGF0ZS5wdXNoKGUuZ2V0RWRpdG9yU3RhdGUoKSxpLFwiY2hhbmdlLWJsb2NrLWRhdGFcIikpLGwuc2V0U3RhdGUoe2R1bW15OiEwfSl9LGwudG9nZ2xlSG92ZXJlZD1mdW5jdGlvbigpe3ZhciBlPSFsLnN0YXRlLmhvdmVyZWQ7bC5zZXRTdGF0ZSh7aG92ZXJlZDplfSl9LGE9byxyKGwsYSl9cmV0dXJuIGwobix0KSxhKG4sW3trZXk6XCJyZW5kZXJBbGlnbm1lbnRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTooMCxwLmRlZmF1bHQpKFwicmR3LWltYWdlLWFsaWdubWVudC1vcHRpb25zLXBvcHVwXCIse1wicmR3LWltYWdlLWFsaWdubWVudC1vcHRpb25zLXBvcHVwLXJpZ2h0XCI6XCJyaWdodFwiPT09ZX0pfSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChELmRlZmF1bHQse29uQ2xpY2s6dGhpcy5zZXRFbnRpdHlBbGlnbm1lbnRMZWZ0LGNsYXNzTmFtZTpcInJkdy1pbWFnZS1hbGlnbm1lbnQtb3B0aW9uXCJ9LFwiTFwiKSxzLmRlZmF1bHQuY3JlYXRlRWxlbWVudChELmRlZmF1bHQse29uQ2xpY2s6dGhpcy5zZXRFbnRpdHlBbGlnbm1lbnRDZW50ZXIsY2xhc3NOYW1lOlwicmR3LWltYWdlLWFsaWdubWVudC1vcHRpb25cIn0sXCJDXCIpLHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEQuZGVmYXVsdCx7b25DbGljazp0aGlzLnNldEVudGl0eUFsaWdubWVudFJpZ2h0LGNsYXNzTmFtZTpcInJkdy1pbWFnZS1hbGlnbm1lbnQtb3B0aW9uXCJ9LFwiUlwiKSl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb3BzLG49dC5ibG9jayxvPXQuY29udGVudFN0YXRlLGk9dGhpcy5zdGF0ZS5ob3ZlcmVkLHI9ZS5pc1JlYWRPbmx5LGw9ZS5pc0ltYWdlQWxpZ25tZW50RW5hYmxlZCxhPW8uZ2V0RW50aXR5KG4uZ2V0RW50aXR5QXQoMCkpLGM9YS5nZXREYXRhKCksTT1jLnNyYyx1PWMuYWxpZ25tZW50LGc9Yy5oZWlnaHQsZD1jLndpZHRoLE49Yy5hbHQ7cmV0dXJuIHMuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtvbk1vdXNlRW50ZXI6dGhpcy50b2dnbGVIb3ZlcmVkLG9uTW91c2VMZWF2ZTp0aGlzLnRvZ2dsZUhvdmVyZWQsY2xhc3NOYW1lOigwLHAuZGVmYXVsdCkoXCJyZHctaW1hZ2UtYWxpZ25tZW50XCIse1wicmR3LWltYWdlLWxlZnRcIjpcImxlZnRcIj09PXUsXCJyZHctaW1hZ2UtcmlnaHRcIjpcInJpZ2h0XCI9PT11LFwicmR3LWltYWdlLWNlbnRlclwiOiF1fHxcIm5vbmVcIj09PXV9KX0scy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse2NsYXNzTmFtZTpcInJkdy1pbWFnZS1pbWFnZXdyYXBwZXJcIn0scy5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIix7c3JjOk0sYWx0Ok4sc3R5bGU6e2hlaWdodDpnLHdpZHRoOmR9fSksIXIoKSYmaSYmbCgpP3RoaXMucmVuZGVyQWxpZ25tZW50T3B0aW9ucyh1KTp2b2lkIDApKX19XSksbn0oYy5Db21wb25lbnQpLHQucHJvcFR5cGVzPXtibG9jazp1LmRlZmF1bHQub2JqZWN0LGNvbnRlbnRTdGF0ZTp1LmRlZmF1bHQub2JqZWN0fSxufTt0LmRlZmF1bHQ9SX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9e1wicmR3LWltYWdlLWFsaWdubWVudC1vcHRpb25zLXBvcHVwXCI6XCJyZHctaW1hZ2UtYWxpZ25tZW50LW9wdGlvbnMtcG9wdXBcIixcInJkdy1hbGlnbm1lbnQtb3B0aW9uLWxlZnRcIjpcInJkdy1hbGlnbm1lbnQtb3B0aW9uLWxlZnRcIixcInJkdy1pbWFnZS1hbGlnbm1lbnQtb3B0aW9uXCI6XCJyZHctaW1hZ2UtYWxpZ25tZW50LW9wdGlvblwiLFwicmR3LWltYWdlLWFsaWdubWVudFwiOlwicmR3LWltYWdlLWFsaWdubWVudFwiLFwicmR3LWltYWdlLWltYWdld3JhcHBlclwiOlwicmR3LWltYWdlLWltYWdld3JhcHBlclwiLFwicmR3LWltYWdlLWNlbnRlclwiOlwicmR3LWltYWdlLWNlbnRlclwiLFwicmR3LWltYWdlLWxlZnRcIjpcInJkdy1pbWFnZS1sZWZ0XCIsXCJyZHctaW1hZ2UtcmlnaHRcIjpcInJkdy1pbWFnZS1yaWdodFwiLFwicmR3LWltYWdlLWFsaWdubWVudC1vcHRpb25zLXBvcHVwLXJpZ2h0XCI6XCJyZHctaW1hZ2UtYWxpZ25tZW50LW9wdGlvbnMtcG9wdXAtcmlnaHRcIn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1uKDk1KSxyPW8oaSksbD1uKDk2KSxhPW8obCksYz1uKDk3KSxzPW8oYyksTT1uKDk4KSx1PW8oTSksZz1uKDk5KSxkPW8oZykscD1uKDEwMCksTj1vKHApLEQ9bigxMDEpLEk9byhEKSx5PW4oMTAyKSxqPW8oeSksZj1uKDEwMyksdz1vKGYpLG09bigxMDQpLEM9byhtKSx6PW4oMTA1KSxBPW8oeiksVD1uKDEwNiksRT1vKFQpLEw9bigxMDcpLHg9byhMKSxPPW4oMTA4KSxrPW8oTyksaD1uKDEwOSksYj1vKGgpLFM9bigxMTApLHY9byhTKSxVPW4oMTExKSxRPW8oVSksWT1uKDExMiksXz1vKFkpLFA9bigxMTMpLEI9byhQKSxaPW4oMTE0KSxHPW8oWiksRj1uKDExNSksUj1vKEYpLFc9bigxMTYpLEg9byhXKSxKPW4oMTE3KSxWPW8oSiksSz1uKDExOCksWD1vKEspLHE9bigxMTkpLCQ9byhxKTt0LmRlZmF1bHQ9e29wdGlvbnM6W1wiaW5saW5lXCIsXCJibG9ja1R5cGVcIixcImZvbnRTaXplXCIsXCJmb250RmFtaWx5XCIsXCJsaXN0XCIsXCJ0ZXh0QWxpZ25cIixcImNvbG9yUGlja2VyXCIsXCJsaW5rXCIsXCJlbWJlZGRlZFwiLFwiZW1vamlcIixcImltYWdlXCIsXCJyZW1vdmVcIixcImhpc3RvcnlcIl0saW5saW5lOntpbkRyb3Bkb3duOiExLGNsYXNzTmFtZTp2b2lkIDAsY29tcG9uZW50OnZvaWQgMCxkcm9wZG93bkNsYXNzTmFtZTp2b2lkIDAsb3B0aW9uczpbXCJib2xkXCIsXCJpdGFsaWNcIixcInVuZGVybGluZVwiLFwic3RyaWtldGhyb3VnaFwiLFwibW9ub3NwYWNlXCIsXCJzdXBlcnNjcmlwdFwiLFwic3Vic2NyaXB0XCJdLGJvbGQ6e2ljb246ci5kZWZhdWx0LGNsYXNzTmFtZTp2b2lkIDAsdGl0bGU6dm9pZCAwfSxpdGFsaWM6e2ljb246YS5kZWZhdWx0LGNsYXNzTmFtZTp2b2lkIDAsdGl0bGU6dm9pZCAwfSx1bmRlcmxpbmU6e2ljb246cy5kZWZhdWx0LGNsYXNzTmFtZTp2b2lkIDAsdGl0bGU6dm9pZCAwfSxzdHJpa2V0aHJvdWdoOntpY29uOnUuZGVmYXVsdCxjbGFzc05hbWU6dm9pZCAwLHRpdGxlOnZvaWQgMH0sbW9ub3NwYWNlOntpY29uOmQuZGVmYXVsdCxjbGFzc05hbWU6dm9pZCAwLHRpdGxlOnZvaWQgMH0sc3VwZXJzY3JpcHQ6e2ljb246JC5kZWZhdWx0LGNsYXNzTmFtZTp2b2lkIDAsdGl0bGU6dm9pZCAwfSxzdWJzY3JpcHQ6e2ljb246WC5kZWZhdWx0LGNsYXNzTmFtZTp2b2lkIDAsdGl0bGU6dm9pZCAwfX0sYmxvY2tUeXBlOntpbkRyb3Bkb3duOiEwLG9wdGlvbnM6W1wiTm9ybWFsXCIsXCJIMVwiLFwiSDJcIixcIkgzXCIsXCJINFwiLFwiSDVcIixcIkg2XCIsXCJCbG9ja3F1b3RlXCIsXCJDb2RlXCJdLGNsYXNzTmFtZTp2b2lkIDAsY29tcG9uZW50OnZvaWQgMCxkcm9wZG93bkNsYXNzTmFtZTp2b2lkIDAsdGl0bGU6dm9pZCAwfSxmb250U2l6ZTp7aWNvbjpOLmRlZmF1bHQsb3B0aW9uczpbOCw5LDEwLDExLDEyLDE0LDE2LDE4LDI0LDMwLDM2LDQ4LDYwLDcyLDk2XSxjbGFzc05hbWU6dm9pZCAwLGNvbXBvbmVudDp2b2lkIDAsZHJvcGRvd25DbGFzc05hbWU6dm9pZCAwLHRpdGxlOnZvaWQgMH0sZm9udEZhbWlseTp7b3B0aW9uczpbXCJBcmlhbFwiLFwiR2VvcmdpYVwiLFwiSW1wYWN0XCIsXCJUYWhvbWFcIixcIlRpbWVzIE5ldyBSb21hblwiLFwiVmVyZGFuYVwiXSxjbGFzc05hbWU6dm9pZCAwLGNvbXBvbmVudDp2b2lkIDAsZHJvcGRvd25DbGFzc05hbWU6dm9pZCAwLHRpdGxlOnZvaWQgMH0sbGlzdDp7aW5Ecm9wZG93bjohMSxjbGFzc05hbWU6dm9pZCAwLGNvbXBvbmVudDp2b2lkIDAsZHJvcGRvd25DbGFzc05hbWU6dm9pZCAwLG9wdGlvbnM6W1widW5vcmRlcmVkXCIsXCJvcmRlcmVkXCIsXCJpbmRlbnRcIixcIm91dGRlbnRcIl0sdW5vcmRlcmVkOntpY29uOkMuZGVmYXVsdCxjbGFzc05hbWU6dm9pZCAwLHRpdGxlOnZvaWQgMH0sb3JkZXJlZDp7aWNvbjp3LmRlZmF1bHQsY2xhc3NOYW1lOnZvaWQgMCx0aXRsZTp2b2lkIDB9LGluZGVudDp7aWNvbjpJLmRlZmF1bHQsY2xhc3NOYW1lOnZvaWQgMCx0aXRsZTp2b2lkIDB9LG91dGRlbnQ6e2ljb246ai5kZWZhdWx0LGNsYXNzTmFtZTp2b2lkIDAsdGl0bGU6dm9pZCAwfSx0aXRsZTp2b2lkIDB9LHRleHRBbGlnbjp7aW5Ecm9wZG93bjohMSxjbGFzc05hbWU6dm9pZCAwLGNvbXBvbmVudDp2b2lkIDAsZHJvcGRvd25DbGFzc05hbWU6dm9pZCAwLG9wdGlvbnM6W1wibGVmdFwiLFwiY2VudGVyXCIsXCJyaWdodFwiLFwianVzdGlmeVwiXSxsZWZ0OntpY29uOkEuZGVmYXVsdCxjbGFzc05hbWU6dm9pZCAwLHRpdGxlOnZvaWQgMH0sY2VudGVyOntpY29uOkUuZGVmYXVsdCxjbGFzc05hbWU6dm9pZCAwLHRpdGxlOnZvaWQgMH0scmlnaHQ6e2ljb246eC5kZWZhdWx0LGNsYXNzTmFtZTp2b2lkIDAsdGl0bGU6dm9pZCAwfSxqdXN0aWZ5OntpY29uOmsuZGVmYXVsdCxjbGFzc05hbWU6dm9pZCAwLHRpdGxlOnZvaWQgMH0sdGl0bGU6dm9pZCAwfSxjb2xvclBpY2tlcjp7aWNvbjpiLmRlZmF1bHQsY2xhc3NOYW1lOnZvaWQgMCxjb21wb25lbnQ6dm9pZCAwLHBvcHVwQ2xhc3NOYW1lOnZvaWQgMCxjb2xvcnM6W1wicmdiKDk3LDE4OSwxMDkpXCIsXCJyZ2IoMjYsMTg4LDE1NilcIixcInJnYig4NCwxNzIsMjEwKVwiLFwicmdiKDQ0LDEzMCwyMDEpXCIsXCJyZ2IoMTQ3LDEwMSwxODQpXCIsXCJyZ2IoNzEsODUsMTE5KVwiLFwicmdiKDIwNCwyMDQsMjA0KVwiLFwicmdiKDY1LDE2OCw5NSlcIixcInJnYigwLDE2OCwxMzMpXCIsXCJyZ2IoNjEsMTQyLDE4NSlcIixcInJnYig0MSwxMDUsMTc2KVwiLFwicmdiKDg1LDU3LDEzMClcIixcInJnYig0MCw1MCw3OClcIixcInJnYigwLDAsMClcIixcInJnYigyNDcsMjE4LDEwMClcIixcInJnYigyNTEsMTYwLDM4KVwiLFwicmdiKDIzNSwxMDcsODYpXCIsXCJyZ2IoMjI2LDgwLDY1KVwiLFwicmdiKDE2MywxNDMsMTMyKVwiLFwicmdiKDIzOSwyMzksMjM5KVwiLFwicmdiKDI1NSwyNTUsMjU1KVwiLFwicmdiKDI1MCwxOTcsMjgpXCIsXCJyZ2IoMjQzLDEyMSw1MilcIixcInJnYigyMDksNzIsNjUpXCIsXCJyZ2IoMTg0LDQ5LDQ3KVwiLFwicmdiKDEyNCwxMTIsMTA3KVwiLFwicmdiKDIwOSwyMTMsMjE2KVwiXSx0aXRsZTp2b2lkIDB9LGxpbms6e2luRHJvcGRvd246ITEsY2xhc3NOYW1lOnZvaWQgMCxjb21wb25lbnQ6dm9pZCAwLHBvcHVwQ2xhc3NOYW1lOnZvaWQgMCxkcm9wZG93bkNsYXNzTmFtZTp2b2lkIDAsc2hvd09wZW5PcHRpb25PbkhvdmVyOiEwLGRlZmF1bHRUYXJnZXRPcHRpb246XCJfc2VsZlwiLG9wdGlvbnM6W1wibGlua1wiLFwidW5saW5rXCJdLGxpbms6e2ljb246US5kZWZhdWx0LGNsYXNzTmFtZTp2b2lkIDAsdGl0bGU6dm9pZCAwfSx1bmxpbms6e2ljb246Xy5kZWZhdWx0LGNsYXNzTmFtZTp2b2lkIDAsdGl0bGU6dm9pZCAwfX0sZW1vamk6e2ljb246Qi5kZWZhdWx0LGNsYXNzTmFtZTp2b2lkIDAsY29tcG9uZW50OnZvaWQgMCxwb3B1cENsYXNzTmFtZTp2b2lkIDAsZW1vamlzOltcIvCfmIBcIixcIvCfmIFcIixcIvCfmIJcIixcIvCfmINcIixcIvCfmIlcIixcIvCfmItcIixcIvCfmI5cIixcIvCfmI1cIixcIvCfmJdcIixcIvCfpJdcIixcIvCfpJRcIixcIvCfmKNcIixcIvCfmKtcIixcIvCfmLRcIixcIvCfmIxcIixcIvCfpJNcIixcIvCfmJtcIixcIvCfmJxcIixcIvCfmKBcIixcIvCfmIdcIixcIvCfmLdcIixcIvCfmIhcIixcIvCfkbtcIixcIvCfmLpcIixcIvCfmLhcIixcIvCfmLlcIixcIvCfmLtcIixcIvCfmLxcIixcIvCfmL1cIixcIvCfmYBcIixcIvCfmYhcIixcIvCfmYlcIixcIvCfmYpcIixcIvCfkbxcIixcIvCfka5cIixcIvCflbVcIixcIvCfkoJcIixcIvCfkbNcIixcIvCfjoVcIixcIvCfkbhcIixcIvCfkbBcIixcIvCfkbJcIixcIvCfmY1cIixcIvCfmYdcIixcIvCfmrZcIixcIvCfj4NcIixcIvCfkoNcIixcIuKbt1wiLFwi8J+PglwiLFwi8J+PjFwiLFwi8J+PhFwiLFwi8J+ao1wiLFwi8J+PilwiLFwi4pu5XCIsXCLwn4+LXCIsXCLwn5q0XCIsXCLwn5GrXCIsXCLwn5KqXCIsXCLwn5GIXCIsXCLwn5GJXCIsXCLwn5GJXCIsXCLwn5GGXCIsXCLwn5aVXCIsXCLwn5GHXCIsXCLwn5aWXCIsXCLwn6SYXCIsXCLwn5aQXCIsXCLwn5GMXCIsXCLwn5GNXCIsXCLwn5GOXCIsXCLinIpcIixcIvCfkYpcIixcIvCfkY9cIixcIvCfmYxcIixcIvCfmY9cIixcIvCfkLVcIixcIvCfkLZcIixcIvCfkIdcIixcIvCfkKVcIixcIvCfkLhcIixcIvCfkIxcIixcIvCfkJtcIixcIvCfkJxcIixcIvCfkJ1cIixcIvCfjYlcIixcIvCfjYRcIixcIvCfjZRcIixcIvCfjaRcIixcIvCfjahcIixcIvCfjapcIixcIvCfjoJcIixcIvCfjbBcIixcIvCfjb5cIixcIvCfjbdcIixcIvCfjbhcIixcIvCfjbpcIixcIvCfjI1cIixcIvCfmpFcIixcIuKPsFwiLFwi8J+MmVwiLFwi8J+MnVwiLFwi8J+MnlwiLFwi4q2QXCIsXCLwn4yfXCIsXCLwn4ygXCIsXCLwn4yoXCIsXCLwn4ypXCIsXCLim4RcIixcIvCflKVcIixcIvCfjoRcIixcIvCfjohcIixcIvCfjolcIixcIvCfjopcIixcIvCfjoFcIixcIvCfjpdcIixcIvCfj4BcIixcIvCfj4hcIixcIvCfjrJcIixcIvCflIdcIixcIvCflIhcIixcIvCfk6NcIixcIvCflJRcIixcIvCfjrVcIixcIvCfjrdcIixcIvCfkrBcIixcIvCflopcIixcIvCfk4VcIixcIuKchVwiLFwi4p2OXCIsXCLwn5KvXCJdLHRpdGxlOnZvaWQgMH0sZW1iZWRkZWQ6e2ljb246Ry5kZWZhdWx0LGNsYXNzTmFtZTp2b2lkIDAsY29tcG9uZW50OnZvaWQgMCxwb3B1cENsYXNzTmFtZTp2b2lkIDAsZGVmYXVsdFNpemU6e2hlaWdodDpcImF1dG9cIix3aWR0aDpcImF1dG9cIn0sdGl0bGU6dm9pZCAwfSxpbWFnZTp7aWNvbjpSLmRlZmF1bHQsY2xhc3NOYW1lOnZvaWQgMCxjb21wb25lbnQ6dm9pZCAwLHBvcHVwQ2xhc3NOYW1lOnZvaWQgMCx1cmxFbmFibGVkOiEwLHVwbG9hZEVuYWJsZWQ6ITAscHJldmlld0ltYWdlOiExLGFsaWdubWVudEVuYWJsZWQ6ITAsdXBsb2FkQ2FsbGJhY2s6dm9pZCAwLGlucHV0QWNjZXB0OlwiaW1hZ2UvZ2lmLGltYWdlL2pwZWcsaW1hZ2UvanBnLGltYWdlL3BuZyxpbWFnZS9zdmdcIixhbHQ6e3ByZXNlbnQ6ITEsbWFuZGF0b3J5OiExfSxkZWZhdWx0U2l6ZTp7aGVpZ2h0OlwiYXV0b1wiLHdpZHRoOlwiYXV0b1wifSx0aXRsZTp2b2lkIDB9LHJlbW92ZTp7aWNvbjp2LmRlZmF1bHQsY2xhc3NOYW1lOnZvaWQgMCxjb21wb25lbnQ6dm9pZCAwLHRpdGxlOnZvaWQgMH0saGlzdG9yeTp7aW5Ecm9wZG93bjohMSxjbGFzc05hbWU6dm9pZCAwLGNvbXBvbmVudDp2b2lkIDAsZHJvcGRvd25DbGFzc05hbWU6dm9pZCAwLG9wdGlvbnM6W1widW5kb1wiLFwicmVkb1wiXSx1bmRvOntpY29uOkguZGVmYXVsdCxjbGFzc05hbWU6dm9pZCAwLHRpdGxlOnZvaWQgMH0scmVkbzp7aWNvbjpWLmRlZmF1bHQsY2xhc3NOYW1lOnZvaWQgMCx0aXRsZTp2b2lkIDB9LHRpdGxlOnZvaWQgMH19fSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRXljSGdpSUdobGFXZG9kRDBpTVROd2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFeUlERXpJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVStZbTlzWkR3dmRHbDBiR1UrQ2lBZ0lDQThaR1Z6WXo1RGNtVmhkR1ZrSUhkcGRHZ2dVMnRsZEdOb0xqd3ZaR1Z6WXo0S0lDQWdJRHhrWldaelBqd3ZaR1ZtY3o0S0lDQWdJRHhuSUdsa1BTSlFZV2RsTFRFaUlITjBjbTlyWlQwaWJtOXVaU0lnYzNSeWIydGxMWGRwWkhSb1BTSXhJaUJtYVd4c1BTSnViMjVsSWlCbWFXeHNMWEoxYkdVOUltVjJaVzV2WkdRaVBnb2dJQ0FnSUNBZ0lEeG5JR2xrUFNKaWIyeGtJaUJtYVd4c1BTSWpNREF3TURBd0lqNEtJQ0FnSUNBZ0lDQWdJQ0FnUEdjZ2FXUTlJbEJoWjJVdE1TSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThaejRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOFp5QnBaRDBpWW05c1pDSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeG5JR2xrUFNKRFlXeHhkV1ZmTVNJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjR0YwYUNCa1BTSk5OaTR5TXpZMExEQWdRemN1T0RnM05pd3dJRGt1TVRjMk5Dd3dMakk1TnpreE5qWTJOeUF4TUM0eE1ERTJMREF1T0RreU5qWTJOalkzSUVNeE1TNHdNalk0TERFdU5EZzROU0F4TVM0ME9Td3lMak0zTnpreE5qWTNJREV4TGpRNUxETXVOVFl5SUVNeE1TNDBPU3cwTGpFMk16STFJREV4TGpNeE56SXNOQzQzTURBMU9ETXpNeUF4TUM0NU56UXNOUzR4TnpJNU1UWTJOeUJETVRBdU5qTXdPQ3cxTGpZME5qTXpNek16SURFd0xqRXpNRFFzTmk0d01ESTNOU0E1TGpRM05USXNOaTR5TkNCRE1UQXVNekUzTml3MkxqUXdOamd6TXpNeklERXdMamswT0Rnc05pNDNOak15TlNBeE1TNHpOeXczTGpNeE1UUXhOalkzSUVNeE1TNDNPRGc0TERjdU9EWXdOalkyTmpjZ01USXNPQzQwT1RRME1UWTJOeUF4TWl3NUxqSXhNemMxSUVNeE1pd3hNQzQwTlRnMUlERXhMalUxTml3eE1TNDBNREVnTVRBdU5qY3dOQ3d4TWk0d016a3dPRE16SUVNNUxqYzRNellzTVRJdU5qZ3dOREUyTnlBNExqVXlOaXd4TXlBMkxqa3dNVElzTVRNZ1REQXNNVE1nVERBc01UQXVPRE16TXpNek15Qk1NUzQwT1RRc01UQXVPRE16TXpNek15Qk1NUzQwT1RRc01pNHhOalkyTmpZMk55Qk1NQ3d5TGpFMk5qWTJOalkzSUV3d0xEQWdUREV1TkRrMExEQWdURFl1TWpNMk5Dd3dJRXcyTGpJek5qUXNNQ0JNTmk0eU16WTBMREFnV2lCTk5DNHpNRGdzTlM0ME5EVTVNVFkyTnlCTU5pNHpNekkwTERVdU5EUTFPVEUyTmpjZ1F6Y3VNRGd6Tml3MUxqUTBOVGt4TmpZM0lEY3VOall5TERVdU16QXlPVEUyTmpjZ09DNHdOalkwTERVdU1ERTJPVEUyTmpjZ1F6Z3VORGN3T0N3MExqY3pNRGt4TmpZM0lEZ3VOamN6Tml3MExqTXhORGt4TmpZM0lEZ3VOamN6Tml3ekxqYzJOamMxSUVNNExqWTNNellzTXk0eE5qVTFJRGd1TkRZNU5pd3lMamN5TWpReE5qWTNJRGd1TURZeE5pd3lMalF6TmpReE5qWTNJRU0zTGpZMU16WXNNaTR4TlRBME1UWTJOeUEzTGpBME5qUXNNaTR3TURnMUlEWXVNak0yTkN3eUxqQXdPRFVnVERRdU16QTRMREl1TURBNE5TQk1OQzR6TURnc05TNDBORFU1TVRZMk55Qk1OQzR6TURnc05TNDBORFU1TVRZMk55Qk1OQzR6TURnc05TNDBORFU1TVRZMk55QmFJRTAwTGpNd09DdzNMakkwT1RZMk5qWTNJRXcwTGpNd09Dd3hNQzQ1T1Rrd09ETXpJRXcyTGprd01USXNNVEF1T1RrNU1EZ3pNeUJETnk0Mk5EYzJMREV3TGprNU9UQTRNek1nT0M0eU1UVXlMREV3TGpnME9EVWdPQzQyTURjMkxERXdMalUwT0RReE5qY2dRemd1T1RrNE9Dd3hNQzR5TkRnek16TXpJRGt1TVRrMU5pdzVMamd3TXpBNE16TXpJRGt1TVRrMU5pdzVMakl4TXpjMUlFTTVMakU1TlRZc09DNDFOemM0TXpNek15QTVMakF5TnpZc09DNHdPVEF6TXpNek15QTRMalk1TlRJc055NDNOVFExSUVNNExqTTJNRFFzTnk0ME1UZzJOalkyTnlBM0xqZ3pNalFzTnk0eU5EazJOalkyTnlBM0xqRXhNellzTnk0eU5EazJOalkyTnlCTU5DNHpNRGdzTnk0eU5EazJOalkyTnlCTU5DNHpNRGdzTnk0eU5EazJOalkyTnlCTU5DNHpNRGdzTnk0eU5EazJOalkyTnlCYUlpQnBaRDBpVTJoaGNHVWlQand2Y0dGMGFENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOW5QZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dlp6NEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZaejRLSUNBZ0lDQWdJQ0FnSUNBZ1BDOW5QZ29nSUNBZ0lDQWdJRHd2Wno0S0lDQWdJRHd2Wno0S1BDOXpkbWMrXCJ9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPVwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpZFhSbUxUZ2lQejRLUENFdExTQkhaVzVsY21GMGIzSTZJRUZrYjJKbElFbHNiSFZ6ZEhKaGRHOXlJREUxTGpBdU1pd2dVMVpISUVWNGNHOXlkQ0JRYkhWbkxVbHVJQzRnVTFaSElGWmxjbk5wYjI0NklEWXVNREFnUW5WcGJHUWdNQ2tnSUMwdFBnbzhJVVJQUTFSWlVFVWdjM1puSUZCVlFreEpReUFpTFM4dlZ6TkRMeTlFVkVRZ1UxWkhJREV1TVM4dlJVNGlJQ0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTlIY21Gd2FHbGpjeTlUVmtjdk1TNHhMMFJVUkM5emRtY3hNUzVrZEdRaVBnbzhjM1puSUhabGNuTnBiMjQ5SWpFdU1TSWdhV1E5SWtOaGJIRjFaVjh4SWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhodGJHNXpPbmhzYVc1clBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1TDNoc2FXNXJJaUI0UFNJd2NIZ2lJSGs5SWpCd2VDSUtDU0IzYVdSMGFEMGlNVFp3ZUNJZ2FHVnBaMmgwUFNJeE5uQjRJaUIyYVdWM1FtOTRQU0l3SURBZ01UWWdNVFlpSUdWdVlXSnNaUzFpWVdOclozSnZkVzVrUFNKdVpYY2dNQ0F3SURFMklERTJJaUI0Yld3NmMzQmhZMlU5SW5CeVpYTmxjblpsSWo0S1BHYytDZ2s4Y0dGMGFDQmtQU0pOTnl3elZqSm9OSFl4U0RrdU56VXpiQzB6TERFd1NEaDJNVWcwZGkweGFERXVNalEzYkRNdE1UQklOM29pTHo0S1BDOW5QZ284TDNOMlp6NEtcIn0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9XCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlkWFJtTFRnaVB6NEtQQ0V0TFNCSFpXNWxjbUYwYjNJNklFRmtiMkpsSUVsc2JIVnpkSEpoZEc5eUlERTFMakF1TWl3Z1UxWkhJRVY0Y0c5eWRDQlFiSFZuTFVsdUlDNGdVMVpISUZabGNuTnBiMjQ2SURZdU1EQWdRblZwYkdRZ01Da2dJQzB0UGdvOElVUlBRMVJaVUVVZ2MzWm5JRkJWUWt4SlF5QWlMUzh2VnpOREx5OUVWRVFnVTFaSElERXVNUzh2UlU0aUlDSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OUhjbUZ3YUdsamN5OVRWa2N2TVM0eEwwUlVSQzl6ZG1jeE1TNWtkR1FpUGdvOGMzWm5JSFpsY25OcGIyNDlJakV1TVNJZ2FXUTlJa05oYkhGMVpWOHhJaUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGh0Ykc1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQjRQU0l3Y0hnaUlIazlJakJ3ZUNJS0NTQjNhV1IwYUQwaU1UWndlQ0lnYUdWcFoyaDBQU0l4Tm5CNElpQjJhV1YzUW05NFBTSXdJREFnTVRZZ01UWWlJR1Z1WVdKc1pTMWlZV05yWjNKdmRXNWtQU0p1WlhjZ01DQXdJREUySURFMklpQjRiV3c2YzNCaFkyVTlJbkJ5WlhObGNuWmxJajRLUEdjK0NnazhjR0YwYUNCa1BTSk5OaTR3TkRVc01uWXdMams1TWt3MExqYzROU3d6ZGpVdU1UY3lZekFzTUM0NE5Ua3NNQzR5TkRNc01TNDFNVElzTUM0M01qY3NNUzQ1TlRkek1TNHhNalFzTUM0Mk5qZ3NNUzQ1TVRnc01DNDJOamhqTUM0NE16WXNNQ3d4TGpVd09TMHdMakl5TVN3eUxqQXhPUzB3TGpZMk5Bb0pDV013TGpVeE1TMHdMalEwTWl3d0xqYzJOaTB4TGpBNU5pd3dMamMyTmkweExqazJNVll6YkMweExqSTJMVEF1TURBNFZqSm9NaTQzT0RSSU1UTjJNQzQ1T1RKTU1URXVOek01TEROMk5TNHhOekpqTUN3eExqSXpOQzB3TGpNNU9Dd3lMakU0TVMweExqRTVOU3d5TGpnMENna0pRemt1TnpRM0xERXhMalkzTVN3NExqY3dPU3d4TWl3M0xqUXpMREV5WXkweExqSTBNaXd3TFRJdU1qUTRMVEF1TXpJNUxUTXVNREUzTFRBdU9UZzRZeTB3TGpjMk9TMHdMalkxT1MweExqRTFNaTB4TGpZd05TMHhMakUxTWkweUxqZzBWak5NTWl3eUxqazVNbFl5YURFdU1qWXhTRFl1TURRMWVpSUtDUWt2UGdvOEwyYytDanh5WldOMElIZzlJaklpSUhrOUlqRXpJaUIzYVdSMGFEMGlNVEVpSUdobGFXZG9kRDBpTVNJdlBnbzhMM04yWno0S1wifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRTFjSGdpSUdobGFXZG9kRDBpTVROd2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFMUlERXpJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVStjM1J5YVd0bGRHaHliM1ZuYUR3dmRHbDBiR1UrQ2lBZ0lDQThaR1Z6WXo1RGNtVmhkR1ZrSUhkcGRHZ2dVMnRsZEdOb0xqd3ZaR1Z6WXo0S0lDQWdJRHhrWldaelBqd3ZaR1ZtY3o0S0lDQWdJRHhuSUdsa1BTSlFZV2RsTFRFaUlITjBjbTlyWlQwaWJtOXVaU0lnYzNSeWIydGxMWGRwWkhSb1BTSXhJaUJtYVd4c1BTSnViMjVsSWlCbWFXeHNMWEoxYkdVOUltVjJaVzV2WkdRaVBnb2dJQ0FnSUNBZ0lEeG5JR2xrUFNKemRISnBhMlYwYUhKdmRXZG9JaUJtYVd4c1BTSWpNREF3TURBd0lqNEtJQ0FnSUNBZ0lDQWdJQ0FnUEdjZ2FXUTlJbEJoWjJVdE1TSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThaejRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOFp5QnBaRDBpYzNSeWFXdGxkR2h5YjNWbmFDSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeG5JR2xrUFNKRFlYQmhYekVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BHY2dhV1E5SWtkeWIzVndJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjR0YwYUNCa1BTSk5OQzR3TkRBd05qZ3pOaXcxTGprMU5ETTROREE1SUV3eE1DNHlOVFEyTXpnMkxEVXVPVFUwTXpnME1Ea2dRekV3TGpBME9ETXpNREVzTlM0NE1UazFOamd4T0NBNUxqYzRNelF5TnpjMkxEVXVOamN6TWpVNU1Ea2dPUzQwTlRrNU9UQXlOaXcxTGpVeE5UYzRNVGd5SUVNNExqZzRNRE15TWpJMExEVXVNalUzTVRRd09URWdPQzR6T1RjMk5UWXlOU3cxTGpBM01UVXdOamd5SURndU1ERXlPRFF4Tnprc05DNDVOVGt3T0RZek55QkROaTQ0TWpVeU16UXpOeXcwTGpZeE1EVXdPVEE1SURZdU1EUTNNelF6TnpVc05DNHlORGMyT1RBNU1TQTFMalkzT1RJNE56RXhMRE11T0Rjd09UVTJPRElnUXpVdU16RXhNak13TkRjc015NDBPVFF4TmpNMk15QTFMakV5TnpJME5qRXNNeTR4TURBMU5Ua3dPU0ExTGpFeU56STBOakVzTWk0Mk9EazVPVFUwTlNCRE5TNHhNamN5TkRZeExESXVNVGsxTURJd05EVWdOUzR6TVRReE16QTROaXd4TGpjNE5EUTFOamd5SURVdU5qZzNOamsxTXpFc01TNDBOVGd6TXpRd09TQkROaTR3TmpZNE9EUTNOaXd4TGpFeU5qWXlOekkzSURZdU5UYzBNek0xT1RRc01DNDVOakEyTVRFek5qZ2dOeTR5TVRBd01UazFNeXd3TGprMk1EWXhNVE0yT0NCRE55NDRPVEF6TWpJeU5pd3dMamsyTURZeE1UTTJPQ0E0TGpRM05UZ3lNRE14TERFdU1qRTJORGMxSURndU9UWTJOakF4TlRNc01TNDNNamd5TXpFNE1pQkRPUzR5TmpJd05qQTFPU3d5TGpBME16QTJPREU0SURrdU5UUTVOREEwTWprc01pNDJNVGsxSURrdU9ESTRNVEExTkRRc015NDBOVGMwT1RjM015Qk1PUzQ1TkRVME1UQXhNaXd6TGpRM05ESTNPVFUxSUV3eE1DNDJORGd3TURjNExETXVOVEkwT0RZeE16Y2dUREV3TGpjME9EUTVOakVzTXk0ME9UazJNamsxTlNCRE1UQXVOemMyTXpVM05Dd3pMak0wTnpjd05qZ3lJREV3TGpjNU1ETTVNRFlzTXk0eU1qRXpOREE1TVNBeE1DNDNPVEF6T1RBMkxETXVNVEU1T1Rjd05EVWdRekV3TGpjNU1ETTVNRFlzTWk0M09ESTFNekU0TWlBeE1DNDNOVEV6TURnMkxESXVNalk0TURnMk16Y2dNVEF1Tmpjek1EZzJMREV1TlRjMk16TTROak1nUXpFd0xqWXhNVFV6TXpJc01TNHhNalkxT1RjM015QXhNQzQxTlRNeE56TTVMREF1TnprME5qVTBOVFExSURFd0xqUTVOelExTVRFc01DNDFPREE1TWpJM01qY2dRemt1T0RjNE5qUXlOVFlzTUM0ek56ZzFOalU1TURrZ09TNHpPRFE1TmpBNU55d3dMakkwTXpVME16RTRNaUE1TGpBeE5qa3pNelU1TERBdU1UYzJNVEl3TkRVMUlFTTRMak0yTkRVMU1EYzRMREF1TURZNU1qVTBOVFExTlNBM0xqZzVPRGMxT1RjMkxEQXVNREUxT0RBMk9ERTRNaUEzTGpZeU1ESXpORE00TERBdU1ERTFPREEyT0RFNE1pQkROaTR4TnpBeU5EUXhOQ3d3TGpBeE5UZ3dOamd4T0RJZ05TNHdOelExT1RrMk1Td3dMak0zTXpBME1Ea3dPU0EwTGpNek1qZzJNVE16TERFdU1EZzNNVEkxSUVNekxqVTROVFkwTkRVekxERXVPREEyT1RFeE16Y2dNeTR5TVRJd09EQXdPQ3d5TGpZM05Ua3dNakkzSURNdU1qRXlNRGd3TURnc015NDJPVE0zTnpJM015QkRNeTR5TVRJd09EQXdPQ3cwTGpJd05UUTBNRGt4SURNdU16UTFPVEE0TWpFc05DNDNNelF3TURrd09TQXpMall4TXpZeU16QTBMRFV1TWpjNU5UTTJNemNnUXpNdU56UXhOekE0T1Rrc05TNDFNekkyT0RFNE1pQXpMamc0TXpreE5qQXhMRFV1TnpVM05qUXdPVEVnTkM0d05EQXdOamd6Tml3MUxqazFORE00TkRBNUlFdzBMakEwTURBMk9ETTJMRFV1T1RVME16ZzBNRGtnVERRdU1EUXdNRFk0TXpZc05TNDVOVFF6T0RRd09TQmFJaUJwWkQwaVUyaGhjR1VpUGp3dmNHRjBhRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjR0YwYUNCa1BTSk5PQzR5T0RBM05qRTNNaXc0TGpFeE16ZzVNRGt4SUVNNExqZzFOVEV5TmpreExEZ3VNelV3TURjM01qY2dPUzR5TXpjeU1UWTNPU3c0TGpVME9UZzJNell6SURrdU5ESTJOekE0T1Rjc09DNDNNVEkzTnpjeU55QkRPUzQ0TnpnME5qWTNPU3c1TGpFeU16TTNNRFExSURFd0xqRXdOREkxTnpnc09TNDFOalE0TURrd05pQXhNQzR4TURReU5UYzRMREV3TGpBek56QTVNeklnUXpFd0xqRXdOREkxTnpnc01UQXVOREU1TlRnNE55QTVMamszTXpBNU5UY3hMREV3TGpjNE1qSTRPRGNnT1M0M01URXdNelV4TWl3eE1TNHhNalV6TkRBNUlFTTVMalEyTURFNU5UTXlMREV4TGpRMk1qWXpNVGdnT1M0eE1qQXhNVGN4T0N3eE1TNDNNRFEzT0RZeklEZ3VOamt3TmpJMUxERXhMamcxTURjeE1UTWdRemd1TWpjeU5qRTNNVGtzTVRJdU1EQXlPRGN3TlNBM0xqZzRORGt6TVRZMExERXlMakEzT0RVNU5UVWdOeTQxTWpneU1USTRPU3d4TWk0d056ZzFPVFUxSUVNM0xqRXlNVEU1TVRRc01USXVNRGM0TlRrMU5TQTJMamMxTXpFMk5EQTJMREV5TGpBeE5qWXdPVEVnTmk0ME1qUXhOakF4TlN3eE1TNDRPVEk1TmpFeklFTTJMakEzT0RRMU56QXpMREV4TGpjM05EYzNPVFVnTlM0M09EVTJOalF3Tml3eE1TNDJNVFEzTURJeklEVXVOVFExT0RNNU9EVXNNVEV1TkRFeU1UQTVNU0JETlM0eU9UUTVOREUwTERFeExqSXdOREF5TURVZ05TNHdOekU0TVRZMExERXdMamt6T1Rjek5qTWdOQzQ0TnpZMk5qazVNaXd4TUM0Mk1Ua3hNRGt4SUVNMExqZzBPRGMxTERFd0xqVTNOREk0T0RjZ05DNDRNVE00TlRjME1pd3hNQzQwT1RneU5qZ3lJRFF1TnpjeU1EVXdOemdzTVRBdU16a3hOVEl3TlNCRE5DNDNNekF6TURJM05Dd3hNQzR5T0RRMU16WXpJRFF1TmpZM05ETXhOalFzTVRBdU1USTNNakEyT0NBMExqVTRNemczTmprMkxEa3VPVEU1TWpNMk16SWdRelF1TlRBd01qQTFNRGdzT1M0M01URXdOVGt3TmlBMExqUXhOalkxTURNNUxEa3VOVEV4TkRVZ05DNHpNekk1TnpnMU1TdzVMak15TURJNU1EazBJRXd6TGpRM09UZ3lOREl5TERrdU16TTNNVFl4TXpJZ1RETXVORGM1T0RJME1qSXNPUzQzTURnek1URXpNaUJNTXk0ME5qTXdPVFUzTVN3eE1DNHdNakEyTXpZeklFTXpMalExTnpVNE56ZzVMREV3TGpJek5ERTVNRGtnTXk0ME5UYzFPRGM0T1N3eE1DNDBNalV6TnprMUlETXVORFl6TURrMU56RXNNVEF1TlRrME1URXpOeUJETXk0ME56UXhOams1TWl3eE1DNDROak01T0RFNElETXVORGM1T0RJME1qSXNNVEV1TXpBeU5qY3lOeUF6TGpRM09UZ3lOREl5TERFeExqa3hNREUxTmpnZ1RETXVORGM1T0RJME1qSXNNVEl1TURFNU9EVTVNU0JETXk0ME56azRNalF5TWl3eE1pNHdPVGcyTWpjeklETXVOVEF5TURnNU9EVXNNVEl1TVRZd016RTRNaUF6TGpVME5qWTFNRE01TERFeUxqSXdOVFE1TXpJZ1F6TXVOak13TWpreU9UY3NNVEl1TWpjeU56QTVNU0F6TGpnek1UQXpOVEUxTERFeUxqTTFNVFU1TlRVZ05DNHhORGc1TURZeU5Td3hNaTQwTkRFMU9UQTVJRXcxTGpNeE9UZzNNekEwTERFeUxqYzNPRGszTURVZ1F6VXVOemN4TkRnME16Y3NNVEl1T1RBNE5EQTVNU0EyTGpNeE5USXpORE0zTERFeUxqazNNekV4TXpjZ05pNDVOVEE1TVRjNU55d3hNaTQ1TnpNeE1UTTNJRU0zTGpZek5qZzNOU3d4TWk0NU56TXhNVE0zSURndU1qQXlOVFk0TXpZc01USXVPVEUwTURVeU15QTRMalkwT0Rrd05qSTFMREV5TGpjNU5UZzNNRFVnUXprdU1EVTJNRFEwT1RRc01USXVOamswTkRRd09TQTVMalE0TWpJeU5qVXpMREV5TGpVd09EZzVOVFVnT1M0NU1qZzNNVEE1Tnl3eE1pNHlNemt4TkRVMUlFTXhNQzR6TXpBeE16WTNMREV4TGprNE1ESTVOemNnTVRBdU5qTTBNVEl4TVN3eE1TNDNOVEkzTURreElERXdMamcwTURRMU9Td3hNUzQxTlRVMk5EQTVJRU14TVM0eE1EYzROVEUxTERFeExqSTRNREl4T0RJZ01URXVNekEyTURjME1pd3hNQzQ1T0RjNE1EWTRJREV4TGpRek5ETXdOamNzTVRBdU5qYzRNekU0TWlCRE1URXVOall6TVRFMU15d3hNQzR4TVRBek9UVTFJREV4TGpjM056STROVEVzT1M0MU1UUXlOVFkzT1NBeE1TNDNOemN5T0RVeExEZ3VPRGt3TVRrM056TWdRekV4TGpjM056STROVEVzT0M0MU9USXdNalVnTVRFdU56VTNPVFE1TWl3NExqTXpNelEzTWpjeklERXhMamN4T1RBME1qa3NPQzR4TVRRd05qZ3hPQ0JNT0M0eU9EQTNOakUzTWl3NExqRXhOREEyT0RFNElFdzRMakk0TURjMk1UY3lMRGd1TVRFek9Ea3dPVEVnVERndU1qZ3dOell4TnpJc09DNHhNVE00T1RBNU1TQk1PQzR5T0RBM05qRTNNaXc0TGpFeE16ZzVNRGt4SUZvaUlHbGtQU0pUYUdGd1pTSStQQzl3WVhSb1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4d1lYUm9JR1E5SWsweE5DNDVNVE00TmpjeUxEWXVOVGN3TVRRd09URWdRekUwTGpnMk16VXpOVEVzTmk0MU1UazFPRGcyTXlBeE5DNDNPVGsxT0RBeExEWXVORGswTXpJM01qY2dNVFF1TnpJeE16ZzJOeXcyTGpRNU5ETXlOekkzSUV3d0xqSTJOell5TmprMU15dzJMalE1TkRNeU56STNJRU13TGpFNE9UVXlNVFE0TlN3MkxqUTVORE15TnpJM0lEQXVNVEkxTkRRNU1qRTVMRFl1TlRFNU5UZzROak1nTUM0d056VXlNelF6TnpVc05pNDFOekF4TkRBNU1TQkRNQzR3TWpVeE5qWXdNVFUyTERZdU5qSXdOamt6TVRnZ01DdzJMalk0TlRNNU56Y3pJREFzTmk0M05qUXlPRFF3T1NCTU1DdzNMak13TXprNU1Ea3hJRU13TERjdU16Z3lPRGMzTWpjZ01DNHdNalV3TkRnNE1qZ3hMRGN1TkRRM05EWXpOak1nTUM0d056VXlNelF6TnpVc055NDBPVGd4TXpRd09TQkRNQzR4TWpVME5Ea3lNVGtzTnk0MU5EZzJPRFl6TnlBd0xqRTRPVFl6T0RZM01pdzNMalUzTXpjM01EUTFJREF1TWpZM05qSTJPVFV6TERjdU5UY3pOemN3TkRVZ1RERTBMamN5TVRNNE5qY3NOeTQxTnpNM056QTBOU0JETVRRdU56azVOVGd3TVN3M0xqVTNNemMzTURRMUlERTBMamcyTXpVMk5EUXNOeTQxTkRnMk9EWXpOeUF4TkM0NU1UTTROamN5TERjdU5EazRNVE0wTURrZ1F6RTBMamsyTXprNU5ESXNOeTQwTkRjME5qTTJNeUF4TkM0NU9Ea3dOREk1TERjdU16Z3lPRGMzTWpjZ01UUXVPVGc1TURReU9TdzNMak13TXprNU1Ea3hJRXd4TkM0NU9Ea3dOREk1TERZdU56WTBNamcwTURrZ1F6RTBMams0T1RBME1qa3NOaTQyT0RVek9UYzNNeUF4TkM0NU5qTTVPVFF5TERZdU5qSXdOamt6TVRnZ01UUXVPVEV6T0RZM01pdzJMalUzTURFME1Ea3hJRXd4TkM0NU1UTTROamN5TERZdU5UY3dNVFF3T1RFZ1RERTBMamt4TXpnMk56SXNOaTQxTnpBeE5EQTVNU0JhSWlCcFpEMGlVMmhoY0dVaVBqd3ZjR0YwYUQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZaejRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZaejRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Wno0S0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUR3dlp6NEtJQ0FnSUR3dlp6NEtQQzl6ZG1jK1wifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRXpjSGdpSUdobGFXZG9kRDBpTVRWd2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFeklERTFJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVStZMjlrWlR3dmRHbDBiR1UrQ2lBZ0lDQThaR1Z6WXo1RGNtVmhkR1ZrSUhkcGRHZ2dVMnRsZEdOb0xqd3ZaR1Z6WXo0S0lDQWdJRHhrWldaelBqd3ZaR1ZtY3o0S0lDQWdJRHhuSUdsa1BTSlFZV2RsTFRFaUlITjBjbTlyWlQwaWJtOXVaU0lnYzNSeWIydGxMWGRwWkhSb1BTSXhJaUJtYVd4c1BTSnViMjVsSWlCbWFXeHNMWEoxYkdVOUltVjJaVzV2WkdRaVBnb2dJQ0FnSUNBZ0lEeG5JR2xrUFNKamIyUmxJaUJtYVd4c1BTSWpORFEwTkRRMElqNEtJQ0FnSUNBZ0lDQWdJQ0FnUEdjZ2FXUTlJbEJoWjJVdE1TSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThaejRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOFp5QnBaRDBpWTI5a1pTSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeG5JR2xrUFNKSGNtOTFjQ0krQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNHRjBhQ0JrUFNKTk1TNHdNakUwTWpnMU55d3lMamt3TmpJMUlFTXhMakl3TnpFME1qZzJMRFF1TVRJMUlERXVNemt5T0RVM01UUXNOQzQwTURZeU5TQXhMak01TWpnMU56RTBMRFV1TmpJMUlFTXhMak01TWpnMU56RTBMRFl1TXpjMUlEQXNOeTR3TXpFeU5TQXdMRGN1TURNeE1qVWdUREFzTnk0NU5qZzNOU0JETUN3M0xqazJPRGMxSURFdU16a3lPRFUzTVRRc09DNDJNalVnTVM0ek9USTROVGN4TkN3NUxqTTNOU0JETVM0ek9USTROVGN4TkN3eE1DNDFPVE0zTlNBeExqSXdOekUwTWpnMkxERXdMamczTlNBeExqQXlNVFF5T0RVM0xERXlMakE1TXpjMUlFTXdMamMwTWpnMU56RTBNeXd4TkM0d05qSTFJREV1TnpZME1qZzFOekVzTVRVZ01pNDJPVEk0TlRjeE5Dd3hOU0JNTkM0Mk5ESTROVGN4TkN3eE5TQk1OQzQyTkRJNE5UY3hOQ3d4TXk0eE1qVWdRelF1TmpReU9EVTNNVFFzTVRNdU1USTFJREl1T1RjeE5ESTROVGNzTVRNdU16RXlOU0F5TGprM01UUXlPRFUzTERFeUxqRTROelVnUXpJdU9UY3hOREk0TlRjc01URXVNelF6TnpVZ015NHhOVGN4TkRJNE5pd3hNUzR6TkRNM05TQXpMak0wTWpnMU56RTBMRGt1TkRZNE56VWdRek11TkRNMU56RTBNamtzT0M0Mk1qVWdNaTQ0TnpnMU56RTBNeXczTGprMk9EYzFJREl1TXpJeE5ESTROVGNzTnk0MUlFTXlMamczT0RVM01UUXpMRGN1TURNeE1qVWdNeTQwTXpVM01UUXlPU3cyTGpRMk9EYzFJRE11TXpReU9EVTNNVFFzTlM0Mk1qVWdRek11TURZME1qZzFOekVzTXk0M05TQXlMamszTVRReU9EVTNMRE11TnpVZ01pNDVOekUwTWpnMU55d3lMamt3TmpJMUlFTXlMamszTVRReU9EVTNMREV1TnpneE1qVWdOQzQyTkRJNE5UY3hOQ3d4TGpnM05TQTBMalkwTWpnMU56RTBMREV1T0RjMUlFdzBMalkwTWpnMU56RTBMREFnVERJdU5qa3lPRFUzTVRRc01DQkRNUzQyTnpFME1qZzFOeXd3SURBdU56UXlPRFUzTVRRekxEQXVPVE0zTlNBeExqQXlNVFF5T0RVM0xESXVPVEEyTWpVZ1RERXVNREl4TkRJNE5UY3NNaTQ1TURZeU5TQk1NUzR3TWpFME1qZzFOeXd5TGprd05qSTFJRm9pSUdsa1BTSlRhR0Z3WlNJK1BDOXdZWFJvUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BIQmhkR2dnWkQwaVRURXhMamszT0RVM01UUXNNaTQ1TURZeU5TQkRNVEV1TnpreU9EVTNNU3cwTGpFeU5TQXhNUzQyTURjeE5ESTVMRFF1TkRBMk1qVWdNVEV1TmpBM01UUXlPU3cxTGpZeU5TQkRNVEV1TmpBM01UUXlPU3cyTGpNM05TQXhNeXczTGpBek1USTFJREV6TERjdU1ETXhNalVnVERFekxEY3VPVFk0TnpVZ1F6RXpMRGN1T1RZNE56VWdNVEV1TmpBM01UUXlPU3c0TGpZeU5TQXhNUzQyTURjeE5ESTVMRGt1TXpjMUlFTXhNUzQyTURjeE5ESTVMREV3TGpVNU16YzFJREV4TGpjNU1qZzFOekVzTVRBdU9EYzFJREV4TGprM09EVTNNVFFzTVRJdU1Ea3pOelVnUXpFeUxqSTFOekUwTWprc01UUXVNRFl5TlNBeE1TNHlNelUzTVRRekxERTFJREV3TGpNd056RTBNamtzTVRVZ1REZ3VNelUzTVRReU9EWXNNVFVnVERndU16VTNNVFF5T0RZc01UTXVNVEkxSUVNNExqTTFOekUwTWpnMkxERXpMakV5TlNBeE1DNHdNamcxTnpFMExERXpMak14TWpVZ01UQXVNREk0TlRjeE5Dd3hNaTR4T0RjMUlFTXhNQzR3TWpnMU56RTBMREV4TGpNME16YzFJRGt1T0RReU9EVTNNVFFzTVRFdU16UXpOelVnT1M0Mk5UY3hOREk0Tml3NUxqUTJPRGMxSUVNNUxqVTJOREk0TlRjeExEZ3VOakkxSURFd0xqRXlNVFF5T0RZc055NDVOamczTlNBeE1DNDJOemcxTnpFMExEY3VOU0JETVRBdU1USXhOREk0Tml3M0xqQXpNVEkxSURrdU5UWTBNamcxTnpFc05pNDBOamczTlNBNUxqWTFOekUwTWpnMkxEVXVOakkxSUVNNUxqZzBNamcxTnpFMExETXVOelVnTVRBdU1ESTROVGN4TkN3ekxqYzFJREV3TGpBeU9EVTNNVFFzTWk0NU1EWXlOU0JETVRBdU1ESTROVGN4TkN3eExqYzRNVEkxSURndU16VTNNVFF5T0RZc01TNDROelVnT0M0ek5UY3hOREk0Tml3eExqZzNOU0JNT0M0ek5UY3hOREk0Tml3d0lFd3hNQzR6TURjeE5ESTVMREFnUXpFeExqTXlPRFUzTVRRc01DQXhNaTR5TlRjeE5ESTVMREF1T1RNM05TQXhNUzQ1TnpnMU56RTBMREl1T1RBMk1qVWdUREV4TGprM09EVTNNVFFzTWk0NU1EWXlOU0JNTVRFdU9UYzROVGN4TkN3eUxqa3dOakkxSUZvaUlHbGtQU0pUYUdGd1pTSStQQzl3WVhSb1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOEwyYytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5blBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOW5QZ29nSUNBZ0lDQWdJQ0FnSUNBOEwyYytDaUFnSUNBZ0lDQWdQQzluUGdvZ0lDQWdQQzluUGdvOEwzTjJaejQ9XCJ9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPVwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpVlZSR0xUZ2lJSE4wWVc1a1lXeHZibVU5SW01dklqOCtDanh6ZG1jZ2QybGtkR2c5SWpFMGNIZ2lJR2hsYVdkb2REMGlNVFJ3ZUNJZ2RtbGxkMEp2ZUQwaU1DQXdJREUwSURFMElpQjJaWEp6YVc5dVBTSXhMakVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUlnZUcxc2JuTTZlR3hwYm1zOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2ZUd4cGJtc2lQZ29nSUNBZ1BDRXRMU0JIWlc1bGNtRjBiM0k2SUZOclpYUmphQ0EwTUM0eklDZ3pNemd6T1NrZ0xTQm9kSFJ3T2k4dmQzZDNMbUp2YUdWdGFXRnVZMjlrYVc1bkxtTnZiUzl6YTJWMFkyZ2dMUzArQ2lBZ0lDQThkR2wwYkdVK1ptOXVkQzF6YVhwbFBDOTBhWFJzWlQ0S0lDQWdJRHhrWlhOalBrTnlaV0YwWldRZ2QybDBhQ0JUYTJWMFkyZ3VQQzlrWlhOalBnb2dJQ0FnUEdSbFpuTStQQzlrWldaelBnb2dJQ0FnUEdjZ2FXUTlJbEJoWjJVdE1TSWdjM1J5YjJ0bFBTSnViMjVsSWlCemRISnZhMlV0ZDJsa2RHZzlJakVpSUdacGJHdzlJbTV2Ym1VaUlHWnBiR3d0Y25Wc1pUMGlaWFpsYm05a1pDSStDaUFnSUNBZ0lDQWdQR2NnYVdROUltWnZiblF0YzJsNlpTSWdabWxzYkQwaUl6QXdNREF3TUNJK0NpQWdJQ0FnSUNBZ0lDQWdJRHhuSUdsa1BTSlFZV2RsTFRFaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BHYytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEdjZ2FXUTlJbVp2Ym5RdGMybDZaU0krQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHhuSUdsa1BTSkRZWEJoWHpFaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQR2NnYVdROUlrZHliM1Z3SWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y0dGMGFDQmtQU0pOTVRFdU9USXdPVFUzTVN3ekxqRXhPVEF5TlNCRE1USXVNREF5TkRZMk15d3pMakl5TWpRd05qSTFJREV5TGpFeU5UWXpNVGtzTXk0eU9ESTFNVGczTlNBeE1pNHlOVFUzT1RjMkxETXVNamd5TlRFNE56VWdUREV6TGpJeU5UZ3pORE1zTXk0eU9ESTFNVGczTlNCRE1UTXVNelF3TURZM05Dd3pMakk0TWpVeE9EYzFJREV6TGpRME9UWXhPVFlzTXk0eU16WXhJREV6TGpVek1ESXlOeXd6TGpFMU16WXpNVEkxSUVNeE15NDJNVEE0TXpRekxETXVNRGN4TVRZeU5TQXhNeTQyTlRVNE9ETTFMREl1T1RVNU16TTNOU0F4TXk0Mk5UVXlPREl5TERJdU9EUXlPVEU0TnpVZ1RERXpMalkxTmpjNE5USXNNQzQwTXpNNE5qZzNOU0JETVRNdU5qVTBNRE0yT1N3d0xqRTVOREUyTWpVZ01UTXVORFl5TlRRMkxEQXVNREF4TWpZNE56VWdNVE11TWpJM016TTNOQ3d3TGpBd01USTJPRGMxSUV3d0xqUXlPVFEwTnpnMU1pd3dMakF3TVRJMk9EYzFJRU13TGpFNU1qSTJNemd3TkN3d0xqQXdNVEkyT0RjMUlEQXNNQzR4T1RjeE9ERXlOU0F3TERBdU5ETTROelk0TnpVZ1REQXNNaTQ0TkRVd01UZzNOU0JETUN3ekxqQTROall3TmpJMUlEQXVNVGt5TWpZek9EQTBMRE11TWpneU5URTROelVnTUM0ME1qazBORGM0TlRJc015NHlPREkxTVRnM05TQk1NUzR6T1RrNE1qZ3lNaXd6TGpJNE1qVXhPRGMxSUVNeExqVXpNRE16TnpReUxETXVNamd5TlRFNE56VWdNUzQyTlRNM01UYzNPU3d6TGpJeU1qRWdNUzQzTXpVeE9EUXdOU3d6TGpFeE9ETXlOU0JNTWk0ME5qVXhOVGsxTVN3eUxqRTRPRGd4TWpVZ1REVXVOVE01TmpZeU5UZ3NNaTR4T0RnNE1USTFJRXcxTGpVek9UWTJNalU0TERFekxqVTBOemcwTXpnZ1F6VXVOVE01TmpZeU5UZ3NNVE11TnpnNU16ZzNOU0ExTGpjek1Ua3lOak00TERFekxqazROVE0wTXpnZ05TNDVOamt4TVRBME15d3hNeTQ1T0RVek5ETTRJRXczTGpZNE5qa3dNVGcwTERFekxqazROVE0wTXpnZ1F6Y3VPVEkwTERFekxqazROVE0wTXpnZ09DNHhNVFl6TkRrM0xERXpMamM0T1RNNE56VWdPQzR4TVRZek5EazNMREV6TGpVME56ZzBNemdnVERndU1URTJNelE1Tnl3eUxqRTRPRGcxTmpJMUlFd3hNUzR4T0RjME5qQXhMREl1TVRnNE9EVTJNalVnVERFeExqa3lNRGsxTnpFc015NHhNVGt3TWpVZ1RERXhMamt5TURrMU56RXNNeTR4TVRrd01qVWdUREV4TGpreU1EazFOekVzTXk0eE1Ua3dNalVnV2lJZ2FXUTlJbE5vWVhCbElqNDhMM0JoZEdnK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhCaGRHZ2daRDBpVFRFekxqZzVOelkyTWpZc01URXVNall6TXpVZ1F6RXpMamM0TkRnME5qWXNNVEV1TVRFME1qQTJNaUF4TXk0MU9UQTVNRGdzTVRFdU1EVTFNell5TlNBeE15NDBNVFl6T0RBMExERXhMakV4TnpFek56VWdUREV5TGpnMk9EVTNOamNzTVRFdU16RXhNalUyTWlCTU1USXVPRFk0TmpZeU5pdzVMall4TnpFeU5TQkRNVEl1T0RZNE5qWXlOaXc1TGpVd01URWdNVEl1T0RJek5EUXhOeXc1TGpNNE9UZ2dNVEl1TnpReU9USXdNaXc1TGpNd056Y3lOU0JETVRJdU5qWXlNems0Tnl3NUxqSXlOVFk1TXpjMUlERXlMalUxTXpFd05ETXNPUzR4TnprMU9ERXlOU0F4TWk0ME16a3lNVFE0TERrdU1UYzVOVGd4TWpVZ1RERXlMakF4TURFNU5qTXNPUzR4TnprMU9ERXlOU0JETVRFdU56Y3pNRGs0TVN3NUxqRTNPVFU0TVRJMUlERXhMalU0TURjME9EVXNPUzR6TnpVMU16YzFOU0F4TVM0MU9EQTNORGcxTERrdU5qRTNNRGd4TWpNZ1RERXhMalU0TURjME9EVXNNVEV1TXpFeE1qVTJNaUJNTVRFdU1ETXlPRFU0T1N3eE1TNHhNVGN4TXpjMUlFTXhNQzQ0TlRnME1UY3lMREV4TGpBMU5URTROelVnTVRBdU5qWTBOVFkwTkN3eE1TNHhNVFF5TURZeUlERXdMalUxTVRjME9EVXNNVEV1TWpZek16VWdRekV3TGpRek9EZzBOallzTVRFdU5ERXlORFVnTVRBdU5ETXlOREEwT1N3eE1TNDJNVGd6T0RFeUlERXdMalV6TlRZME5ESXNNVEV1TnpjME55Qk1NVEV1T0RZNE16UTVOeXd4TXk0M09USXhORE00SUVNeE1TNDVORGd4T0RReExERXpMamt4TWprNE1USWdNVEl1TURneE9ESTRNeXd4TXk0NU9EVTBNekV5SURFeUxqSXlORFkyTWpZc01UTXVPVGcxTkRNeE1pQkRNVEl1TXpZM05UZ3lPQ3d4TXk0NU9EVTBNekV5SURFeUxqVXdNVEU0TkRFc01UTXVPVEV5T1RneE1pQXhNaTQxT0RBNU56VTFMREV6TGpjNU1qRTBNemdnVERFekxqa3hNemMyTmprc01URXVOemMwTnlCRE1UUXVNREUyT1RZek1Td3hNUzQyTVRnek9ERXlJREUwTGpBeE1EUTNPRFVzTVRFdU5ERXlORFVnTVRNdU9EazNOall5Tml3eE1TNHlOak16TlNCTU1UTXVPRGszTmpZeU5pd3hNUzR5TmpNek5TQk1NVE11T0RrM05qWXlOaXd4TVM0eU5qTXpOU0JhSWlCcFpEMGlVMmhoY0dVaVBqd3ZjR0YwYUQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZaejRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZaejRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Wno0S0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUR3dlp6NEtJQ0FnSUR3dlp6NEtQQzl6ZG1jK1wifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRTNjSGdpSUdobGFXZG9kRDBpTVRSd2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFM0lERTBJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVSthVzVrWlc1MFBDOTBhWFJzWlQ0S0lDQWdJRHhrWlhOalBrTnlaV0YwWldRZ2QybDBhQ0JUYTJWMFkyZ3VQQzlrWlhOalBnb2dJQ0FnUEdSbFpuTStQQzlrWldaelBnb2dJQ0FnUEdjZ2FXUTlJbEJoWjJVdE1TSWdjM1J5YjJ0bFBTSnViMjVsSWlCemRISnZhMlV0ZDJsa2RHZzlJakVpSUdacGJHdzlJbTV2Ym1VaUlHWnBiR3d0Y25Wc1pUMGlaWFpsYm05a1pDSStDaUFnSUNBZ0lDQWdQR2NnYVdROUltbHVaR1Z1ZENJZ1ptbHNiRDBpSXpBd01EQXdNQ0krQ2lBZ0lDQWdJQ0FnSUNBZ0lEeG5JR2xrUFNKTVlYbGxjbDh4SWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4bklHbGtQU0pIY205MWNDSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhKbFkzUWdhV1E5SWxKbFkzUmhibWRzWlMxd1lYUm9JaUI0UFNJMUxqY3hOalE0TXpVeUlpQjVQU0l6TGpJeE1EZ3lOakl4SWlCM2FXUjBhRDBpTVRFdU1qZ3pOVEUyTlNJZ2FHVnBaMmgwUFNJeExqRTVOalU0TVRJaVBqd3ZjbVZqZEQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVZqZENCcFpEMGlVbVZqZEdGdVoyeGxMWEJoZEdnaUlIZzlJakFpSUhrOUlqQXVNREU1T1RRek1ERTVPU0lnZDJsa2RHZzlJakUzSWlCb1pXbG5hSFE5SWpFdU1UazJOVGd4TWlJK1BDOXlaV04wUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaV04wSUdsa1BTSlNaV04wWVc1bmJHVXRjR0YwYUNJZ2VEMGlNQ0lnZVQwaU1USXVOemd6TkRjMU9DSWdkMmxrZEdnOUlqRTNJaUJvWldsbmFIUTlJakV1TVRrMk5UZ3hNaUkrUEM5eVpXTjBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4eVpXTjBJR2xrUFNKU1pXTjBZVzVuYkdVdGNHRjBhQ0lnZUQwaU5TNDNNVFkwT0RNMU1pSWdlVDBpT1M0MU9USTFPVEkxT1NJZ2QybGtkR2c5SWpFeExqSTRNelV4TmpVaUlHaGxhV2RvZEQwaU1TNHhPVFkxT0RFeUlqNDhMM0psWTNRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEpsWTNRZ2FXUTlJbEpsWTNSaGJtZHNaUzF3WVhSb0lpQjRQU0kxTGpjeE5qUTRNelV5SWlCNVBTSTJMalF3TVRjd09UUWlJSGRwWkhSb1BTSXhNUzR5T0RNMU1UWTFJaUJvWldsbmFIUTlJakV1TVRrMk5UZ3hNaUkrUEM5eVpXTjBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4d2IyeDVaMjl1SUdsa1BTSlRhR0Z3WlNJZ2NHOXBiblJ6UFNJd0xqRTROamd4TXpFNE55QTVMalE1TVRRd01UY3hJREl1TlRJd05UazFOaUEzSURBdU1UZzJPREV6TVRnM0lEUXVOVEE0TlRrNE1qa2lQand2Y0c5c2VXZHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Wno0S0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUR3dlp6NEtJQ0FnSUR3dlp6NEtQQzl6ZG1jK1wifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRTJjSGdpSUdobGFXZG9kRDBpTVRSd2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFMklERTBJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVStiM1YwWkdWdWREd3ZkR2wwYkdVK0NpQWdJQ0E4WkdWell6NURjbVZoZEdWa0lIZHBkR2dnVTJ0bGRHTm9Mand2WkdWell6NEtJQ0FnSUR4a1pXWnpQand2WkdWbWN6NEtJQ0FnSUR4bklHbGtQU0pRWVdkbExURWlJSE4wY205clpUMGlibTl1WlNJZ2MzUnliMnRsTFhkcFpIUm9QU0l4SWlCbWFXeHNQU0p1YjI1bElpQm1hV3hzTFhKMWJHVTlJbVYyWlc1dlpHUWlQZ29nSUNBZ0lDQWdJRHhuSUdsa1BTSnZkWFJrWlc1MElpQm1hV3hzUFNJak1EQXdNREF3SWo0S0lDQWdJQ0FnSUNBZ0lDQWdQR2NnYVdROUlreGhlV1Z5WHpFaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BHY2dhV1E5SWtkeWIzVndJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNtVmpkQ0JwWkQwaVVtVmpkR0Z1WjJ4bExYQmhkR2dpSUhnOUlqVXVNemsyTVRZMk15SWdlVDBpTXk0eE9UTTBNelU1SWlCM2FXUjBhRDBpTVRBdU5UY3pNekEwTWlJZ2FHVnBaMmgwUFNJeExqRTVOalU0TVRJaVBqd3ZjbVZqZEQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVZqZENCcFpEMGlVbVZqZEdGdVoyeGxMWEJoZEdnaUlIZzlJakF1TURNNU5Ea3lNelF4TkNJZ2VUMGlNQzR3TURJMU5USTNNRFkxTlNJZ2QybGtkR2c5SWpFMUxqa3lPVGszT0RFaUlHaGxhV2RvZEQwaU1TNHhPVFkxT0RFeUlqNDhMM0psWTNRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEpsWTNRZ2FXUTlJbEpsWTNSaGJtZHNaUzF3WVhSb0lpQjRQU0l3TGpBek9UUTVNak0wTVRRaUlIazlJakV5TGpjMk5qQTROVFVpSUhkcFpIUm9QU0l4TlM0NU1qazVOemd4SWlCb1pXbG5hSFE5SWpFdU1UazJOVGd4TWlJK1BDOXlaV04wUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaV04wSUdsa1BTSlNaV04wWVc1bmJHVXRjR0YwYUNJZ2VEMGlOUzR6T1RZeE5qWXpJaUI1UFNJNUxqVTNOVEl3TWpJNElpQjNhV1IwYUQwaU1UQXVOVGN6TXpBME1pSWdhR1ZwWjJoMFBTSXhMakU1TmpVNE1USWlQand2Y21WamRENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y21WamRDQnBaRDBpVW1WamRHRnVaMnhsTFhCaGRHZ2lJSGc5SWpVdU16azJNVFkyTXlJZ2VUMGlOaTR6T0RRek1Ua3dPU0lnZDJsa2RHZzlJakV3TGpVM016TXdORElpSUdobGFXZG9kRDBpTVM0eE9UWTFPREV5SWo0OEwzSmxZM1ErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BIQnZiSGxuYjI0Z2FXUTlJbE5vWVhCbElpQndiMmx1ZEhNOUlqSXVNVGcyT0RnNE5DQTBMalE1TVRJd056azRJREFnTmk0NU9ESTJNRGsyT1NBeUxqRTROamc0T0RRZ09TNDBOelF3TVRFMElqNDhMM0J2YkhsbmIyNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThMMmMrQ2lBZ0lDQWdJQ0FnSUNBZ0lEd3ZaejRLSUNBZ0lDQWdJQ0E4TDJjK0NpQWdJQ0E4TDJjK0Nqd3ZjM1puUGc9PVwifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRXpjSGdpSUdobGFXZG9kRDBpTVROd2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFeklERXpJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVStiR2x6ZEMxdmNtUmxjbVZrUEM5MGFYUnNaVDRLSUNBZ0lEeGtaWE5qUGtOeVpXRjBaV1FnZDJsMGFDQlRhMlYwWTJndVBDOWtaWE5qUGdvZ0lDQWdQR1JsWm5NK1BDOWtaV1p6UGdvZ0lDQWdQR2NnYVdROUlsQmhaMlV0TVNJZ2MzUnliMnRsUFNKdWIyNWxJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqRWlJR1pwYkd3OUltNXZibVVpSUdacGJHd3RjblZzWlQwaVpYWmxibTlrWkNJK0NpQWdJQ0FnSUNBZ1BHY2dhV1E5SW14cGMzUXRiM0prWlhKbFpDSWdabWxzYkQwaUl6QXdNREF3TUNJK0NpQWdJQ0FnSUNBZ0lDQWdJRHhuSUdsa1BTSlFZV2RsTFRFaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BHYytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEdjZ2FXUTlJbXhwYzNRdGIzSmtaWEpsWkNJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4bklHbGtQU0pEWVhCaFh6RWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEdjZ2FXUTlJa2R5YjNWd0lqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNHRjBhQ0JrUFNKTk5DNHlNREU1TXpReE5pd3hMalEyTlRjek9EQXhJRXd4TWk0ek5USTBNRFF6TERFdU5EWTFOek00TURFZ1F6RXlMalk0T1RrNU5qa3NNUzQwTmpVM016Z3dNU0F4TWk0NU5qTTJPRGszTERFdU1UUXpOVFk0TWpZZ01USXVPVFl6TmpnNU55d3dMamMwTmpFNE1EZ3hNaUJETVRJdU9UWXpOamc1Tnl3d0xqTTBPRGM1TXpNMU9DQXhNaTQyT0RrNU9UWTVMREF1TURJMk5qSXpOakUyTXlBeE1pNHpOVEkwTURRekxEQXVNREkyTmpJek5qRTJNeUJNTkM0eU1ERTVNelF4Tml3d0xqQXlOall5TXpZeE5qTWdRek11T0RZME16UXhOeXd3TGpBeU5qWXlNell4TmpNZ015NDFPVEEyTkRnNUxEQXVNelE0Tnprek16VTRJRE11TlRrd05qUTRPU3d3TGpjME5qRTRNRGd4TWlCRE15NDFPVEEyTkRnNUxERXVNVFF6TlRZNE1qWWdNeTQ0TmpRek5ERTNMREV1TkRZMU56TTRNREVnTkM0eU1ERTVNelF4Tml3eExqUTJOVGN6T0RBeElFdzBMakl3TVRrek5ERTJMREV1TkRZMU56TTRNREVnVERRdU1qQXhPVE0wTVRZc01TNDBOalUzTXpnd01TQmFJaUJwWkQwaVUyaGhjR1VpUGp3dmNHRjBhRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjR0YwYUNCa1BTSk5NVEl1TXpVeU5EQTBNeXcxTGpjNE16QTRNVEU0SUV3MExqSXdNVGt6TkRFMkxEVXVOemd6TURneE1UZ2dRek11T0RZME16UXhOeXcxTGpjNE16QTRNVEU0SURNdU5Ua3dOalE0T1N3MkxqRXdOVEkxTURreUlETXVOVGt3TmpRNE9TdzJMalV3TWpZek9ETTNJRU16TGpVNU1EWTBPRGtzTmk0NU1EQXdNalU0TXlBekxqZzJORE0wTVRjc055NHlNakl4T1RVMU55QTBMakl3TVRrek5ERTJMRGN1TWpJeU1UazFOVGNnVERFeUxqTTFNalF3TkRNc055NHlNakl4T1RVMU55QkRNVEl1TmpnNU9UazJPU3czTGpJeU1qRTVOVFUzSURFeUxqazJNelk0T1Rjc05pNDVNREF3TWpVNE15QXhNaTQ1TmpNMk9EazNMRFl1TlRBeU5qTTRNemNnUXpFeUxqazJNelk0T1Rjc05pNHhNRFV5TURJNU5TQXhNaTQyT1RBd016YzNMRFV1Tnpnek1EZ3hNVGdnTVRJdU16VXlOREEwTXl3MUxqYzRNekE0TVRFNElFd3hNaTR6TlRJME1EUXpMRFV1Tnpnek1EZ3hNVGdnVERFeUxqTTFNalF3TkRNc05TNDNPRE13T0RFeE9DQmFJaUJwWkQwaVUyaGhjR1VpUGp3dmNHRjBhRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjR0YwYUNCa1BTSk5NVEl1TXpVeU5EQTBNeXd4TVM0MU16azFNemczSUV3MExqSXdNVGt6TkRFMkxERXhMalV6T1RVek9EY2dRek11T0RZME16UXhOeXd4TVM0MU16azFNemczSURNdU5Ua3dOalE0T1N3eE1TNDROakUzTURnMUlETXVOVGt3TmpRNE9Td3hNaTR5TlRrd09UWWdRek11TlRrd05qUTRPU3d4TWk0Mk5UWTBPRE0wSURNdU9EWTBNelF4Tnl3eE1pNDVOemcyTlRNeElEUXVNakF4T1RNME1UWXNNVEl1T1RjNE5qVXpNU0JNTVRJdU16VXlOREEwTXl3eE1pNDVOemcyTlRNeElFTXhNaTQyT0RrNU9UWTVMREV5TGprM09EWTFNekVnTVRJdU9UWXpOamc1Tnl3eE1pNDJOVFkwT0RNMElERXlMamsyTXpZNE9UY3NNVEl1TWpVNU1EazJJRU14TWk0NU5qTTJPRGszTERFeExqZzJNVGN3T0RVZ01USXVOamt3TURNM055d3hNUzQxTXprMU16ZzNJREV5TGpNMU1qUXdORE1zTVRFdU5UTTVOVE00TnlCTU1USXVNelV5TkRBME15d3hNUzQxTXprMU16ZzNJRXd4TWk0ek5USTBNRFF6TERFeExqVXpPVFV6T0RjZ1dpSWdhV1E5SWxOb1lYQmxJajQ4TDNCaGRHZytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BIQmhkR2dnWkQwaVRUQXVOelkzTWpBek56WXlMREV1TWpRNE9UVTVOREVnVERBdU56WTNNakF6TnpZeUxETXVNRFV3T1RJeU5URWdRekF1TnpZM01qQXpOell5TERNdU1qUTJNelUwTWpVZ01DNDVNREkxTURFMU5qZ3NNeTR6T1RNM01UazFOaUF4TGpBNE1UazNORGt5TERNdU16a3pOekU1TlRZZ1F6RXVNalU0TkRNeU5pd3pMak01TXpjeE9UVTJJREV1TXprMk5qSXpPRE1zTXk0eU5ETXhOREF5TXlBeExqTTVOall5TXpnekxETXVNRFV3T1RJeU5URWdUREV1TXprMk5qSXpPRE1zTUM0ek5UWXlNamczT0RJZ1F6RXVNemsyTmpJek9ETXNNQzR4TmpZeU5qVTJPRElnTVM0eU5qUXpNREE1TkN3d0xqQXhOelF4TXpJNE5ERWdNUzR3T1RVek9ESTBOQ3d3TGpBeE56UXhNekk0TkRFZ1F6QXVPVFEyTnprNU16WTVMREF1TURFM05ERXpNamcwTVNBd0xqZzNNalEyTnpBNE5Dd3dMakV6TkRjME9UQTNOeUF3TGpnME9EQTFOalF5Tml3d0xqRTNNek14TnpNME15QkRNQzQ0TkRjd016YzJNVGNzTUM0eE56UTVORGd6TXprZ01DNDRORFl3TVRnNE1Ea3NNQzR4TnpZMU56a3pNellnTUM0NE5EVXNNQzR4Tnpnek1EWXlOek1nVERBdU5UYzVNRFV3TVRVMkxEQXVOakl4TVRZNU56UXlJRU13TGpVeU56UXhOamt5T0N3d0xqWTROekkzTXpBMk15QXdMalE0TVRRNE9UQXlPQ3d3TGpjNU15QXdMalE0TVRRNE9UQXlPQ3d3TGpnNU5EUXdPVFU1TmlCRE1DNDBPREUwTkRneU56WXNNUzR3T0RjM016QTJNeUF3TGpZd09URTJOakUwTkN3eExqSTBOVFF3T1RZZ01DNDNOamN5TURNM05qSXNNUzR5TkRnNU5UazBNU0JNTUM0M05qY3lNRE0zTmpJc01TNHlORGc1TlRrME1TQk1NQzQzTmpjeU1ETTNOaklzTVM0eU5EZzVOVGswTVNCYUlpQnBaRDBpVTJoaGNHVWlQand2Y0dGMGFENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNHRjBhQ0JrUFNKTk1DNHpOVEUyT1RJM09TdzRMakU1TURjMk56UTVJRXd4TGpVMU1EQTFOalF6TERndU1Ua3dOelkzTkRrZ1F6RXVOekEyT1RFeU1qTXNPQzR4T1RBM05qYzBPU0F4TGpnek5EVTBPRFU1TERndU1ESTRNRGs1TmpNZ01TNDRNelExTkRnMU9TdzNMamd5T0RFMU9EWTNJRU14TGpnek5EVTBPRFU1TERjdU5qTXdNekk0TkRFZ01TNDNNRFk1TlRJNU55dzNMalEyT1RNNE56UTFJREV1TlRVd01EVTJORE1zTnk0ME5qa3pPRGMwTlNCTU1DNDJOems1TVRJeU1qWXNOeTQwTmprek9EYzBOU0JNTUM0Mk56azVNVEl5TWpZc055NDBOak0wT0Rjd09TQkRNQzQyTnprNU1USXlNallzTnk0ek5UVTNPVE16TmlBd0xqZzRPVGN3TlRNeU9TdzNMakU0TVRVeE5qWXhJREV1TURVNE1qazNPREVzTnk0d05ERTBPVEEzTnlCRE1TNHpPVE0yTkRnNUxEWXVOell5T1RJMk1pQXhMamd4TURrNU16Y3pMRFl1TkRFMk1qa3hOVEVnTVM0NE1UQTVPVE0zTXl3MUxqZ3hOVEV5TlRRMklFTXhMamd4TURrNU16Y3pMRFV1TWpRME5qRXlOVFVnTVM0ME16VTBNakF3Tml3MExqZ3hORFEyTVRJMUlEQXVPVE0zTXpRME9ETXhMRFF1T0RFME5EWXhNalVnUXpBdU5EWXdOREl3TURZekxEUXVPREUwTkRZeE1qVWdNQzR4TURBNE1qRXpNVGNzTlM0eU1EQXpNelUzT1NBd0xqRXdNRGd5TVRNeE55dzFMamN4TWpBek5qa2dRekF1TVRBd09ESXhNekUzTERZdU1EQTRPVGMwTVRjZ01DNHlOalV3TVRJMU16a3NOaTR4TVRRek5qVXpNU0F3TGpRd05UWXdPREUxTERZdU1URTBNelkxTXpFZ1F6QXVOakEyT0RRek1qWXNOaTR4TVRRek5qVXpNU0F3TGpjeU56RXdNelEwT1N3MUxqa3pOemszTnpnMklEQXVOekkzTVRBek5EUTVMRFV1TnpZM05UTTROelVnUXpBdU56STNNVEF6TkRRNUxEVXVOall4TlRjeE9UWWdNQzQzTlRBeU5UQTNPRE1zTlM0MU16azVNVGc0TWlBd0xqa3pNRFl5TURZNU15dzFMalV6T1RreE9EZ3lJRU14TGpFM05ESTNPU3cxTGpVek9Ua3hPRGd5SURFdU1UZ3hNamc0TkN3MUxqYzVOREEyTmpReUlERXVNVGd4TWpnNE5DdzFMamd5TXpBME1EVTVJRU14TGpFNE1USTRPRFFzTmk0d05URTBOell3TWlBd0xqa3lPVFF6T0RnM01pdzJMakkyTlRBME1EVTVJREF1TmpnMU9EWXlNRFk1TERZdU5EY3hOVFV6TlRFZ1F6QXVNemcwTnpnek5qazVMRFl1TnpJMk9EQTBORE1nTUM0d05ETTFNak0xTVRFc055NHdNVFl4TmpJek5pQXdMakEwTXpVeU16VXhNU3czTGpRMk16VTRNekF6SUV3d0xqQTBNelV5TXpVeE1TdzNMamcwTnpreU1qVXhJRU13TGpBME16UTRNamMxT0RZc09DNHdOVEk1T1RZek1TQXdMakl3TWpnMk5USXdNeXc0TGpFNU1EYzJOelE1SURBdU16VXhOamt5Tnprc09DNHhPVEEzTmpjME9TQk1NQzR6TlRFMk9USTNPU3c0TGpFNU1EYzJOelE1SUV3d0xqTTFNVFk1TWpjNUxEZ3VNVGt3TnpZM05Ea2dXaUlnYVdROUlsTm9ZWEJsSWo0OEwzQmhkR2crQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEJoZEdnZ1pEMGlUVEV1Tnpjd05USTJOalFzTVRBdU5UUXpNRGsySUVNeExqYzNNRFV5TmpZMExEa3VPVFV4TURRME1qY2dNUzQwTnpNMU1qTTFNU3c1TGpZeE1UVXdPVEl4SURBdU9UVTFOekkwTVRNNUxEa3VOakV4TlRBNU1qRWdRekF1TWpjMk56ZzVPVFk1TERrdU5qRXhOVEE1TWpFZ01DNHdPVGN6T1RneE1Ua3NNVEF1TVRneU1qWXlJREF1TURrM016azRNVEU1TERFd0xqUTROREEwTkRNZ1F6QXVNRGszTXprNE1URTVMREV3TGpnek5UTTRNREVnTUM0ek1Ua3lPVFEyTnl3eE1DNDROek16TWpRM0lEQXVOREUwTmprMU9USTFMREV3TGpnM016TXlORGNnUXpBdU5qQXdORGcxT0RrekxERXdMamczTXpNeU5EY2dNQzQzTWpVeU5qazFPVElzTVRBdU56STJNemt4TWlBd0xqY3lOVEkyT1RVNU1pd3hNQzQxTURjMk9UTTNJRU13TGpjeU5USTJPVFU1TWl3eE1DNDBNak0xTlRNMUlEQXVOelV3TmprNU1EWXNNVEF1TXpJMk9UZzRPU0F3TGprME9EZzNOemMwTkN3eE1DNHpNalk1T0RnNUlFTXhMakE1TVRNd056SXhMREV3TGpNeU5qazRPRGtnTVM0eE5Ea3lPVGM0TVN3eE1DNHpOVEV4TmpZeElERXVNVFE1TWprM09ERXNNVEF1TlRrME1EZzROU0JETVM0eE5Ea3lPVGM0TVN3eE1DNDRNekUwTkRZMUlERXVNVEEyTURFNE9ERXNNVEF1T0RVM016QXlOU0F3TGprek5UVTFNVGN5TXl3eE1DNDROVGN6TURJMUlFTXdMamMzTVRnd09EYzNOeXd4TUM0NE5UY3pNREkxSURBdU5qUTRNelk1T1RBMkxERXhMakF3T1RReE55QXdMalkwT0RNMk9Ua3dOaXd4TVM0eU1URXdPRFE1SUVNd0xqWTBPRE0yT1Rrd05pd3hNUzQwTVRBMU9UUXhJREF1Tnpjek16RTJOakUxTERFeExqVTJNVEEzTnpVZ01DNDVNemc1TnpRNU1pd3hNUzQxTmpFd056YzFJRU14TGpFMk5ERXpNVFkyTERFeExqVTJNVEEzTnpVZ01TNHlNRGt6TmpZM055d3hNUzQyTmpreU9UZzVJREV1TWpBNU16WTJOemNzTVRFdU9EUXpPVFU1TkNCTU1TNHlNRGt6TmpZM055d3hNUzQ1TVRnM05EVTBJRU14TGpJd09UTTJOamMzTERFeUxqSXhNall4TWpVZ01TNHhNVEl3TURrME1Td3hNaTR5Tmpnek1EWXpJREF1T1RNeU16TXlNamt4TERFeUxqSTJPRE13TmpNZ1F6QXVOamcwTkRNMU56TTJMREV5TGpJMk9ETXdOak1nTUM0Mk5qVXhOVGs0TnpVc01USXVNVEU0TURZeU55QXdMalkyTlRFMU9UZzNOU3d4TWk0d056SXdNVEV4SUVNd0xqWTJOVEUxT1RnM05Td3hNUzQ0T1RjNE16QXpJREF1TlRZM01EWTRPVFkxTERFeExqY3lNakEyTmpRZ01DNHpORGM1TURJNE1qSXNNVEV1TnpJeU1EWTJOQ0JETUM0eE5UVTFOVEUzTWpRc01URXVOekl5TURZMk5DQXdMakEwTURjeE1UVTVPRGdzTVRFdU9EWXpNVFEzTmlBd0xqQTBNRGN4TVRVNU9EZ3NNVEl1TURrNU5UUTJNU0JETUM0d05EQTNNVEUxT1RnNExERXlMalV6TURFeU9URWdNQzR6TlRRek5ERTJPVE1zTVRJdU9UZzNOelkzTlNBd0xqa3pOVFUxTVRjeU15d3hNaTQ1T0RjM05qYzFJRU14TGpVd01ERXpORGdzTVRJdU9UZzNOelkzTlNBeExqZ3pOekl6T0RJMExERXlMalU0T0RFeU5UVWdNUzQ0TXpjeU16Z3lOQ3d4TVM0NU1UZzNORFUwSUV3eExqZ3pOekl6T0RJMExERXhMamcwTXprMU9UUWdRekV1T0RNM01qTTRNalFzTVRFdU5UWTVOVEl3TXlBeExqYzJNalkyTVRRMExERXhMak0wTVRrME9ETWdNUzQyTWpJM01UYzROeXd4TVM0eE56Z3pNakVnUXpFdU56RTROVFkzTkN3eE1TNHdNVFV3TnpjMUlERXVOemN3TlRJMk5qUXNNVEF1TnprM01qUXpOU0F4TGpjM01EVXlOalkwTERFd0xqVTBNekE1TmlCTU1TNDNOekExTWpZMk5Dd3hNQzQxTkRNd09UWWdUREV1Tnpjd05USTJOalFzTVRBdU5UUXpNRGsySUZvaUlHbGtQU0pUYUdGd1pTSStQQzl3WVhSb1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4TDJjK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5blBnb2dJQ0FnSUNBZ0lDQWdJQ0E4TDJjK0NpQWdJQ0FnSUNBZ1BDOW5QZ29nSUNBZ1BDOW5QZ284TDNOMlp6ND1cIn0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9XCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlWVlJHTFRnaUlITjBZVzVrWVd4dmJtVTlJbTV2SWo4K0NqeHpkbWNnZDJsa2RHZzlJakUyY0hnaUlHaGxhV2RvZEQwaU1UUndlQ0lnZG1sbGQwSnZlRDBpTUNBd0lERTJJREUwSWlCMlpYSnphVzl1UFNJeExqRWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaVBnb2dJQ0FnUENFdExTQkhaVzVsY21GMGIzSTZJRk5yWlhSamFDQTBNQzR6SUNnek16Z3pPU2tnTFNCb2RIUndPaTh2ZDNkM0xtSnZhR1Z0YVdGdVkyOWthVzVuTG1OdmJTOXphMlYwWTJnZ0xTMCtDaUFnSUNBOGRHbDBiR1UrYkdsemRDMTFibTl5WkdWeVpXUThMM1JwZEd4bFBnb2dJQ0FnUEdSbGMyTStRM0psWVhSbFpDQjNhWFJvSUZOclpYUmphQzQ4TDJSbGMyTStDaUFnSUNBOFpHVm1jejQ4TDJSbFpuTStDaUFnSUNBOFp5QnBaRDBpVUdGblpTMHhJaUJ6ZEhKdmEyVTlJbTV2Ym1VaUlITjBjbTlyWlMxM2FXUjBhRDBpTVNJZ1ptbHNiRDBpYm05dVpTSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJajRLSUNBZ0lDQWdJQ0E4WnlCcFpEMGliR2x6ZEMxMWJtOXlaR1Z5WldRaUlHWnBiR3c5SWlNd01EQXdNREFpUGdvZ0lDQWdJQ0FnSUNBZ0lDQThaeUJwWkQwaVEyRndZVjh4SWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4bklHbGtQU0pIY205MWNDSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhCaGRHZ2daRDBpVFRFdU56SXdPREUyTXpNc015NDBNamN3T0RNek15QkRNaTQyTnpFd01qQTBNU3d6TGpReU56QTRNek16SURNdU5EUXhOak15TmpVc01pNDJOVGt3TWpjM09DQXpMalEwTVRZek1qWTFMREV1TnpFNU1qRXlPVFlnUXpNdU5EUXhOak15TmpVc01DNDNOemt6T1RneE5EZ2dNaTQyTnpFd01qQTBNU3d3TGpBd09ERXdNVGcxTVRnMUlERXVOekl3T0RFMk16TXNNQzR3TURneE1ERTROVEU0TlNCRE1DNDNOekEyTVRJeU5EVXNNQzR3TURneE1ERTROVEU0TlNBd0xEQXVOemMyTVRVM05EQTNJREFzTVM0M01UVTVOekl5TWlCRE1Dd3lMalkxTlRjNE56QTBJREF1Tnpjek9EYzNOVFV4TERNdU5ESTNNRGd6TXpNZ01TNDNNakE0TVRZek15d3pMalF5TnpBNE16TXpJRXd4TGpjeU1EZ3hOak16TERNdU5ESTNNRGd6TXpNZ1dpQk5NUzQzTWpBNE1UWXpNeXd3TGpnd01qQTRNek16TXlCRE1pNHlNekF5TURRd09Dd3dMamd3TWpBNE16TXpNeUF5TGpZME1UWXpNalkxTERFdU1qRXpOalUzTkRFZ01pNDJOREUyTXpJMk5Td3hMamN4TlRrM01qSXlJRU15TGpZME1UWXpNalkxTERJdU1qRTRNamczTURRZ01pNHlNalk1TXpnM09Dd3lMall5T1RnMk1URXhJREV1TnpJd09ERTJNek1zTWk0Mk1qazROakV4TVNCRE1TNHlNVFEyT1RNNE9Dd3lMall5T1RnMk1URXhJREF1T0N3eUxqSXhPREk0TnpBMElEQXVPQ3d4TGpjeE5UazNNakl5SUVNd0xqZ3NNUzR5TVRNMk5UYzBNU0F4TGpJeE5EWTVNemc0TERBdU9EQXlNRGd6TXpNeklERXVOekl3T0RFMk16TXNNQzQ0TURJd09ETXpNek1nVERFdU56SXdPREUyTXpNc01DNDRNREl3T0RNek16TWdXaUlnYVdROUlsTm9ZWEJsSWo0OEwzQmhkR2crQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BIQmhkR2dnWkQwaVRURXVOekl3T0RFMk16TXNPQzQzTURNd01Ea3lOaUJETWk0Mk56RXdNakEwTVN3NExqY3dNekF3T1RJMklETXVORFF4TmpNeU5qVXNOeTQ1TXpRNU5UTTNJRE11TkRReE5qTXlOalVzTmk0NU9UVXhNemc0T1NCRE15NDBOREUyTXpJMk5TdzJMakExTlRNeU5EQTNJREl1TmpjeE1ESXdOREVzTlM0eU9EY3lOamcxTWlBeExqY3lNRGd4TmpNekxEVXVNamczTWpZNE5USWdRekF1Tnpjd05qRXlNalExTERVdU1qZzNNalk0TlRJZ01DdzJMakExTWpBNE16TXpJREFzTmk0NU9UVXhNemc0T1NCRE1DdzNMamt6T0RFNU5EUTBJREF1Tnpjek9EYzNOVFV4TERndU56QXpNREE1TWpZZ01TNDNNakE0TVRZek15dzRMamN3TXpBd09USTJJRXd4TGpjeU1EZ3hOak16TERndU56QXpNREE1TWpZZ1dpQk5NUzQzTWpBNE1UWXpNeXcyTGpBNE1USTFJRU15TGpJek1ESXdOREE0TERZdU1EZ3hNalVnTWk0Mk5ERTJNekkyTlN3MkxqUTVNamd5TkRBM0lESXVOalF4TmpNeU5qVXNOaTQ1T1RVeE16ZzRPU0JETWk0Mk5ERTJNekkyTlN3M0xqUTVOelExTXpjZ01pNHlNalk1TXpnM09DdzNMamt3T1RBeU56YzRJREV1TnpJd09ERTJNek1zTnk0NU1Ea3dNamMzT0NCRE1TNHlNVFEyT1RNNE9DdzNMamt3T1RBeU56YzRJREF1T0N3M0xqVXdNRFk1TkRRMElEQXVPQ3cyTGprNU5URXpPRGc1SUVNd0xqZ3NOaTQwT0RrMU9ETXpNeUF4TGpJeE5EWTVNemc0TERZdU1EZ3hNalVnTVM0M01qQTRNVFl6TXl3MkxqQTRNVEkxSUV3eExqY3lNRGd4TmpNekxEWXVNRGd4TWpVZ1dpSWdhV1E5SWxOb1lYQmxJajQ4TDNCaGRHZytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhCaGRHZ2daRDBpVFRFdU56SXdPREUyTXpNc01UTXVPVGd5TVRjMU9TQkRNaTQyTnpFd01qQTBNU3d4TXk0NU9ESXhOelU1SURNdU5EUXhOak15TmpVc01UTXVNakUwTVRJd05DQXpMalEwTVRZek1qWTFMREV5TGpJM05ETXdOVFlnUXpNdU5EUXhOak15TmpVc01URXVNek14TWpVZ01pNDJOamMzTlRVeExERXdMalUyTmpRek5USWdNUzQzTWpBNE1UWXpNeXd4TUM0MU5qWTBNelV5SUVNd0xqYzNNemczTnpVMU1Td3hNQzQxTmpZME16VXlJREFzTVRFdU16TTBORGt3TnlBd0xERXlMakkzTkRNd05UWWdRekFzTVRNdU1qRTBNVEl3TkNBd0xqYzNNemczTnpVMU1Td3hNeTQ1T0RJeE56VTVJREV1TnpJd09ERTJNek1zTVRNdU9UZ3lNVGMxT1NCTU1TNDNNakE0TVRZek15d3hNeTQ1T0RJeE56VTVJRm9nVFRFdU56SXdPREUyTXpNc01URXVNelUzTVRjMU9TQkRNaTR5TXpBeU1EUXdPQ3d4TVM0ek5UY3hOelU1SURJdU5qUXhOak15TmpVc01URXVOelk0TnpVZ01pNDJOREUyTXpJMk5Td3hNaTR5TnpFd05qUTRJRU15TGpZME1UWXpNalkxTERFeUxqYzNOall5TURRZ01pNHlNalk1TXpnM09Dd3hNeTR4T0RRNU5UTTNJREV1TnpJd09ERTJNek1zTVRNdU1UZzBPVFV6TnlCRE1TNHlNVFEyT1RNNE9Dd3hNeTR4T0RRNU5UTTNJREF1T0N3eE1pNDNOek16TnprMklEQXVPQ3d4TWk0eU56RXdOalE0SUVNd0xqZ3NNVEV1TnpZNE56VWdNUzR5TVRRMk9UTTRPQ3d4TVM0ek5UY3hOelU1SURFdU56SXdPREUyTXpNc01URXVNelUzTVRjMU9TQk1NUzQzTWpBNE1UWXpNeXd4TVM0ek5UY3hOelU1SUZvaUlHbGtQU0pUYUdGd1pTSStQQzl3WVhSb1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh3WVhSb0lHUTlJazAxTGpjME16WTNNelEzTERJdU1URTBOVGd6TXpNZ1RERTFMalU0T0RVM01UUXNNaTR4TVRRMU9ETXpNeUJETVRVdU9ERXdOakV5TWl3eUxqRXhORFU0TXpNeklERTFMams1TURJd05ERXNNUzQ1TXpZek5ESTFPU0F4TlM0NU9UQXlNRFF4TERFdU56RTFPVGN5TWpJZ1F6RTFMams1TURJd05ERXNNUzQwT1RVMk1ERTROU0F4TlM0NE1UQTJNVEl5TERFdU16RTNNell4TVRFZ01UVXVOVGc0TlRjeE5Dd3hMak14TnpNMk1URXhJRXcxTGpjME16WTNNelEzTERFdU16RTNNell4TVRFZ1F6VXVOVEl4TmpNeU5qVXNNUzR6TVRjek5qRXhNU0ExTGpNME1qQTBNRGd5TERFdU5EazFOakF4T0RVZ05TNHpOREl3TkRBNE1pd3hMamN4TlRrM01qSXlJRU0xTGpNME1qQTBNRGd5TERFdU9UTTJNelF5TlRrZ05TNDFNakUyTXpJMk5Td3lMakV4TkRVNE16TXpJRFV1TnpRek5qY3pORGNzTWk0eE1UUTFPRE16TXlCTU5TNDNORE0yTnpNME55d3lMakV4TkRVNE16TXpJRm9pSUdsa1BTSlRhR0Z3WlNJK1BDOXdZWFJvUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHdZWFJvSUdROUlrMDFMamMwTXpZM016UTNMRGN1TXprek56VWdUREUxTGpVNE9EVTNNVFFzTnk0ek9UTTNOU0JETVRVdU9ERXdOakV5TWl3M0xqTTVNemMxSURFMUxqazVNREl3TkRFc055NHlNVFUxTURreU5pQXhOUzQ1T1RBeU1EUXhMRFl1T1RrMU1UTTRPRGtnUXpFMUxqazVNREl3TkRFc05pNDNOelEzTmpnMU1pQXhOUzQ0TVRBMk1USXlMRFl1TlRrMk5USTNOemdnTVRVdU5UZzROVGN4TkN3MkxqVTVOalV5TnpjNElFdzFMamMwTXpZM016UTNMRFl1TlRrMk5USTNOemdnUXpVdU5USXhOak15TmpVc05pNDFPVFkxTWpjM09DQTFMak0wTWpBME1EZ3lMRFl1TnpjME56WTROVElnTlM0ek5ESXdOREE0TWl3MkxqazVOVEV6T0RnNUlFTTFMak0wTWpBME1EZ3lMRGN1TWpFMU5UQTVNallnTlM0MU1qRTJNekkyTlN3M0xqTTVNemMxSURVdU56UXpOamN6TkRjc055NHpPVE0zTlNCTU5TNDNORE0yTnpNME55dzNMak01TXpjMUlGb2lJR2xrUFNKVGFHRndaU0krUEM5d1lYUm9QZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4d1lYUm9JR1E5SWswMUxqYzBNelkzTXpRM0xERXlMalkyT1RZM05Ua2dUREUxTGpVNE9EVTNNVFFzTVRJdU5qWTVOamMxT1NCRE1UVXVPREV3TmpFeU1pd3hNaTQyTmprMk56VTVJREUxTGprNU1ESXdOREVzTVRJdU5Ea3hORE0xTWlBeE5TNDVPVEF5TURReExERXlMakkzTVRBMk5EZ2dRekUxTGprNU1ESXdOREVzTVRJdU1EVXdOamswTkNBeE5TNDRNVEEyTVRJeUxERXhMamczTWpRMU16Y2dNVFV1TlRnNE5UY3hOQ3d4TVM0NE56STBOVE0zSUV3MUxqYzBNelkzTXpRM0xERXhMamczTWpRMU16Y2dRelV1TlRJeE5qTXlOalVzTVRFdU9EY3lORFV6TnlBMUxqTTBNakEwTURneUxERXlMakExTURZNU5EUWdOUzR6TkRJd05EQTRNaXd4TWk0eU56RXdOalE0SUVNMUxqTTBNakEwTURneUxERXlMalE1TVRRek5USWdOUzQxTWpFMk16STJOU3d4TWk0Mk5qazJOelU1SURVdU56UXpOamN6TkRjc01USXVOalk1TmpjMU9TQk1OUzQzTkRNMk56TTBOeXd4TWk0Mk5qazJOelU1SUZvaUlHbGtQU0pUYUdGd1pTSStQQzl3WVhSb1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOW5QZ29nSUNBZ0lDQWdJQ0FnSUNBOEwyYytDaUFnSUNBZ0lDQWdQQzluUGdvZ0lDQWdQQzluUGdvOEwzTjJaejQ9XCJ9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPVwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpVlZSR0xUZ2lJSE4wWVc1a1lXeHZibVU5SW01dklqOCtDanh6ZG1jZ2QybGtkR2c5SWpFMWNIZ2lJR2hsYVdkb2REMGlNVFZ3ZUNJZ2RtbGxkMEp2ZUQwaU1DQXdJREUxSURFMUlpQjJaWEp6YVc5dVBTSXhMakVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUlnZUcxc2JuTTZlR3hwYm1zOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2ZUd4cGJtc2lQZ29nSUNBZ1BDRXRMU0JIWlc1bGNtRjBiM0k2SUZOclpYUmphQ0EwTUM0eklDZ3pNemd6T1NrZ0xTQm9kSFJ3T2k4dmQzZDNMbUp2YUdWdGFXRnVZMjlrYVc1bkxtTnZiUzl6YTJWMFkyZ2dMUzArQ2lBZ0lDQThkR2wwYkdVK1lXeHBaMjR0YkdWbWREd3ZkR2wwYkdVK0NpQWdJQ0E4WkdWell6NURjbVZoZEdWa0lIZHBkR2dnVTJ0bGRHTm9Mand2WkdWell6NEtJQ0FnSUR4a1pXWnpQand2WkdWbWN6NEtJQ0FnSUR4bklHbGtQU0pRWVdkbExURWlJSE4wY205clpUMGlibTl1WlNJZ2MzUnliMnRsTFhkcFpIUm9QU0l4SWlCbWFXeHNQU0p1YjI1bElpQm1hV3hzTFhKMWJHVTlJbVYyWlc1dlpHUWlQZ29nSUNBZ0lDQWdJRHhuSUdsa1BTSmhiR2xuYmkxc1pXWjBJaUJtYVd4c1BTSWpNREF3TURBd0lqNEtJQ0FnSUNBZ0lDQWdJQ0FnUEdjZ2FXUTlJa05oY0dGZk1TSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThaeUJwWkQwaVIzSnZkWEFpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHdZWFJvSUdROUlrMDRMalE1TXpJMk1EZzNMREUwTGpnNE56RTNNemtnVERBdU16STJNRGcyT1RVM0xERTBMamc0TnpFM016a2dRekF1TVRRMk1EZzJPVFUzTERFMExqZzROekUzTXprZ01Dd3hOQzQzTkRFd09EY2dNQ3d4TkM0MU5qRXdPRGNnUXpBc01UUXVNemd4TURnM0lEQXVNVFEyTURnMk9UVTNMREUwTGpJek5TQXdMak15TmpBNE5qazFOeXd4TkM0eU16VWdURGd1TkRrek1qWXdPRGNzTVRRdU1qTTFJRU00TGpZM016STJNRGczTERFMExqSXpOU0E0TGpneE9UTTBOemd6TERFMExqTTRNVEE0TnlBNExqZ3hPVE0wTnpnekxERTBMalUyTVRBNE55QkRPQzQ0TVRrek5EYzRNeXd4TkM0M05ERXdPRGNnT0M0Mk56TTVNVE13TkN3eE5DNDRPRGN4TnpNNUlEZ3VORGt6TWpZd09EY3NNVFF1T0RnM01UY3pPU0JNT0M0ME9UTXlOakE0Tnl3eE5DNDRPRGN4TnpNNUlGb2lJR2xrUFNKVGFHRndaU0krUEM5d1lYUm9QZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4d1lYUm9JR1E5SWsweE5DNDJNVGM0TWpZeExERXdMakUyTVRVeU1UY2dUREF1TXpJMk1EZzJPVFUzTERFd0xqRTJNVFV5TVRjZ1F6QXVNVFEyTURnMk9UVTNMREV3TGpFMk1UVXlNVGNnTUN3eE1DNHdNVFUwTXpRNElEQXNPUzQ0TXpVME16UTNPQ0JETUN3NUxqWTFOVFF6TkRjNElEQXVNVFEyTURnMk9UVTNMRGt1TlRBNU16UTNPRE1nTUM0ek1qWXdPRFk1TlRjc09TNDFNRGt6TkRjNE15Qk1NVFF1TmpFM09ESTJNU3c1TGpVd09UTTBOemd6SUVNeE5DNDNPVGM0TWpZeExEa3VOVEE1TXpRM09ETWdNVFF1T1RRek9URXpMRGt1TmpVMU5ETTBOemdnTVRRdU9UUXpPVEV6TERrdU9ETTFORE0wTnpnZ1F6RTBMamswTXpreE15d3hNQzR3TVRVME16UTRJREUwTGpjNU56Z3lOakVzTVRBdU1UWXhOVEl4TnlBeE5DNDJNVGM0TWpZeExERXdMakUyTVRVeU1UY2dUREUwTGpZeE56Z3lOakVzTVRBdU1UWXhOVEl4TnlCYUlpQnBaRDBpVTJoaGNHVWlQand2Y0dGMGFENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y0dGMGFDQmtQU0pOT0M0ME9UTXlOakE0Tnl3MUxqUXpOVEl4TnpNNUlFd3dMak15TmpBNE5qazFOeXcxTGpRek5USXhOek01SUVNd0xqRTBOakE0TmprMU55dzFMalF6TlRJeE56TTVJREFzTlM0eU9Ea3hNekEwTXlBd0xEVXVNVEE1TVRNd05ETWdRekFzTkM0NU1qa3hNekEwTXlBd0xqRTBOakE0TmprMU55dzBMamM0TXpBME16UTRJREF1TXpJMk1EZzJPVFUzTERRdU56Z3pNRFF6TkRnZ1REZ3VORGt6TWpZd09EY3NOQzQzT0RNd05ETTBPQ0JET0M0Mk56TXlOakE0Tnl3MExqYzRNekEwTXpRNElEZ3VPREU1TXpRM09ETXNOQzQ1TWpreE16QTBNeUE0TGpneE9UTTBOemd6TERVdU1UQTVNVE13TkRNZ1F6Z3VPREU1TXpRM09ETXNOUzR5T0RreE16QTBNeUE0TGpZM016a3hNekEwTERVdU5ETTFNakUzTXprZ09DNDBPVE15TmpBNE55dzFMalF6TlRJeE56TTVJRXc0TGpRNU16STJNRGczTERVdU5ETTFNakUzTXprZ1dpSWdhV1E5SWxOb1lYQmxJajQ4TDNCaGRHZytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhCaGRHZ2daRDBpVFRFMExqWXhOemd5TmpFc01DNDNNRGc1TVRNd05ETWdUREF1TXpJMk1EZzJPVFUzTERBdU56QTRPVEV6TURReklFTXdMakUwTmpBNE5qazFOeXd3TGpjd09Ea3hNekEwTXlBd0xEQXVOVFl5T0RJMk1EZzNJREFzTUM0ek9ESTRNall3T0RjZ1F6QXNNQzR5TURJNE1qWXdPRGNnTUM0eE5EWXdPRFk1TlRjc01DNHdOVFkzTXpreE16QTBJREF1TXpJMk1EZzJPVFUzTERBdU1EVTJOek01TVRNd05DQk1NVFF1TmpFM09ESTJNU3d3TGpBMU5qY3pPVEV6TURRZ1F6RTBMamM1TnpneU5qRXNNQzR3TlRZM016a3hNekEwSURFMExqazBNemt4TXl3d0xqSXdNamd5TmpBNE55QXhOQzQ1TkRNNU1UTXNNQzR6T0RJNE1qWXdPRGNnUXpFMExqazBNemt4TXl3d0xqVTJNamd5TmpBNE55QXhOQzQzT1RjNE1qWXhMREF1TnpBNE9URXpNRFF6SURFMExqWXhOemd5TmpFc01DNDNNRGc1TVRNd05ETWdUREUwTGpZeE56Z3lOakVzTUM0M01EZzVNVE13TkRNZ1dpSWdhV1E5SWxOb1lYQmxJajQ4TDNCaGRHZytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThMMmMrQ2lBZ0lDQWdJQ0FnSUNBZ0lEd3ZaejRLSUNBZ0lDQWdJQ0E4TDJjK0NpQWdJQ0E4TDJjK0Nqd3ZjM1puUGc9PVwifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRTFjSGdpSUdobGFXZG9kRDBpTVRWd2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFMUlERTFJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVStZV3hwWjI0dFkyVnVkR1Z5UEM5MGFYUnNaVDRLSUNBZ0lEeGtaWE5qUGtOeVpXRjBaV1FnZDJsMGFDQlRhMlYwWTJndVBDOWtaWE5qUGdvZ0lDQWdQR1JsWm5NK1BDOWtaV1p6UGdvZ0lDQWdQR2NnYVdROUlsQmhaMlV0TVNJZ2MzUnliMnRsUFNKdWIyNWxJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqRWlJR1pwYkd3OUltNXZibVVpSUdacGJHd3RjblZzWlQwaVpYWmxibTlrWkNJK0NpQWdJQ0FnSUNBZ1BHY2dhV1E5SW1Gc2FXZHVMV05sYm5SbGNpSWdabWxzYkQwaUl6QXdNREF3TUNJK0NpQWdJQ0FnSUNBZ0lDQWdJRHhuSUdsa1BTSkhjbTkxY0NJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNHRjBhQ0JrUFNKTk1URXVOVFUxT0RZNU5pd3hOQzQ0T0RjeE56TTVJRXd6TGpNNE9EQTBNelE0TERFMExqZzROekUzTXprZ1F6TXVNakE0TURRek5EZ3NNVFF1T0RnM01UY3pPU0F6TGpBMk1UazFOalV5TERFMExqYzBNVEE0TnlBekxqQTJNVGsxTmpVeUxERTBMalUyTVRBNE55QkRNeTR3TmpFNU5UWTFNaXd4TkM0ek9ERXdPRGNnTXk0eU1EZ3dORE0wT0N3eE5DNHlNelVnTXk0ek9EZ3dORE0wT0N3eE5DNHlNelVnVERFeExqVTFOVEl4TnpRc01UUXVNak0xSUVNeE1TNDNNelV5TVRjMExERTBMakl6TlNBeE1TNDRPREV6TURRekxERTBMak00TVRBNE55QXhNUzQ0T0RFek1EUXpMREUwTGpVMk1UQTROeUJETVRFdU9EZ3hNekEwTXl3eE5DNDNOREV3T0RjZ01URXVOek0xT0RZNU5pd3hOQzQ0T0RjeE56TTVJREV4TGpVMU5UZzJPVFlzTVRRdU9EZzNNVGN6T1NCTU1URXVOVFUxT0RZNU5pd3hOQzQ0T0RjeE56TTVJRm9pSUdsa1BTSlRhR0Z3WlNJK1BDOXdZWFJvUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhCaGRHZ2daRDBpVFRFMExqWXhOemd5TmpFc01UQXVNVFl4TlRJeE55Qk1NQzR6TWpZd09EWTVOVGNzTVRBdU1UWXhOVEl4TnlCRE1DNHhORFl3T0RZNU5UY3NNVEF1TVRZeE5USXhOeUF3TERFd0xqQXhOVFF6TkRnZ01DdzVMamd6TlRRek5EYzRJRU13TERrdU5qVTFORE0wTnpnZ01DNHhORFl3T0RZNU5UY3NPUzQxTURrek5EYzRNeUF3TGpNeU5qQTROamsxTnl3NUxqVXdPVE0wTnpneklFd3hOQzQyTVRjNE1qWXhMRGt1TlRBNU16UTNPRE1nUXpFMExqYzVOemd5TmpFc09TNDFNRGt6TkRjNE15QXhOQzQ1TkRNNU1UTXNPUzQyTlRVME16UTNPQ0F4TkM0NU5ETTVNVE1zT1M0NE16VTBNelEzT0NCRE1UUXVPVFF6T1RFekxERXdMakF4TlRRek5EZ2dNVFF1TnprM09ESTJNU3d4TUM0eE5qRTFNakUzSURFMExqWXhOemd5TmpFc01UQXVNVFl4TlRJeE55Qk1NVFF1TmpFM09ESTJNU3d4TUM0eE5qRTFNakUzSUZvaUlHbGtQU0pUYUdGd1pTSStQQzl3WVhSb1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BIQmhkR2dnWkQwaVRURXhMalUxTlRnMk9UWXNOUzQwTXpVeU1UY3pPU0JNTXk0ek9EZ3dORE0wT0N3MUxqUXpOVEl4TnpNNUlFTXpMakl3T0RBME16UTRMRFV1TkRNMU1qRTNNemtnTXk0d05qRTVOVFkxTWl3MUxqSTRPVEV6TURReklETXVNRFl4T1RVMk5USXNOUzR4TURreE16QTBNeUJETXk0d05qRTVOVFkxTWl3MExqa3lPVEV6TURReklETXVNakE0TURRek5EZ3NOQzQzT0RNd05ETTBPQ0F6TGpNNE9EQTBNelE0TERRdU56Z3pNRFF6TkRnZ1RERXhMalUxTlRJeE56UXNOQzQzT0RNd05ETTBPQ0JETVRFdU56TTFNakUzTkN3MExqYzRNekEwTXpRNElERXhMamc0TVRNd05ETXNOQzQ1TWpreE16QTBNeUF4TVM0NE9ERXpNRFF6TERVdU1UQTVNVE13TkRNZ1F6RXhMamc0TVRNd05ETXNOUzR5T0RreE16QTBNeUF4TVM0M016VTROamsyTERVdU5ETTFNakUzTXprZ01URXVOVFUxT0RZNU5pdzFMalF6TlRJeE56TTVJRXd4TVM0MU5UVTROamsyTERVdU5ETTFNakUzTXprZ1dpSWdhV1E5SWxOb1lYQmxJajQ4TDNCaGRHZytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjR0YwYUNCa1BTSk5NVFF1TmpFM09ESTJNU3d3TGpjd09Ea3hNekEwTXlCTU1DNHpNall3T0RZNU5UY3NNQzQzTURnNU1UTXdORE1nUXpBdU1UUTJNRGcyT1RVM0xEQXVOekE0T1RFek1EUXpJREFzTUM0MU5qSTRNall3T0RjZ01Dd3dMak00TWpneU5qQTROeUJETUN3d0xqSXdNamd5TmpBNE55QXdMakUwTmpBNE5qazFOeXd3TGpBMU5qY3pPVEV6TURRZ01DNHpNall3T0RZNU5UY3NNQzR3TlRZM016a3hNekEwSUV3eE5DNDJNVGM0TWpZeExEQXVNRFUyTnpNNU1UTXdOQ0JETVRRdU56azNPREkyTVN3d0xqQTFOamN6T1RFek1EUWdNVFF1T1RRek9URXpMREF1TWpBeU9ESTJNRGczSURFMExqazBNemt4TXl3d0xqTTRNamd5TmpBNE55QkRNVFF1T1RRek9URXpMREF1TlRZeU9ESTJNRGczSURFMExqYzVOemd5TmpFc01DNDNNRGc1TVRNd05ETWdNVFF1TmpFM09ESTJNU3d3TGpjd09Ea3hNekEwTXlCTU1UUXVOakUzT0RJMk1Td3dMamN3T0RreE16QTBNeUJhSWlCcFpEMGlVMmhoY0dVaVBqd3ZjR0YwYUQ0S0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUR3dlp6NEtJQ0FnSUR3dlp6NEtQQzl6ZG1jK1wifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRTFjSGdpSUdobGFXZG9kRDBpTVRWd2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFMUlERTFJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVStZV3hwWjI0dGNtbG5hSFE4TDNScGRHeGxQZ29nSUNBZ1BHUmxjMk0rUTNKbFlYUmxaQ0IzYVhSb0lGTnJaWFJqYUM0OEwyUmxjMk0rQ2lBZ0lDQThaR1ZtY3o0OEwyUmxabk0rQ2lBZ0lDQThaeUJwWkQwaVVHRm5aUzB4SWlCemRISnZhMlU5SW01dmJtVWlJSE4wY205clpTMTNhV1IwYUQwaU1TSWdabWxzYkQwaWJtOXVaU0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWo0S0lDQWdJQ0FnSUNBOFp5QnBaRDBpWVd4cFoyNHRjbWxuYUhRaUlHWnBiR3c5SWlNd01EQXdNREFpUGdvZ0lDQWdJQ0FnSUNBZ0lDQThaeUJwWkQwaVEyRndZVjh4SWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4bklHbGtQU0pIY205MWNDSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhCaGRHZ2daRDBpVFRFMExqWXhOemd5TmpFc01UUXVPRGczTVRjek9TQk1OaTQwTlRBMk5USXhOeXd4TkM0NE9EY3hOek01SUVNMkxqSTNNRFkxTWpFM0xERTBMamc0TnpFM016a2dOaTR4TWpRMU5qVXlNaXd4TkM0M05ERXdPRGNnTmk0eE1qUTFOalV5TWl3eE5DNDFOakV3T0RjZ1F6WXVNVEkwTlRZMU1qSXNNVFF1TXpneE1EZzNJRFl1TWpjd05qVXlNVGNzTVRRdU1qTTFJRFl1TkRVd05qVXlNVGNzTVRRdU1qTTFJRXd4TkM0Mk1UYzRNall4TERFMExqSXpOU0JETVRRdU56azNPREkyTVN3eE5DNHlNelVnTVRRdU9UUXpPVEV6TERFMExqTTRNVEE0TnlBeE5DNDVORE01TVRNc01UUXVOVFl4TURnM0lFTXhOQzQ1TkRNNU1UTXNNVFF1TnpReE1EZzNJREUwTGpjNU56Z3lOakVzTVRRdU9EZzNNVGN6T1NBeE5DNDJNVGM0TWpZeExERTBMamc0TnpFM016a2dUREUwTGpZeE56Z3lOakVzTVRRdU9EZzNNVGN6T1NCYUlpQnBaRDBpVTJoaGNHVWlQand2Y0dGMGFENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y0dGMGFDQmtQU0pOTVRRdU5qRTNPREkyTVN3eE1DNHhOakUxTWpFM0lFd3dMak15TmpBNE5qazFOeXd4TUM0eE5qRTFNakUzSUVNd0xqRTBOakE0TmprMU55d3hNQzR4TmpFMU1qRTNJREFzTVRBdU1ERTFORE0wT0NBd0xEa3VPRE0xTkRNME56Z2dRekFzT1M0Mk5UVTBNelEzT0NBd0xqRTBOakE0TmprMU55dzVMalV3T1RNME56Z3pJREF1TXpJMk1EZzJPVFUzTERrdU5UQTVNelEzT0RNZ1RERTBMall4TnpneU5qRXNPUzQxTURrek5EYzRNeUJETVRRdU56azNPREkyTVN3NUxqVXdPVE0wTnpneklERTBMamswTXpreE15dzVMalkxTlRRek5EYzRJREUwTGprME16a3hNeXc1TGpnek5UUXpORGM0SUVNeE5DNDVORE01TVRNc01UQXVNREUxTkRNME9DQXhOQzQzT1RjNE1qWXhMREV3TGpFMk1UVXlNVGNnTVRRdU5qRTNPREkyTVN3eE1DNHhOakUxTWpFM0lFd3hOQzQyTVRjNE1qWXhMREV3TGpFMk1UVXlNVGNnV2lJZ2FXUTlJbE5vWVhCbElqNDhMM0JoZEdnK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEJoZEdnZ1pEMGlUVEUwTGpZeE56Z3lOakVzTlM0ME16VXlNVGN6T1NCTU5pNDBOVEEyTlRJeE55dzFMalF6TlRJeE56TTVJRU0yTGpJM01EWTFNakUzTERVdU5ETTFNakUzTXprZ05pNHhNalExTmpVeU1pdzFMakk0T1RFek1EUXpJRFl1TVRJME5UWTFNaklzTlM0eE1Ea3hNekEwTXlCRE5pNHhNalExTmpVeU1pdzBMamt5T1RFek1EUXpJRFl1TWpjd05qVXlNVGNzTkM0M09ETXdORE0wT0NBMkxqUTFNRFkxTWpFM0xEUXVOemd6TURRek5EZ2dUREUwTGpZeE56Z3lOakVzTkM0M09ETXdORE0wT0NCRE1UUXVOemszT0RJMk1TdzBMamM0TXpBME16UTRJREUwTGprME16a3hNeXcwTGpreU9URXpNRFF6SURFMExqazBNemt4TXl3MUxqRXdPVEV6TURReklFTXhOQzQ1TkRNNU1UTXNOUzR5T0RreE16QTBNeUF4TkM0M09UYzRNall4TERVdU5ETTFNakUzTXprZ01UUXVOakUzT0RJMk1TdzFMalF6TlRJeE56TTVJRXd4TkM0Mk1UYzRNall4TERVdU5ETTFNakUzTXprZ1dpSWdhV1E5SWxOb1lYQmxJajQ4TDNCaGRHZytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhCaGRHZ2daRDBpVFRFMExqWXhOemd5TmpFc01DNDNNRGc1TVRNd05ETWdUREF1TXpJMk1EZzJPVFUzTERBdU56QTRPVEV6TURReklFTXdMakUwTmpBNE5qazFOeXd3TGpjd09Ea3hNekEwTXlBd0xEQXVOVFl5T0RJMk1EZzNJREFzTUM0ek9ESTRNall3T0RjZ1F6QXNNQzR5TURJNE1qWXdPRGNnTUM0eE5EWXdPRFk1TlRjc01DNHdOVFkzTXpreE16QTBJREF1TXpJMk1EZzJPVFUzTERBdU1EVTJOek01TVRNd05DQk1NVFF1TmpFM09ESTJNU3d3TGpBMU5qY3pPVEV6TURRZ1F6RTBMamM1TnpneU5qRXNNQzR3TlRZM016a3hNekEwSURFMExqazBNemt4TXl3d0xqSXdNamd5TmpBNE55QXhOQzQ1TkRNNU1UTXNNQzR6T0RJNE1qWXdPRGNnUXpFMExqazBNemt4TXl3d0xqVTJNamd5TmpBNE55QXhOQzQzT1RjNE1qWXhMREF1TnpBNE9URXpNRFF6SURFMExqWXhOemd5TmpFc01DNDNNRGc1TVRNd05ETWdUREUwTGpZeE56Z3lOakVzTUM0M01EZzVNVE13TkRNZ1dpSWdhV1E5SWxOb1lYQmxJajQ4TDNCaGRHZytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThMMmMrQ2lBZ0lDQWdJQ0FnSUNBZ0lEd3ZaejRLSUNBZ0lDQWdJQ0E4TDJjK0NpQWdJQ0E4TDJjK0Nqd3ZjM1puUGc9PVwifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRTFjSGdpSUdobGFXZG9kRDBpTVRWd2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFMUlERTFJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVStZV3hwWjI0dGFuVnpkR2xtZVR3dmRHbDBiR1UrQ2lBZ0lDQThaR1Z6WXo1RGNtVmhkR1ZrSUhkcGRHZ2dVMnRsZEdOb0xqd3ZaR1Z6WXo0S0lDQWdJRHhrWldaelBqd3ZaR1ZtY3o0S0lDQWdJRHhuSUdsa1BTSlFZV2RsTFRFaUlITjBjbTlyWlQwaWJtOXVaU0lnYzNSeWIydGxMWGRwWkhSb1BTSXhJaUJtYVd4c1BTSnViMjVsSWlCbWFXeHNMWEoxYkdVOUltVjJaVzV2WkdRaVBnb2dJQ0FnSUNBZ0lEeG5JR2xrUFNKaGJHbG5iaTFxZFhOMGFXWjVJaUJtYVd4c1BTSWpNREF3TURBd0lqNEtJQ0FnSUNBZ0lDQWdJQ0FnUEdjZ2FXUTlJa05oY0dGZk1TSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThaeUJwWkQwaVIzSnZkWEFpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHdZWFJvSUdROUlrMHhOQzQyTVRreE16QTBMREUwTGpnNE56Z3lOakVnVERBdU16STJNRGcyT1RVM0xERTBMamc0TnpneU5qRWdRekF1TVRRMk1EZzJPVFUzTERFMExqZzROemd5TmpFZ01Dd3hOQzQzTkRFM016a3hJREFzTVRRdU5UWXhOek01TVNCRE1Dd3hOQzR6T0RFM016a3hJREF1TVRRMk1EZzJPVFUzTERFMExqSXpOVFkxTWpJZ01DNHpNall3T0RZNU5UY3NNVFF1TWpNMU5qVXlNaUJNTVRRdU5qRTVNVE13TkN3eE5DNHlNelUyTlRJeUlFTXhOQzQzT1RreE16QTBMREUwTGpJek5UWTFNaklnTVRRdU9UUTFNakUzTkN3eE5DNHpPREUzTXpreElERTBMamswTlRJeE56UXNNVFF1TlRZeE56TTVNU0JETVRRdU9UUTFNakUzTkN3eE5DNDNOREUzTXpreElERTBMamM1T1RFek1EUXNNVFF1T0RnM09ESTJNU0F4TkM0Mk1Ua3hNekEwTERFMExqZzROemd5TmpFZ1RERTBMall4T1RFek1EUXNNVFF1T0RnM09ESTJNU0JhSWlCcFpEMGlVMmhoY0dVaVBqd3ZjR0YwYUQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjR0YwYUNCa1BTSk5NVFF1TmpFNU1UTXdOQ3d4TUM0eE5qSXhOek01SUV3d0xqTXlOakE0TmprMU55d3hNQzR4TmpJeE56TTVJRU13TGpFME5qQTROamsxTnl3eE1DNHhOakl4TnpNNUlEQXNNVEF1TURFMk1EZzNJREFzT1M0NE16WXdPRFk1TmlCRE1DdzVMalkxTmpBNE5qazJJREF1TVRRMk1EZzJPVFUzTERrdU5URWdNQzR6TWpZd09EWTVOVGNzT1M0MU1TQk1NVFF1TmpFNU1UTXdOQ3c1TGpVeElFTXhOQzQzT1RreE16QTBMRGt1TlRFZ01UUXVPVFExTWpFM05DdzVMalkxTmpBNE5qazJJREUwTGprME5USXhOelFzT1M0NE16WXdPRFk1TmlCRE1UUXVPVFExTWpFM05Dd3hNQzR3TVRZd09EY2dNVFF1TnprNU1UTXdOQ3d4TUM0eE5qSXhOek01SURFMExqWXhPVEV6TURRc01UQXVNVFl5TVRjek9TQk1NVFF1TmpFNU1UTXdOQ3d4TUM0eE5qSXhOek01SUZvaUlHbGtQU0pUYUdGd1pTSStQQzl3WVhSb1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh3WVhSb0lHUTlJazB4TkM0Mk1Ua3hNekEwTERVdU5ETTFPRFk1TlRjZ1REQXVNekkyTURnMk9UVTNMRFV1TkRNMU9EWTVOVGNnUXpBdU1UUTJNRGcyT1RVM0xEVXVORE0xT0RZNU5UY2dNQ3cxTGpJNE9UYzRNall4SURBc05TNHhNRGszT0RJMk1TQkRNQ3cwTGpreU9UYzRNall4SURBdU1UUTJNRGcyT1RVM0xEUXVOemd6TmprMU5qVWdNQzR6TWpZd09EWTVOVGNzTkM0M09ETTJPVFUyTlNCTU1UUXVOakU1TVRNd05DdzBMamM0TXpZNU5UWTFJRU14TkM0M09Ua3hNekEwTERRdU56Z3pOamsxTmpVZ01UUXVPVFExTWpFM05DdzBMamt5T1RjNE1qWXhJREUwTGprME5USXhOelFzTlM0eE1EazNPREkyTVNCRE1UUXVPVFExTWpFM05DdzFMakk0T1RjNE1qWXhJREUwTGpjNU9URXpNRFFzTlM0ME16VTROamsxTnlBeE5DNDJNVGt4TXpBMExEVXVORE0xT0RZNU5UY2dUREUwTGpZeE9URXpNRFFzTlM0ME16VTROamsxTnlCYUlpQnBaRDBpVTJoaGNHVWlQand2Y0dGMGFENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y0dGMGFDQmtQU0pOTVRRdU5qRTVNVE13TkN3d0xqY3dPVFUyTlRJeE55Qk1NQzR6TWpZd09EWTVOVGNzTUM0M01EazFOalV5TVRjZ1F6QXVNVFEyTURnMk9UVTNMREF1TnpBNU5UWTFNakUzSURBc01DNDFOak0wTnpneU5qRWdNQ3d3TGpNNE16UTNPREkyTVNCRE1Dd3dMakl3TXpRM09ESTJNU0F3TGpFME5qQTROamsxTnl3d0xqQTFOek01TVRNd05ETWdNQzR6TWpZd09EWTVOVGNzTUM0d05UY3pPVEV6TURReklFd3hOQzQyTVRreE16QTBMREF1TURVM016a3hNekEwTXlCRE1UUXVOems1TVRNd05Dd3dMakExTnpNNU1UTXdORE1nTVRRdU9UUTFNakUzTkN3d0xqSXdNelEzT0RJMk1TQXhOQzQ1TkRVeU1UYzBMREF1TXpnek5EYzRNall4SUVNeE5DNDVORFV5TVRjMExEQXVOVFl6TkRjNE1qWXhJREUwTGpjNU9URXpNRFFzTUM0M01EazFOalV5TVRjZ01UUXVOakU1TVRNd05Dd3dMamN3T1RVMk5USXhOeUJNTVRRdU5qRTVNVE13TkN3d0xqY3dPVFUyTlRJeE55QmFJaUJwWkQwaVUyaGhjR1VpUGp3dmNHRjBhRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Wno0S0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUR3dlp6NEtJQ0FnSUR3dlp6NEtQQzl6ZG1jK1wifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRTFjSGdpSUdobGFXZG9kRDBpTVRWd2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFMUlERTFJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVStZMjlzYjNJOEwzUnBkR3hsUGdvZ0lDQWdQR1JsYzJNK1EzSmxZWFJsWkNCM2FYUm9JRk5yWlhSamFDNDhMMlJsYzJNK0NpQWdJQ0E4WkdWbWN6NDhMMlJsWm5NK0NpQWdJQ0E4WnlCcFpEMGlVR0ZuWlMweElpQnpkSEp2YTJVOUltNXZibVVpSUhOMGNtOXJaUzEzYVdSMGFEMGlNU0lnWm1sc2JEMGlibTl1WlNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lqNEtJQ0FnSUNBZ0lDQThaeUJwWkQwaVkyOXNiM0lpSUdacGJHdzlJaU13TURBd01EQWlQZ29nSUNBZ0lDQWdJQ0FnSUNBOFp5QnBaRDBpUTJGd1lWOHhJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHhuSUdsa1BTSkhjbTkxY0NJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEJoZEdnZ1pEMGlUVEUwTGpRd05qTTROekVzTUM0MU9EVXlOVGd3TmpVZ1F6RXpMall5TmpJNU1ETXNMVEF1TVRrME9EY3dPVFk0SURFeUxqTTJNVFExTVRZc0xUQXVNVGsxTURrMk56YzBJREV4TGpVNE1EZ3pPRGNzTUM0MU9EVWdUREV4TGpBME1UVTRNRFlzTVM0eE1qUXlOVGd3TmlCRE1UQXVOelV4T1RBek1pd3dMamd6TkRZeE1qa3dNeUF4TUM0eU9ESTNNRGszTERBdU9ETTBOakV5T1RBeklEa3VPVGt6TURZME5USXNNUzR4TWpReU5UZ3dOaUJET1M0M01ETXpOVFE0TkN3eExqUXhNelkzTnpReUlEa3VOekF6TXpVME9EUXNNUzQ0T0RNek9EY3hJRGt1T1Rrek1EWTBOVElzTWk0eE56STRNRFkwTlNCTU1UQXVNVFkzTnpjME1pd3lMak0wTnpZeE1qa2dURFF1TXpReU16VTBPRFFzT0M0eE56TTBOVEUyTVNCTU5DNHpOREU0TXpnM01TdzRMakUzTXpRMU1UWXhJRXd5TGpNeE9UYzBNVGswTERFd0xqRTVOVGMwTVRrZ1F6SXVNVFU1TURNeU1qWXNNVEF1TXpVMk5EVXhOaUF5TGpBMk5ESTVNRE15TERFd0xqVTNNVFF4T1RRZ01pNHdOVFF3T1RZM055d3hNQzQzT1RnME5URTJJRXd5TGpBME9USTFPREEyTERFd0xqa3dOak15TWpZZ1RESXVNRFE1TWpVNE1EWXNNVEF1T1RBM09EQTJOU0JNTVM0NU5qYzJOemMwTWl3eE1pNDNNelk1TmpjM0lFTXhMamsyTkRNeU1qVTRMREV5TGpneU1Ua3dNeklnTVM0NU9UWXhOakV5T1N3eE1pNDVNRFF5TWpVNElESXVNRFUyTURNeU1qWXNNVEl1T1RZME16SXlOaUJETWk0eE1USTFNVFl4TXl3eE15NHdNakV3TmpRMUlESXVNVGc1TnpReE9UUXNNVE11TURVeU5qUTFNaUF5TGpJMk9Ua3dNekl6TERFekxqQTFNalkwTlRJZ1F6SXVNamMwTWpVNE1EWXNNVE11TURVeU5qUTFNaUF5TGpJM09EVTRNRFkxTERFekxqQTFNalkwTlRJZ01pNHlPRE0wTlRFMk1Td3hNeTR3TlRJek9EY3hJRXd6TGpJMU16STFPREEyTERFekxqQXdPVFExTVRZZ1RETXVNalV6TnpjME1Ua3NNVE11TURBNU5EVXhOaUJNTXk0NE5EUTJOemMwTWl3eE1pNDVPRE14TmpFeklFdzBMakV4TXl3eE1pNDVOekV6TlRRNElFTTBMalF3T1RnM01EazNMREV5TGprMU9EQTJORFVnTkM0Mk9URTRNemczTVN3eE1pNDRNek01TmpjM0lEUXVPVEF5TXpJeU5UZ3NNVEl1TmpJek56UXhPU0JNTVRJdU5qY3pNakkxT0N3MExqZzFNekEyTkRVeUlFd3hNaTQ0TVRnMU9EQTJMRFF1T1RrNE16ZzNNU0JETVRJdU9UWXpOREU1TkN3MUxqRTBNekUyTVRJNUlERXpMakUxTXpFMk1UTXNOUzR5TVRVMU9EQTJOU0F4TXk0ek5ESTRNemczTERVdU1qRTFOVGd3TmpVZ1F6RXpMalV6TWpVME9EUXNOUzR5TVRVMU9EQTJOU0F4TXk0M01qSXpNakkyTERVdU1UUXpNVFl4TWprZ01UTXVPRFkzTVRJNUxEUXVPVGs0TXpnM01TQkRNVFF1TVRVMk9EQTJOU3cwTGpjd09Ea3pOVFE0SURFMExqRTFOamd3TmpVc05DNHlNemt5TWpVNE1TQXhNeTQ0TmpjeE1qa3NNeTQ1TkRrNE16ZzNNU0JNTVRRdU5EQTJNelUwT0N3ekxqUXhNRFUwT0RNNUlFTXhOUzR4T0RZMU1UWXhMREl1TmpNd05EVXhOakVnTVRVdU1UZzJOVEUyTVN3eExqTTJOVFl4TWprZ01UUXVOREEyTXpnM01Td3dMalU0TlRJMU9EQTJOU0JNTVRRdU5EQTJNemczTVN3d0xqVTROVEkxT0RBMk5TQmFJRTA0TGpjNU5EZ3dOalExTERjdU16TXpNakkxT0RFZ1REWXVNRFkxTnpjME1Ua3NOeTQ0TkRnd05qUTFNaUJNTVRBdU5URTNNekl5Tml3ekxqTTVOak15TWpVNElFd3hNUzQyTWpRNE1EWTFMRFF1TlRBek1qa3dNeklnVERndU56azBPREEyTkRVc055NHpNek15TWpVNE1TQk1PQzQzT1RRNE1EWTBOU3czTGpNek16SXlOVGd4SUZvaUlHbGtQU0pUYUdGd1pTSStQQzl3WVhSb1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh3WVhSb0lHUTlJazB5TGpBNE1EWTBOVEUyTERFekxqWTNNekk1TURNZ1F6QXVPVE14TnpBNU5qYzNMREV6TGpZM016STVNRE1nTUN3eE15NDVOamd5T1RBeklEQXNNVFF1TXpNeU5EZ3pPU0JETUN3eE5DNDJPVFkwT0RNNUlEQXVPVE14TnpBNU5qYzNMREUwTGprNU1UUTFNVFlnTWk0d09EQTJORFV4Tml3eE5DNDVPVEUwTlRFMklFTXpMakl5T1RVNE1EWTFMREUwTGprNU1UUTFNVFlnTkM0eE5qQTRNemczTVN3eE5DNDJPVFkxTVRZeElEUXVNVFl3T0RNNE56RXNNVFF1TXpNeU5EZ3pPU0JETkM0eE5qQTRNemczTVN3eE15NDVOamd5TlRneElETXVNakk1TlRnd05qVXNNVE11Tmpjek1qa3dNeUF5TGpBNE1EWTBOVEUyTERFekxqWTNNekk1TURNZ1RESXVNRGd3TmpRMU1UWXNNVE11Tmpjek1qa3dNeUJhSWlCcFpEMGlVMmhoY0dVaVBqd3ZjR0YwYUQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dlp6NEtJQ0FnSUNBZ0lDQWdJQ0FnUEM5blBnb2dJQ0FnSUNBZ0lEd3ZaejRLSUNBZ0lEd3ZaejRLUEM5emRtYytcIn0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9XCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlkWFJtTFRnaVB6NEtQQ0V0TFNCSFpXNWxjbUYwWldRZ1lua2dTV052VFc5dmJpNXBieUF0TFQ0S1BDRkVUME5VV1ZCRklITjJaeUJRVlVKTVNVTWdJaTB2TDFjelF5OHZSRlJFSUZOV1J5QXhMakV2TDBWT0lpQWlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZSM0poY0docFkzTXZVMVpITHpFdU1TOUVWRVF2YzNabk1URXVaSFJrSWo0S1BITjJaeUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpSUhkcFpIUm9QU0l4TlNJZ2FHVnBaMmgwUFNJeE5TSWdkbWxsZDBKdmVEMGlNQ0F3SURFMklERTJJajRLUEhCaGRHZ2dabWxzYkQwaUl6QXdNREF3TUNJZ1pEMGlUVGd1TVNBeE5HdzJMalF0Tnk0eVl6QXVOaTB3TGpjZ01DNDJMVEV1T0Mwd0xqRXRNaTQxYkMweUxqY3RNaTQzWXkwd0xqTXRNQzQwTFRBdU9DMHdMall0TVM0ekxUQXVObWd0TVM0NFl5MHdMalVnTUMweElEQXVNaTB4TGpRZ01DNDJiQzAyTGpjZ055NDJZeTB3TGpZZ01DNDNMVEF1TmlBeExqa2dNQzR4SURJdU5Xd3lMamNnTWk0M1l6QXVNeUF3TGpRZ01DNDRJREF1TmlBeExqTWdNQzQyYURFeExqUjJMVEZvTFRjdU9YcE5OaTQ0SURFekxqbGpNQ0F3SURBdE1DNHhJREFnTUd3dE1pNDNMVEl1TjJNdE1DNDBMVEF1TkMwd0xqUXRNQzQ1SURBdE1TNHpiRE11TkMwekxqbG9MVEZzTFRNZ015NHpZeTB3TGpZZ01DNDNMVEF1TmlBeExqY2dNQzR4SURJdU5Hd3lMak1nTWk0emFDMHhMak5qTFRBdU1pQXdMVEF1TkMwd0xqRXRNQzQyTFRBdU1td3RNaTQ0TFRJdU9HTXRNQzR6TFRBdU15MHdMak10TUM0NElEQXRNUzR4YkRNdU5TMHpMamxvTVM0NGJETXVOUzAwYURGc0xUTXVOU0EwSURNdU1TQXpMamN0TXk0MUlEUmpMVEF1TVNBd0xqRXRNQzR5SURBdU1TMHdMak1nTUM0eWVpSStQQzl3WVhSb1BnbzhMM04yWno0S1wifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRTFjSGdpSUdobGFXZG9kRDBpTVRWd2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFMUlERTFJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVStiR2x1YXp3dmRHbDBiR1UrQ2lBZ0lDQThaR1Z6WXo1RGNtVmhkR1ZrSUhkcGRHZ2dVMnRsZEdOb0xqd3ZaR1Z6WXo0S0lDQWdJRHhrWldaelBqd3ZaR1ZtY3o0S0lDQWdJRHhuSUdsa1BTSlFZV2RsTFRFaUlITjBjbTlyWlQwaWJtOXVaU0lnYzNSeWIydGxMWGRwWkhSb1BTSXhJaUJtYVd4c1BTSnViMjVsSWlCbWFXeHNMWEoxYkdVOUltVjJaVzV2WkdRaVBnb2dJQ0FnSUNBZ0lEeG5JR2xrUFNKc2FXNXJJaUJtYVd4c1BTSWpNREF3TURBd0lqNEtJQ0FnSUNBZ0lDQWdJQ0FnUEdjZ2FXUTlJa05oY0dGZk1TSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjR0YwYUNCa1BTSk5NVE11T1RZM0xEQXVPVFVnUXpFekxqTTFOVFVzTUM0ek16ZzFJREV5TGpVek9UYzFMREF1TURBeE56VWdNVEV1TmpZNU56VXNNQzR3TURFM05TQkRNVEF1T0N3d0xqQXdNVGMxSURrdU9UZzBMREF1TXpNNE5TQTVMak0zTWpVc01DNDVOU0JNTnk0eE1EVXNNeTR5TVRjMUlFTTJMakk0TmpJMUxEUXVNRE0yTWpVZ05pdzFMakU0TmpVZ05pNHlNemszTlN3MkxqSTBJRU0yTGpBd05EVXNOaTR4T0RjZ05TNDNOakl5TlN3MkxqRTFOamMxSURVdU5URTBOelVzTmk0eE5UWTNOU0JETkM0Mk5EVXNOaTR4TlRZM05TQXpMamd5T1N3MkxqUTVNelVnTXk0eU1UYzNOU3czTGpFd05TQk1NQzQ1TlN3NUxqTTNNamMxSUVNdE1DNHpNVFkxTERFd0xqWXpPVEkxSUMwd0xqTXhOalVzTVRJdU56QXdOelVnTUM0NU5Td3hNeTQ1TmpjeU5TQkRNUzQxTmpFMUxERTBMalUzT0RjMUlESXVNemMzTWpVc01UUXVPVEUxTlNBekxqSTBOekkxTERFMExqa3hOVFVnUXpRdU1URTNNalVzTVRRdU9URTFOU0EwTGprek15d3hOQzQxTnpnM05TQTFMalUwTkRVc01UTXVPVFkzTWpVZ1REY3VPREV5TERFeExqWTVPVGMxSUVNNExqWXpNRGMxTERFd0xqZzRNU0E0TGpreE55dzVMamN6TURjMUlEZ3VOamMzTWpVc09DNDJOemN5TlNCRE9DNDVNVEkxTERndU56TXdNalVnT1M0eE5UUTNOU3c0TGpjMk1EVWdPUzQwTURJeU5TdzRMamMyTURVZ1F6RXdMakkzTWpJMUxEZ3VOell3TlNBeE1TNHdPRGd5TlN3NExqUXlNemMxSURFeExqWTVPVFVzTnk0NE1USXlOU0JNTVRNdU9UWTNNalVzTlM0MU5EUTNOU0JETVRVdU1qTTBMRFF1TWpjNElERTFMakl6TkN3eUxqSXhOamMxSURFekxqazJOeXd3TGprMUlFd3hNeTQ1Tmpjc01DNDVOU0JhSUUwM0xqRXdOU3d4TUM0NU9USTFJRXcwTGpnek56VXNNVE11TWpZZ1F6UXVOREUxTERFekxqWTRNalVnTXk0NE5Td3hNeTQ1TVRVeU5TQXpMakkwTnpJMUxERXpMamt4TlRJMUlFTXlMalkwTkRVc01UTXVPVEUxTWpVZ01pNHdOemszTlN3eE15NDJPREkxSURFdU5qVTNMREV6TGpJMklFTXdMamM0TURJMUxERXlMak00TXlBd0xqYzRNREkxTERFd0xqazFOalVnTVM0Mk5UY3NNVEF1TURjNU5TQk1NeTQ1TWpRM05TdzNMamd4TWlCRE5DNHpORGN5TlN3M0xqTTRPVFVnTkM0NU1USXNOeTR4TlRZM05TQTFMalV4TkRjMUxEY3VNVFUyTnpVZ1F6VXVPVFExTnpVc055NHhOVFkzTlNBMkxqTTFOakkxTERjdU1qYzNOU0EyTGpjeE1ESTFMRGN1TkRrNU56VWdURFF1TnpjeU1qVXNPUzQwTXpjM05TQkROQzQxTnpjc09TNDJNek1nTkM0MU56Y3NPUzQ1TkRrMUlEUXVOemN5TWpVc01UQXVNVFEwTnpVZ1F6UXVPRFk1TnpVc01UQXVNalF5TlNBMExqazVOemMxTERFd0xqSTVNVEkxSURVdU1USTFOelVzTVRBdU1qa3hNalVnUXpVdU1qVXpOelVzTVRBdU1qa3hNalVnTlM0ek9ERTNOU3d4TUM0eU5ESTFJRFV1TkRjNU1qVXNNVEF1TVRRME56VWdURGN1TkRFM05TdzRMakl3TmpVZ1F6Y3VPVFl6TERrdU1EYzFJRGN1T0RZc01UQXVNak0zTWpVZ055NHhNRFVzTVRBdU9Ua3lOU0JNTnk0eE1EVXNNVEF1T1RreU5TQmFJRTB4TXk0eU5pdzBMamd6TnpVZ1RERXdMams1TWpJMUxEY3VNVEExSUVNeE1DNDFOamszTlN3M0xqVXlOelVnTVRBdU1EQTFMRGN1TnpZd01qVWdPUzQwTURJc055NDNOakF5TlNCRE9DNDVOekVzTnk0M05qQXlOU0E0TGpVMk1EYzFMRGN1TmpNNU5TQTRMakl3TmpjMUxEY3VOREUzTWpVZ1RERXdMakUwTkRjMUxEVXVORGM1TWpVZ1F6RXdMak0wTERVdU1qZzBJREV3TGpNMExEUXVPVFkzTlNBeE1DNHhORFEzTlN3MExqYzNNakkxSUVNNUxqazBPVGMxTERRdU5UYzNJRGt1TmpNeU56VXNOQzQxTnpjZ09TNDBNemMzTlN3MExqYzNNakkxSUV3M0xqUTVPVFVzTmk0M01UQTFJRU0yTGprMU5DdzFMamcwTWlBM0xqQTFOeXcwTGpZNElEY3VPREV5TERNdU9USTBOelVnVERFd0xqQTNPVFVzTVM0Mk5UY3lOU0JETVRBdU5UQXlMREV1TWpNME56VWdNVEV1TURZM0xERXVNREF5SURFeExqWTJPVGMxTERFdU1EQXlJRU14TWk0eU56STNOU3d4TGpBd01pQXhNaTQ0TXpjeU5Td3hMakl6TkRjMUlERXpMakkyTERFdU5qVTNNalVnUXpFekxqWTRNamMxTERJdU1EYzVOelVnTVRNdU9URTFNalVzTWk0Mk5EUTFJREV6TGpreE5USTFMRE11TWpRM05TQkRNVE11T1RFMU1qVXNNeTQ0TlRBeU5TQXhNeTQyT0RJMUxEUXVOREUxSURFekxqSTJMRFF1T0RNM05TQk1NVE11TWpZc05DNDRNemMxSUZvaUlHbGtQU0pUYUdGd1pTSStQQzl3WVhSb1Bnb2dJQ0FnSUNBZ0lDQWdJQ0E4TDJjK0NpQWdJQ0FnSUNBZ1BDOW5QZ29nSUNBZ1BDOW5QZ284TDNOMlp6ND1cIn0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9XCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlWVlJHTFRnaUlITjBZVzVrWVd4dmJtVTlJbTV2SWo4K0NqeHpkbWNnZDJsa2RHZzlJakUxY0hnaUlHaGxhV2RvZEQwaU1UVndlQ0lnZG1sbGQwSnZlRDBpTUNBd0lERTFJREUxSWlCMlpYSnphVzl1UFNJeExqRWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaVBnb2dJQ0FnUENFdExTQkhaVzVsY21GMGIzSTZJRk5yWlhSamFDQTBNQzR6SUNnek16Z3pPU2tnTFNCb2RIUndPaTh2ZDNkM0xtSnZhR1Z0YVdGdVkyOWthVzVuTG1OdmJTOXphMlYwWTJnZ0xTMCtDaUFnSUNBOGRHbDBiR1UrZFc1c2FXNXJQQzkwYVhSc1pUNEtJQ0FnSUR4a1pYTmpQa055WldGMFpXUWdkMmwwYUNCVGEyVjBZMmd1UEM5a1pYTmpQZ29nSUNBZ1BHUmxabk0rUEM5a1pXWnpQZ29nSUNBZ1BHY2dhV1E5SWxCaFoyVXRNU0lnYzNSeWIydGxQU0p1YjI1bElpQnpkSEp2YTJVdGQybGtkR2c5SWpFaUlHWnBiR3c5SW01dmJtVWlJR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0krQ2lBZ0lDQWdJQ0FnUEdjZ2FXUTlJblZ1YkdsdWF5SWdabWxzYkQwaUl6QXdNREF3TUNJK0NpQWdJQ0FnSUNBZ0lDQWdJRHhuSUdsa1BTSkRZWEJoWHpFaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BHY2dhV1E5SWtkeWIzVndJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNHRjBhQ0JrUFNKTk1UTXVPVFUyTWpjeU55d3hMakF6TmpZek5qTTJJRU14TWk0MU56UXdPVEE1TEMwd0xqTTBOVFUwTlRRMU5TQXhNQzR6TWpRNU1Ea3hMQzB3TGpNME5TQTRMamswTWpRMU5EVTFMREV1TURNMk5qTTJNellnVERZdU5ETTFOVFExTkRVc015NDFORE0xTkRVME5TQkROaTR5TWpJMU5EVTBOU3d6TGpjMU5qVTBOVFExSURZdU1qSXlOVFExTkRVc05DNHhNREU0TVRneE9DQTJMalF6TlRVME5UUTFMRFF1TXpFME9ERTRNVGdnUXpZdU5qUTROVFExTkRVc05DNDFNamM0TVRneE9DQTJMams1TXpneE9ERTRMRFF1TlRJM09ERTRNVGdnTnk0eU1EWTRNVGd4T0N3MExqTXhORGd4T0RFNElFdzVMamN4TXpjeU56STNMREV1T0RBM09UQTVNRGtnUXpFd0xqRTNORGt3T1RFc01TNHpORGNnTVRBdU56a3hNamN5Tnl3eExqQTVNamd4T0RFNElERXhMalEwT1RBNU1Ea3NNUzR3T1RJNE1UZ3hPQ0JETVRJdU1UQTNNVGd4T0N3eExqQTVNamd4T0RFNElERXlMamN5TXpVME5UVXNNUzR6TkRjZ01UTXVNVGcwTnpJM015d3hMamd3T0RFNE1UZ3lJRU14TXk0Mk5EVTVNRGt4TERJdU1qWTVNell6TmpRZ01UTXVPVEF3TURrd09Td3lMamc0TlRjeU56STNJREV6TGprd01EQTVNRGtzTXk0MU5ETTRNVGd4T0NCRE1UTXVPVEF3TURrd09TdzBMakl3TVRZek5qTTJJREV6TGpZME5Ua3dPVEVzTkM0NE1UZ2dNVE11TVRnME56STNNeXcxTGpJM09URTRNVGd5SUV3NUxqa3dOamd4T0RFNExEZ3VOVFUzT1RBNU1Ea2dRemd1T1RRNU5UUTFORFVzT1M0MU1UUTJNell6TmlBM0xqTTVNalUwTlRRMUxEa3VOVEUwTmpNMk16WWdOaTQwTXpVeU56STNNeXc0TGpVMU56a3dPVEE1SUVNMkxqSXlNakkzTWpjekxEZ3VNelEwT1RBNU1Ea2dOUzQ0Tnpjc09DNHpORFE1TURrd09TQTFMalkyTkN3NExqVTFOemt3T1RBNUlFTTFMalExTVN3NExqYzNNRGt3T1RBNUlEVXVORFV4TERrdU1URTJORFUwTlRVZ05TNDJOalFzT1M0ek1qa3hPREU0TWlCRE5pNHpOVFV3T1RBNU1Td3hNQzR3TWpBeU56STNJRGN1TWpZekxERXdMak0yTlRneE9ESWdPQzR4TnpBNU1Ea3dPU3d4TUM0ek5qVTRNVGd5SUVNNUxqQTNPRGd4T0RFNExERXdMak0yTlRneE9ESWdPUzQ1T0RZM01qY3lOeXd4TUM0d01qQXlOekkzSURFd0xqWTNOemd4T0RJc09TNHpNamt4T0RFNE1pQk1NVE11T1RVMk1qY3lOeXcyTGpBMU1EY3lOekkzSUVNeE5DNDJNak0yTXpZMExEVXVNemd6TmpNMk16WWdNVFF1T1RreE1qY3lOeXcwTGpRNU16RTRNVGd5SURFMExqazVNVEkzTWpjc015NDFORE00TVRneE9DQkRNVFF1T1RreE1qY3lOeXd5TGpVNU5ERTRNVGd5SURFMExqWXlNell6TmpRc01TNDNNRFFnTVRNdU9UVTJNamN5Tnl3eExqQXpOall6TmpNMklFd3hNeTQ1TlRZeU56STNMREV1TURNMk5qTTJNellnV2lJZ2FXUTlJbE5vWVhCbElqNDhMM0JoZEdnK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEJoZEdnZ1pEMGlUVGN1TXprNU5qTTJNellzTVRFdU1EWTBOVFExTlNCTU5TNHlOemd6TmpNMk5Dd3hNeTR4T0RVNE1UZ3lJRU0wTGpneE56RTRNVGd5TERFekxqWTBOeUEwTGpJd01EZ3hPREU0TERFekxqa3dNVEU0TVRnZ015NDFOREkzTWpjeU55d3hNeTQ1TURFeE9ERTRJRU15TGpnNE5Ea3dPVEE1TERFekxqa3dNVEU0TVRnZ01pNHlOamd5TnpJM015d3hNeTQyTkRjZ01TNDRNRGN3T1RBNU1Td3hNeTR4T0RVNE1UZ3lJRU13TGpnMU1EQTVNRGt3T1N3eE1pNHlNamc0TVRneUlEQXVPRFV3TURrd09UQTVMREV3TGpZM01UVTBOVFVnTVM0NE1EY3dPVEE1TVN3NUxqY3hORFUwTlRRMUlFdzBMamc1TWpjeU56STNMRFl1TmpJNE9UQTVNRGtnUXpVdU16VXpPVEE1TURrc05pNHhOamdnTlM0NU56QXlOekkzTXl3MUxqa3hNemd4T0RFNElEWXVOakk0TXpZek5qUXNOUzQ1TVRNNE1UZ3hPQ0JETnk0eU9EWXhPREU0TWl3MUxqa3hNemd4T0RFNElEY3VPVEF5TlRRMU5EVXNOaTR4TmpnZ09DNHpOak0zTWpjeU55dzJMall5T0Rrd09UQTVJRU00TGpVM05qY3lOekkzTERZdU9EUXhPVEE1TURrZ09DNDVNaklzTmk0NE5ERTVNRGt3T1NBNUxqRXpOU3cyTGpZeU9Ea3dPVEE1SUVNNUxqTTBPQ3cyTGpReE5Ua3dPVEE1SURrdU16UTRMRFl1TURjd05qTTJNellnT1M0eE16VXNOUzQ0TlRjMk16WXpOaUJETnk0M05UTXdPVEE1TVN3MExqUTNOVGN5TnpJM0lEVXVOVEF6T1RBNU1Ea3NOQzQwTnpVME5UUTFOU0EwTGpFeU1URTRNVGd5TERVdU9EVTNOak0yTXpZZ1RERXVNRE0xTlRRMU5EVXNPQzQ1TkRNMU5EVTBOU0JETUM0ek5qZzBOVFExTkRVc09TNDJNVEEyTXpZek5pQXdMakF3TURneE9ERTRNVGd4T0N3eE1DNDFNREV3T1RBNUlEQXVNREF3T0RFNE1UZ3hPREU0TERFeExqUTFNRFExTkRVZ1F6QXVNREF3T0RFNE1UZ3hPREU0TERFeUxqTTVPVFUwTlRVZ01DNHpOamcwTlRRMU5EVXNNVE11TWprZ01TNHdNelU0TVRneE9Dd3hNeTQ1TlRjd09UQTVJRU14TGpjd01qa3dPVEE1TERFMExqWXlORFExTkRVZ01pNDFPVE16TmpNMk5Dd3hOQzQ1T1RJd09UQTVJRE11TlRReU5EVTBOVFVzTVRRdU9Ua3lNRGt3T1NCRE5DNDBPVEU0TVRneE9Dd3hOQzQ1T1RJd09UQTVJRFV1TXpneU1qY3lOek1zTVRRdU5qSTBORFUwTlNBMkxqQTBPVE0yTXpZMExERXpMamsxTnpBNU1Ea2dURGd1TVRjd05qTTJNellzTVRFdU9ETTFPREU0TWlCRE9DNHpPRE0yTXpZek5pd3hNUzQyTWpJNE1UZ3lJRGd1TXpnek5qTTJNellzTVRFdU1qYzNOVFExTlNBNExqRTNNRFl6TmpNMkxERXhMakEyTkRVME5UVWdRemN1T1RVM05qTTJNellzTVRBdU9EVXhOVFExTlNBM0xqWXhNall6TmpNMkxERXdMamcxTVRVME5UVWdOeTR6T1RrMk16WXpOaXd4TVM0d05qUTFORFUxSUV3M0xqTTVPVFl6TmpNMkxERXhMakEyTkRVME5UVWdXaUlnYVdROUlsTm9ZWEJsSWo0OEwzQmhkR2crQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BIQmhkR2dnWkQwaVRUa3VNamN6TlRRMU5EVXNNVEl1TURBeE9UQTVNU0JET0M0NU56STBOVFExTlN3eE1pNHdNREU1TURreElEZ3VOekk0TURrd09URXNNVEl1TWpRMk1qY3lOeUE0TGpjeU9EQTVNRGt4TERFeUxqVTBOek0yTXpZZ1REZ3VOekk0TURrd09URXNNVFF1TVRnek56STNNeUJET0M0M01qZ3dPVEE1TVN3eE5DNDBPRFE0TVRneUlEZ3VPVGN5TkRVME5UVXNNVFF1TnpJNU1UZ3hPQ0E1TGpJM016VTBOVFExTERFMExqY3lPVEU0TVRnZ1F6a3VOVGMwTmpNMk16WXNNVFF1TnpJNU1UZ3hPQ0E1TGpneE9Td3hOQzQwT0RRNE1UZ3lJRGt1T0RFNUxERTBMakU0TXpjeU56TWdURGt1T0RFNUxERXlMalUwTnpNMk16WWdRemt1T0RFNUxERXlMakkwTmlBNUxqVTNORGt3T1RBNUxERXlMakF3TVRrd09URWdPUzR5TnpNMU5EVTBOU3d4TWk0d01ERTVNRGt4SUV3NUxqSTNNelUwTlRRMUxERXlMakF3TVRrd09URWdXaUlnYVdROUlsTm9ZWEJsSWo0OEwzQmhkR2crQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BIQmhkR2dnWkQwaVRURXhMakl5T1RVME5UVXNNVEV1TmpFMk1qY3lOeUJETVRFdU1ERTJOVFExTlN3eE1TNDBNRE15TnpJM0lERXdMalkzTVRJM01qY3NNVEV1TkRBek1qY3lOeUF4TUM0ME5UZ3lOekkzTERFeExqWXhOakkzTWpjZ1F6RXdMakkwTlRJM01qY3NNVEV1T0RJNU1qY3lOeUF4TUM0eU5EVXlOekkzTERFeUxqRTNORFUwTlRVZ01UQXVORFU0TWpjeU55d3hNaTR6T0RjMU5EVTFJRXd4TVM0Mk1UVXhPREU0TERFekxqVTBORFExTkRVZ1F6RXhMamN5TVRneE9ESXNNVE11TmpVeE1Ea3dPU0F4TVM0NE5qRXhPREU0TERFekxqY3dOREkzTWpjZ01USXVNREF3T0RFNE1pd3hNeTQzTURReU56STNJRU14TWk0eE5EQTBOVFExTERFekxqY3dOREkzTWpjZ01USXVNamM1T0RFNE1pd3hNeTQyTlRFd09UQTVJREV5TGpNNE5qUTFORFVzTVRNdU5UUTBORFUwTlNCRE1USXVOVGs1TkRVME5Td3hNeTR6TXpFME5UUTFJREV5TGpVNU9UUTFORFVzTVRJdU9UZzJNVGd4T0NBeE1pNHpPRFkwTlRRMUxERXlMamMzTXpFNE1UZ2dUREV4TGpJeU9UVTBOVFVzTVRFdU5qRTJNamN5TnlCTU1URXVNakk1TlRRMU5Td3hNUzQyTVRZeU56STNJRm9pSUdsa1BTSlRhR0Z3WlNJK1BDOXdZWFJvUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHdZWFJvSUdROUlrMHhNaTQxTXpZM01qY3pMRGt1T0RJd01Ea3dPVEVnVERFd0xqa3dNRE0yTXpZc09TNDRNakF3T1RBNU1TQkRNVEF1TlRrNU1qY3lOeXc1TGpneU1EQTVNRGt4SURFd0xqTTFORGt3T1RFc01UQXVNRFkwTkRVME5TQXhNQzR6TlRRNU1Ea3hMREV3TGpNMk5UVTBOVFVnUXpFd0xqTTFORGt3T1RFc01UQXVOalkyTmpNMk5DQXhNQzQxT1RreU56STNMREV3TGpreE1TQXhNQzQ1TURBek5qTTJMREV3TGpreE1TQk1NVEl1TlRNMk56STNNeXd4TUM0NU1URWdRekV5TGpnek56Z3hPRElzTVRBdU9URXhJREV6TGpBNE1qRTRNVGdzTVRBdU5qWTJOak0yTkNBeE15NHdPREl4T0RFNExERXdMak0yTlRVME5UVWdRekV6TGpBNE1qRTRNVGdzTVRBdU1EWTBORFUwTlNBeE1pNDRNemd3T1RBNUxEa3VPREl3TURrd09URWdNVEl1TlRNMk56STNNeXc1TGpneU1EQTVNRGt4SUV3eE1pNDFNelkzTWpjekxEa3VPREl3TURrd09URWdXaUlnYVdROUlsTm9ZWEJsSWo0OEwzQmhkR2crQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BIQmhkR2dnWkQwaVRUUXVPVEE1T1RBNU1Ea3NNeTQxTkRjek5qTTJOQ0JETlM0eU1URXNNeTQxTkRjek5qTTJOQ0ExTGpRMU5UTTJNelkwTERNdU16QXpJRFV1TkRVMU16WXpOalFzTXk0d01ERTVNRGt3T1NCTU5TNDBOVFV6TmpNMk5Dd3hMak0yTlRVME5UUTFJRU0xTGpRMU5UTTJNelkwTERFdU1EWTBORFUwTlRVZ05TNHlNVEVzTUM0NE1qQXdPVEE1TURrZ05DNDVNRGs1TURrd09Td3dMamd5TURBNU1Ea3dPU0JETkM0Mk1EZzRNVGd4T0N3d0xqZ3lNREE1TURrd09TQTBMak0yTkRRMU5EVTFMREV1TURZME5EVTBOVFVnTkM0ek5qUTBOVFExTlN3eExqTTJOVFUwTlRRMUlFdzBMak0yTkRRMU5EVTFMRE11TURBeE9UQTVNRGtnUXpRdU16WTBORFUwTlRVc015NHpNRE1nTkM0Mk1EZzRNVGd4T0N3ekxqVTBOek0yTXpZMElEUXVPVEE1T1RBNU1Ea3NNeTQxTkRjek5qTTJOQ0JNTkM0NU1EazVNRGt3T1N3ekxqVTBOek0yTXpZMElGb2lJR2xrUFNKVGFHRndaU0krUEM5d1lYUm9QZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4d1lYUm9JR1E5SWsweUxqZzROemt3T1RBNUxETXVPVE16SUVNeUxqazVORFUwTlRRMUxEUXVNRE01TmpNMk16WWdNeTR4TXpNNU1Ea3dPU3cwTGpBNU1qZ3hPREU0SURNdU1qY3pOVFExTkRVc05DNHdPVEk0TVRneE9DQkRNeTQwTVRNeE9ERTRNaXcwTGpBNU1qZ3hPREU0SURNdU5UVXlOVFExTkRVc05DNHdNemsyTXpZek5pQXpMalkxT1RFNE1UZ3lMRE11T1RNeklFTXpMamczTWpFNE1UZ3lMRE11TnpJZ015NDROekl4T0RFNE1pd3pMak0zTkRjeU56STNJRE11TmpVNU1UZ3hPRElzTXk0eE5qRTNNamN5TnlCTU1pNDFNREl5TnpJM015d3lMakF3TkRVME5UUTFJRU15TGpJNE9USTNNamN6TERFdU56a3hOVFExTkRVZ01TNDVORFFzTVM0M09URTFORFUwTlNBeExqY3pNU3d5TGpBd05EVTBOVFExSUVNeExqVXhPQ3d5TGpJeE56VTBOVFExSURFdU5URTRMREl1TlRZeU9ERTRNVGdnTVM0M016RXNNaTQzTnpVNE1UZ3hPQ0JNTWk0NE9EYzVNRGt3T1N3ekxqa3pNeUJNTWk0NE9EYzVNRGt3T1N3ekxqa3pNeUJhSWlCcFpEMGlVMmhoY0dVaVBqd3ZjR0YwYUQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjR0YwYUNCa1BTSk5NUzQyTWpjMk16WXpOaXcxTGpjeU9URTRNVGd5SUV3ekxqSTJOQ3cxTGpjeU9URTRNVGd5SUVNekxqVTJOVEE1TURreExEVXVOekk1TVRneE9ESWdNeTQ0TURrME5UUTFOU3cxTGpRNE5EZ3hPREU0SURNdU9EQTVORFUwTlRVc05TNHhPRE0zTWpjeU55QkRNeTQ0TURrME5UUTFOU3cwTGpnNE1qWXpOak0ySURNdU5UWTFNRGt3T1RFc05DNDJNemd5TnpJM015QXpMakkyTkN3MExqWXpPREkzTWpjeklFd3hMall5TnpZek5qTTJMRFF1TmpNNE1qY3lOek1nUXpFdU16STJOVFExTkRVc05DNDJNemd5TnpJM015QXhMakE0TWpFNE1UZ3lMRFF1T0RneU5qTTJNellnTVM0d09ESXhPREU0TWl3MUxqRTRNemN5TnpJM0lFTXhMakE0TWpFNE1UZ3lMRFV1TkRnME9ERTRNVGdnTVM0ek1qWTFORFUwTlN3MUxqY3lPVEU0TVRneUlERXVOakkzTmpNMk16WXNOUzQzTWpreE9ERTRNaUJNTVM0Mk1qYzJNell6Tml3MUxqY3lPVEU0TVRneUlGb2lJR2xrUFNKVGFHRndaU0krUEM5d1lYUm9QZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUNBZ0lDQThMMmMrQ2lBZ0lDQWdJQ0FnUEM5blBnb2dJQ0FnUEM5blBnbzhMM04yWno0PVwifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaWRYUm1MVGdpUHo0S1BITjJaeUIzYVdSMGFEMGlNVFl1T1RrNU9UZ3lPRE16T0RZeU16QTFJaUJvWldsbmFIUTlJakUyTGprNU9UazRNRGt5TmpVeE16WTNNaUlnZG1sbGQwSnZlRDBpTVRVdU56STRPU0F5TWk0d09ESTBJREUzSURFM0lpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaVBnb2dJRHhuSUhSeVlXNXpabTl5YlQwaWJXRjBjbWw0S0RBdU1UWTFOVEUxT1RnNU1EWTFNVGN3TXl3Z01Dd2dNQ3dnTUM0eE5qVTFNVFU1T0Rrd05qVXhOekF6TENBeE5pNDFPRFV3TmpjM05Ea3dNak0wTXpnc0lESXlMamt6T0RReU5qazNNVFF6TlRVME55a2lQZ29nSUNBZ1BIQmhkR2dnWkQwaVRTQTNPUzR5T0RVZ01UTXVNRGcwSUVNZ05qRXVNRE14SUMwMUxqRTNNaUF6TVM0ek16SWdMVFV1TVRjeUlERXpMakE0TVNBeE15NHdPQ0JESUMwMUxqRTNNeUF6TVM0ek16RWdMVFV1TVRjeElEWXhMakF6TVNBeE15NHdPRE1nTnprdU1qZzJJRU1nTXpFdU16TXlJRGszTGpVek55QTJNUzR3TXpFZ09UY3VOVE0zSURjNUxqSTRNeUEzT1M0eU9ETWdReUE1Tnk0MU16WWdOakV1TURNeElEazNMalV6TlNBek1TNHpNek1nTnprdU1qZzFJREV6TGpBNE5DQmFJRTBnTnpRdU1UYzNJRGMwTGpFM09DQkRJRFU0TGpjME1TQTRPUzQyTVRRZ016TXVOakkxSURnNUxqWXhOaUF4T0M0eE9EY2dOelF1TVRnZ1F5QXlMamMwT0NBMU9DNDNORElnTWk0M05TQXpNeTQyTWpJZ01UZ3VNVGczSURFNExqRTROaUJESURNekxqWXlNeUF5TGpjMU1TQTFPQzQzTkNBeUxqYzBPU0EzTkM0eE56a2dNVGd1TVRnNElFTWdPRGt1TmpFMUlETXpMall5TXlBNE9TNDJNVE1nTlRndU56UXpJRGMwTGpFM055QTNOQzR4TnpnZ1dpQk5JREk0TGpjeU1TQXpNeTQxTVRNZ1F5QXlPQzQzTWpFZ016QXVORGt5SURNeExqRTNNU0F5T0M0d05ESWdNelF1TVRreUlESTRMakEwTWlCRElETTNMakl4TXlBeU9DNHdORElnTXprdU5qWXpJRE13TGpRNU1TQXpPUzQyTmpNZ016TXVOVEV6SUVNZ016a3VOall6SURNMkxqVXpOaUF6Tnk0eU1UTWdNemd1T1RnMklETTBMakU1TWlBek9DNDVPRFlnUXlBek1TNHhOekVnTXpndU9UZzJJREk0TGpjeU1TQXpOaTQxTXpZZ01qZ3VOekl4SURNekxqVXhNeUJhSUUwZ05UTXVOVE1nTXpNdU5URXpJRU1nTlRNdU5UTWdNekF1TkRreUlEVTFMams0TWlBeU9DNHdORElnTlRrdU1EQTBJREk0TGpBME1pQkRJRFl5TGpBeU5DQXlPQzR3TkRJZ05qUXVORGMwSURNd0xqUTVNU0EyTkM0ME56UWdNek11TlRFeklFTWdOalF1TkRjMElETTJMalV6TmlBMk1pNHdNalVnTXpndU9UZzJJRFU1TGpBd05DQXpPQzQ1T0RZZ1F5QTFOUzQ1T0RJZ016Z3VPVGcySURVekxqVXpJRE0yTGpVek5pQTFNeTQxTXlBek15NDFNVE1nV2lCTklEWTJMalEyTlNBMU5TNDVNaklnUXlBMk15NHdOelVnTmpNdU56WTBJRFUxTGpFek5DQTJPQzQ0TXlBME5pNHlNellnTmpndU9ETWdReUF6Tnk0eE5EY2dOamd1T0RNZ01qa3VNVFU1SURZekxqY3pPQ0F5TlM0NE9EVWdOVFV1T0RVM0lFTWdNalV1TXpJMElEVTBMalV3T0NBeU5TNDVOalFnTlRJdU9UVTVJREkzTGpNeE5DQTFNaTR6T1RjZ1F5QXlOeTQyTkRZZ05USXVNallnTWpjdU9Ua2dOVEl1TVRrMklESTRMak15T1NBMU1pNHhPVFlnUXlBeU9TNHpOamNnTlRJdU1UazJJRE13TGpNMU1pQTFNaTQ0TURnZ016QXVOemMwSURVekxqZ3lOeUJESURNekxqSXlOQ0ExT1M0M01qY2dNemt1TWpreklEWXpMalV6TnlBME5pNHlNellnTmpNdU5UTTNJRU1nTlRNdU1ESXhJRFl6TGpVek55QTFPUzR3TlRRZ05Ua3VOekkwSURZeExqWXdOaUExTXk0NE1qRWdReUEyTWk0eE9EY2dOVEl1TkRnZ05qTXVOelExSURVeExqZzJNU0EyTlM0d09EY2dOVEl1TkRReUlFTWdOall1TkRJM0lEVXpMakF5TkNBMk55NHdORFlnTlRRdU5UZ3hJRFkyTGpRMk5TQTFOUzQ1TWpJZ1dpSXZQZ29nSUR3dlp6NEtQQzl6ZG1jK1wifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaWRYUm1MVGdpUHo0S1BITjJaeUIzYVdSMGFEMGlNVFl1T1RrNU9UTTNNRFUzTkRrMU1URTNJaUJvWldsbmFIUTlJakUyTGprNU9Ua3pOekExTnpRNU5URXhOeUlnZG1sbGQwSnZlRDBpTlM0NE1USTNObVV0TnlBekxqQTFOREl3WlMwNElERTJMams1T1RrZ01UWXVPVGs1T1NJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0S0lDQThaeUIwY21GdWMyWnZjbTA5SW0xaGRISnBlQ2d3TGpBek16SXdNams1T0RNME1ERXlPVGcxTENBd0xDQXdMQ0F3TGpBek16SXdNams1T0RNME1ERXlPVGcxTENBdE1pNDROREl4TnpBNU5ETXdOREEwTURGbExURTBMQ0F3S1NJK0NpQWdJQ0E4Wno0S0lDQWdJQ0FnUEhCaGRHZ2daRDBpVFRJd01pNHdORElzTVRrNUxqSXpPR010Tmk0NU16Z3RNaTR4TURNdE1UUXVNalk0TERFdU9ESXRNVFl1TXpjeExEZ3VOelU1YkMwMU5TNHhNemdzTVRneUxqQTBOV010TWk0eE1ESXNOaTQ1TXpnc01TNDRNaXd4TkM0eU5qZ3NPQzQzTlRrc01UWXVNemNtSXpFd095WWpPVHNtSXprN0ppTTVPMk14TGpJM0xEQXVNemcxTERJdU5UUTVMREF1TlRZNExETXVPREV4TERBdU5UWTRZelV1TmpNekxEQXNNVEF1T0RReExUTXVOalUyTERFeUxqVTJMVGt1TXpJMmJEVTFMakV6T0MweE9ESXVNRFExSmlNeE1Ec21Jems3SmlNNU95WWpPVHRETWpFeUxqa3dNU3d5TURndU5qWTRMREl3T0M0NU9ERXNNakF4TGpNek9Dd3lNREl1TURReUxERTVPUzR5TXpoNklpOCtDaUFnSUNBOEwyYytDaUFnUEM5blBnb2dJRHhuSUhSeVlXNXpabTl5YlQwaWJXRjBjbWw0S0RBdU1ETXpNakF5T1RrNE16UXdNVEk1T0RVc0lEQXNJREFzSURBdU1ETXpNakF5T1RrNE16UXdNVEk1T0RVc0lDMHlMamcwTWpFM01EazBNekEwTURRd01XVXRNVFFzSURBcElqNEtJQ0FnSUR4blBnb2dJQ0FnSUNBOGNHRjBhQ0JrUFNKTk1qWTRMams1TkN3eE9Ua3VNak00WXkwMkxqa3pMVEl1TVRBekxURTBMakkyT0N3eExqZ3lMVEUyTGpNM0xEZ3VOelU1YkMwMU5TNHhNemdzTVRneUxqQTBOV010TWk0eE1ESXNOaTQ1TXpnc01TNDRNaXd4TkM0eU5qZ3NPQzQzTlRrc01UWXVNemNtSXpFd095WWpPVHNtSXprN0ppTTVPMk14TGpJMk9Td3dMak00TlN3eUxqVTBPU3d3TGpVMk9Dd3pMamd4TVN3d0xqVTJPR00xTGpZek15d3dMREV3TGpnME1TMHpMalkxTml3eE1pNDFOaTA1TGpNeU5tdzFOUzR4TXpndE1UZ3lMakEwTlNZak1UQTdKaU01T3lZak9Uc21Jems3UXpJM09TNDROVGNzTWpBNExqWTJPQ3d5TnpVdU9UTTFMREl3TVM0ek16Z3NNalk0TGprNU5Dd3hPVGt1TWpNNGVpSXZQZ29nSUNBZ1BDOW5QZ29nSUR3dlp6NEtJQ0E4WnlCMGNtRnVjMlp2Y20wOUltMWhkSEpwZUNnd0xqQXpNekl3TWprNU9ETTBNREV5T1RnMUxDQXdMQ0F3TENBd0xqQXpNekl3TWprNU9ETTBNREV5T1RnMUxDQXRNaTQ0TkRJeE56QTVORE13TkRBME1ERmxMVEUwTENBd0tTSStDaUFnSUNBOFp6NEtJQ0FnSUNBZ1BIQmhkR2dnWkQwaVRUUTVPQzQ0TnpJc01FZ3hNeTR4TWpoRE5TNDROemdzTUN3d0xEVXVPRGM1TERBc01UTXVNVEk0ZGpRNE5TNDNORFJETUN3MU1EWXVNVEl4TERVdU9EYzRMRFV4TWl3eE15NHhNamdzTlRFeWFEUTROUzQzTkRRbUl6RXdPeVlqT1RzbUl6azdKaU01TzJNM0xqSTBPU3d3TERFekxqRXlPQzAxTGpnM09Td3hNeTR4TWpndE1UTXVNVEk0VmpFekxqRXlPRU0xTVRJc05TNDROemtzTlRBMkxqRXlNU3d3TERRNU9DNDROeklzTUhvZ1RURXdOUzR3TWpZc01qWXVNalUyYURNd01TNDVORGwyTlRJdU5URXpTREV3TlM0d01qWldNall1TWpVMmVpWWpNVEE3SmlNNU95WWpPVHNtSXprN0lFMHlOaTR5TlRZc01qWXVNalUyYURVeUxqVXhNM1kxTWk0MU1UTklNall1TWpVMlZqSTJMakkxTm5vZ1RUUTROUzQzTkRRc05EZzFMamMwTkVneU5pNHlOVFpXTVRBMUxqQXlObWcwTlRrdU5EZzNWalE0TlM0M05EUjZJRTAwT0RVdU56UTBMRGM0TGpjMk9XZ3ROVEl1TlRFelZqSTJMakkxTmlZak1UQTdKaU01T3lZak9Uc21Jems3YURVeUxqVXhNMVkzT0M0M05qbDZJaTgrQ2lBZ0lDQThMMmMrQ2lBZ1BDOW5QZ29nSUR4bklIUnlZVzV6Wm05eWJUMGliV0YwY21sNEtEQXVNRE16TWpBeU9UazRNelF3TVRJNU9EVXNJREFzSURBc0lEQXVNRE16TWpBeU9UazRNelF3TVRJNU9EVXNJQzB5TGpnME1qRTNNRGswTXpBME1EUXdNV1V0TVRRc0lEQXBJajRLSUNBZ0lEeG5QZ29nSUNBZ0lDQThZMmx5WTJ4bElHTjRQU0k1TXk0NE5qY2lJR041UFNJeU5EVXVNRFkwSWlCeVBTSXhNeTR4TWpnaUx6NEtJQ0FnSUR3dlp6NEtJQ0E4TDJjK0NpQWdQR2NnZEhKaGJuTm1iM0p0UFNKdFlYUnlhWGdvTUM0d016TXlNREk1T1Rnek5EQXhNams0TlN3Z01Dd2dNQ3dnTUM0d016TXlNREk1T1Rnek5EQXhNams0TlN3Z0xUSXVPRFF5TVRjd09UUXpNRFF3TkRBeFpTMHhOQ3dnTUNraVBnb2dJQ0FnUEdjK0NpQWdJQ0FnSUR4amFYSmpiR1VnWTNnOUlqa3pMamcyTnlJZ1kzazlJak0yTUM0MU9USWlJSEk5SWpFekxqRXlPQ0l2UGdvZ0lDQWdQQzluUGdvZ0lEd3ZaejRLSUNBOFp5QjBjbUZ1YzJadmNtMDlJbTFoZEhKcGVDZ3dMakF6TXpJd01qazVPRE0wTURFeU9UZzFMQ0F3TENBd0xDQXdMakF6TXpJd01qazVPRE0wTURFeU9UZzFMQ0F0TWk0NE5ESXhOekE1TkRNd05EQTBNREZsTFRFMExDQXdLU0krQ2lBZ0lDQThaejRLSUNBZ0lDQWdQSEJoZEdnZ1pEMGlUVFF5T1M0eU9USXNNemd3TGpjeE9FZ3pNRGN1TW1NdE55NHlORGtzTUMweE15NHhNamdzTlM0NE56a3RNVE11TVRJNExERXpMakV5T0dNd0xEY3VNalE1TERVdU9EYzVMREV6TGpFeU9Dd3hNeTR4TWpnc01UTXVNVEk0YURFeU1pNHdPVEltSXpFd095WWpPVHNtSXprN0ppTTVPMk0zTGpJME9Td3dMREV6TGpFeU9DMDFMamczT1N3eE15NHhNamd0TVRNdU1USTRRelEwTWk0ME1qRXNNemcyTGpVNU55dzBNell1TlRReUxETTRNQzQzTVRnc05ESTVMakk1TWl3ek9EQXVOekU0ZWlJdlBnb2dJQ0FnUEM5blBnb2dJRHd2Wno0S0lDQThaeUIwY21GdWMyWnZjbTA5SW0xaGRISnBlQ2d3TGpBek16SXdNams1T0RNME1ERXlPVGcxTENBd0xDQXdMQ0F3TGpBek16SXdNams1T0RNME1ERXlPVGcxTENBdE1pNDROREl4TnpBNU5ETXdOREEwTURGbExURTBMQ0F3S1NJdlBnb2dJRHhuSUhSeVlXNXpabTl5YlQwaWJXRjBjbWw0S0RBdU1ETXpNakF5T1RrNE16UXdNVEk1T0RVc0lEQXNJREFzSURBdU1ETXpNakF5T1RrNE16UXdNVEk1T0RVc0lDMHlMamcwTWpFM01EazBNekEwTURRd01XVXRNVFFzSURBcElpOCtDaUFnUEdjZ2RISmhibk5tYjNKdFBTSnRZWFJ5YVhnb01DNHdNek15TURJNU9UZ3pOREF4TWprNE5Td2dNQ3dnTUN3Z01DNHdNek15TURJNU9UZ3pOREF4TWprNE5Td2dMVEl1T0RReU1UY3dPVFF6TURRd05EQXhaUzB4TkN3Z01Da2lMejRLSUNBOFp5QjBjbUZ1YzJadmNtMDlJbTFoZEhKcGVDZ3dMakF6TXpJd01qazVPRE0wTURFeU9UZzFMQ0F3TENBd0xDQXdMakF6TXpJd01qazVPRE0wTURFeU9UZzFMQ0F0TWk0NE5ESXhOekE1TkRNd05EQTBNREZsTFRFMExDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNek1qQXlPVGs0TXpRd01USTVPRFVzSURBc0lEQXNJREF1TURNek1qQXlPVGs0TXpRd01USTVPRFVzSUMweUxqZzBNakUzTURrME16QTBNRFF3TVdVdE1UUXNJREFwSWk4K0NpQWdQR2NnZEhKaGJuTm1iM0p0UFNKdFlYUnlhWGdvTUM0d016TXlNREk1T1Rnek5EQXhNams0TlN3Z01Dd2dNQ3dnTUM0d016TXlNREk1T1Rnek5EQXhNams0TlN3Z0xUSXVPRFF5TVRjd09UUXpNRFF3TkRBeFpTMHhOQ3dnTUNraUx6NEtJQ0E4WnlCMGNtRnVjMlp2Y20wOUltMWhkSEpwZUNnd0xqQXpNekl3TWprNU9ETTBNREV5T1RnMUxDQXdMQ0F3TENBd0xqQXpNekl3TWprNU9ETTBNREV5T1RnMUxDQXRNaTQ0TkRJeE56QTVORE13TkRBME1ERmxMVEUwTENBd0tTSXZQZ29nSUR4bklIUnlZVzV6Wm05eWJUMGliV0YwY21sNEtEQXVNRE16TWpBeU9UazRNelF3TVRJNU9EVXNJREFzSURBc0lEQXVNRE16TWpBeU9UazRNelF3TVRJNU9EVXNJQzB5TGpnME1qRTNNRGswTXpBME1EUXdNV1V0TVRRc0lEQXBJaTgrQ2lBZ1BHY2dkSEpoYm5ObWIzSnRQU0p0WVhSeWFYZ29NQzR3TXpNeU1ESTVPVGd6TkRBeE1qazROU3dnTUN3Z01Dd2dNQzR3TXpNeU1ESTVPVGd6TkRBeE1qazROU3dnTFRJdU9EUXlNVGN3T1RRek1EUXdOREF4WlMweE5Dd2dNQ2tpTHo0S0lDQThaeUIwY21GdWMyWnZjbTA5SW0xaGRISnBlQ2d3TGpBek16SXdNams1T0RNME1ERXlPVGcxTENBd0xDQXdMQ0F3TGpBek16SXdNams1T0RNME1ERXlPVGcxTENBdE1pNDROREl4TnpBNU5ETXdOREEwTURGbExURTBMQ0F3S1NJdlBnb2dJRHhuSUhSeVlXNXpabTl5YlQwaWJXRjBjbWw0S0RBdU1ETXpNakF5T1RrNE16UXdNVEk1T0RVc0lEQXNJREFzSURBdU1ETXpNakF5T1RrNE16UXdNVEk1T0RVc0lDMHlMamcwTWpFM01EazBNekEwTURRd01XVXRNVFFzSURBcElpOCtDaUFnUEdjZ2RISmhibk5tYjNKdFBTSnRZWFJ5YVhnb01DNHdNek15TURJNU9UZ3pOREF4TWprNE5Td2dNQ3dnTUN3Z01DNHdNek15TURJNU9UZ3pOREF4TWprNE5Td2dMVEl1T0RReU1UY3dPVFF6TURRd05EQXhaUzB4TkN3Z01Da2lMejRLSUNBOFp5QjBjbUZ1YzJadmNtMDlJbTFoZEhKcGVDZ3dMakF6TXpJd01qazVPRE0wTURFeU9UZzFMQ0F3TENBd0xDQXdMakF6TXpJd01qazVPRE0wTURFeU9UZzFMQ0F0TWk0NE5ESXhOekE1TkRNd05EQTBNREZsTFRFMExDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNek1qQXlPVGs0TXpRd01USTVPRFVzSURBc0lEQXNJREF1TURNek1qQXlPVGs0TXpRd01USTVPRFVzSUMweUxqZzBNakUzTURrME16QTBNRFF3TVdVdE1UUXNJREFwSWk4K0NpQWdQR2NnZEhKaGJuTm1iM0p0UFNKdFlYUnlhWGdvTUM0d016TXlNREk1T1Rnek5EQXhNams0TlN3Z01Dd2dNQ3dnTUM0d016TXlNREk1T1Rnek5EQXhNams0TlN3Z0xUSXVPRFF5TVRjd09UUXpNRFF3TkRBeFpTMHhOQ3dnTUNraUx6NEtQQzl6ZG1jK1wifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRTFjSGdpSUdobGFXZG9kRDBpTVRSd2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFMUlERTBJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVSthVzFoWjJVOEwzUnBkR3hsUGdvZ0lDQWdQR1JsYzJNK1EzSmxZWFJsWkNCM2FYUm9JRk5yWlhSamFDNDhMMlJsYzJNK0NpQWdJQ0E4WkdWbWN6NDhMMlJsWm5NK0NpQWdJQ0E4WnlCcFpEMGlVR0ZuWlMweElpQnpkSEp2YTJVOUltNXZibVVpSUhOMGNtOXJaUzEzYVdSMGFEMGlNU0lnWm1sc2JEMGlibTl1WlNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lqNEtJQ0FnSUNBZ0lDQThaeUJwWkQwaWFXMWhaMlVpSUdacGJHdzlJaU13TURBd01EQWlQZ29nSUNBZ0lDQWdJQ0FnSUNBOFp5QnBaRDBpUTJGd1lWOHhJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHhuSUdsa1BTSkhjbTkxY0NJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEJoZEdnZ1pEMGlUVEUwTGpjME1UTTNPVE1zTUNCTU1DNHlOVGcyTWpBMk9Td3dJRU13TGpFeE5UZzJNakEyT1N3d0lEQXNNQzR4TXpZd05ETTBOemdnTUN3d0xqTXdORE0wTnpneU5pQk1NQ3d4TXk0Mk9UVTJOVEl5SUVNd0xERXpMamcyTXprMU5qVWdNQzR4TVRVNE5qSXdOamtzTVRRZ01DNHlOVGcyTWpBMk9Td3hOQ0JNTVRRdU56UXhNemM1TXl3eE5DQkRNVFF1T0RnME1UTTNPU3d4TkNBeE5Td3hNeTQ0TmpNNU5UWTFJREUxTERFekxqWTVOVFkxTWpJZ1RERTFMREF1TXpBME16UTNPREkySUVNeE5Td3dMakV6TmpBME16UTNPQ0F4TkM0NE9EUXhNemM1TERBZ01UUXVOelF4TXpjNU15d3dJRXd4TkM0M05ERXpOemt6TERBZ1dpQk5NVFF1TkRneU56VTROaXd4TXk0ek9URXpNRFF6SUV3d0xqVXhOekkwTVRNM09Td3hNeTR6T1RFek1EUXpJRXd3TGpVeE56STBNVE0zT1N3d0xqWXdPRFk1TlRZMU1pQk1NVFF1TkRneU56VTROaXd3TGpZd09EWTVOVFkxTWlCTU1UUXVORGd5TnpVNE5pd3hNeTR6T1RFek1EUXpJRXd4TkM0ME9ESTNOVGcyTERFekxqTTVNVE13TkRNZ1dpSWdhV1E5SWxOb1lYQmxJajQ4TDNCaGRHZytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhCaGRHZ2daRDBpVFRRdU1UTTNPVE14TURNc05pNDNNemMyTlRJeE55QkROQzQ1TXpJeE5UVXhOeXcyTGpjek56WTFNakUzSURVdU5UYzRNVGc1TmpZc05TNDVOemN6T1RFeklEVXVOVGM0TVRnNU5qWXNOUzR3TkRNd05ETTBPQ0JETlM0MU56Z3hPRGsyTml3MExqRXdPREE0TmprMklEUXVPVE15TVRVMU1UY3NNeTR6TkRjNE1qWXdPU0EwTGpFek56a3pNVEF6TERNdU16UTNPREkyTURrZ1F6TXVNelF6TnpBMk9Td3pMak0wTnpneU5qQTVJREl1TmprM05qY3lOREVzTkM0eE1EZ3dPRFk1TmlBeUxqWTVOelkzTWpReExEVXVNRFF5TnpNNU1UTWdRekl1TmprM05qY3lOREVzTlM0NU56Y3pPVEV6SURNdU16UXpOekEyT1N3MkxqY3pOelkxTWpFM0lEUXVNVE0zT1RNeE1ETXNOaTQzTXpjMk5USXhOeUJNTkM0eE16YzVNekV3TXl3MkxqY3pOelkxTWpFM0lGb2dUVFF1TVRNM09UTXhNRE1zTXk0NU5UWTFNakUzTkNCRE5DNDJORFk0T1RZMU5Td3pMamsxTmpVeU1UYzBJRFV1TURZd09UUTRNamdzTkM0ME5EUXdPRFk1TmlBMUxqQTJNRGswT0RJNExEVXVNRFF5TnpNNU1UTWdRelV1TURZd09UUTRNamdzTlM0Mk5ERXpPVEV6SURRdU5qUTJPRGsyTlRVc05pNHhNamc1TlRZMU1pQTBMakV6Tnprek1UQXpMRFl1TVRJNE9UVTJOVElnUXpNdU5qSTRPVFkxTlRJc05pNHhNamc1TlRZMU1pQXpMakl4TkRreE16YzVMRFV1TmpReE5qazFOalVnTXk0eU1UUTVNVE0zT1N3MUxqQTBNekEwTXpRNElFTXpMakl4TkRreE16YzVMRFF1TkRRME16a3hNeUF6TGpZeU9EazJOVFV5TERNdU9UVTJOVEl4TnpRZ05DNHhNemM1TXpFd015d3pMamsxTmpVeU1UYzBJRXcwTGpFek56a3pNVEF6TERNdU9UVTJOVEl4TnpRZ1dpSWdhV1E5SWxOb1lYQmxJajQ4TDNCaGRHZytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhCaGRHZ2daRDBpVFRFdU9ERXdNelEwT0RNc01USXVNVGN6T1RFeklFTXhMamczTURnMk1qQTNMREV5TGpFM016a3hNeUF4TGprek1UZzVOalUxTERFeUxqRTBPRGsxTmpVZ01TNDVPREV3TXpRME9Dd3hNaTR3T1RneE16QTBJRXcyTGpFNU9Ua3hNemM1TERjdU56STNNRGcyT1RZZ1REZ3VPRFkwTWpJME1UUXNNVEF1T0RZeU1UY3pPU0JET0M0NU5qVXpORFE0TXl3eE1DNDVPREV4TnpNNUlEa3VNVEk0Tnprek1Td3hNQzQ1T0RFeE56TTVJRGt1TWpJNU9URXpOemtzTVRBdU9EWXlNVGN6T1NCRE9TNHpNekV3TXpRME9Dd3hNQzQzTkRNeE56TTVJRGt1TXpNeE1ETTBORGdzTVRBdU5UVXdPREkyTVNBNUxqSXlPVGt4TXpjNUxERXdMalF6TVRneU5qRWdURGN1T1RnMk56STBNVFFzT0M0NU5qZzRNall3T1NCTU1UQXVNell4TVRJd055dzFMamt3T0RreE16QTBJRXd4TXk0eU56TTBORGd6TERrdU1EVXdOamsxTmpVZ1F6RXpMak0zT0Rjd05qa3NPUzR4TmpReU1UY3pPU0F4TXk0MU5ESTBNVE00TERrdU1UVTFOamsxTmpVZ01UTXVOak00T0RjNU15dzVMakF6TVRneU5qQTVJRU14TXk0M016VXpORFE0TERndU9UQTNPVFUyTlRJZ01UTXVOekk0TXpZeU1TdzRMamN4TlRNd05ETTFJREV6TGpZeU1qZzBORGdzT0M0Mk1ERTNPREkyTVNCTU1UQXVOVEU1TXprMk5pdzFMakkxTXprMU5qVXlJRU14TUM0ME5qZzNNRFk1TERVdU1UazVORGM0TWpZZ01UQXVOREF4TWpBMk9TdzFMakUzTWpNNU1UTWdNVEF1TXpNek1UZzVOeXcxTGpFM05ESXhOek01SUVNeE1DNHlOalEyTlRVeUxEVXVNVGMzT0RZNU5UY2dNVEF1TWl3MUxqSXhNelEzT0RJMklERXdMakUxTXpjd05qa3NOUzR5TnpNeE16QTBNeUJNTnk0Mk1qQTNOelU0Tml3NExqVXpOemcyT1RVM0lFdzJMak01TkRFek56a3pMRGN1TURrME16UTNPRE1nUXpZdU1qazNOREV6Tnprc05pNDVPREE0TWpZd09TQTJMakUwTWpjMU9EWXlMRFl1T1RjMU1EUXpORGdnTmk0d05EQXpORFE0TXl3M0xqQTRNRGsxTmpVeUlFd3hMall6T1RNNU5qVTFMREV4TGpZME1TQkRNUzQxTXpJd05qZzVOeXd4TVM0M05USXdPRGNnTVM0MU1qRTNNalF4TkN3eE1TNDVORFEwTXpRNElERXVOakUyTVRJd05qa3NNVEl1TURjd056TTVNU0JETVM0Mk5qY3pNamMxT1N3eE1pNHhNemt5TVRjMElERXVOek00TnpBMk9Td3hNaTR4TnpNNU1UTWdNUzQ0TVRBek5EUTRNeXd4TWk0eE56TTVNVE1nVERFdU9ERXdNelEwT0RNc01USXVNVGN6T1RFeklGb2lJR2xrUFNKVGFHRndaU0krUEM5d1lYUm9QZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUNBZ0lDQThMMmMrQ2lBZ0lDQWdJQ0FnUEM5blBnb2dJQ0FnUEM5blBnbzhMM04yWno0PVwifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRTBjSGdpSUdobGFXZG9kRDBpTVRkd2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFMElERTNJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVStkVzVrYnp3dmRHbDBiR1UrQ2lBZ0lDQThaR1Z6WXo1RGNtVmhkR1ZrSUhkcGRHZ2dVMnRsZEdOb0xqd3ZaR1Z6WXo0S0lDQWdJRHhrWldaelBqd3ZaR1ZtY3o0S0lDQWdJRHhuSUdsa1BTSlFZV2RsTFRFaUlITjBjbTlyWlQwaWJtOXVaU0lnYzNSeWIydGxMWGRwWkhSb1BTSXhJaUJtYVd4c1BTSnViMjVsSWlCbWFXeHNMWEoxYkdVOUltVjJaVzV2WkdRaVBnb2dJQ0FnSUNBZ0lEeG5JR2xrUFNKMWJtUnZJaUJtYVd4c1BTSWpNREF3TURBd0lqNEtJQ0FnSUNBZ0lDQWdJQ0FnUEdjZ2FXUTlJa05oY0dGZk1TSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjR0YwYUNCa1BTSk5OeXd4TkM0NE56VWdRemt1TmpjeU16RTNNekVzTVRRdU9EYzFJREV4TGpnME5qRTFNemdzTVRJdU56TXdNamMzTXlBeE1TNDRORFl4TlRNNExERXdMakE1TXpjMUlFTXhNUzQ0TkRZeE5UTTRMRGN1TkRVM01qSXlOallnT1M0Mk56SXpNVGN6TVN3MUxqTXhNalVnTnl3MUxqTXhNalVnVERjc09DNDFJRXd4TGpZeE5UTTRORFl5TERRdU1qVWdURGNzTUNCTU55d3pMakU0TnpVZ1F6RXdMamcxT1RZNU1qTXNNeTR4T0RjMUlERTBMRFl1TWpnMU56Z3pNaUF4TkN3eE1DNHdPVE0zTlNCRE1UUXNNVE11T1RBeE56VWdNVEF1T0RVNU5qa3lNeXd4TnlBM0xERTNJRU16TGpFME1ETTBNVE0xTERFM0lEQXNNVE11T1RBeE56VWdNQ3d4TUM0d09UTTNOU0JNTWk0eE5UTTRORFl4TlN3eE1DNHdPVE0zTlNCRE1pNHhOVE00TkRZeE5Td3hNaTQzTXpBeU56Y3pJRFF1TXpJM05qZ3lOamtzTVRRdU9EYzFJRGNzTVRRdU9EYzFJRXczTERFMExqZzNOU0JhSWlCcFpEMGlVMmhoY0dVaVBqd3ZjR0YwYUQ0S0lDQWdJQ0FnSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0FnSUR3dlp6NEtJQ0FnSUR3dlp6NEtQQzl6ZG1jK1wifSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p4emRtY2dkMmxrZEdnOUlqRXpjSGdpSUdobGFXZG9kRDBpTVRad2VDSWdkbWxsZDBKdmVEMGlNQ0F3SURFeklERTJJaUIyWlhKemFXOXVQU0l4TGpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGdvZ0lDQWdQQ0V0TFNCSFpXNWxjbUYwYjNJNklGTnJaWFJqYUNBME1DNHpJQ2d6TXpnek9Ta2dMU0JvZEhSd09pOHZkM2QzTG1KdmFHVnRhV0Z1WTI5a2FXNW5MbU52YlM5emEyVjBZMmdnTFMwK0NpQWdJQ0E4ZEdsMGJHVStjbVZrYnp3dmRHbDBiR1UrQ2lBZ0lDQThaR1Z6WXo1RGNtVmhkR1ZrSUhkcGRHZ2dVMnRsZEdOb0xqd3ZaR1Z6WXo0S0lDQWdJRHhrWldaelBqd3ZaR1ZtY3o0S0lDQWdJRHhuSUdsa1BTSlFZV2RsTFRFaUlITjBjbTlyWlQwaWJtOXVaU0lnYzNSeWIydGxMWGRwWkhSb1BTSXhJaUJtYVd4c1BTSnViMjVsSWlCbWFXeHNMWEoxYkdVOUltVjJaVzV2WkdRaVBnb2dJQ0FnSUNBZ0lEeG5JR2xrUFNKeVpXUnZJaUJtYVd4c1BTSWpNREF3TURBd0lqNEtJQ0FnSUNBZ0lDQWdJQ0FnUEdjZ2FXUTlJa05oY0dGZk1TSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjR0YwYUNCa1BTSk5OaTQxTURNMU1qRTFNaXd4TXk0NU56Y3lOVEVnUXpRdU1ESTJPRGN6TkRJc01UTXVPVGMzTWpVeElESXVNREV5TVRZNU5qSXNNVEV1T1RZeU1UTTVPU0F5TGpBeE1qRTJPVFl5TERrdU5EZzBOVGMyTVRNZ1F6SXVNREV5TVRZNU5qSXNOeTR3TURjeE5EUXdNeUEwTGpBeU5qZzNNelF5TERRdU9Ua3hPRFk0TXpFZ05pNDFNRE0xTWpFMU1pdzBMams1TVRnMk9ETXhJRXcyTGpVd016VXlNVFV5TERjdU9UZzNNREk0T0RFZ1RERXhMalE1TXpnME15d3pMams1TXpVME56TXpJRXcyTGpVd016VXlNVFV5TERBZ1REWXVOVEF6TlRJeE5USXNNaTQ1T1RVeE5qQTBPU0JETWk0NU1qWTBPREV3TVN3eUxqazVOVEUyTURRNUlEQXVNREUyTVRJMk5UZ3lNeXcxTGprd05qVXdNakEySURBdU1ERTJNVEkyTlRneU15dzVMalE0TkRZd09UQTFJRU13TGpBeE5qRXlOalU0TWpNc01UTXVNRFl5T1RFek5pQXlMamt5TmpRNE1UQXhMREUxTGprM05EQTVNRFVnTmk0MU1ETTFNakUxTWl3eE5TNDVOelF3T1RBMUlFTXhNQzR3T0RBMU5qSXNNVFV1T1RjME1Ea3dOU0F4TWk0NU9UQTRNVGMzTERFekxqQTJNamt4TXpZZ01USXVPVGt3T0RFM055dzVMalE0TkRZd09UQTFJRXd4TUM0NU9UUTVNRFl6TERrdU5EZzBOakE1TURVZ1F6RXdMams1TkRrek9USXNNVEV1T1RZeU1UTTVPU0E0TGprNE1ERTJPVFl5TERFekxqazNOekkxTVNBMkxqVXdNelV5TVRVeUxERXpMamszTnpJMU1TQk1OaTQxTURNMU1qRTFNaXd4TXk0NU56Y3lOVEVnV2lJZ2FXUTlJbE5vWVhCbElqNDhMM0JoZEdnK0NpQWdJQ0FnSUNBZ0lDQWdJRHd2Wno0S0lDQWdJQ0FnSUNBOEwyYytDaUFnSUNBOEwyYytDand2YzNablBnPT1cIn0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9XCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlkWFJtTFRnaVB6NEtQSE4yWnlCM2FXUjBhRDBpTVRZdU9UazVPRFExTlRBME56WXdOelF5SWlCb1pXbG5hSFE5SWpFMExqazVPVGcxTWpFNE1EUTRNRGsxTnlJZ2RtbGxkMEp2ZUQwaU1DNHdNREF3TURJek16QTBNeUF4TGpZNE56WTNaUzAzSURFMkxqazVPVGdnTVRRdU9UazVPU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajRLSUNBOFp5QjBjbUZ1YzJadmNtMDlJbTFoZEhKcGVDZ3dMakF6TkRVMk9EQXdNRFU0TkRnME1EYzNOU3dnTUN3Z01Dd2dNQzR3TXpReE5qa3dNRE16TmpjME1qUXdNU3dnTUN3Z01Da2lQZ29nSUNBZ1BIQmhkR2dnWkQwaVRUTTBNeTR5TnpNc016UXdMamd5TkdndE9ERXVNVGM1YkMwNU1pNHpOemt0TVRBNExqTTNOMHczT1M0ME1qa3NNelF3TGpneU5FZ3diREV6TUM0NE5qUXRNVFE0TGpFNE4wdzJMakk1TlN3MU1pNDNPVEpJT0RZdU5ETnNPRFl1TnprM0xERXdNUzR6T0RnbUl6RXdPeVlqT1RzbUl6azdiRGczTGpRMk1TMHhNREV1TXpnNGFEYzJMall6T1V3eU1URXVNelV5TERFNU1pNDJNemRNTXpRekxqSTNNeXd6TkRBdU9ESTBlaUJOTXprekxqRTFOQ3cwTURFdU1EWnNOVEl1T0RZdE5EQXVNRE0wWXpFNExqVTBNaTB4TWk0M016RXNNekF1TnpJMExUSTBMalUxT1N3ek5pNDFOak10TXpVdU5EWTBKaU14TURzbUl6azdKaU01TzJNMUxqZzBMVEV3TGprc09DNDNORGd0TWpJdU5qSXhMRGd1TnpRNExUTTFMakUzTm1Nd0xUSXdMalV3TkMwMkxqZzFOaTB6Tnk0d05UVXRNakF1TlRVNExUUTVMalkxTTJNdE1UTXVOekF4TFRFeUxqWXdNaTB6TVM0M01qTXRNVGd1T0RrMkxUVTBMakEwT0MweE9DNDRPVFltSXpFd095WWpPVHNtSXprN1l5MHlNUzQxTWpFc01DMHpPQzQzTlRFc05pNHpOekl0TlRFdU5qTTJMREU1TGpFeE1tTXRNVEl1T1RJeUxERXlMamMxTFRFNUxqTTNMRE14TGprMkxURTVMak0zTERVM0xqWTBPR2cwTVM0MU1qTmpNQzB4TlM0ek1qY3NNaTQzTVRNdE1qVXVPVEkxTERndU1UTXpMVE14TGpnd01TWWpNVEE3SmlNNU95WWpPVHRqTlM0ME1qWXROUzQ0TnpVc01USXVPRFl5TFRndU9ERTRMREl5TGpNek1TMDRMamd4T0dNNUxqUTJNeXd3TERFMkxqazBMREl1T1Rrc01qSXVORGcwTERndU9UWXhZelV1TlRBNUxEVXVPVGNzT0M0eU55d3hNeTR6T1RRc09DNHlOeXd5TWk0eU5pWWpNVEE3SmlNNU95WWpPVHRqTUN3NExqZzFOQzB5TGpVMU5Dd3hOaTQ0TmprdE55NDJPU3d5TkM0d016bGpMVFV1TVRNc055NHhOeTB4T1M0ek9ERXNNVGt1TWpZekxUUXlMamMzTml3ek5pNHlPRFpqTFRJd0xqQXlMREUwTGpZek5TMDBOeTR3T1RFc01qZ3VORE14TFRVMUxqSXhPQ3cwTVM0ek5qTW1JekV3T3lZak9Uc21Jems3YkRBdU5EQTNMRFE0TGpFd00yZ3hORGd1TmpBemRpMHpOeTQ1TXpab0xUazRMall5TjFZME1ERXVNRFo2SWk4K0NpQWdQQzluUGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWTRNREF3TlRnME9EUXdOemMxTENBd0xDQXdMQ0F3TGpBek5ERTJPVEF3TXpNMk56UXlOREF4TENBd0xDQXdLU0l2UGdvOEwzTjJaejQ9XCJ9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPVwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpZFhSbUxUZ2lQejRLUEhOMlp5QjNhV1IwYUQwaU1UWXVPVGs1T1RNeE16TTFORFE1TWpJaUlHaGxhV2RvZEQwaU1UVXVNREF3TVRrNE16WTBNalUzT0RFeUlpQjJhV1YzUW05NFBTSXRNQzR3TURBd01EUXhNamM1TmlBeUxqSTJNalV6WlMwM0lERTJMams1T1RrZ01UVXVNREF3TWlJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0S0lDQThaeUIwY21GdWMyWnZjbTA5SW0xaGRISnBlQ2d3TGpBek5EVTJNVEF3TURjMk5ETTJPVGszTENBd0xDQXdMQ0F3TGpBek1qWXlOekF3TVRRd05EYzJNakkzTENBd0xDQXdLU0krQ2lBZ0lDQThjR0YwYUNCa1BTSk5NakV4TGpNMU55d3pNVEV1TlRac01UTXhMamt5TWl3eE5EZ3VNVGc0YUMwNE1TNHhOemhzTFRreUxqTTRMVEV3T0M0ek56bE1Oemt1TkRNMUxEUTFPUzQzTkRoSU1Fd3hNekF1T0RZeExETXhNUzQxTmt3MkxqTXdNU3d4TnpFdU56RTBhRGd3TGpFek5TWWpNVEE3SmlNNU95WWpPVHRzT0RZdU56azBMREV3TVM0ek9URnNPRGN1TkRjdE1UQXhMak01TVdnM05pNDJNemxNTWpFeExqTTFOeXd6TVRFdU5UWjZJRTB6T1RFdU56TTJMREl4TVM0ek5tdzFOQzR6TnpNdE5EQXVNRE16WXpFNExqVTBNaTB4TWk0M05ERXNNekF1TnpJMExUSTBMalUyTERNMkxqVTJNeTB6TlM0ME5qZ21JekV3T3lZak9Uc21Jems3WXpVdU9ETTBMVEV3TGprd01pdzRMamMwT0MweU1pNDJNVGdzT0M0M05EZ3RNelV1TVRjeVl6QXRNakF1TlRBNExUWXVPRFUyTFRNM0xqQTJNUzB5TUM0MU5USXRORGt1TmpVMll5MHhNeTQzTURjdE1USXVOakF5TFRNeExqY3lPUzB4T0M0NE9UY3ROVFF1TURVMExURTRMamc1TnlZak1UQTdKaU01T3lZak9UdGpMVEl4TGpVeU55d3dMVE00TGpjME5TdzJMak0zTlMwMU1TNDJNemNzTVRrdU1URTFRek0xTWk0eU5UZ3NOak11T1RrMkxETTBOUzQ0TVN3NE15NHlNRFlzTXpRMUxqZ3hMREV3T0M0NWFEUXhMalV5TTJNd0xURTFMak16TERJdU56RTVMVEkxTGpreU9DdzRMakUwTlMwek1TNDRNRFltSXpFd095WWpPVHNtSXprN1l6VXVOREkyTFRVdU9EYzVMREV5TGpnMk1TMDRMamd4T1N3eU1pNHpNekV0T0M0NE1UbGpPUzQwTlRjc01Dd3hOaTQ1TWprc01pNDVPVEVzTWpJdU5EY3pMRGd1T1RZMFl6VXVOVEl4TERVdU9UWTNMRGd1TWpjMUxERXpMak00T0N3NExqSTNOU3d5TWk0eU5UY21JekV3T3lZak9Uc21Jems3WXpBc09DNDROVFF0TWk0MU5UUXNNVFl1T0RZMkxUY3VOamcxTERJMExqQXpPWE10TVRrdU16ZzNMREU1TGpJM01pMDBNaTQzT0RJc016WXVNams0WXkweU1DNHdNVFFzTVRRdU5qTTFMVFEzTGpBNU55d3lPQzQwTWpJdE5UVXVNakU0TERReExqTTJOR3d3TGpRd055dzBPQzR3T1RNbUl6RXdPeVlqT1RzbUl6azdhREUwT0M0Mk1ETjJMVE0zTGprelNETTVNUzQzTXpaNklpOCtDaUFnUEM5blBnb2dJRHhuSUhSeVlXNXpabTl5YlQwaWJXRjBjbWw0S0RBdU1ETTBOVFl4TURBd056WTBNelk1T1Rjc0lEQXNJREFzSURBdU1ETXlOakkzTURBeE5EQTBOell5TWpjc0lEQXNJREFwSWk4K0NpQWdQR2NnZEhKaGJuTm1iM0p0UFNKdFlYUnlhWGdvTUM0d016UTFOakV3TURBM05qUXpOams1Tnl3Z01Dd2dNQ3dnTUM0d016STJNamN3TURFME1EUTNOakl5Tnl3Z01Dd2dNQ2tpTHo0S0lDQThaeUIwY21GdWMyWnZjbTA5SW0xaGRISnBlQ2d3TGpBek5EVTJNVEF3TURjMk5ETTJPVGszTENBd0xDQXdMQ0F3TGpBek1qWXlOekF3TVRRd05EYzJNakkzTENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWXhNREF3TnpZME16WTVPVGNzSURBc0lEQXNJREF1TURNeU5qSTNNREF4TkRBME56WXlNamNzSURBc0lEQXBJaTgrQ2lBZ1BHY2dkSEpoYm5ObWIzSnRQU0p0WVhSeWFYZ29NQzR3TXpRMU5qRXdNREEzTmpRek5qazVOeXdnTUN3Z01Dd2dNQzR3TXpJMk1qY3dNREUwTURRM05qSXlOeXdnTUN3Z01Da2lMejRLSUNBOFp5QjBjbUZ1YzJadmNtMDlJbTFoZEhKcGVDZ3dMakF6TkRVMk1UQXdNRGMyTkRNMk9UazNMQ0F3TENBd0xDQXdMakF6TWpZeU56QXdNVFF3TkRjMk1qSTNMQ0F3TENBd0tTSXZQZ29nSUR4bklIUnlZVzV6Wm05eWJUMGliV0YwY21sNEtEQXVNRE0wTlRZeE1EQXdOelkwTXpZNU9UY3NJREFzSURBc0lEQXVNRE15TmpJM01EQXhOREEwTnpZeU1qY3NJREFzSURBcElpOCtDaUFnUEdjZ2RISmhibk5tYjNKdFBTSnRZWFJ5YVhnb01DNHdNelExTmpFd01EQTNOalF6TmprNU55d2dNQ3dnTUN3Z01DNHdNekkyTWpjd01ERTBNRFEzTmpJeU55d2dNQ3dnTUNraUx6NEtJQ0E4WnlCMGNtRnVjMlp2Y20wOUltMWhkSEpwZUNnd0xqQXpORFUyTVRBd01EYzJORE0yT1RrM0xDQXdMQ0F3TENBd0xqQXpNall5TnpBd01UUXdORGMyTWpJM0xDQXdMQ0F3S1NJdlBnb2dJRHhuSUhSeVlXNXpabTl5YlQwaWJXRjBjbWw0S0RBdU1ETTBOVFl4TURBd056WTBNelk1T1Rjc0lEQXNJREFzSURBdU1ETXlOakkzTURBeE5EQTBOell5TWpjc0lEQXNJREFwSWk4K0NpQWdQR2NnZEhKaGJuTm1iM0p0UFNKdFlYUnlhWGdvTUM0d016UTFOakV3TURBM05qUXpOams1Tnl3Z01Dd2dNQ3dnTUM0d016STJNamN3TURFME1EUTNOakl5Tnl3Z01Dd2dNQ2tpTHo0S0lDQThaeUIwY21GdWMyWnZjbTA5SW0xaGRISnBlQ2d3TGpBek5EVTJNVEF3TURjMk5ETTJPVGszTENBd0xDQXdMQ0F3TGpBek1qWXlOekF3TVRRd05EYzJNakkzTENBd0xDQXdLU0l2UGdvZ0lEeG5JSFJ5WVc1elptOXliVDBpYldGMGNtbDRLREF1TURNME5UWXhNREF3TnpZME16WTVPVGNzSURBc0lEQXNJREF1TURNeU5qSTNNREF4TkRBME56WXlNamNzSURBc0lEQXBJaTgrQ2lBZ1BHY2dkSEpoYm5ObWIzSnRQU0p0WVhSeWFYZ29NQzR3TXpRMU5qRXdNREEzTmpRek5qazVOeXdnTUN3Z01Dd2dNQzR3TXpJMk1qY3dNREUwTURRM05qSXlOeXdnTUN3Z01Da2lMejRLSUNBOFp5QjBjbUZ1YzJadmNtMDlJbTFoZEhKcGVDZ3dMakF6TkRVMk1UQXdNRGMyTkRNMk9UazNMQ0F3TENBd0xDQXdMakF6TWpZeU56QXdNVFF3TkRjMk1qSTNMQ0F3TENBd0tTSXZQZ284TDNOMlp6ND1cIn0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fXZhciBpPW4oMTIxKSxyPW8oaSksbD1uKDEyMiksYT1vKGwpLGM9bigxMjMpLHM9byhjKSxNPW4oMTI0KSx1PW8oTSksZz1uKDEyNSksZD1vKGcpLHA9bigxMjYpLE49byhwKSxEPW4oMTI3KSxJPW8oRCkseT1uKDEyOCksaj1vKHkpLGY9bigxMjkpLHc9byhmKSxtPW4oMTMwKSxDPW8obSksej1uKDEzMSksQT1vKHopLFQ9bigxMzIpLEU9byhUKSxMPW4oMTMzKSx4PW8oTCksTz1uKDEzNCksaz1vKE8pO2UuZXhwb3J0cz17ZW46ci5kZWZhdWx0LGZyOmEuZGVmYXVsdCx6aDpzLmRlZmF1bHQscnU6dS5kZWZhdWx0LHB0OmQuZGVmYXVsdCxrbzpOLmRlZmF1bHQsaXQ6SS5kZWZhdWx0LG5sOmouZGVmYXVsdCxkZTp3LmRlZmF1bHQsZGE6Qy5kZWZhdWx0LHpoX3R3OkEuZGVmYXVsdCxwbDpFLmRlZmF1bHQsZXM6eC5kZWZhdWx0LGphOmsuZGVmYXVsdH19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9e1wiZ2VuZXJpYy5hZGRcIjpcIkFkZFwiLFwiZ2VuZXJpYy5jYW5jZWxcIjpcIkNhbmNlbFwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDFcIjpcIkgxXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oMlwiOlwiSDJcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgzXCI6XCJIM1wiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDRcIjpcIkg0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNVwiOlwiSDVcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg2XCI6XCJINlwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuYmxvY2txdW90ZVwiOlwiQmxvY2txdW90ZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuY29kZVwiOlwiQ29kZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuYmxvY2t0eXBlXCI6XCJCbG9jayBUeXBlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ub3JtYWxcIjpcIk5vcm1hbFwiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci5jb2xvcnBpY2tlclwiOlwiQ29sb3IgUGlja2VyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLnRleHRcIjpcIlRleHRcIixcImNvbXBvbmVudHMuY29udHJvbHMuY29sb3JwaWNrZXIuYmFja2dyb3VuZFwiOlwiSGlnaGxpZ2h0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVtYmVkZGVkXCI6XCJFbWJlZGRlZFwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbWJlZGRlZC5lbWJlZGRlZGxpbmtcIjpcIkVtYmVkZGVkIExpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW50ZXJsaW5rXCI6XCJFbnRlciBsaW5rXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtb2ppLmVtb2ppXCI6XCJFbW9qaVwiLFwiY29tcG9uZW50cy5jb250cm9scy5mb250ZmFtaWx5LmZvbnRmYW1pbHlcIjpcIkZvbnRcIixcImNvbXBvbmVudHMuY29udHJvbHMuZm9udHNpemUuZm9udHNpemVcIjpcIkZvbnQgU2l6ZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5Lmhpc3RvcnlcIjpcIkhpc3RvcnlcIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS51bmRvXCI6XCJVbmRvXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkucmVkb1wiOlwiUmVkb1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5pbWFnZVwiOlwiSW1hZ2VcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuZmlsZVVwbG9hZFwiOlwiRmlsZSBVcGxvYWRcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuYnlVUkxcIjpcIlVSTFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5kcm9wRmlsZVRleHRcIjpcIkRyb3AgdGhlIGZpbGUgb3IgY2xpY2sgdG8gdXBsb2FkXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5ib2xkXCI6XCJCb2xkXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5pdGFsaWNcIjpcIkl0YWxpY1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUudW5kZXJsaW5lXCI6XCJVbmRlcmxpbmVcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN0cmlrZXRocm91Z2hcIjpcIlN0cmlrZXRocm91Z2hcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLm1vbm9zcGFjZVwiOlwiTW9ub3NwYWNlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5zdXBlcnNjcmlwdFwiOlwiU3VwZXJzY3JpcHRcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN1YnNjcmlwdFwiOlwiU3Vic2NyaXB0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RpdGxlXCI6XCJMaW5rIFRpdGxlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RhcmdldFwiOlwiTGluayBUYXJnZXRcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGFyZ2V0T3B0aW9uXCI6XCJPcGVuIGxpbmsgaW4gbmV3IHdpbmRvd1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtcIjpcIkxpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay51bmxpbmtcIjpcIlVubGlua1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lmxpc3RcIjpcIkxpc3RcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC51bm9yZGVyZWRcIjpcIlVub3JkZXJlZFwiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lm9yZGVyZWRcIjpcIk9yZGVyZWRcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5pbmRlbnRcIjpcIkluZGVudFwiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lm91dGRlbnRcIjpcIk91dGRlbnRcIixcImNvbXBvbmVudHMuY29udHJvbHMucmVtb3ZlLnJlbW92ZVwiOlwiUmVtb3ZlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi50ZXh0YWxpZ25cIjpcIlRleHQgQWxpZ25cIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmxlZnRcIjpcIkxlZnRcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmNlbnRlclwiOlwiQ2VudGVyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5yaWdodFwiOlwiUmlnaHRcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmp1c3RpZnlcIjpcIkp1c3RpZnlcIn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9e1wiZ2VuZXJpYy5hZGRcIjpcIk9rXCIsXCJnZW5lcmljLmNhbmNlbFwiOlwiQW5udWxlclwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDFcIjpcIlRpdHJlIDFcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgyXCI6XCJUaXRyZSAyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oM1wiOlwiVGl0cmUgM1wiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDRcIjpcIlRpdHJlIDRcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg1XCI6XCJUaXRyZSA1XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNlwiOlwiVGl0cmUgNlwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuYmxvY2txdW90ZVwiOlwiQ2l0YXRpb25cIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmNvZGVcIjpcIkNvZGVcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmJsb2NrdHlwZVwiOlwiVHlwZSBibG9jXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ub3JtYWxcIjpcIk5vcm1hbFwiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci5jb2xvcnBpY2tlclwiOlwiUGFsZXR0ZSBkZSBjb3VsZXVyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLnRleHRcIjpcIlRleHRlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLmJhY2tncm91bmRcIjpcIkZvbmRcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW1iZWRkZWRcIjpcIkVtYmVkZGVkXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVtYmVkZGVkbGlua1wiOlwiTGllbiBpRnJhbWVcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW50ZXJsaW5rXCI6XCJFbnRyZXIgbGUgbGllblwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbW9qaS5lbW9qaVwiOlwiRW1vamlcIixcImNvbXBvbmVudHMuY29udHJvbHMuZm9udGZhbWlseS5mb250ZmFtaWx5XCI6XCJQb2xpY2VcIixcImNvbXBvbmVudHMuY29udHJvbHMuZm9udHNpemUuZm9udHNpemVcIjpcIlRhaWxsZSBkZSBwb2xpY2VcIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS5oaXN0b3J5XCI6XCJIaXN0b3JpcXVlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkudW5kb1wiOlwiUHLDqWPDqWRlbnRcIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS5yZWRvXCI6XCJTdWl2YW50XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmltYWdlXCI6XCJJbWFnZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5maWxlVXBsb2FkXCI6XCJUw6lsw6ljaGFyZ2VtZW50XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmJ5VVJMXCI6XCJVUkxcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuZHJvcEZpbGVUZXh0XCI6XCJHbGlzc2VyIHVuZSBpbWFnZSBvdSBjbGlxdWVyIHBvdXIgdMOpbMOpY2hhcmdlclwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuYm9sZFwiOlwiR3Jhc1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuaXRhbGljXCI6XCJJdGFsaXF1ZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUudW5kZXJsaW5lXCI6XCJTb3VsaWduZXJcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN0cmlrZXRocm91Z2hcIjpcIkJhcnJlclwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUubW9ub3NwYWNlXCI6XCJNb25vc3BhY2VcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN1cGVyc2NyaXB0XCI6XCJFeHBvc2FudFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3Vic2NyaXB0XCI6XCJJbmRpY2VcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGl0bGVcIjpcIlRpdHJlIGR1IGxpZW5cIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGFyZ2V0XCI6XCJDaWJsZSBkdSBsaWVuXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RhcmdldE9wdGlvblwiOlwiT3V2cmlyIGxlIGxpZW4gZGFucyB1bmUgbm91dmVsbGUgZmVuw6p0cmVcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rXCI6XCJMaWVyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsudW5saW5rXCI6XCJEw6lsaWVyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3QubGlzdFwiOlwiTGlzdGVcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC51bm9yZGVyZWRcIjpcIkTDqXNvcmRvbm7DqWVcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5vcmRlcmVkXCI6XCJPcmRvbm7DqWVcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5pbmRlbnRcIjpcIkF1Z21lbnRlciBsZSByZXRyYWl0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3Qub3V0ZGVudFwiOlwiRGltaW51ZXIgbGUgcmV0cmF0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnJlbW92ZS5yZW1vdmVcIjpcIlN1cHByaW1lclwiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24udGV4dGFsaWduXCI6XCJBbGlnbmVtZW50IGR1IHRleHRlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5sZWZ0XCI6XCJHYXVjaGVcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmNlbnRlclwiOlwiQ2VudHJlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5yaWdodFwiOlwiRHJvaXRlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5qdXN0aWZ5XCI6XCJKdXN0aWZpZXJcIn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9e1wiZ2VuZXJpYy5hZGRcIjpcIua3u+WKoFwiLFwiZ2VuZXJpYy5jYW5jZWxcIjpcIuWPlua2iFwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDFcIjpcIuagh+mimDFcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgyXCI6XCLmoIfpopgyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oM1wiOlwi5qCH6aKYM1wiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDRcIjpcIuagh+mimDRcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg1XCI6XCLmoIfpopg1XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNlwiOlwi5qCH6aKYNlwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuYmxvY2txdW90ZVwiOlwi5byV55SoXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5jb2RlXCI6XCLmupDnoIFcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmJsb2NrdHlwZVwiOlwi5qC35byPXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ub3JtYWxcIjpcIuato+aWh1wiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci5jb2xvcnBpY2tlclwiOlwi6YCJ6Imy5ZmoXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLnRleHRcIjpcIuaWh+Wtl1wiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci5iYWNrZ3JvdW5kXCI6XCLog4zmma9cIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW1iZWRkZWRcIjpcIuWGheW1jFwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbWJlZGRlZC5lbWJlZGRlZGxpbmtcIjpcIuWGheW1jOe9kemhtVwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbWJlZGRlZC5lbnRlcmxpbmtcIjpcIui+k+WFpee9kemhteWcsOWdgFwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbW9qaS5lbW9qaVwiOlwi6KGo5oOF56ym5Y+3XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmZvbnRmYW1pbHkuZm9udGZhbWlseVwiOlwi5a2X5L2TXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmZvbnRzaXplLmZvbnRzaXplXCI6XCLlrZflj7dcIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS5oaXN0b3J5XCI6XCLljoblj7JcIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS51bmRvXCI6XCLmkqTplIBcIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS5yZWRvXCI6XCLmgaLlpI1cIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuaW1hZ2VcIjpcIuWbvueJh1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5maWxlVXBsb2FkXCI6XCLmnaXoh6rmlofku7ZcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuYnlVUkxcIjpcIuWcqOe6v+WbvueJh1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5kcm9wRmlsZVRleHRcIjpcIueCueWHu+aIluiAheaLluaLveaWh+S7tuS4iuS8oFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuYm9sZFwiOlwi57KX5L2TXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5pdGFsaWNcIjpcIuaWnOS9k1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUudW5kZXJsaW5lXCI6XCLkuIvliJLnur9cIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN0cmlrZXRocm91Z2hcIjpcIuWIoOmZpOe6v1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUubW9ub3NwYWNlXCI6XCLnrYnlrr3lrZfkvZNcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN1cGVyc2NyaXB0XCI6XCLkuIrmoIdcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN1YnNjcmlwdFwiOlwi5LiL5qCHXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RpdGxlXCI6XCLotoXpk77mjqVcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGFyZ2V0XCI6XCLovpPlhaXpk77mjqXlnLDlnYBcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGFyZ2V0T3B0aW9uXCI6XCLlnKjmlrDnqpflj6PkuK3miZPlvIDpk77mjqVcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rXCI6XCLpk77mjqVcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay51bmxpbmtcIjpcIuWIoOmZpOmTvuaOpVwiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lmxpc3RcIjpcIuWIl+ihqFwiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0LnVub3JkZXJlZFwiOlwi6aG555uu56ym5Y+3XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3Qub3JkZXJlZFwiOlwi57yW5Y+3XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3QuaW5kZW50XCI6XCLlop7liqDnvKnov5vph49cIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5vdXRkZW50XCI6XCLlh4/lsJHnvKnov5vph49cIixcImNvbXBvbmVudHMuY29udHJvbHMucmVtb3ZlLnJlbW92ZVwiOlwi5riF6Zmk5qC85byPXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi50ZXh0YWxpZ25cIjpcIuaWh+acrOWvuem9kFwiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24ubGVmdFwiOlwi5paH5pys5bem5a+56b2QXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5jZW50ZXJcIjpcIuWxheS4rVwiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24ucmlnaHRcIjpcIuaWh+acrOWPs+Wvuem9kFwiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24uanVzdGlmeVwiOlwi5Lik56uv5a+56b2QXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXtcImdlbmVyaWMuYWRkXCI6XCLQlNC+0LHQsNCy0LjRgtGMXCIsXCJnZW5lcmljLmNhbmNlbFwiOlwi0J7RgtC80LXQvdC40YLRjFwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDFcIjpcItCX0LDQs9C+0LvQvtCy0L7QuiAxXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oMlwiOlwi0JfQsNCz0L7Qu9C+0LLQvtC6IDJcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgzXCI6XCLQl9Cw0LPQvtC70L7QstC+0LogM1wiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDRcIjpcItCX0LDQs9C+0LvQvtCy0L7QuiA0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNVwiOlwi0JfQsNCz0L7Qu9C+0LLQvtC6IDVcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg2XCI6XCLQl9Cw0LPQvtC70L7QstC+0LogNlwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuYmxvY2txdW90ZVwiOlwi0KbQuNGC0LDRgtCwXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5jb2RlXCI6XCLQmtC+0LRcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmJsb2NrdHlwZVwiOlwi0KTQvtGA0LzQsNGC0LjRgNC+0LLQsNC90LjQtVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUubm9ybWFsXCI6XCLQntCx0YvRh9C90YvQuVwiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci5jb2xvcnBpY2tlclwiOlwi0JLRi9Cx0L7RgCDRhtCy0LXRgtCwXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLnRleHRcIjpcItCi0LXQutGB0YJcIixcImNvbXBvbmVudHMuY29udHJvbHMuY29sb3JwaWNrZXIuYmFja2dyb3VuZFwiOlwi0KTQvtC9XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVtYmVkZGVkXCI6XCLQktGB0YLRgNCw0LjQstCw0L3QuNC1XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVtYmVkZGVkbGlua1wiOlwi0KHRgdGL0LvQutCwINCyIGlGcmFtZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbWJlZGRlZC5lbnRlcmxpbmtcIjpcItCS0YHRgtCw0LLRjNGC0LUg0YHRgdGL0LvQutGDXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtb2ppLmVtb2ppXCI6XCLQrdC80L7QtNC30LhcIixcImNvbXBvbmVudHMuY29udHJvbHMuZm9udGZhbWlseS5mb250ZmFtaWx5XCI6XCLQqNGA0LjRhNGCXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmZvbnRzaXplLmZvbnRzaXplXCI6XCLQoNCw0LfQvNC10YAg0YjRgNC40YTRgtCwXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkuaGlzdG9yeVwiOlwi0JjRgdGC0L7RgNC40Y9cIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS51bmRvXCI6XCLQntGC0LzQtdC90LjRgtGMXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkucmVkb1wiOlwi0JLQtdGA0L3Rg9GC0YxcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuaW1hZ2VcIjpcItCY0LfQvtCx0YDQsNC20LXQvdC40LVcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuZmlsZVVwbG9hZFwiOlwi0KTQsNC50LvRi1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5ieVVSTFwiOlwiVVJMXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmRyb3BGaWxlVGV4dFwiOlwi0J/QtdGA0LXQvNC10YHRgtC40YLQtSDQsiDRjdGC0YMg0L7QsdC70LDRgdGC0Ywg0YTQsNC50LvRiyDQuNC70Lgg0LrQu9C40LrQvdC40YLQtSDQtNC70Y8g0LfQsNCz0YDRg9C30LrQuFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuYm9sZFwiOlwi0JbQuNGA0L3Ri9C5XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5pdGFsaWNcIjpcItCa0YPRgNGB0LjQslwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUudW5kZXJsaW5lXCI6XCLQn9C+0LTRh9C10YDQutC40LLQsNC90LjQtVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3RyaWtldGhyb3VnaFwiOlwi0JfQsNGH0LXRgNC60LjQstCw0L3QuNC1XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5tb25vc3BhY2VcIjpcIk1vbm9zcGFjZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3VwZXJzY3JpcHRcIjpcItCS0LXRgNGF0L3QuNC5INC40L3QtNC10LrRgVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3Vic2NyaXB0XCI6XCLQndC40LbQvdC40Lkg0LjQvdC00LXQutGBXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RpdGxlXCI6XCLQotC10LrRgdGCXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RhcmdldFwiOlwi0JDQtNGA0LXRgSDRgdGB0YvQu9C60LhcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGFyZ2V0T3B0aW9uXCI6XCLQntGC0LrRgNGL0LLQsNGC0Ywg0LIg0L3QvtCy0L7QvCDQvtC60L3QtVwiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtcIjpcItCh0YHRi9C70LrQsFwiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLnVubGlua1wiOlwi0KPQsdGA0LDRgtGMINGB0YHRi9C70LrRg1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lmxpc3RcIjpcItCh0L/QuNGB0L7QulwiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0LnVub3JkZXJlZFwiOlwi0J3QtdGD0L/QvtGA0Y/QtNC+0YfQtdC90L3Ri9C5XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3Qub3JkZXJlZFwiOlwi0KPQv9C+0YDRj9C00L7Rh9C10L3QvdGL0LlcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5pbmRlbnRcIjpcItCe0YLRgdGC0YPQv1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lm91dGRlbnRcIjpcItCS0YvRgdGC0YPQv1wiLFwiY29tcG9uZW50cy5jb250cm9scy5yZW1vdmUucmVtb3ZlXCI6XCLQo9C00LDQu9C40YLRjFwiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24udGV4dGFsaWduXCI6XCLQktGL0YDQsNCy0L3QuNCy0LDQvdC40LUg0YLQtdC60YHRgtCwXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5sZWZ0XCI6XCLQodC70LXQstCwXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5jZW50ZXJcIjpcItCf0L4g0YbQtdC90YLRgNGDXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5yaWdodFwiOlwi0KHQv9GA0LDQstCwXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5qdXN0aWZ5XCI6XCLQktGL0YDQsNCy0L3QuNGC0YxcIn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9e1wiZ2VuZXJpYy5hZGRcIjpcIk9rXCIsXCJnZW5lcmljLmNhbmNlbFwiOlwiQ2FuY2VsYXJcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgxXCI6XCJUw610dWxvIDFcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgyXCI6XCJUw610dWxvIDJcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgzXCI6XCJUw610dWxvIDNcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg0XCI6XCJUw610dWxvIDRcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg1XCI6XCJUw610dWxvIDVcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg2XCI6XCJUw610dWxvIDZcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmJsb2NrcXVvdGVcIjpcIkNpdGHDp8Ojb1wiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuY29kZVwiOlwiQ29kZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuYmxvY2t0eXBlXCI6XCJFc3RpbG9cIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLm5vcm1hbFwiOlwiTm9ybWFsXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLmNvbG9ycGlja2VyXCI6XCJQYWxldGEgZGUgY29yZXNcIixcImNvbXBvbmVudHMuY29udHJvbHMuY29sb3JwaWNrZXIudGV4dFwiOlwiVGV4dG9cIixcImNvbXBvbmVudHMuY29udHJvbHMuY29sb3JwaWNrZXIuYmFja2dyb3VuZFwiOlwiRnVuZG9cIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW1iZWRkZWRcIjpcIkVtYmFyY2Fkb1wiLFwiY29tcG9uZW50cy5jb250cm9scy5lbWJlZGRlZC5lbWJlZGRlZGxpbmtcIjpcIkxpbmsgZW1iYXJjYWRvXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVudGVybGlua1wiOlwiQ29sb3F1ZSBvIGxpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1vamkuZW1vamlcIjpcIkVtb2ppXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmZvbnRmYW1pbHkuZm9udGZhbWlseVwiOlwiRm9udGVcIixcImNvbXBvbmVudHMuY29udHJvbHMuZm9udHNpemUuZm9udHNpemVcIjpcIlRhbWFuaG8gZGEgRm9udGVcIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS5oaXN0b3J5XCI6XCJIaXN0w7NyaWNvXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkudW5kb1wiOlwiRGVzZmF6ZXJcIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS5yZWRvXCI6XCJSZWZhemVyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmltYWdlXCI6XCJJbWFnZW1cIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuZmlsZVVwbG9hZFwiOlwiQ2FycmVnYXIgYXJxdWl2b1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5ieVVSTFwiOlwiVVJMXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmRyb3BGaWxlVGV4dFwiOlwiQXJyYXN0ZSB1bWEgaW1hZ2VtIGFxdWkgb3UgY2xpcXVlIHBhcmEgY2FycmVnYXJcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLmJvbGRcIjpcIk5lZ3JpdG9cIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLml0YWxpY1wiOlwiSXTDoWxpY29cIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnVuZGVybGluZVwiOlwiU3VibGluaGFkb1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3RyaWtldGhyb3VnaFwiOlwiU3RyaWtldGhyb3VnaFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUubW9ub3NwYWNlXCI6XCJNb25vc3BhY2VcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN1cGVyc2NyaXB0XCI6XCJTb2JyZXNjcml0b1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3Vic2NyaXB0XCI6XCJTdWJzY3JpdG9cIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGl0bGVcIjpcIlTDrXR1bG8gZG8gbGlua1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtUYXJnZXRcIjpcIkFsdm8gZG8gbGlua1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtUYXJnZXRPcHRpb25cIjpcIkFicmlyIGxpbmsgZW0gb3V0cmEgamFuZWxhXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1wiOlwiQWRpY2lvbmFyIExpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay51bmxpbmtcIjpcIlJlbW92ZXIgbGlua1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lmxpc3RcIjpcIkxpc3RhXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3QudW5vcmRlcmVkXCI6XCJTZW0gb3JkZW7Dp8Ojb1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lm9yZGVyZWRcIjpcIk9yZGVuYWRhXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3QuaW5kZW50XCI6XCJBdW1lbnRhciByZWN1b1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lm91dGRlbnRcIjpcIkRpbWludWlyIHJlY3VvXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnJlbW92ZS5yZW1vdmVcIjpcIlJlbW92ZXJcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLnRleHRhbGlnblwiOlwiQWxpbmhhbWVudG8gZG8gdGV4dG9cIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmxlZnRcIjpcIsOAIEVzcXVlcmRhXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5jZW50ZXJcIjpcIkNlbnRyYWxpemFkb1wiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24ucmlnaHRcIjpcIsOAIERpcmVpdGFcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmp1c3RpZnlcIjpcIkp1c3RpZmljYWRvXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXtcImdlbmVyaWMuYWRkXCI6XCLsnoXroKVcIixcImdlbmVyaWMuY2FuY2VsXCI6XCLst6jshoxcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgxXCI6XCLsoJzrqqkxXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oMlwiOlwi7KCc66qpMlwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDNcIjpcIuygnOuqqTNcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg0XCI6XCLsoJzrqqk0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNVwiOlwi7KCc66qpNVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDZcIjpcIuygnOuqqTZcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmJsb2NrcXVvdGVcIjpcIuyduOyaqVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuY29kZVwiOlwiQ29kZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuYmxvY2t0eXBlXCI6XCLruJTroZ1cIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLm5vcm1hbFwiOlwi7ZGc7KSAXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLmNvbG9ycGlja2VyXCI6XCLsg4nsg4Eg7ISg7YOdXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLnRleHRcIjpcIuq4gOq8tOyDiVwiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci5iYWNrZ3JvdW5kXCI6XCLrsLDqsr3sg4lcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW1iZWRkZWRcIjpcIuyehOuyoOuTnFwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbWJlZGRlZC5lbWJlZGRlZGxpbmtcIjpcIuyehOuyoOuTnCDrp4HtgaxcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW50ZXJsaW5rXCI6XCLso7zshozrpbwg7J6F66Cl7ZWY7IS47JqUXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtb2ppLmVtb2ppXCI6XCLsnbTrqqjsp4BcIixcImNvbXBvbmVudHMuY29udHJvbHMuZm9udGZhbWlseS5mb250ZmFtaWx5XCI6XCLquIDqvLRcIixcImNvbXBvbmVudHMuY29udHJvbHMuZm9udHNpemUuZm9udHNpemVcIjpcIuq4gOq8tCDtgazquLBcIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS5oaXN0b3J5XCI6XCLtnojsiqTthqDrpqxcIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS51bmRvXCI6XCLsi6Ttlokg7Leo7IaMXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkucmVkb1wiOlwi64uk7IucIOyLpO2WiVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5pbWFnZVwiOlwi7J2066+47KeAXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmZpbGVVcGxvYWRcIjpcIu2MjOydvCDsl4XroZzrk5xcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuYnlVUkxcIjpcIuyjvOyGjFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5kcm9wRmlsZVRleHRcIjpcIu2BtOumre2VmOqxsOuCmCDtjIzsnbzsnYQg65Oc66Gt7ZWY7JesIOyXheuhnOuTnO2VmOyEuOyalFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuYm9sZFwiOlwi6rW16rKMXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5pdGFsaWNcIjpcIuq4sOyauOyehOq8tFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUudW5kZXJsaW5lXCI6XCLrsJHspIRcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN0cmlrZXRocm91Z2hcIjpcIuy3qOyGjOyEoFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUubW9ub3NwYWNlXCI6XCLqs6DsoJUg64SI67mEXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5zdXBlcnNjcmlwdFwiOlwi7JyEIOyyqOyekFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3Vic2NyaXB0XCI6XCLslYTrnpgg7LKo7J6QXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RpdGxlXCI6XCLrp4Htgawg7KCc66qpXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RhcmdldFwiOlwi66eB7YGsIO2DgOqyn1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtUYXJnZXRPcHRpb25cIjpcIuyDiOywveycvOuhnCDsl7TquLBcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rXCI6XCLrp4HtgaxcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay51bmxpbmtcIjpcIuunge2BrCDsoJzqsbBcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5saXN0XCI6XCLrpqzsiqTtirhcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC51bm9yZGVyZWRcIjpcIuydvOuwmCDrpqzsiqTtirhcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5vcmRlcmVkXCI6XCLsiJzshJwg66as7Iqk7Yq4XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3QuaW5kZW50XCI6XCLrk6Tsl6zsk7DquLBcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5vdXRkZW50XCI6XCLrgrTslrTsk7DquLBcIixcImNvbXBvbmVudHMuY29udHJvbHMucmVtb3ZlLnJlbW92ZVwiOlwi7IKt7KCcXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi50ZXh0YWxpZ25cIjpcIu2FjeyKpO2KuCDsoJXroKxcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmxlZnRcIjpcIuyZvOyqvVwiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24uY2VudGVyXCI6XCLspJHslZlcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLnJpZ2h0XCI6XCLsmKTrpbjsqr1cIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmp1c3RpZnlcIjpcIuyWkeyqvVwifX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17XCJnZW5lcmljLmFkZFwiOlwiQWdnaXVuZ2lcIixcImdlbmVyaWMuY2FuY2VsXCI6XCJBbm51bGxhXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oMVwiOlwiSDFcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgyXCI6XCJIMlwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDNcIjpcIkgzXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNFwiOlwiSDRcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg1XCI6XCJINVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDZcIjpcIkg2XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ibG9ja3F1b3RlXCI6XCJDaXRhemlvbmVcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmNvZGVcIjpcIkNvZGljZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuYmxvY2t0eXBlXCI6XCJTdGlsaVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUubm9ybWFsXCI6XCJOb3JtYWxlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLmNvbG9ycGlja2VyXCI6XCJDb2xvcmUgdGVzdG9cIixcImNvbXBvbmVudHMuY29udHJvbHMuY29sb3JwaWNrZXIudGV4dFwiOlwiVGVzdG9cIixcImNvbXBvbmVudHMuY29udHJvbHMuY29sb3JwaWNrZXIuYmFja2dyb3VuZFwiOlwiRXZpZGVuemlhemlvbmVcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW1iZWRkZWRcIjpcIkluY29ycG9yYVwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbWJlZGRlZC5lbWJlZGRlZGxpbmtcIjpcIkluY29ycG9yYSBsaW5rXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVudGVybGlua1wiOlwiSW5zZXJpc2NpIGxpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1vamkuZW1vamlcIjpcIkVtb2ppXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmZvbnRmYW1pbHkuZm9udGZhbWlseVwiOlwiQ2FyYXR0ZXJlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmZvbnRzaXplLmZvbnRzaXplXCI6XCJEaW1lbnNpb25lIGNhcmF0dGVyZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5Lmhpc3RvcnlcIjpcIk1vZGlmaWNoZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5LnVuZG9cIjpcIkFubnVsbGFcIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS5yZWRvXCI6XCJSaXByaXN0aW5hXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmltYWdlXCI6XCJJbW1hZ2luZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5maWxlVXBsb2FkXCI6XCJDYXJpY2EgaW1tYWdpbmVcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuYnlVUkxcIjpcIlVSTFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5kcm9wRmlsZVRleHRcIjpcIlRyYXNjaW5hIGlsIGZpbGUgbyBjbGljY2EgcGVyIGNhcmljYXJlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5ib2xkXCI6XCJHcmFzc2V0dG9cIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLml0YWxpY1wiOlwiQ29yc2l2b1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUudW5kZXJsaW5lXCI6XCJTb3R0b2xpbmVhdG9cIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN0cmlrZXRocm91Z2hcIjpcIkJhcnJhdG9cIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLm1vbm9zcGFjZVwiOlwiTW9ub3NwYWNlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5zdXBlcnNjcmlwdFwiOlwiQXBpY2VcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN1YnNjcmlwdFwiOlwiUGVkaWNlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RpdGxlXCI6XCJUZXN0b1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtUYXJnZXRcIjpcIkxpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGFyZ2V0T3B0aW9uXCI6XCJBcHJpIGxpbmsgaW4gdW5hIG51b3ZhIGZpbmVzdHJhXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1wiOlwiSW5zZXJpc2NpIGxpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay51bmxpbmtcIjpcIlJpbXVvdmkgbGlua1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lmxpc3RcIjpcIkxpc3RhXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3QudW5vcmRlcmVkXCI6XCJFbGVuY28gcHVudGF0b1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lm9yZGVyZWRcIjpcIkVsZW5jbyBudW1lcmF0b1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0LmluZGVudFwiOlwiSW5kZW50XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3Qub3V0ZGVudFwiOlwiT3V0ZGVudFwiLFwiY29tcG9uZW50cy5jb250cm9scy5yZW1vdmUucmVtb3ZlXCI6XCJSaW11b3ZpIGZvcm1hdHRhemlvbmVcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLnRleHRhbGlnblwiOlwiQWxsaW5lYW1lbnRvIGRlbCB0ZXN0b1wiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24ubGVmdFwiOlwiQWxsaW5lYSBhIHNpbmlzdHJhXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5jZW50ZXJcIjpcIkFsbGluZWEgYWwgY2VudHJvXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5yaWdodFwiOlwiQWxsaW5lYSBhIGRlc3RyYVwiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24uanVzdGlmeVwiOlwiR2l1c3RpZmljYVwifX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17XCJnZW5lcmljLmFkZFwiOlwiVG9ldm9lZ2VuXCIsXCJnZW5lcmljLmNhbmNlbFwiOlwiQW5udWxlcmVuXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oMVwiOlwiSDFcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgyXCI6XCJIMlwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDNcIjpcIkgzXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNFwiOlwiSDRcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg1XCI6XCJINVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDZcIjpcIkg2XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ibG9ja3F1b3RlXCI6XCJCbG9ja3F1b3RlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5jb2RlXCI6XCJDb2RlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ibG9ja3R5cGVcIjpcIkJsb2NrdHlwZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUubm9ybWFsXCI6XCJOb3JtYWFsXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLmNvbG9ycGlja2VyXCI6XCJLbGV1cmtpZXplclwiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci50ZXh0XCI6XCJUZWtzdFwiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci5iYWNrZ3JvdW5kXCI6XCJBY2h0ZXJncm9uZFwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbWJlZGRlZC5lbWJlZGRlZFwiOlwiSW5nZXZvZWdkXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVtYmVkZGVkbGlua1wiOlwiSW5nZXZvZWdkZSBsaW5rXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVudGVybGlua1wiOlwiVm9lZyBsaW5rIHRvZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbW9qaS5lbW9qaVwiOlwiRW1vamlcIixcImNvbXBvbmVudHMuY29udHJvbHMuZm9udGZhbWlseS5mb250ZmFtaWx5XCI6XCJMZXR0ZXJ0eXBlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmZvbnRzaXplLmZvbnRzaXplXCI6XCJMZXR0ZXJncm9vdHRlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkuaGlzdG9yeVwiOlwiR2VzY2hpZWRlbmlzXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkudW5kb1wiOlwiT25nZWRhYW4gbWFrZW5cIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS5yZWRvXCI6XCJPcG5pZXV3XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmltYWdlXCI6XCJBZmJlZWxkaW5nXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmZpbGVVcGxvYWRcIjpcIkJlc3RhbmQgdXBsb2FkZW5cIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuYnlVUkxcIjpcIlVSTFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5kcm9wRmlsZVRleHRcIjpcIkRyb3AgaGV0IGJlc3RhbmQgaGllciBvZiBrbGlrIG9tIHRlIHVwbG9hZGVuXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5ib2xkXCI6XCJEaWtnZWRydWt0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5pdGFsaWNcIjpcIlNjaHVpbmdlZHJ1a3RcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnVuZGVybGluZVwiOlwiT25kZXJzdHJlcGVuXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5zdHJpa2V0aHJvdWdoXCI6XCJEb29yc3RyZXBlblwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUubW9ub3NwYWNlXCI6XCJNb25vc3BhY2VcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN1cGVyc2NyaXB0XCI6XCJTdXBlcnNjcmlwdFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3Vic2NyaXB0XCI6XCJTdWJzY3JpcHRcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGl0bGVcIjpcIkxpbmt0aXRlbFwiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtUYXJnZXRcIjpcIkxpbmsgYmVzdGVtbWluZ1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtUYXJnZXRPcHRpb25cIjpcIk9wZW4gbGluayBpbiBlZW4gbmlldXcgdmVuc3RlclwiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtcIjpcIkxpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay51bmxpbmtcIjpcIlVubGlua1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lmxpc3RcIjpcIkxpanN0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3QudW5vcmRlcmVkXCI6XCJPbmdlb3JkZW5kXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3Qub3JkZXJlZFwiOlwiR2VvcmRlbmRcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5pbmRlbnRcIjpcIkluc3ByaW5nZW5cIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5vdXRkZW50XCI6XCJJbnNwcmluZ2VuIHZlcmtsZWluZW5cIixcImNvbXBvbmVudHMuY29udHJvbHMucmVtb3ZlLnJlbW92ZVwiOlwiVmVyd2lqZGVyZW5cIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLnRleHRhbGlnblwiOlwiVGVrc3QgdWl0bGlqbmVuXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5sZWZ0XCI6XCJMaW5rc1wiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24uY2VudGVyXCI6XCJHZWNlbnRyZWVyZFwiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24ucmlnaHRcIjpcIlJlY2h0c1wiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24uanVzdGlmeVwiOlwiVWl0Z2VsaWpuZFwifX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17XCJnZW5lcmljLmFkZFwiOlwiSGluenVmw7xnZW5cIixcImdlbmVyaWMuY2FuY2VsXCI6XCJBYmJyZWNoZW5cIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgxXCI6XCLDnGJlcnNjaHJpZnQgMVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDJcIjpcIsOcYmVyc2NocmlmdCAyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oM1wiOlwiw5xiZXJzY2hyaWZ0IDNcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg0XCI6XCLDnGJlcnNjaHJpZnQgNFwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDVcIjpcIsOcYmVyc2NocmlmdCA1XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNlwiOlwiw5xiZXJzY2hyaWZ0IDZcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmJsb2NrcXVvdGVcIjpcIlppdGF0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5jb2RlXCI6XCJRdWVsbGNvZGVcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmJsb2NrdHlwZVwiOlwiQmxvY2t0eXBcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLm5vcm1hbFwiOlwiTm9ybWFsXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLmNvbG9ycGlja2VyXCI6XCJGYXJiYXVzd2FobFwiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci50ZXh0XCI6XCJUZXh0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLmJhY2tncm91bmRcIjpcIkhpbnRlcmdydW5kXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVtYmVkZGVkXCI6XCJFaW5nZWJldHRldFwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbWJlZGRlZC5lbWJlZGRlZGxpbmtcIjpcIkVpbmdlYmV0dGV0ZXIgTGlua1wiLFwiY29tcG9uZW50cy5jb250cm9scy5lbWJlZGRlZC5lbnRlcmxpbmtcIjpcIkxpbmsgZWluZ2ViZW5cIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1vamkuZW1vamlcIjpcIkVtb2ppXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmZvbnRmYW1pbHkuZm9udGZhbWlseVwiOlwiU2NocmlmdGFydFwiLFwiY29tcG9uZW50cy5jb250cm9scy5mb250c2l6ZS5mb250c2l6ZVwiOlwiU2NocmlmdGdyw7bDn2VcIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS5oaXN0b3J5XCI6XCJIaXN0b3JpZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5LnVuZG9cIjpcIlp1csO8Y2tuZWhtZW5cIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS5yZWRvXCI6XCJXaWVkZXJob2xlblwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5pbWFnZVwiOlwiQmlsZFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5maWxlVXBsb2FkXCI6XCJEYXRlaS1VcGxvYWRcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuYnlVUkxcIjpcIlVSTFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5kcm9wRmlsZVRleHRcIjpcIkRhdGVpZW4gemllaGVuIHVuZCBhYmxlZ2VuLCBvZGVyIGtsaWNrZW4genVtIEhvY2hsYWRlblwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuYm9sZFwiOlwiRmV0dFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuaXRhbGljXCI6XCJLdXJzaXZcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnVuZGVybGluZVwiOlwiVW50ZXJzdHJlaWNoZW5cIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN0cmlrZXRocm91Z2hcIjpcIkR1cmNoc3RyZWljaGVuXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5tb25vc3BhY2VcIjpcIk1vbm9zcGFjZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3VwZXJzY3JpcHRcIjpcIkhvY2hnZXN0ZWxsdFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3Vic2NyaXB0XCI6XCJUaWVmZ2VzdGVsbHRcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGl0bGVcIjpcIkxpbmstVGl0ZWxcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGFyZ2V0XCI6XCJMaW5rLVppZWxcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGFyZ2V0T3B0aW9uXCI6XCJMaW5rIGluIG5ldWVtIEZlbnN0ZXIgw7ZmZm5lblwiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtcIjpcIkxpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay51bmxpbmtcIjpcIkF1ZmhlYmVuXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3QubGlzdFwiOlwiTGlzdGVcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC51bm9yZGVyZWRcIjpcIkF1ZnrDpGhsdW5nXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3Qub3JkZXJlZFwiOlwiTnVtbWVyaWVydGUgTGlzdGVcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5pbmRlbnRcIjpcIkVpbnp1ZyB2ZXJncsO2w59lcm5cIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5vdXRkZW50XCI6XCJFaW56dWcgcmVkdXppZXJlblwiLFwiY29tcG9uZW50cy5jb250cm9scy5yZW1vdmUucmVtb3ZlXCI6XCJFbnRmZXJuZW5cIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLnRleHRhbGlnblwiOlwiVGV4dGF1c3JpY2h0dW5nXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5sZWZ0XCI6XCJMaW5rc2LDvG5kaWdcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmNlbnRlclwiOlwiWmVudHJpZXJlblwiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24ucmlnaHRcIjpcIlJlY2h0c2LDvG5kaWdcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmp1c3RpZnlcIjpcIkJsb2Nrc2F0elwifX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17XCJnZW5lcmljLmFkZFwiOlwiVGlsZsO4alwiLFwiZ2VuZXJpYy5jYW5jZWxcIjpcIkFubnVsbGVyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oMVwiOlwiT3ZlcnNrcmlmdCAxXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oMlwiOlwiT3ZlcnNrcmlmdCAyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oM1wiOlwiT3ZlcnNrcmlmdCAzXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNFwiOlwiT3ZlcnNrcmlmdCA0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNVwiOlwiT3ZlcnNrcmlmdCA1XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNlwiOlwiT3ZlcnNrcmlmdCA2XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ibG9ja3F1b3RlXCI6XCJCbG9rY2l0YXRcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmNvZGVcIjpcIktvZGVcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmJsb2NrdHlwZVwiOlwiQmxvayBUeXBlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ub3JtYWxcIjpcIk5vcm1hbFwiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci5jb2xvcnBpY2tlclwiOlwiRmFydmVyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLnRleHRcIjpcIlRla3N0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLmJhY2tncm91bmRcIjpcIkJhZ2dydW5kXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVtYmVkZGVkXCI6XCJJbmRsZWpyZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbWJlZGRlZC5lbWJlZGRlZGxpbmtcIjpcIkluZGxlanJlIExpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW50ZXJsaW5rXCI6XCJJbmR0YXN0IGxpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1vamkuZW1vamlcIjpcIkVtb2ppXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmZvbnRmYW1pbHkuZm9udGZhbWlseVwiOlwiRm9udHR5cGVcIixcImNvbXBvbmVudHMuY29udHJvbHMuZm9udHNpemUuZm9udHNpemVcIjpcIkZvbnRzdMO4cnJlbHNlclwiLFwiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5Lmhpc3RvcnlcIjpcIkhpc3RvcmllXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkudW5kb1wiOlwiRm9ydHJ5ZFwiLFwiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5LnJlZG9cIjpcIkdlbmRhblwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5pbWFnZVwiOlwiQmlsbGVkZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5maWxlVXBsb2FkXCI6XCJGaWxvdmVyZsO4cnNlbFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5ieVVSTFwiOlwiVVJMXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmRyb3BGaWxlVGV4dFwiOlwiRHJvcCBmaWxlbiBlbGxlciBrbGlrIGZvciBhdCB1cGxvYWRlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5ib2xkXCI6XCJGZWRcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLml0YWxpY1wiOlwiS3Vyc2l2XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS51bmRlcmxpbmVcIjpcIlVuZGVyc3RyZWdlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5zdHJpa2V0aHJvdWdoXCI6XCJHZW5uZW1zdHJlZ2V0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5tb25vc3BhY2VcIjpcIk1vbm9zcGFjZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3VwZXJzY3JpcHRcIjpcIkjDpnZldFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3Vic2NyaXB0XCI6XCJTw6Zua2V0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RpdGxlXCI6XCJMaW5rIFRpdGVsXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RhcmdldFwiOlwiTGluayBNw6VsXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RhcmdldE9wdGlvblwiOlwiw4VibiBsaW5rIGkgbnl0IHZpbmR1ZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtcIjpcIkxpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay51bmxpbmtcIjpcIkZqZXJuIGxpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5saXN0XCI6XCJMaXN0ZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0LnVub3JkZXJlZFwiOlwiVW9yZG5ldFwiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lm9yZGVyZWRcIjpcIk9yZG5ldFwiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0LmluZGVudFwiOlwiSW5kcnlrbmluZ1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lm91dGRlbnRcIjpcIlVkcnlrbmluZ1wiLFwiY29tcG9uZW50cy5jb250cm9scy5yZW1vdmUucmVtb3ZlXCI6XCJGamVyblwiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24udGV4dGFsaWduXCI6XCJUZWtzdGp1c3RlcmluZ1wiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24ubGVmdFwiOlwiVmVuc3RyZVwiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24uY2VudGVyXCI6XCJDZW50ZXJcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLnJpZ2h0XCI6XCJIw7hqcmVcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmp1c3RpZnlcIjpcIk1hcmdlbmVyXCJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXtcImdlbmVyaWMuYWRkXCI6XCLmlrDlop5cIixcImdlbmVyaWMuY2FuY2VsXCI6XCLlj5bmtohcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgxXCI6XCLmqJnpoYwxXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oMlwiOlwi5qiZ6aGMMlwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDNcIjpcIuaomemhjDNcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg0XCI6XCLmqJnpoYw0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNVwiOlwi5qiZ6aGMNVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDZcIjpcIuaomemhjDZcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmJsb2NrcXVvdGVcIjpcIuW8leeUqFwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuY29kZVwiOlwi56iL5byP56K8XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ibG9ja3R5cGVcIjpcIuaoo+W8j1wiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUubm9ybWFsXCI6XCLmraPmlodcIixcImNvbXBvbmVudHMuY29udHJvbHMuY29sb3JwaWNrZXIuY29sb3JwaWNrZXJcIjpcIumBuOiJsuWZqFwiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci50ZXh0XCI6XCLmloflrZdcIixcImNvbXBvbmVudHMuY29udHJvbHMuY29sb3JwaWNrZXIuYmFja2dyb3VuZFwiOlwi6IOM5pmvXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVtYmVkZGVkXCI6XCLlhafltYxcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW1iZWRkZWRsaW5rXCI6XCLlhafltYzntrLpoIFcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW50ZXJsaW5rXCI6XCLovLjlhaXntrLpoIHlnLDlnYBcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1vamkuZW1vamlcIjpcIuihqOaDheespuiZn1wiLFwiY29tcG9uZW50cy5jb250cm9scy5mb250ZmFtaWx5LmZvbnRmYW1pbHlcIjpcIuWtl+mrlFwiLFwiY29tcG9uZW50cy5jb250cm9scy5mb250c2l6ZS5mb250c2l6ZVwiOlwi5a2X6auU5aSn5bCPXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkuaGlzdG9yeVwiOlwi5q235Y+y57SA6YyEXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkudW5kb1wiOlwi5b6p5Y6fXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkucmVkb1wiOlwi6YeN5YGaXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmltYWdlXCI6XCLlnJbniYdcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuZmlsZVVwbG9hZFwiOlwi5qqU5qGI5LiK5YKzXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmJ5VVJMXCI6XCLntrLlnYBcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuZHJvcEZpbGVUZXh0XCI6XCLpu57mk4rmiJbmi5bmm7PmqpTmoYjkuIrlgrNcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLmJvbGRcIjpcIueyl+mrlFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuaXRhbGljXCI6XCLmlpzpq5RcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnVuZGVybGluZVwiOlwi5bqV57eaXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5zdHJpa2V0aHJvdWdoXCI6XCLliKrpmaTnt5pcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLm1vbm9zcGFjZVwiOlwi562J5a+s5a2X6auUXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5zdXBlcnNjcmlwdFwiOlwi5LiK5qiZXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5zdWJzY3JpcHRcIjpcIuS4i+aomVwiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtUaXRsZVwiOlwi6LaF6YCj57WQXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RhcmdldFwiOlwi6Ly45YWl6YCj57WQ5L2N5Z2AXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RhcmdldE9wdGlvblwiOlwi5Zyo5paw6KaW56qX5omT6ZaL6YCj57WQXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1wiOlwi6YCj57WQXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsudW5saW5rXCI6XCLliKrpmaTpgKPntZBcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5saXN0XCI6XCLliJfooahcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC51bm9yZGVyZWRcIjpcIumgheebruespuiZn1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lm9yZGVyZWRcIjpcIue3qOiZn1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0LmluZGVudFwiOlwi5aKe5Yqg57iu5o6SXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3Qub3V0ZGVudFwiOlwi5rib5bCR57iu5o6SXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnJlbW92ZS5yZW1vdmVcIjpcIua4hemZpOagvOW8j1wiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24udGV4dGFsaWduXCI6XCLmloflrZflsI3pvYpcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmxlZnRcIjpcIuaWh+Wtl+WQkeW3puWwjem9ilwiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24uY2VudGVyXCI6XCLmloflrZfnva7kuK1cIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLnJpZ2h0XCI6XCLmloflrZflkJHlj7PlsI3pvYpcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmp1c3RpZnlcIjpcIuWFqeerr+Wwjem9ilwifX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17XCJnZW5lcmljLmFkZFwiOlwiRG9kYWpcIixcImdlbmVyaWMuY2FuY2VsXCI6XCJBbnVsdWpcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgxXCI6XCJOYWfFgsOzd2VrIDFcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgyXCI6XCJOYWfFgsOzd2VrIDJcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgzXCI6XCJOYWfFgsOzd2VrIDNcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg0XCI6XCJOYWfFgsOzd2VrIDRcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg1XCI6XCJOYWfFgsOzd2VrIDVcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg2XCI6XCJOYWfFgsOzd2VrIDZcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmJsb2NrcXVvdGVcIjpcIkN5dGF0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5jb2RlXCI6XCJLb2RcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmJsb2NrdHlwZVwiOlwiRm9ybWF0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ub3JtYWxcIjpcIk5vcm1hbG55XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLmNvbG9ycGlja2VyXCI6XCJLb2xvclwiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci50ZXh0XCI6XCJUZWtzdFwiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci5iYWNrZ3JvdW5kXCI6XCJUxYJvXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVtYmVkZGVkXCI6XCJPc2FkxbpcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW1iZWRkZWRsaW5rXCI6XCJPc2Fkxbogb2Rub8WbbmlrXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVudGVybGlua1wiOlwiV3Byb3dhZMW6IG9kbm/Fm25pa1wiLFwiY29tcG9uZW50cy5jb250cm9scy5lbW9qaS5lbW9qaVwiOlwiRW1vamlcIixcImNvbXBvbmVudHMuY29udHJvbHMuZm9udGZhbWlseS5mb250ZmFtaWx5XCI6XCJLcsOzaiBjemNpb25raVwiLFwiY29tcG9uZW50cy5jb250cm9scy5mb250c2l6ZS5mb250c2l6ZVwiOlwiUm96bWlhciBjemNpb25raVwiLFwiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5Lmhpc3RvcnlcIjpcIkhpc3RvcmlhXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkudW5kb1wiOlwiQ29mbmlqXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmhpc3RvcnkucmVkb1wiOlwiUG9uw7N3XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmltYWdlXCI6XCJPYnJhemVrXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmZpbGVVcGxvYWRcIjpcIlByemXFm2xpaiBwbGlrXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmJ5VVJMXCI6XCJVUkxcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuZHJvcEZpbGVUZXh0XCI6XCJVcHXFm8SHIHBsaWsgbHViIGtsaWtuaWosIGFieSBwcnplc8WCYcSHXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5ib2xkXCI6XCJQb2dydWJpZW5pZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuaXRhbGljXCI6XCJLdXJzeXdhXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS51bmRlcmxpbmVcIjpcIlBvZGtyZcWbbGVuaWVcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN0cmlrZXRocm91Z2hcIjpcIlByemVrcmXFm2xlbmllXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5tb25vc3BhY2VcIjpcIk1vbm9zcGFjZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3VwZXJzY3JpcHRcIjpcIkluZGVrcyBnw7NybnlcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN1YnNjcmlwdFwiOlwiSW5kZWtzIGRvbG55XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RpdGxlXCI6XCJUeXR1xYIgb2Rub8WbbmlrYVwiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtUYXJnZXRcIjpcIkFkcmVzIG9kbm/Fm25pa2FcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGFyZ2V0T3B0aW9uXCI6XCJPdHfDs3J6IG9kbm/Fm25payB3IG5vd2VqIGthcmNpZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtcIjpcIldzdGF3IG9kbm/Fm25pa1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLnVubGlua1wiOlwiVXN1xYQgb2Rub8WbbmlrXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3QubGlzdFwiOlwiTGlzdGFcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC51bm9yZGVyZWRcIjpcIkxpc3RhIG5pZXVwb3J6xIVka293YW5hXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3Qub3JkZXJlZFwiOlwiTGlzdGEgdXBvcnrEhWRrb3dhbmFcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5pbmRlbnRcIjpcIlp3acSZa3N6IHdjacSZY2llXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3Qub3V0ZGVudFwiOlwiWm1uaWVqc3ogd2NpxJljaWVcIixcImNvbXBvbmVudHMuY29udHJvbHMucmVtb3ZlLnJlbW92ZVwiOlwiVXN1xYRcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLnRleHRhbGlnblwiOlwiV3lyw7N3bmFqIHRla3N0XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5sZWZ0XCI6XCJEbyBsZXdlalwiLFwiY29tcG9uZW50cy5jb250cm9scy50ZXh0YWxpZ24uY2VudGVyXCI6XCJEbyDFm3JvZGthXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5yaWdodFwiOlwiRG8gcHJhd2VqXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5qdXN0aWZ5XCI6XCJXeWp1c3R1alwifX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17XCJnZW5lcmljLmFkZFwiOlwiQcOxYWRpclwiLFwiZ2VuZXJpYy5jYW5jZWxcIjpcIkNhbmNlbGFyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oMVwiOlwiSDFcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgyXCI6XCJIMlwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDNcIjpcIkgzXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNFwiOlwiSDRcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg1XCI6XCJINVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDZcIjpcIkg2XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ibG9ja3F1b3RlXCI6XCJCbG9ja3F1b3RlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5jb2RlXCI6XCJDw7NkaWdvXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ibG9ja3R5cGVcIjpcIlRpcG8gZGUgYmxvcXVlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ub3JtYWxcIjpcIk5vcm1hbFwiLFwiY29tcG9uZW50cy5jb250cm9scy5jb2xvcnBpY2tlci5jb2xvcnBpY2tlclwiOlwiU2VsZWNjaW9uYXIgY29sb3JcIixcImNvbXBvbmVudHMuY29udHJvbHMuY29sb3JwaWNrZXIudGV4dFwiOlwiVGV4dG9cIixcImNvbXBvbmVudHMuY29udHJvbHMuY29sb3JwaWNrZXIuYmFja2dyb3VuZFwiOlwiU3VicmF5YWRvXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVtYmVkZGVkXCI6XCJBZGp1bnRhclwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbWJlZGRlZC5lbWJlZGRlZGxpbmtcIjpcIkFkanVudGFyIExpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1iZWRkZWQuZW50ZXJsaW5rXCI6XCJJbnRyb2R1Y2lyIGxpbmtcIixcImNvbXBvbmVudHMuY29udHJvbHMuZW1vamkuZW1vamlcIjpcIkVtb2ppXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmZvbnRmYW1pbHkuZm9udGZhbWlseVwiOlwiRnVlbnRlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmZvbnRzaXplLmZvbnRzaXplXCI6XCJUYW1hw7FvIGRlIGZ1ZW50ZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5Lmhpc3RvcnlcIjpcIkhpc3TDs3JpY29cIixcImNvbXBvbmVudHMuY29udHJvbHMuaGlzdG9yeS51bmRvXCI6XCJEZXNoYWNlclwiLFwiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5LnJlZG9cIjpcIlJlaGFjZXJcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuaW1hZ2VcIjpcIkltYWdlblwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5maWxlVXBsb2FkXCI6XCJTdWJpciBhcmNoaXZvXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmJ5VVJMXCI6XCJVUkxcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW1hZ2UuZHJvcEZpbGVUZXh0XCI6XCJBcnJhc3RyYSBlbCBhcmNoaXZvIG8gaGF6IGNsaWNrIHBhcmEgc3ViaXJsb1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuYm9sZFwiOlwiTmVncml0YVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuaXRhbGljXCI6XCJDdXJzaXZhXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS51bmRlcmxpbmVcIjpcIlN1YnJheWFkb1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3RyaWtldGhyb3VnaFwiOlwiVGFjaGFkb1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUubW9ub3NwYWNlXCI6XCJNb25vc3BhY2VcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN1cGVyc2NyaXB0XCI6XCJTb2JyZcOtbmRpY2VcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLnN1YnNjcmlwdFwiOlwiU3Viw61uZGljZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtUaXRsZVwiOlwiVMOtdHVsbyBkZWwgZW5sYWNlXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsubGlua1RhcmdldFwiOlwiT2JqZXRpdm8gZGVsIGVubGFjZVwiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtUYXJnZXRPcHRpb25cIjpcIkFicmlyIGVuIG51ZXZhIHZlbnRhbmFcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rXCI6XCJFbmxhemFyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpbmsudW5saW5rXCI6XCJEZXNlbmxhemFyXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3QubGlzdFwiOlwiTGlzdGFcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC51bm9yZGVyZWRcIjpcIkRlc29yZGVuYWRhXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3Qub3JkZXJlZFwiOlwiT3JkZW5hZGFcIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5pbmRlbnRcIjpcIkluZGVudGFkYVwiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lm91dGRlbnRcIjpcIkRlbnRhZGFcIixcImNvbXBvbmVudHMuY29udHJvbHMucmVtb3ZlLnJlbW92ZVwiOlwiRWxpbWluYXJcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLnRleHRhbGlnblwiOlwiQWxpbmVhY2nDs24gZGVsIHRleHRvXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5sZWZ0XCI6XCJJenF1aWVyZGFcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmNlbnRlclwiOlwiQ2VudHJhZG9cIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLnJpZ2h0XCI6XCJEZXJlY2hhXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5qdXN0aWZ5XCI6XCJKdXN0aWZpY2Fkb1wifX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17XCJnZW5lcmljLmFkZFwiOlwi6L+95YqgXCIsXCJnZW5lcmljLmNhbmNlbFwiOlwi44Kt44Oj44Oz44K744OrXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oMVwiOlwi6KaL5Ye644GXMVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDJcIjpcIuimi+WHuuOBlzJcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmgzXCI6XCLopovlh7rjgZczXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5oNFwiOlwi6KaL5Ye644GXNFwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuaDVcIjpcIuimi+WHuuOBlzVcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmg2XCI6XCLopovlh7rjgZc2XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmJsb2NrdHlwZS5ibG9ja3F1b3RlXCI6XCLlvJXnlKhcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLmNvZGVcIjpcIuOCs+ODvOODiVwiLFwiY29tcG9uZW50cy5jb250cm9scy5ibG9ja3R5cGUuYmxvY2t0eXBlXCI6XCLjgrnjgr/jgqTjg6tcIixcImNvbXBvbmVudHMuY29udHJvbHMuYmxvY2t0eXBlLm5vcm1hbFwiOlwi5qiZ5rqW44OG44Kt44K544OIXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLmNvbG9ycGlja2VyXCI6XCLjg4bjgq3jgrnjg4jjga7oibJcIixcImNvbXBvbmVudHMuY29udHJvbHMuY29sb3JwaWNrZXIudGV4dFwiOlwi44OG44Kt44K544OIXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmNvbG9ycGlja2VyLmJhY2tncm91bmRcIjpcIuODj+OCpOODqeOCpOODiFwiLFwiY29tcG9uZW50cy5jb250cm9scy5lbWJlZGRlZC5lbWJlZGRlZFwiOlwi5Z+L44KB6L6844G/XCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVtYmVkZGVkbGlua1wiOlwi5Z+L44KB6L6844G/44Oq44Oz44KvXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtYmVkZGVkLmVudGVybGlua1wiOlwi44Oq44Oz44Kv44KS5YWl5Yqb44GX44Gm44GP44Gg44GV44GEXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmVtb2ppLmVtb2ppXCI6XCLntbXmloflrZdcIixcImNvbXBvbmVudHMuY29udHJvbHMuZm9udGZhbWlseS5mb250ZmFtaWx5XCI6XCLjg5Xjgqnjg7Pjg4hcIixcImNvbXBvbmVudHMuY29udHJvbHMuZm9udHNpemUuZm9udHNpemVcIjpcIuODleOCqeODs+ODiOOCteOCpOOCulwiLFwiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5Lmhpc3RvcnlcIjpcIuWxpeattFwiLFwiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5LnVuZG9cIjpcIuWFg+OBq+aIu+OBmVwiLFwiY29tcG9uZW50cy5jb250cm9scy5oaXN0b3J5LnJlZG9cIjpcIuOChOOCiuebtOOBl1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5pbWFnZVwiOlwi55S75YOPXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmZpbGVVcGxvYWRcIjpcIuODleOCoeOCpOODq+OCkuOCouODg+ODl+ODreODvOODiVwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbWFnZS5ieVVSTFwiOlwiVVJMXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmltYWdlLmRyb3BGaWxlVGV4dFwiOlwi44GT44GT44Gr55S75YOP44KS44OJ44Op44OD44Kw44GZ44KL44GL44CB44Kv44Oq44OD44Kv44GX44Gm44GP44Gg44GV44GEXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5ib2xkXCI6XCLlpKrlrZdcIixcImNvbXBvbmVudHMuY29udHJvbHMuaW5saW5lLml0YWxpY1wiOlwi5pac5L2TXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS51bmRlcmxpbmVcIjpcIuS4i+e3mlwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3RyaWtldGhyb3VnaFwiOlwi5Y+W44KK5raI44GX57eaXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmlubGluZS5tb25vc3BhY2VcIjpcIuetieW5heODleOCqeODs+ODiFwiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3VwZXJzY3JpcHRcIjpcIuS4iuS7mOOBjeaWh+Wtl1wiLFwiY29tcG9uZW50cy5jb250cm9scy5pbmxpbmUuc3Vic2NyaXB0XCI6XCLkuIvku5jjgY3mloflrZdcIixcImNvbXBvbmVudHMuY29udHJvbHMubGluay5saW5rVGl0bGVcIjpcIuODquODs+OCr+OCv+OCpOODiOODq1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtUYXJnZXRcIjpcIuODquODs+OCr+WvvuixoVwiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtUYXJnZXRPcHRpb25cIjpcIuaWsOOBl+OBhOOCpuOCo+ODs+ODieOCpuOBp+mWi+OBj1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLmxpbmtcIjpcIuODquODs+OCr1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saW5rLnVubGlua1wiOlwi44Oq44Oz44Kv44KS6Kej6ZmkXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3QubGlzdFwiOlwi44Oq44K544OIXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLmxpc3QudW5vcmRlcmVkXCI6XCLnrofmnaHmm7jjgY1cIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5vcmRlcmVkXCI6XCLnlarlj7fku5jjgY1cIixcImNvbXBvbmVudHMuY29udHJvbHMubGlzdC5pbmRlbnRcIjpcIuOCpOODs+ODh+ODs+ODiOWil1wiLFwiY29tcG9uZW50cy5jb250cm9scy5saXN0Lm91dGRlbnRcIjpcIuOCpOODs+ODh+ODs+ODiOa4m1wiLFwiY29tcG9uZW50cy5jb250cm9scy5yZW1vdmUucmVtb3ZlXCI6XCLmm7jlvI/jgpLjgq/jg6rjgqJcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLnRleHRhbGlnblwiOlwi5pW05YiXXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5sZWZ0XCI6XCLlt6bmj4PjgYhcIixcImNvbXBvbmVudHMuY29udHJvbHMudGV4dGFsaWduLmNlbnRlclwiOlwi5Lit5aSu5o+D44GIXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5yaWdodFwiOlwi5Y+z5o+D44GIXCIsXCJjb21wb25lbnRzLmNvbnRyb2xzLnRleHRhbGlnbi5qdXN0aWZ5XCI6XCLkuKHnq6/mj4PjgYhcIn19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXtcInJkdy1lZGl0b3ItbWFpblwiOlwicmR3LWVkaXRvci1tYWluXCIsXCJyZHctZWRpdG9yLXRvb2xiYXJcIjpcInJkdy1lZGl0b3ItdG9vbGJhclwiLFwicHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWJsb2NrXCI6XCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtYmxvY2tcIixcInJkdy1lZGl0b3Itd3JhcHBlclwiOlwicmR3LWVkaXRvci13cmFwcGVyXCJ9fSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz17XCJEcmFmdEVkaXRvci1lZGl0b3JDb250YWluZXJcIjpcIkRyYWZ0RWRpdG9yLWVkaXRvckNvbnRhaW5lclwiLFwiRHJhZnRFZGl0b3Itcm9vdFwiOlwiRHJhZnRFZGl0b3Itcm9vdFwiLFwicHVibGljLURyYWZ0RWRpdG9yLWNvbnRlbnRcIjpcInB1YmxpYy1EcmFmdEVkaXRvci1jb250ZW50XCIsXCJwdWJsaWMtRHJhZnRFZGl0b3ItYmxvY2tcIjpcInB1YmxpYy1EcmFmdEVkaXRvci1ibG9ja1wiLFwiRHJhZnRFZGl0b3ItYWxpZ25MZWZ0XCI6XCJEcmFmdEVkaXRvci1hbGlnbkxlZnRcIixcInB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1ibG9ja1wiOlwicHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWJsb2NrXCIsXCJwdWJsaWMtRHJhZnRFZGl0b3JQbGFjZWhvbGRlci1yb290XCI6XCJwdWJsaWMtRHJhZnRFZGl0b3JQbGFjZWhvbGRlci1yb290XCIsXCJEcmFmdEVkaXRvci1hbGlnbkNlbnRlclwiOlwiRHJhZnRFZGl0b3ItYWxpZ25DZW50ZXJcIixcIkRyYWZ0RWRpdG9yLWFsaWduUmlnaHRcIjpcIkRyYWZ0RWRpdG9yLWFsaWduUmlnaHRcIixcInB1YmxpYy1EcmFmdEVkaXRvclBsYWNlaG9sZGVyLWhhc0ZvY3VzXCI6XCJwdWJsaWMtRHJhZnRFZGl0b3JQbGFjZWhvbGRlci1oYXNGb2N1c1wiLFwiRHJhZnRFZGl0b3JQbGFjZWhvbGRlci1oaWRkZW5cIjpcIkRyYWZ0RWRpdG9yUGxhY2Vob2xkZXItaGlkZGVuXCIsXCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtbHRyXCI6XCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtbHRyXCIsXCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtcnRsXCI6XCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtcnRsXCIsXCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtbGlzdExUUlwiOlwicHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWxpc3RMVFJcIixcInB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1saXN0UlRMXCI6XCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtbGlzdFJUTFwiLFwicHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LW9sXCI6XCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtb2xcIixcInB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC11bFwiOlwicHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LXVsXCIsXCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGgwXCI6XCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGgwXCIsXCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGgxXCI6XCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGgxXCIsXCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGgyXCI6XCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGgyXCIsXCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGgzXCI6XCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGgzXCIsXCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGg0XCI6XCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGg0XCIsXCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtdW5vcmRlcmVkTGlzdEl0ZW1cIjpcInB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC11bm9yZGVyZWRMaXN0SXRlbVwiLFwicHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LW9yZGVyZWRMaXN0SXRlbVwiOlwicHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LW9yZGVyZWRMaXN0SXRlbVwiLFwicHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LXJlc2V0XCI6XCJwdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtcmVzZXRcIn19XSl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFmdC13eXNpd3lnL2Rpc3QvcmVhY3QtZHJhZnQtd3lzaXd5Zy5qc1xuLy8gbW9kdWxlIGlkID0gNDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwuSW1tdXRhYmxlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7dmFyIFNMSUNFJDAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3MoY3Rvciwgc3VwZXJDbGFzcykge1xuICAgIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgIH1cbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBJdGVyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSXRlcmFibGUodmFsdWUpID8gdmFsdWUgOiBTZXEodmFsdWUpO1xuICAgIH1cblxuXG4gIGNyZWF0ZUNsYXNzKEtleWVkSXRlcmFibGUsIEl0ZXJhYmxlKTtcbiAgICBmdW5jdGlvbiBLZXllZEl0ZXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZSA6IEtleWVkU2VxKHZhbHVlKTtcbiAgICB9XG5cblxuICBjcmVhdGVDbGFzcyhJbmRleGVkSXRlcmFibGUsIEl0ZXJhYmxlKTtcbiAgICBmdW5jdGlvbiBJbmRleGVkSXRlcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0luZGV4ZWQodmFsdWUpID8gdmFsdWUgOiBJbmRleGVkU2VxKHZhbHVlKTtcbiAgICB9XG5cblxuICBjcmVhdGVDbGFzcyhTZXRJdGVyYWJsZSwgSXRlcmFibGUpO1xuICAgIGZ1bmN0aW9uIFNldEl0ZXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJdGVyYWJsZSh2YWx1ZSkgJiYgIWlzQXNzb2NpYXRpdmUodmFsdWUpID8gdmFsdWUgOiBTZXRTZXEodmFsdWUpO1xuICAgIH1cblxuXG5cbiAgZnVuY3Rpb24gaXNJdGVyYWJsZShtYXliZUl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuICEhKG1heWJlSXRlcmFibGUgJiYgbWF5YmVJdGVyYWJsZVtJU19JVEVSQUJMRV9TRU5USU5FTF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNLZXllZChtYXliZUtleWVkKSB7XG4gICAgcmV0dXJuICEhKG1heWJlS2V5ZWQgJiYgbWF5YmVLZXllZFtJU19LRVlFRF9TRU5USU5FTF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJbmRleGVkKG1heWJlSW5kZXhlZCkge1xuICAgIHJldHVybiAhIShtYXliZUluZGV4ZWQgJiYgbWF5YmVJbmRleGVkW0lTX0lOREVYRURfU0VOVElORUxdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXNzb2NpYXRpdmUobWF5YmVBc3NvY2lhdGl2ZSkge1xuICAgIHJldHVybiBpc0tleWVkKG1heWJlQXNzb2NpYXRpdmUpIHx8IGlzSW5kZXhlZChtYXliZUFzc29jaWF0aXZlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT3JkZXJlZChtYXliZU9yZGVyZWQpIHtcbiAgICByZXR1cm4gISEobWF5YmVPcmRlcmVkICYmIG1heWJlT3JkZXJlZFtJU19PUkRFUkVEX1NFTlRJTkVMXSk7XG4gIH1cblxuICBJdGVyYWJsZS5pc0l0ZXJhYmxlID0gaXNJdGVyYWJsZTtcbiAgSXRlcmFibGUuaXNLZXllZCA9IGlzS2V5ZWQ7XG4gIEl0ZXJhYmxlLmlzSW5kZXhlZCA9IGlzSW5kZXhlZDtcbiAgSXRlcmFibGUuaXNBc3NvY2lhdGl2ZSA9IGlzQXNzb2NpYXRpdmU7XG4gIEl0ZXJhYmxlLmlzT3JkZXJlZCA9IGlzT3JkZXJlZDtcblxuICBJdGVyYWJsZS5LZXllZCA9IEtleWVkSXRlcmFibGU7XG4gIEl0ZXJhYmxlLkluZGV4ZWQgPSBJbmRleGVkSXRlcmFibGU7XG4gIEl0ZXJhYmxlLlNldCA9IFNldEl0ZXJhYmxlO1xuXG5cbiAgdmFyIElTX0lURVJBQkxFX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfSVRFUkFCTEVfX0BAJztcbiAgdmFyIElTX0tFWUVEX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfS0VZRURfX0BAJztcbiAgdmFyIElTX0lOREVYRURfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9JTkRFWEVEX19AQCc7XG4gIHZhciBJU19PUkRFUkVEX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfT1JERVJFRF9fQEAnO1xuXG4gIC8vIFVzZWQgZm9yIHNldHRpbmcgcHJvdG90eXBlIG1ldGhvZHMgdGhhdCBJRTggY2hva2VzIG9uLlxuICB2YXIgREVMRVRFID0gJ2RlbGV0ZSc7XG5cbiAgLy8gQ29uc3RhbnRzIGRlc2NyaWJpbmcgdGhlIHNpemUgb2YgdHJpZSBub2Rlcy5cbiAgdmFyIFNISUZUID0gNTsgLy8gUmVzdWx0ZWQgaW4gYmVzdCBwZXJmb3JtYW5jZSBhZnRlciBfX19fX18/XG4gIHZhciBTSVpFID0gMSA8PCBTSElGVDtcbiAgdmFyIE1BU0sgPSBTSVpFIC0gMTtcblxuICAvLyBBIGNvbnNpc3RlbnQgc2hhcmVkIHZhbHVlIHJlcHJlc2VudGluZyBcIm5vdCBzZXRcIiB3aGljaCBlcXVhbHMgbm90aGluZyBvdGhlclxuICAvLyB0aGFuIGl0c2VsZiwgYW5kIG5vdGhpbmcgdGhhdCBjb3VsZCBiZSBwcm92aWRlZCBleHRlcm5hbGx5LlxuICB2YXIgTk9UX1NFVCA9IHt9O1xuXG4gIC8vIEJvb2xlYW4gcmVmZXJlbmNlcywgUm91Z2ggZXF1aXZhbGVudCBvZiBgYm9vbCAmYC5cbiAgdmFyIENIQU5HRV9MRU5HVEggPSB7IHZhbHVlOiBmYWxzZSB9O1xuICB2YXIgRElEX0FMVEVSID0geyB2YWx1ZTogZmFsc2UgfTtcblxuICBmdW5jdGlvbiBNYWtlUmVmKHJlZikge1xuICAgIHJlZi52YWx1ZSA9IGZhbHNlO1xuICAgIHJldHVybiByZWY7XG4gIH1cblxuICBmdW5jdGlvbiBTZXRSZWYocmVmKSB7XG4gICAgcmVmICYmIChyZWYudmFsdWUgPSB0cnVlKTtcbiAgfVxuXG4gIC8vIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIHZhbHVlIHJlcHJlc2VudGluZyBhbiBcIm93bmVyXCIgZm9yIHRyYW5zaWVudCB3cml0ZXNcbiAgLy8gdG8gdHJpZXMuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBvbmx5IGV2ZXIgZXF1YWwgaXRzZWxmLCBhbmQgd2lsbCBub3QgZXF1YWxcbiAgLy8gdGhlIHJldHVybiBvZiBhbnkgc3Vic2VxdWVudCBjYWxsIG9mIHRoaXMgZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIE93bmVySUQoKSB7fVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2NvcHktYXJyYXktaW5saW5lXG4gIGZ1bmN0aW9uIGFyckNvcHkoYXJyLCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgYXJyLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgdmFyIG5ld0FyciA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICAgIG5ld0FycltpaV0gPSBhcnJbaWkgKyBvZmZzZXRdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlU2l6ZShpdGVyKSB7XG4gICAgaWYgKGl0ZXIuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVyLnNpemUgPSBpdGVyLl9faXRlcmF0ZShyZXR1cm5UcnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXIuc2l6ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBJbmRleChpdGVyLCBpbmRleCkge1xuICAgIC8vIFRoaXMgaW1wbGVtZW50cyBcImlzIGFycmF5IGluZGV4XCIgd2hpY2ggdGhlIEVDTUFTdHJpbmcgc3BlYyBkZWZpbmVzIGFzOlxuICAgIC8vXG4gICAgLy8gICAgIEEgU3RyaW5nIHByb3BlcnR5IG5hbWUgUCBpcyBhbiBhcnJheSBpbmRleCBpZiBhbmQgb25seSBpZlxuICAgIC8vICAgICBUb1N0cmluZyhUb1VpbnQzMihQKSkgaXMgZXF1YWwgdG8gUCBhbmQgVG9VaW50MzIoUCkgaXMgbm90IGVxdWFsXG4gICAgLy8gICAgIHRvIDJeMzLiiJIxLlxuICAgIC8vXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWFycmF5LWV4b3RpYy1vYmplY3RzXG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB1aW50MzJJbmRleCA9IGluZGV4ID4+PiAwOyAvLyBOID4+PiAwIGlzIHNob3J0aGFuZCBmb3IgVG9VaW50MzJcbiAgICAgIGlmICgnJyArIHVpbnQzMkluZGV4ICE9PSBpbmRleCB8fCB1aW50MzJJbmRleCA9PT0gNDI5NDk2NzI5NSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuICAgICAgaW5kZXggPSB1aW50MzJJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IGVuc3VyZVNpemUoaXRlcikgKyBpbmRleCA6IGluZGV4O1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkge1xuICAgIHJldHVybiAoYmVnaW4gPT09IDAgfHwgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBiZWdpbiA8PSAtc2l6ZSkpICYmXG4gICAgICAoZW5kID09PSB1bmRlZmluZWQgfHwgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBlbmQgPj0gc2l6ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKSB7XG4gICAgcmV0dXJuIHJlc29sdmVJbmRleChiZWdpbiwgc2l6ZSwgMCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlRW5kKGVuZCwgc2l6ZSkge1xuICAgIHJldHVybiByZXNvbHZlSW5kZXgoZW5kLCBzaXplLCBzaXplKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVJbmRleChpbmRleCwgc2l6ZSwgZGVmYXVsdEluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgP1xuICAgICAgZGVmYXVsdEluZGV4IDpcbiAgICAgIGluZGV4IDwgMCA/XG4gICAgICAgIE1hdGgubWF4KDAsIHNpemUgKyBpbmRleCkgOlxuICAgICAgICBzaXplID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgIGluZGV4IDpcbiAgICAgICAgICBNYXRoLm1pbihzaXplLCBpbmRleCk7XG4gIH1cblxuICAvKiBnbG9iYWwgU3ltYm9sICovXG5cbiAgdmFyIElURVJBVEVfS0VZUyA9IDA7XG4gIHZhciBJVEVSQVRFX1ZBTFVFUyA9IDE7XG4gIHZhciBJVEVSQVRFX0VOVFJJRVMgPSAyO1xuXG4gIHZhciBSRUFMX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IFJFQUxfSVRFUkFUT1JfU1lNQk9MIHx8IEZBVVhfSVRFUkFUT1JfU1lNQk9MO1xuXG5cbiAgZnVuY3Rpb24gSXRlcmF0b3IobmV4dCkge1xuICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICB9XG5cbiAgICBJdGVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnW0l0ZXJhdG9yXSc7XG4gICAgfTtcblxuXG4gIEl0ZXJhdG9yLktFWVMgPSBJVEVSQVRFX0tFWVM7XG4gIEl0ZXJhdG9yLlZBTFVFUyA9IElURVJBVEVfVkFMVUVTO1xuICBJdGVyYXRvci5FTlRSSUVTID0gSVRFUkFURV9FTlRSSUVTO1xuXG4gIEl0ZXJhdG9yLnByb3RvdHlwZS5pbnNwZWN0ID1cbiAgSXRlcmF0b3IucHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50b1N0cmluZygpOyB9XG4gIEl0ZXJhdG9yLnByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgZnVuY3Rpb24gaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBpdGVyYXRvclJlc3VsdCkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGUgPT09IDAgPyBrIDogdHlwZSA9PT0gMSA/IHYgOiBbaywgdl07XG4gICAgaXRlcmF0b3JSZXN1bHQgPyAoaXRlcmF0b3JSZXN1bHQudmFsdWUgPSB2YWx1ZSkgOiAoaXRlcmF0b3JSZXN1bHQgPSB7XG4gICAgICB2YWx1ZTogdmFsdWUsIGRvbmU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yUmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0b3JEb25lKCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0l0ZXJhdG9yKG1heWJlSXRlcmFibGUpIHtcbiAgICByZXR1cm4gISFnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJdGVyYXRvcihtYXliZUl0ZXJhdG9yKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3IgJiYgdHlwZW9mIG1heWJlSXRlcmF0b3IubmV4dCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGl0ZXJhYmxlKTtcbiAgICByZXR1cm4gaXRlcmF0b3JGbiAmJiBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihpdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gaXRlcmFibGUgJiYgKFxuICAgICAgKFJFQUxfSVRFUkFUT1JfU1lNQk9MICYmIGl0ZXJhYmxlW1JFQUxfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgIGl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXVxuICAgICk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJztcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFNlcSwgSXRlcmFibGUpO1xuICAgIGZ1bmN0aW9uIFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eVNlcXVlbmNlKCkgOlxuICAgICAgICBpc0l0ZXJhYmxlKHZhbHVlKSA/IHZhbHVlLnRvU2VxKCkgOiBzZXFGcm9tVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIFNlcS5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiBTZXEoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU2VxLnByb3RvdHlwZS50b1NlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFNlcS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NlcSB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgU2VxLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9jYWNoZSAmJiB0aGlzLl9faXRlcmF0ZVVuY2FjaGVkKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gdGhpcy5lbnRyeVNlcSgpLnRvQXJyYXkoKTtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5fY2FjaGUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIGFic3RyYWN0IF9faXRlcmF0ZVVuY2FjaGVkKGZuLCByZXZlcnNlKVxuXG4gICAgU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHNlcUl0ZXJhdGUodGhpcywgZm4sIHJldmVyc2UsIHRydWUpO1xuICAgIH07XG5cbiAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdG9yVW5jYWNoZWQodHlwZSwgcmV2ZXJzZSlcblxuICAgIFNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBzZXFJdGVyYXRvcih0aGlzLCB0eXBlLCByZXZlcnNlLCB0cnVlKTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhLZXllZFNlcSwgU2VxKTtcbiAgICBmdW5jdGlvbiBLZXllZFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgP1xuICAgICAgICBlbXB0eVNlcXVlbmNlKCkudG9LZXllZFNlcSgpIDpcbiAgICAgICAgaXNJdGVyYWJsZSh2YWx1ZSkgP1xuICAgICAgICAgIChpc0tleWVkKHZhbHVlKSA/IHZhbHVlLnRvU2VxKCkgOiB2YWx1ZS5mcm9tRW50cnlTZXEoKSkgOlxuICAgICAgICAgIGtleWVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBLZXllZFNlcS5wcm90b3R5cGUudG9LZXllZFNlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuXG5cbiAgY3JlYXRlQ2xhc3MoSW5kZXhlZFNlcSwgU2VxKTtcbiAgICBmdW5jdGlvbiBJbmRleGVkU2VxKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5U2VxdWVuY2UoKSA6XG4gICAgICAgICFpc0l0ZXJhYmxlKHZhbHVlKSA/IGluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIDpcbiAgICAgICAgaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZS5lbnRyeVNlcSgpIDogdmFsdWUudG9JbmRleGVkU2VxKCk7XG4gICAgfVxuXG4gICAgSW5kZXhlZFNlcS5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiBJbmRleGVkU2VxKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvSW5kZXhlZFNlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXEgWycsICddJyk7XG4gICAgfTtcblxuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gc2VxSXRlcmF0ZSh0aGlzLCBmbiwgcmV2ZXJzZSwgZmFsc2UpO1xuICAgIH07XG5cbiAgICBJbmRleGVkU2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHNlcUl0ZXJhdG9yKHRoaXMsIHR5cGUsIHJldmVyc2UsIGZhbHNlKTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhTZXRTZXEsIFNlcSk7XG4gICAgZnVuY3Rpb24gU2V0U2VxKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlTZXF1ZW5jZSgpIDpcbiAgICAgICAgIWlzSXRlcmFibGUodmFsdWUpID8gaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkgOlxuICAgICAgICBpc0tleWVkKHZhbHVlKSA/IHZhbHVlLmVudHJ5U2VxKCkgOiB2YWx1ZVxuICAgICAgKS50b1NldFNlcSgpO1xuICAgIH1cblxuICAgIFNldFNlcS5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiBTZXRTZXEoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU2V0U2VxLnByb3RvdHlwZS50b1NldFNlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuXG5cbiAgU2VxLmlzU2VxID0gaXNTZXE7XG4gIFNlcS5LZXllZCA9IEtleWVkU2VxO1xuICBTZXEuU2V0ID0gU2V0U2VxO1xuICBTZXEuSW5kZXhlZCA9IEluZGV4ZWRTZXE7XG5cbiAgdmFyIElTX1NFUV9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX1NFUV9fQEAnO1xuXG4gIFNlcS5wcm90b3R5cGVbSVNfU0VRX1NFTlRJTkVMXSA9IHRydWU7XG5cblxuXG4gIGNyZWF0ZUNsYXNzKEFycmF5U2VxLCBJbmRleGVkU2VxKTtcbiAgICBmdW5jdGlvbiBBcnJheVNlcShhcnJheSkge1xuICAgICAgdGhpcy5fYXJyYXkgPSBhcnJheTtcbiAgICAgIHRoaXMuc2l6ZSA9IGFycmF5Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBBcnJheVNlcS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpID8gdGhpcy5fYXJyYXlbd3JhcEluZGV4KHRoaXMsIGluZGV4KV0gOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgQXJyYXlTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcbiAgICAgIHZhciBtYXhJbmRleCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICAgIGlmIChmbihhcnJheVtyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXSwgaWksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBpaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpaTtcbiAgICB9O1xuXG4gICAgQXJyYXlTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcbiAgICAgIHZhciBtYXhJbmRleCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpIFxuICAgICAgICB7cmV0dXJuIGlpID4gbWF4SW5kZXggP1xuICAgICAgICAgIGl0ZXJhdG9yRG9uZSgpIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGlpLCBhcnJheVtyZXZlcnNlID8gbWF4SW5kZXggLSBpaSsrIDogaWkrK10pfVxuICAgICAgKTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhPYmplY3RTZXEsIEtleWVkU2VxKTtcbiAgICBmdW5jdGlvbiBPYmplY3RTZXEob2JqZWN0KSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICB0aGlzLl9vYmplY3QgPSBvYmplY3Q7XG4gICAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICAgIHRoaXMuc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgIH1cblxuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaWYgKG5vdFNldFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFtrZXldO1xuICAgIH07XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgIH07XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5fb2JqZWN0O1xuICAgICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICAgICAgdmFyIG1heEluZGV4ID0ga2V5cy5sZW5ndGggLSAxO1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcbiAgICAgICAgaWYgKGZuKG9iamVjdFtrZXldLCBrZXksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBpaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpaTtcbiAgICB9O1xuXG4gICAgT2JqZWN0U2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMuX29iamVjdDtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcbiAgICAgIHZhciBtYXhJbmRleCA9IGtleXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBpaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV07XG4gICAgICAgIHJldHVybiBpaSsrID4gbWF4SW5kZXggP1xuICAgICAgICAgIGl0ZXJhdG9yRG9uZSgpIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGtleSwgb2JqZWN0W2tleV0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICBPYmplY3RTZXEucHJvdG90eXBlW0lTX09SREVSRURfU0VOVElORUxdID0gdHJ1ZTtcblxuXG4gIGNyZWF0ZUNsYXNzKEl0ZXJhYmxlU2VxLCBJbmRleGVkU2VxKTtcbiAgICBmdW5jdGlvbiBJdGVyYWJsZVNlcShpdGVyYWJsZSkge1xuICAgICAgdGhpcy5faXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICAgIHRoaXMuc2l6ZSA9IGl0ZXJhYmxlLmxlbmd0aCB8fCBpdGVyYWJsZS5zaXplO1xuICAgIH1cblxuICAgIEl0ZXJhYmxlU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLl9pdGVyYWJsZTtcbiAgICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGlmIChpc0l0ZXJhdG9yKGl0ZXJhdG9yKSkge1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChmbihzdGVwLnZhbHVlLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgSXRlcmFibGVTZXEucHJvdG90eXBlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMuX2l0ZXJhYmxlO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpO1xuICAgICAgaWYgKCFpc0l0ZXJhdG9yKGl0ZXJhdG9yKSkge1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGl0ZXJhdG9yRG9uZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmUgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuXG5cbiAgY3JlYXRlQ2xhc3MoSXRlcmF0b3JTZXEsIEluZGV4ZWRTZXEpO1xuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yU2VxKGl0ZXJhdG9yKSB7XG4gICAgICB0aGlzLl9pdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgICAgdGhpcy5faXRlcmF0b3JDYWNoZSA9IFtdO1xuICAgIH1cblxuICAgIEl0ZXJhdG9yU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyYXRvcjtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuX2l0ZXJhdG9yQ2FjaGU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB3aGlsZSAoaXRlcmF0aW9ucyA8IGNhY2hlLmxlbmd0aCkge1xuICAgICAgICBpZiAoZm4oY2FjaGVbaXRlcmF0aW9uc10sIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzdGVwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICB2YXIgdmFsID0gc3RlcC52YWx1ZTtcbiAgICAgICAgY2FjaGVbaXRlcmF0aW9uc10gPSB2YWw7XG4gICAgICAgIGlmIChmbih2YWwsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG5cbiAgICBJdGVyYXRvclNlcS5wcm90b3R5cGUuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlcmF0b3I7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLl9pdGVyYXRvckNhY2hlO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIGlmIChpdGVyYXRpb25zID49IGNhY2hlLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWNoZVtpdGVyYXRpb25zXSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucywgY2FjaGVbaXRlcmF0aW9ucysrXSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG5cblxuXG4gIC8vICMgcHJhZ21hIEhlbHBlciBmdW5jdGlvbnNcblxuICBmdW5jdGlvbiBpc1NlcShtYXliZVNlcSkge1xuICAgIHJldHVybiAhIShtYXliZVNlcSAmJiBtYXliZVNlcVtJU19TRVFfU0VOVElORUxdKTtcbiAgfVxuXG4gIHZhciBFTVBUWV9TRVE7XG5cbiAgZnVuY3Rpb24gZW1wdHlTZXF1ZW5jZSgpIHtcbiAgICByZXR1cm4gRU1QVFlfU0VRIHx8IChFTVBUWV9TRVEgPSBuZXcgQXJyYXlTZXEoW10pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleWVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHNlcSA9XG4gICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IG5ldyBBcnJheVNlcSh2YWx1ZSkuZnJvbUVudHJ5U2VxKCkgOlxuICAgICAgaXNJdGVyYXRvcih2YWx1ZSkgPyBuZXcgSXRlcmF0b3JTZXEodmFsdWUpLmZyb21FbnRyeVNlcSgpIDpcbiAgICAgIGhhc0l0ZXJhdG9yKHZhbHVlKSA/IG5ldyBJdGVyYWJsZVNlcSh2YWx1ZSkuZnJvbUVudHJ5U2VxKCkgOlxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IG5ldyBPYmplY3RTZXEodmFsdWUpIDpcbiAgICAgIHVuZGVmaW5lZDtcbiAgICBpZiAoIXNlcSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIEFycmF5IG9yIGl0ZXJhYmxlIG9iamVjdCBvZiBbaywgdl0gZW50cmllcywgJytcbiAgICAgICAgJ29yIGtleWVkIG9iamVjdDogJyArIHZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc2VxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBzZXEgPSBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpO1xuICAgIGlmICghc2VxKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgaXRlcmFibGUgb2JqZWN0IG9mIHZhbHVlczogJyArIHZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc2VxO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHNlcSA9IG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkgfHxcbiAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIG5ldyBPYmplY3RTZXEodmFsdWUpKTtcbiAgICBpZiAoIXNlcSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIEFycmF5IG9yIGl0ZXJhYmxlIG9iamVjdCBvZiB2YWx1ZXMsIG9yIGtleWVkIG9iamVjdDogJyArIHZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc2VxO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSA/IG5ldyBBcnJheVNlcSh2YWx1ZSkgOlxuICAgICAgaXNJdGVyYXRvcih2YWx1ZSkgPyBuZXcgSXRlcmF0b3JTZXEodmFsdWUpIDpcbiAgICAgIGhhc0l0ZXJhdG9yKHZhbHVlKSA/IG5ldyBJdGVyYWJsZVNlcSh2YWx1ZSkgOlxuICAgICAgdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcUl0ZXJhdGUoc2VxLCBmbiwgcmV2ZXJzZSwgdXNlS2V5cykge1xuICAgIHZhciBjYWNoZSA9IHNlcS5fY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICB2YXIgbWF4SW5kZXggPSBjYWNoZS5sZW5ndGggLSAxO1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcbiAgICAgICAgaWYgKGZuKGVudHJ5WzFdLCB1c2VLZXlzID8gZW50cnlbMF0gOiBpaSwgc2VxKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gaWkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaWk7XG4gICAgfVxuICAgIHJldHVybiBzZXEuX19pdGVyYXRlVW5jYWNoZWQoZm4sIHJldmVyc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VxSXRlcmF0b3Ioc2VxLCB0eXBlLCByZXZlcnNlLCB1c2VLZXlzKSB7XG4gICAgdmFyIGNhY2hlID0gc2VxLl9jYWNoZTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHZhciBtYXhJbmRleCA9IGNhY2hlLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBlbnRyeSA9IGNhY2hlW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldO1xuICAgICAgICByZXR1cm4gaWkrKyA+IG1heEluZGV4ID9cbiAgICAgICAgICBpdGVyYXRvckRvbmUoKSA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCB1c2VLZXlzID8gZW50cnlbMF0gOiBpaSAtIDEsIGVudHJ5WzFdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VxLl9faXRlcmF0b3JVbmNhY2hlZCh0eXBlLCByZXZlcnNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21KUyhqc29uLCBjb252ZXJ0ZXIpIHtcbiAgICByZXR1cm4gY29udmVydGVyID9cbiAgICAgIGZyb21KU1dpdGgoY29udmVydGVyLCBqc29uLCAnJywgeycnOiBqc29ufSkgOlxuICAgICAgZnJvbUpTRGVmYXVsdChqc29uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21KU1dpdGgoY29udmVydGVyLCBqc29uLCBrZXksIHBhcmVudEpTT04pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRlci5jYWxsKHBhcmVudEpTT04sIGtleSwgSW5kZXhlZFNlcShqc29uKS5tYXAoZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gZnJvbUpTV2l0aChjb252ZXJ0ZXIsIHYsIGssIGpzb24pfSkpO1xuICAgIH1cbiAgICBpZiAoaXNQbGFpbk9iaihqc29uKSkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRlci5jYWxsKHBhcmVudEpTT04sIGtleSwgS2V5ZWRTZXEoanNvbikubWFwKGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIGZyb21KU1dpdGgoY29udmVydGVyLCB2LCBrLCBqc29uKX0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tSlNEZWZhdWx0KGpzb24pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgcmV0dXJuIEluZGV4ZWRTZXEoanNvbikubWFwKGZyb21KU0RlZmF1bHQpLnRvTGlzdCgpO1xuICAgIH1cbiAgICBpZiAoaXNQbGFpbk9iaihqc29uKSkge1xuICAgICAgcmV0dXJuIEtleWVkU2VxKGpzb24pLm1hcChmcm9tSlNEZWZhdWx0KS50b01hcCgpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGxhaW5PYmoodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCk7XG4gIH1cblxuICAvKipcbiAgICogQW4gZXh0ZW5zaW9uIG9mIHRoZSBcInNhbWUtdmFsdWVcIiBhbGdvcml0aG0gYXMgW2Rlc2NyaWJlZCBmb3IgdXNlIGJ5IEVTNiBNYXBcbiAgICogYW5kIFNldF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwI0tleV9lcXVhbGl0eSlcbiAgICpcbiAgICogTmFOIGlzIGNvbnNpZGVyZWQgdGhlIHNhbWUgYXMgTmFOLCBob3dldmVyIC0wIGFuZCAwIGFyZSBjb25zaWRlcmVkIHRoZSBzYW1lXG4gICAqIHZhbHVlLCB3aGljaCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBieVxuICAgKiBbYE9iamVjdC5pc2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pcykuXG4gICAqXG4gICAqIFRoaXMgaXMgZXh0ZW5kZWQgZnVydGhlciB0byBhbGxvdyBPYmplY3RzIHRvIGRlc2NyaWJlIHRoZSB2YWx1ZXMgdGhleVxuICAgKiByZXByZXNlbnQsIGJ5IHdheSBvZiBgdmFsdWVPZmAgb3IgYGVxdWFsc2AgKGFuZCBgaGFzaENvZGVgKS5cbiAgICpcbiAgICogTm90ZTogYmVjYXVzZSBvZiB0aGlzIGV4dGVuc2lvbiwgdGhlIGtleSBlcXVhbGl0eSBvZiBJbW11dGFibGUuTWFwIGFuZCB0aGVcbiAgICogdmFsdWUgZXF1YWxpdHkgb2YgSW1tdXRhYmxlLlNldCB3aWxsIGRpZmZlciBmcm9tIEVTNiBNYXAgYW5kIFNldC5cbiAgICpcbiAgICogIyMjIERlZmluaW5nIGN1c3RvbSB2YWx1ZXNcbiAgICpcbiAgICogVGhlIGVhc2llc3Qgd2F5IHRvIGRlc2NyaWJlIHRoZSB2YWx1ZSBhbiBvYmplY3QgcmVwcmVzZW50cyBpcyBieSBpbXBsZW1lbnRpbmdcbiAgICogYHZhbHVlT2ZgLiBGb3IgZXhhbXBsZSwgYERhdGVgIHJlcHJlc2VudHMgYSB2YWx1ZSBieSByZXR1cm5pbmcgYSB1bml4XG4gICAqIHRpbWVzdGFtcCBmb3IgYHZhbHVlT2ZgOlxuICAgKlxuICAgKiAgICAgdmFyIGRhdGUxID0gbmV3IERhdGUoMTIzNDU2Nzg5MDAwMCk7IC8vIEZyaSBGZWIgMTMgMjAwOSAuLi5cbiAgICogICAgIHZhciBkYXRlMiA9IG5ldyBEYXRlKDEyMzQ1Njc4OTAwMDApO1xuICAgKiAgICAgZGF0ZTEudmFsdWVPZigpOyAvLyAxMjM0NTY3ODkwMDAwXG4gICAqICAgICBhc3NlcnQoIGRhdGUxICE9PSBkYXRlMiApO1xuICAgKiAgICAgYXNzZXJ0KCBJbW11dGFibGUuaXMoIGRhdGUxLCBkYXRlMiApICk7XG4gICAqXG4gICAqIE5vdGU6IG92ZXJyaWRpbmcgYHZhbHVlT2ZgIG1heSBoYXZlIG90aGVyIGltcGxpY2F0aW9ucyBpZiB5b3UgdXNlIHRoaXMgb2JqZWN0XG4gICAqIHdoZXJlIEphdmFTY3JpcHQgZXhwZWN0cyBhIHByaW1pdGl2ZSwgc3VjaCBhcyBpbXBsaWNpdCBzdHJpbmcgY29lcmNpb24uXG4gICAqXG4gICAqIEZvciBtb3JlIGNvbXBsZXggdHlwZXMsIGVzcGVjaWFsbHkgY29sbGVjdGlvbnMsIGltcGxlbWVudGluZyBgdmFsdWVPZmAgbWF5XG4gICAqIG5vdCBiZSBwZXJmb3JtYW50LiBBbiBhbHRlcm5hdGl2ZSBpcyB0byBpbXBsZW1lbnQgYGVxdWFsc2AgYW5kIGBoYXNoQ29kZWAuXG4gICAqXG4gICAqIGBlcXVhbHNgIHRha2VzIGFub3RoZXIgb2JqZWN0LCBwcmVzdW1hYmx5IG9mIHNpbWlsYXIgdHlwZSwgYW5kIHJldHVybnMgdHJ1ZVxuICAgKiBpZiB0aGUgaXQgaXMgZXF1YWwuIEVxdWFsaXR5IGlzIHN5bW1ldHJpY2FsLCBzbyB0aGUgc2FtZSByZXN1bHQgc2hvdWxkIGJlXG4gICAqIHJldHVybmVkIGlmIHRoaXMgYW5kIHRoZSBhcmd1bWVudCBhcmUgZmxpcHBlZC5cbiAgICpcbiAgICogICAgIGFzc2VydCggYS5lcXVhbHMoYikgPT09IGIuZXF1YWxzKGEpICk7XG4gICAqXG4gICAqIGBoYXNoQ29kZWAgcmV0dXJucyBhIDMyYml0IGludGVnZXIgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgb2JqZWN0IHdoaWNoIHdpbGxcbiAgICogYmUgdXNlZCB0byBkZXRlcm1pbmUgaG93IHRvIHN0b3JlIHRoZSB2YWx1ZSBvYmplY3QgaW4gYSBNYXAgb3IgU2V0LiBZb3UgbXVzdFxuICAgKiBwcm92aWRlIGJvdGggb3IgbmVpdGhlciBtZXRob2RzLCBvbmUgbXVzdCBub3QgZXhpc3Qgd2l0aG91dCB0aGUgb3RoZXIuXG4gICAqXG4gICAqIEFsc28sIGFuIGltcG9ydGFudCByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGVzZSBtZXRob2RzIG11c3QgYmUgdXBoZWxkOiBpZiB0d29cbiAgICogdmFsdWVzIGFyZSBlcXVhbCwgdGhleSAqbXVzdCogcmV0dXJuIHRoZSBzYW1lIGhhc2hDb2RlLiBJZiB0aGUgdmFsdWVzIGFyZSBub3RcbiAgICogZXF1YWwsIHRoZXkgbWlnaHQgaGF2ZSB0aGUgc2FtZSBoYXNoQ29kZTsgdGhpcyBpcyBjYWxsZWQgYSBoYXNoIGNvbGxpc2lvbixcbiAgICogYW5kIHdoaWxlIHVuZGVzaXJhYmxlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBpdCBpcyBhY2NlcHRhYmxlLlxuICAgKlxuICAgKiAgICAgaWYgKGEuZXF1YWxzKGIpKSB7XG4gICAqICAgICAgIGFzc2VydCggYS5oYXNoQ29kZSgpID09PSBiLmhhc2hDb2RlKCkgKTtcbiAgICogICAgIH1cbiAgICpcbiAgICogQWxsIEltbXV0YWJsZSBjb2xsZWN0aW9ucyBpbXBsZW1lbnQgYGVxdWFsc2AgYW5kIGBoYXNoQ29kZWAuXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBpcyh2YWx1ZUEsIHZhbHVlQikge1xuICAgIGlmICh2YWx1ZUEgPT09IHZhbHVlQiB8fCAodmFsdWVBICE9PSB2YWx1ZUEgJiYgdmFsdWVCICE9PSB2YWx1ZUIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZUEgfHwgIXZhbHVlQikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlQS52YWx1ZU9mID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZUIudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWVBID0gdmFsdWVBLnZhbHVlT2YoKTtcbiAgICAgIHZhbHVlQiA9IHZhbHVlQi52YWx1ZU9mKCk7XG4gICAgICBpZiAodmFsdWVBID09PSB2YWx1ZUIgfHwgKHZhbHVlQSAhPT0gdmFsdWVBICYmIHZhbHVlQiAhPT0gdmFsdWVCKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWVBIHx8ICF2YWx1ZUIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlQS5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlQi5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdmFsdWVBLmVxdWFscyh2YWx1ZUIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIWlzSXRlcmFibGUoYikgfHxcbiAgICAgIGEuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGIuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGEuc2l6ZSAhPT0gYi5zaXplIHx8XG4gICAgICBhLl9faGFzaCAhPT0gdW5kZWZpbmVkICYmIGIuX19oYXNoICE9PSB1bmRlZmluZWQgJiYgYS5fX2hhc2ggIT09IGIuX19oYXNoIHx8XG4gICAgICBpc0tleWVkKGEpICE9PSBpc0tleWVkKGIpIHx8XG4gICAgICBpc0luZGV4ZWQoYSkgIT09IGlzSW5kZXhlZChiKSB8fFxuICAgICAgaXNPcmRlcmVkKGEpICE9PSBpc09yZGVyZWQoYilcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYS5zaXplID09PSAwICYmIGIuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG5vdEFzc29jaWF0aXZlID0gIWlzQXNzb2NpYXRpdmUoYSk7XG5cbiAgICBpZiAoaXNPcmRlcmVkKGEpKSB7XG4gICAgICB2YXIgZW50cmllcyA9IGEuZW50cmllcygpO1xuICAgICAgcmV0dXJuIGIuZXZlcnkoZnVuY3Rpb24odiwgaykgIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllcy5uZXh0KCkudmFsdWU7XG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBpcyhlbnRyeVsxXSwgdikgJiYgKG5vdEFzc29jaWF0aXZlIHx8IGlzKGVudHJ5WzBdLCBrKSk7XG4gICAgICB9KSAmJiBlbnRyaWVzLm5leHQoKS5kb25lO1xuICAgIH1cblxuICAgIHZhciBmbGlwcGVkID0gZmFsc2U7XG5cbiAgICBpZiAoYS5zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChiLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGEuY2FjaGVSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBhLmNhY2hlUmVzdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsaXBwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgXyA9IGE7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gXztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWxsRXF1YWwgPSB0cnVlO1xuICAgIHZhciBiU2l6ZSA9IGIuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7XG4gICAgICBpZiAobm90QXNzb2NpYXRpdmUgPyAhYS5oYXModikgOlxuICAgICAgICAgIGZsaXBwZWQgPyAhaXModiwgYS5nZXQoaywgTk9UX1NFVCkpIDogIWlzKGEuZ2V0KGssIE5PVF9TRVQpLCB2KSkge1xuICAgICAgICBhbGxFcXVhbCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYWxsRXF1YWwgJiYgYS5zaXplID09PSBiU2l6ZTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFJlcGVhdCwgSW5kZXhlZFNlcSk7XG5cbiAgICBmdW5jdGlvbiBSZXBlYXQodmFsdWUsIHRpbWVzKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVwZWF0KSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlcGVhdCh2YWx1ZSwgdGltZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc2l6ZSA9IHRpbWVzID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IE1hdGgubWF4KDAsIHRpbWVzKTtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgaWYgKEVNUFRZX1JFUEVBVCkge1xuICAgICAgICAgIHJldHVybiBFTVBUWV9SRVBFQVQ7XG4gICAgICAgIH1cbiAgICAgICAgRU1QVFlfUkVQRUFUID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnUmVwZWF0IFtdJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnUmVwZWF0IFsgJyArIHRoaXMuX3ZhbHVlICsgJyAnICsgdGhpcy5zaXplICsgJyB0aW1lcyBdJztcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgPyB0aGlzLl92YWx1ZSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiBpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICByZXR1cm4gd2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSA/IHRoaXMgOlxuICAgICAgICBuZXcgUmVwZWF0KHRoaXMuX3ZhbHVlLCByZXNvbHZlRW5kKGVuZCwgc2l6ZSkgLSByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpKTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIGlmIChpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIGlmIChpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB0aGlzLnNpemU7IGlpKyspIHtcbiAgICAgICAgaWYgKGZuKHRoaXMuX3ZhbHVlLCBpaSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGlpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlpO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpIFxuICAgICAgICB7cmV0dXJuIGlpIDwgdGhpcyQwLnNpemUgPyBpdGVyYXRvclZhbHVlKHR5cGUsIGlpKyssIHRoaXMkMC5fdmFsdWUpIDogaXRlcmF0b3JEb25lKCl9XG4gICAgICApO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBSZXBlYXQgP1xuICAgICAgICBpcyh0aGlzLl92YWx1ZSwgb3RoZXIuX3ZhbHVlKSA6XG4gICAgICAgIGRlZXBFcXVhbChvdGhlcik7XG4gICAgfTtcblxuXG4gIHZhciBFTVBUWV9SRVBFQVQ7XG5cbiAgZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZXJyb3IpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFJhbmdlLCBJbmRleGVkU2VxKTtcblxuICAgIGZ1bmN0aW9uIFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kLCBzdGVwKTtcbiAgICAgIH1cbiAgICAgIGludmFyaWFudChzdGVwICE9PSAwLCAnQ2Fubm90IHN0ZXAgYSBSYW5nZSBieSAwJyk7XG4gICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gMSA6IE1hdGguYWJzKHN0ZXApO1xuICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHN0ZXAgPSAtc3RlcDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICAgIHRoaXMuc2l6ZSA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoZW5kIC0gc3RhcnQpIC8gc3RlcCAtIDEpICsgMSk7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIGlmIChFTVBUWV9SQU5HRSkge1xuICAgICAgICAgIHJldHVybiBFTVBUWV9SQU5HRTtcbiAgICAgICAgfVxuICAgICAgICBFTVBUWV9SQU5HRSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnUmFuZ2UgW10nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdSYW5nZSBbICcgK1xuICAgICAgICB0aGlzLl9zdGFydCArICcuLi4nICsgdGhpcy5fZW5kICtcbiAgICAgICAgKHRoaXMuX3N0ZXAgIT09IDEgPyAnIGJ5ICcgKyB0aGlzLl9zdGVwIDogJycpICtcbiAgICAgICcgXSc7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgP1xuICAgICAgICB0aGlzLl9zdGFydCArIHdyYXBJbmRleCh0aGlzLCBpbmRleCkgKiB0aGlzLl9zdGVwIDpcbiAgICAgICAgbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICB2YXIgcG9zc2libGVJbmRleCA9IChzZWFyY2hWYWx1ZSAtIHRoaXMuX3N0YXJ0KSAvIHRoaXMuX3N0ZXA7XG4gICAgICByZXR1cm4gcG9zc2libGVJbmRleCA+PSAwICYmXG4gICAgICAgIHBvc3NpYmxlSW5kZXggPCB0aGlzLnNpemUgJiZcbiAgICAgICAgcG9zc2libGVJbmRleCA9PT0gTWF0aC5mbG9vcihwb3NzaWJsZUluZGV4KTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgdGhpcy5zaXplKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCB0aGlzLnNpemUpO1xuICAgICAgZW5kID0gcmVzb2x2ZUVuZChlbmQsIHRoaXMuc2l6ZSk7XG4gICAgICBpZiAoZW5kIDw9IGJlZ2luKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UoMCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuZ2V0KGJlZ2luLCB0aGlzLl9lbmQpLCB0aGlzLmdldChlbmQsIHRoaXMuX2VuZCksIHRoaXMuX3N0ZXApO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICB2YXIgb2Zmc2V0VmFsdWUgPSBzZWFyY2hWYWx1ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgaWYgKG9mZnNldFZhbHVlICUgdGhpcy5fc3RlcCA9PT0gMCkge1xuICAgICAgICB2YXIgaW5kZXggPSBvZmZzZXRWYWx1ZSAvIHRoaXMuX3N0ZXA7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4T2Yoc2VhcmNoVmFsdWUpO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBtYXhJbmRleCA9IHRoaXMuc2l6ZSAtIDE7XG4gICAgICB2YXIgc3RlcCA9IHRoaXMuX3N0ZXA7XG4gICAgICB2YXIgdmFsdWUgPSByZXZlcnNlID8gdGhpcy5fc3RhcnQgKyBtYXhJbmRleCAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcbiAgICAgICAgaWYgKGZuKHZhbHVlLCBpaSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGlpICsgMTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSArPSByZXZlcnNlID8gLXN0ZXAgOiBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlpO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBtYXhJbmRleCA9IHRoaXMuc2l6ZSAtIDE7XG4gICAgICB2YXIgc3RlcCA9IHRoaXMuX3N0ZXA7XG4gICAgICB2YXIgdmFsdWUgPSByZXZlcnNlID8gdGhpcy5fc3RhcnQgKyBtYXhJbmRleCAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcbiAgICAgIHZhciBpaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHYgPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgKz0gcmV2ZXJzZSA/IC1zdGVwIDogc3RlcDtcbiAgICAgICAgcmV0dXJuIGlpID4gbWF4SW5kZXggPyBpdGVyYXRvckRvbmUoKSA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaWkrKywgdik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBSYW5nZSA/XG4gICAgICAgIHRoaXMuX3N0YXJ0ID09PSBvdGhlci5fc3RhcnQgJiZcbiAgICAgICAgdGhpcy5fZW5kID09PSBvdGhlci5fZW5kICYmXG4gICAgICAgIHRoaXMuX3N0ZXAgPT09IG90aGVyLl9zdGVwIDpcbiAgICAgICAgZGVlcEVxdWFsKHRoaXMsIG90aGVyKTtcbiAgICB9O1xuXG5cbiAgdmFyIEVNUFRZX1JBTkdFO1xuXG4gIGNyZWF0ZUNsYXNzKENvbGxlY3Rpb24sIEl0ZXJhYmxlKTtcbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdBYnN0cmFjdCcpO1xuICAgIH1cblxuXG4gIGNyZWF0ZUNsYXNzKEtleWVkQ29sbGVjdGlvbiwgQ29sbGVjdGlvbik7ZnVuY3Rpb24gS2V5ZWRDb2xsZWN0aW9uKCkge31cblxuICBjcmVhdGVDbGFzcyhJbmRleGVkQ29sbGVjdGlvbiwgQ29sbGVjdGlvbik7ZnVuY3Rpb24gSW5kZXhlZENvbGxlY3Rpb24oKSB7fVxuXG4gIGNyZWF0ZUNsYXNzKFNldENvbGxlY3Rpb24sIENvbGxlY3Rpb24pO2Z1bmN0aW9uIFNldENvbGxlY3Rpb24oKSB7fVxuXG5cbiAgQ29sbGVjdGlvbi5LZXllZCA9IEtleWVkQ29sbGVjdGlvbjtcbiAgQ29sbGVjdGlvbi5JbmRleGVkID0gSW5kZXhlZENvbGxlY3Rpb247XG4gIENvbGxlY3Rpb24uU2V0ID0gU2V0Q29sbGVjdGlvbjtcblxuICB2YXIgaW11bCA9XG4gICAgdHlwZW9mIE1hdGguaW11bCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXRoLmltdWwoMHhmZmZmZmZmZiwgMikgPT09IC0yID9cbiAgICBNYXRoLmltdWwgOlxuICAgIGZ1bmN0aW9uIGltdWwoYSwgYikge1xuICAgICAgYSA9IGEgfCAwOyAvLyBpbnRcbiAgICAgIGIgPSBiIHwgMDsgLy8gaW50XG4gICAgICB2YXIgYyA9IGEgJiAweGZmZmY7XG4gICAgICB2YXIgZCA9IGIgJiAweGZmZmY7XG4gICAgICAvLyBTaGlmdCBieSAwIGZpeGVzIHRoZSBzaWduIG9uIHRoZSBoaWdoIHBhcnQuXG4gICAgICByZXR1cm4gKGMgKiBkKSArICgoKChhID4+PiAxNikgKiBkICsgYyAqIChiID4+PiAxNikpIDw8IDE2KSA+Pj4gMCkgfCAwOyAvLyBpbnRcbiAgICB9O1xuXG4gIC8vIHY4IGhhcyBhbiBvcHRpbWl6YXRpb24gZm9yIHN0b3JpbmcgMzEtYml0IHNpZ25lZCBudW1iZXJzLlxuICAvLyBWYWx1ZXMgd2hpY2ggaGF2ZSBlaXRoZXIgMDAgb3IgMTEgYXMgdGhlIGhpZ2ggb3JkZXIgYml0cyBxdWFsaWZ5LlxuICAvLyBUaGlzIGZ1bmN0aW9uIGRyb3BzIHRoZSBoaWdoZXN0IG9yZGVyIGJpdCBpbiBhIHNpZ25lZCBudW1iZXIsIG1haW50YWluaW5nXG4gIC8vIHRoZSBzaWduIGJpdC5cbiAgZnVuY3Rpb24gc21pKGkzMikge1xuICAgIHJldHVybiAoKGkzMiA+Pj4gMSkgJiAweDQwMDAwMDAwKSB8IChpMzIgJiAweEJGRkZGRkZGKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc2gobykge1xuICAgIGlmIChvID09PSBmYWxzZSB8fCBvID09PSBudWxsIHx8IG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygby52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvID0gby52YWx1ZU9mKCk7XG4gICAgICBpZiAobyA9PT0gZmFsc2UgfHwgbyA9PT0gbnVsbCB8fCBvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgbztcbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChvICE9PSBvIHx8IG8gPT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgdmFyIGggPSBvIHwgMDtcbiAgICAgIGlmIChoICE9PSBvKSB7XG4gICAgICAgIGggXj0gbyAqIDB4RkZGRkZGRkY7XG4gICAgICB9XG4gICAgICB3aGlsZSAobyA+IDB4RkZGRkZGRkYpIHtcbiAgICAgICAgbyAvPSAweEZGRkZGRkZGO1xuICAgICAgICBoIF49IG87XG4gICAgICB9XG4gICAgICByZXR1cm4gc21pKGgpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvLmxlbmd0aCA+IFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU4gPyBjYWNoZWRIYXNoU3RyaW5nKG8pIDogaGFzaFN0cmluZyhvKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvLmhhc2hDb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gby5oYXNoQ29kZSgpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBoYXNoSlNPYmoobyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygby50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGhhc2hTdHJpbmcoby50b1N0cmluZygpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSB0eXBlICcgKyB0eXBlICsgJyBjYW5ub3QgYmUgaGFzaGVkLicpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FjaGVkSGFzaFN0cmluZyhzdHJpbmcpIHtcbiAgICB2YXIgaGFzaCA9IHN0cmluZ0hhc2hDYWNoZVtzdHJpbmddO1xuICAgIGlmIChoYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGhhc2ggPSBoYXNoU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9PT0gU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUpIHtcbiAgICAgICAgU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9IDA7XG4gICAgICAgIHN0cmluZ0hhc2hDYWNoZSA9IHt9O1xuICAgICAgfVxuICAgICAgU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSsrO1xuICAgICAgc3RyaW5nSGFzaENhY2hlW3N0cmluZ10gPSBoYXNoO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2hhc2hpbmctc3RyaW5nc1xuICBmdW5jdGlvbiBoYXNoU3RyaW5nKHN0cmluZykge1xuICAgIC8vIFRoaXMgaXMgdGhlIGhhc2ggZnJvbSBKVk1cbiAgICAvLyBUaGUgaGFzaCBjb2RlIGZvciBhIHN0cmluZyBpcyBjb21wdXRlZCBhc1xuICAgIC8vIHNbMF0gKiAzMSBeIChuIC0gMSkgKyBzWzFdICogMzEgXiAobiAtIDIpICsgLi4uICsgc1tuIC0gMV0sXG4gICAgLy8gd2hlcmUgc1tpXSBpcyB0aGUgaXRoIGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nIGFuZCBuIGlzIHRoZSBsZW5ndGggb2ZcbiAgICAvLyB0aGUgc3RyaW5nLiBXZSBcIm1vZFwiIHRoZSByZXN1bHQgdG8gbWFrZSBpdCBiZXR3ZWVuIDAgKGluY2x1c2l2ZSkgYW5kIDJeMzFcbiAgICAvLyAoZXhjbHVzaXZlKSBieSBkcm9wcGluZyBoaWdoIGJpdHMuXG4gICAgdmFyIGhhc2ggPSAwO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBzdHJpbmcubGVuZ3RoOyBpaSsrKSB7XG4gICAgICBoYXNoID0gMzEgKiBoYXNoICsgc3RyaW5nLmNoYXJDb2RlQXQoaWkpIHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHNtaShoYXNoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc2hKU09iaihvYmopIHtcbiAgICB2YXIgaGFzaDtcbiAgICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgICBoYXNoID0gd2Vha01hcC5nZXQob2JqKTtcbiAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzaCA9IG9ialtVSURfSEFTSF9LRVldO1xuICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cblxuICAgIGlmICghY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIGhhc2ggPSBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgJiYgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlW1VJRF9IQVNIX0tFWV07XG4gICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfVxuXG4gICAgICBoYXNoID0gZ2V0SUVOb2RlSGFzaChvYmopO1xuICAgICAgaWYgKGhhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoID0gKytvYmpIYXNoVUlEO1xuICAgIGlmIChvYmpIYXNoVUlEICYgMHg0MDAwMDAwMCkge1xuICAgICAgb2JqSGFzaFVJRCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHVzaW5nV2Vha01hcCkge1xuICAgICAgd2Vha01hcC5zZXQob2JqLCBoYXNoKTtcbiAgICB9IGVsc2UgaWYgKGlzRXh0ZW5zaWJsZSAhPT0gdW5kZWZpbmVkICYmIGlzRXh0ZW5zaWJsZShvYmopID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tZXh0ZW5zaWJsZSBvYmplY3RzIGFyZSBub3QgYWxsb3dlZCBhcyBrZXlzLicpO1xuICAgIH0gZWxzZSBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFVJRF9IQVNIX0tFWSwge1xuICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgICAnY29uZmlndXJhYmxlJzogZmFsc2UsXG4gICAgICAgICd3cml0YWJsZSc6IGZhbHNlLFxuICAgICAgICAndmFsdWUnOiBoYXNoXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgPT09IG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpIHtcbiAgICAgIC8vIFNpbmNlIHdlIGNhbid0IGRlZmluZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBvYmplY3RcbiAgICAgIC8vIHdlJ2xsIGhpamFjayBvbmUgb2YgdGhlIGxlc3MtdXNlZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIHRvXG4gICAgICAvLyBzYXZlIG91ciBoYXNoIG9uIGl0LiBTaW5jZSB0aGlzIGlzIGEgZnVuY3Rpb24gaXQgd2lsbCBub3Qgc2hvdyB1cCBpblxuICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YCB3aGljaCBpcyB3aGF0IHdlIHdhbnQuXG4gICAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlW1VJRF9IQVNIX0tFWV0gPSBoYXNoO1xuICAgIH0gZWxzZSBpZiAob2JqLm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgY291bGRuJ3QgZ2V0IHRoZSBJRSBgdW5pcXVlSURgIHRvIHVzZSBhcyBhIGhhc2hcbiAgICAgIC8vIGFuZCB3ZSBjb3VsZG4ndCB1c2UgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSB0byBleHBsb2l0IHRoZVxuICAgICAgLy8gZG9udEVudW0gYnVnIHNvIHdlIHNpbXBseSBhZGQgdGhlIGBVSURfSEFTSF9LRVlgIG9uIHRoZSBub2RlXG4gICAgICAvLyBpdHNlbGYuXG4gICAgICBvYmpbVUlEX0hBU0hfS0VZXSA9IGhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNldCBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuXG4gIC8vIEdldCByZWZlcmVuY2VzIHRvIEVTNSBvYmplY3QgbWV0aG9kcy5cbiAgdmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiAgLy8gVHJ1ZSBpZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgd29ya3MgYXMgZXhwZWN0ZWQuIElFOCBmYWlscyB0aGlzIHRlc3QuXG4gIHZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnQCcsIHt9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0oKSk7XG5cbiAgLy8gSUUgaGFzIGEgYHVuaXF1ZUlEYCBwcm9wZXJ0eSBvbiBET00gbm9kZXMuIFdlIGNhbiBjb25zdHJ1Y3QgdGhlIGhhc2ggZnJvbSBpdFxuICAvLyBhbmQgYXZvaWQgbWVtb3J5IGxlYWtzIGZyb20gdGhlIElFIGNsb25lTm9kZSBidWcuXG4gIGZ1bmN0aW9uIGdldElFTm9kZUhhc2gobm9kZSkge1xuICAgIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPiAwKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgY2FzZSAxOiAvLyBFbGVtZW50XG4gICAgICAgICAgcmV0dXJuIG5vZGUudW5pcXVlSUQ7XG4gICAgICAgIGNhc2UgOTogLy8gRG9jdW1lbnRcbiAgICAgICAgICByZXR1cm4gbm9kZS5kb2N1bWVudEVsZW1lbnQgJiYgbm9kZS5kb2N1bWVudEVsZW1lbnQudW5pcXVlSUQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgcG9zc2libGUsIHVzZSBhIFdlYWtNYXAuXG4gIHZhciB1c2luZ1dlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJztcbiAgdmFyIHdlYWtNYXA7XG4gIGlmICh1c2luZ1dlYWtNYXApIHtcbiAgICB3ZWFrTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuXG4gIHZhciBvYmpIYXNoVUlEID0gMDtcblxuICB2YXIgVUlEX0hBU0hfS0VZID0gJ19faW1tdXRhYmxlaGFzaF9fJztcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICBVSURfSEFTSF9LRVkgPSBTeW1ib2woVUlEX0hBU0hfS0VZKTtcbiAgfVxuXG4gIHZhciBTVFJJTkdfSEFTSF9DQUNIRV9NSU5fU1RSTEVOID0gMTY7XG4gIHZhciBTVFJJTkdfSEFTSF9DQUNIRV9NQVhfU0laRSA9IDI1NTtcbiAgdmFyIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPSAwO1xuICB2YXIgc3RyaW5nSGFzaENhY2hlID0ge307XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm90SW5maW5pdGUoc2l6ZSkge1xuICAgIGludmFyaWFudChcbiAgICAgIHNpemUgIT09IEluZmluaXR5LFxuICAgICAgJ0Nhbm5vdCBwZXJmb3JtIHRoaXMgYWN0aW9uIHdpdGggYW4gaW5maW5pdGUgc2l6ZS4nXG4gICAgKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE1hcCwgS2V5ZWRDb2xsZWN0aW9uKTtcblxuICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cbiAgICBmdW5jdGlvbiBNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlNYXAoKSA6XG4gICAgICAgIGlzTWFwKHZhbHVlKSAmJiAhaXNPcmRlcmVkKHZhbHVlKSA/IHZhbHVlIDpcbiAgICAgICAgZW1wdHlNYXAoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKG1hcCApIHtcbiAgICAgICAgICB2YXIgaXRlciA9IEtleWVkSXRlcmFibGUodmFsdWUpO1xuICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIG1hcC5zZXQoaywgdil9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgTWFwLm9mID0gZnVuY3Rpb24oKSB7dmFyIGtleVZhbHVlcyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgcmV0dXJuIGVtcHR5TWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbihtYXAgKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5VmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgaWYgKGkgKyAxID49IGtleVZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2YWx1ZSBmb3Iga2V5OiAnICsga2V5VmFsdWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwLnNldChrZXlWYWx1ZXNbaV0sIGtleVZhbHVlc1tpICsgMV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnTWFwIHsnLCAnfScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrLCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QgP1xuICAgICAgICB0aGlzLl9yb290LmdldCgwLCB1bmRlZmluZWQsIGssIG5vdFNldFZhbHVlKSA6XG4gICAgICAgIG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrLCB2KSB7XG4gICAgICByZXR1cm4gdXBkYXRlTWFwKHRoaXMsIGssIHYpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnNldEluID0gZnVuY3Rpb24oa2V5UGF0aCwgdikge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW4oa2V5UGF0aCwgTk9UX1NFVCwgZnVuY3Rpb24oKSAge3JldHVybiB2fSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaykge1xuICAgICAgcmV0dXJuIHVwZGF0ZU1hcCh0aGlzLCBrLCBOT1RfU0VUKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5kZWxldGVJbiA9IGZ1bmN0aW9uKGtleVBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUluKGtleVBhdGgsIGZ1bmN0aW9uKCkgIHtyZXR1cm4gTk9UX1NFVH0pO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGssIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgIGsodGhpcykgOlxuICAgICAgICB0aGlzLnVwZGF0ZUluKFtrXSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnVwZGF0ZUluID0gZnVuY3Rpb24oa2V5UGF0aCwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgICAgIGlmICghdXBkYXRlcikge1xuICAgICAgICB1cGRhdGVyID0gbm90U2V0VmFsdWU7XG4gICAgICAgIG5vdFNldFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZWRWYWx1ZSA9IHVwZGF0ZUluRGVlcE1hcChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZm9yY2VJdGVyYXRvcihrZXlQYXRoKSxcbiAgICAgICAgbm90U2V0VmFsdWUsXG4gICAgICAgIHVwZGF0ZXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gdXBkYXRlZFZhbHVlID09PSBOT1RfU0VUID8gdW5kZWZpbmVkIDogdXBkYXRlZFZhbHVlO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eU1hcCgpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIENvbXBvc2l0aW9uXG5cbiAgICBNYXAucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oLyouLi5pdGVycyovKSB7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCB1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUubWVyZ2VXaXRoID0gZnVuY3Rpb24obWVyZ2VyKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCBtZXJnZXIsIGl0ZXJzKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5tZXJnZUluID0gZnVuY3Rpb24oa2V5UGF0aCkge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW4oXG4gICAgICAgIGtleVBhdGgsXG4gICAgICAgIGVtcHR5TWFwKCksXG4gICAgICAgIGZ1bmN0aW9uKG0gKSB7cmV0dXJuIHR5cGVvZiBtLm1lcmdlID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICBtLm1lcmdlLmFwcGx5KG0sIGl0ZXJzKSA6XG4gICAgICAgICAgaXRlcnNbaXRlcnMubGVuZ3RoIC0gMV19XG4gICAgICApO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLm1lcmdlRGVlcCA9IGZ1bmN0aW9uKC8qLi4uaXRlcnMqLykge1xuICAgICAgcmV0dXJuIG1lcmdlSW50b01hcFdpdGgodGhpcywgZGVlcE1lcmdlciwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gZnVuY3Rpb24obWVyZ2VyKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCBkZWVwTWVyZ2VyV2l0aChtZXJnZXIpLCBpdGVycyk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBmdW5jdGlvbihrZXlQYXRoKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVJbihcbiAgICAgICAga2V5UGF0aCxcbiAgICAgICAgZW1wdHlNYXAoKSxcbiAgICAgICAgZnVuY3Rpb24obSApIHtyZXR1cm4gdHlwZW9mIG0ubWVyZ2VEZWVwID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICBtLm1lcmdlRGVlcC5hcHBseShtLCBpdGVycykgOlxuICAgICAgICAgIGl0ZXJzW2l0ZXJzLmxlbmd0aCAtIDFdfVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgICByZXR1cm4gT3JkZXJlZE1hcChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24obWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICAgIHJldHVybiBPcmRlcmVkTWFwKHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE11dGFiaWxpdHlcblxuICAgIE1hcC5wcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICB2YXIgbXV0YWJsZSA9IHRoaXMuYXNNdXRhYmxlKCk7XG4gICAgICBmbihtdXRhYmxlKTtcbiAgICAgIHJldHVybiBtdXRhYmxlLndhc0FsdGVyZWQoKSA/IG11dGFibGUuX19lbnN1cmVPd25lcih0aGlzLl9fb3duZXJJRCkgOiB0aGlzO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLmFzTXV0YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19vd25lcklEID8gdGhpcyA6IHRoaXMuX19lbnN1cmVPd25lcihuZXcgT3duZXJJRCgpKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19lbnN1cmVPd25lcigpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fYWx0ZXJlZDtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLCB0eXBlLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdGhpcy5fcm9vdCAmJiB0aGlzLl9yb290Lml0ZXJhdGUoZnVuY3Rpb24oZW50cnkgKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgcmV0dXJuIGZuKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyQwKTtcbiAgICAgIH0sIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VNYXAodGhpcy5zaXplLCB0aGlzLl9yb290LCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gICAgfTtcblxuXG4gIGZ1bmN0aW9uIGlzTWFwKG1heWJlTWFwKSB7XG4gICAgcmV0dXJuICEhKG1heWJlTWFwICYmIG1heWJlTWFwW0lTX01BUF9TRU5USU5FTF0pO1xuICB9XG5cbiAgTWFwLmlzTWFwID0gaXNNYXA7XG5cbiAgdmFyIElTX01BUF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX01BUF9fQEAnO1xuXG4gIHZhciBNYXBQcm90b3R5cGUgPSBNYXAucHJvdG90eXBlO1xuICBNYXBQcm90b3R5cGVbSVNfTUFQX1NFTlRJTkVMXSA9IHRydWU7XG4gIE1hcFByb3RvdHlwZVtERUxFVEVdID0gTWFwUHJvdG90eXBlLnJlbW92ZTtcbiAgTWFwUHJvdG90eXBlLnJlbW92ZUluID0gTWFwUHJvdG90eXBlLmRlbGV0ZUluO1xuXG5cbiAgLy8gI3ByYWdtYSBUcmllIE5vZGVzXG5cblxuXG4gICAgZnVuY3Rpb24gQXJyYXlNYXBOb2RlKG93bmVySUQsIGVudHJpZXMpIHtcbiAgICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgIH1cblxuICAgIEFycmF5TWFwTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgICAgZm9yICh2YXIgaWkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpaV1bMF0pKSB7XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXNbaWldWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIEFycmF5TWFwTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuXG4gICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICAgIHZhciBpZHggPSAwO1xuICAgICAgZm9yICh2YXIgbGVuID0gZW50cmllcy5sZW5ndGg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpZHhdWzBdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhpc3RzID0gaWR4IDwgbGVuO1xuXG4gICAgICBpZiAoZXhpc3RzID8gZW50cmllc1tpZHhdWzFdID09PSB2YWx1ZSA6IHJlbW92ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgICAocmVtb3ZlZCB8fCAhZXhpc3RzKSAmJiBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG5cbiAgICAgIGlmIChyZW1vdmVkICYmIGVudHJpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmICghZXhpc3RzICYmICFyZW1vdmVkICYmIGVudHJpZXMubGVuZ3RoID49IE1BWF9BUlJBWV9NQVBfU0laRSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTm9kZXMob3duZXJJRCwgZW50cmllcywga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gICAgICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcblxuICAgICAgaWYgKGV4aXN0cykge1xuICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgIGlkeCA9PT0gbGVuIC0gMSA/IG5ld0VudHJpZXMucG9wKCkgOiAobmV3RW50cmllc1tpZHhdID0gbmV3RW50cmllcy5wb3AoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3RW50cmllc1tpZHhdID0gW2tleSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdFbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgICAgdGhpcy5lbnRyaWVzID0gbmV3RW50cmllcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQXJyYXlNYXBOb2RlKG93bmVySUQsIG5ld0VudHJpZXMpO1xuICAgIH07XG5cblxuXG5cbiAgICBmdW5jdGlvbiBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIG5vZGVzKSB7XG4gICAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5iaXRtYXAgPSBiaXRtYXA7XG4gICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgfVxuXG4gICAgQml0bWFwSW5kZXhlZE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgICB9XG4gICAgICB2YXIgYml0ID0gKDEgPDwgKChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLKSk7XG4gICAgICB2YXIgYml0bWFwID0gdGhpcy5iaXRtYXA7XG4gICAgICByZXR1cm4gKGJpdG1hcCAmIGJpdCkgPT09IDAgPyBub3RTZXRWYWx1ZSA6XG4gICAgICAgIHRoaXMubm9kZXNbcG9wQ291bnQoYml0bWFwICYgKGJpdCAtIDEpKV0uZ2V0KHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpO1xuICAgIH07XG5cbiAgICBCaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgICB9XG4gICAgICB2YXIga2V5SGFzaEZyYWcgPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgICAgIHZhciBiaXQgPSAxIDw8IGtleUhhc2hGcmFnO1xuICAgICAgdmFyIGJpdG1hcCA9IHRoaXMuYml0bWFwO1xuICAgICAgdmFyIGV4aXN0cyA9IChiaXRtYXAgJiBiaXQpICE9PSAwO1xuXG4gICAgICBpZiAoIWV4aXN0cyAmJiB2YWx1ZSA9PT0gTk9UX1NFVCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGlkeCA9IHBvcENvdW50KGJpdG1hcCAmIChiaXQgLSAxKSk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgICAgdmFyIG5vZGUgPSBleGlzdHMgPyBub2Rlc1tpZHhdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG5ld05vZGUgPSB1cGRhdGVOb2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKTtcblxuICAgICAgaWYgKG5ld05vZGUgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmICghZXhpc3RzICYmIG5ld05vZGUgJiYgbm9kZXMubGVuZ3RoID49IE1BWF9CSVRNQVBfSU5ERVhFRF9TSVpFKSB7XG4gICAgICAgIHJldHVybiBleHBhbmROb2Rlcyhvd25lcklELCBub2RlcywgYml0bWFwLCBrZXlIYXNoRnJhZywgbmV3Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChleGlzdHMgJiYgIW5ld05vZGUgJiYgbm9kZXMubGVuZ3RoID09PSAyICYmIGlzTGVhZk5vZGUobm9kZXNbaWR4IF4gMV0pKSB7XG4gICAgICAgIHJldHVybiBub2Rlc1tpZHggXiAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4aXN0cyAmJiBuZXdOb2RlICYmIG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBpc0xlYWZOb2RlKG5ld05vZGUpKSB7XG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICAgICAgdmFyIG5ld0JpdG1hcCA9IGV4aXN0cyA/IG5ld05vZGUgPyBiaXRtYXAgOiBiaXRtYXAgXiBiaXQgOiBiaXRtYXAgfCBiaXQ7XG4gICAgICB2YXIgbmV3Tm9kZXMgPSBleGlzdHMgPyBuZXdOb2RlID9cbiAgICAgICAgc2V0SW4obm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSkgOlxuICAgICAgICBzcGxpY2VPdXQobm9kZXMsIGlkeCwgaXNFZGl0YWJsZSkgOlxuICAgICAgICBzcGxpY2VJbihub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKTtcblxuICAgICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgICAgdGhpcy5iaXRtYXAgPSBuZXdCaXRtYXA7XG4gICAgICAgIHRoaXMubm9kZXMgPSBuZXdOb2RlcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgbmV3Qml0bWFwLCBuZXdOb2Rlcyk7XG4gICAgfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgY291bnQsIG5vZGVzKSB7XG4gICAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgIH1cblxuICAgIEhhc2hBcnJheU1hcE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgICB9XG4gICAgICB2YXIgaWR4ID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZXNbaWR4XTtcbiAgICAgIHJldHVybiBub2RlID8gbm9kZS5nZXQoc2hpZnQgKyBTSElGVCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgICB9XG4gICAgICB2YXIgaWR4ID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaWR4XTtcblxuICAgICAgaWYgKHJlbW92ZWQgJiYgIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdOb2RlID0gdXBkYXRlTm9kZShub2RlLCBvd25lcklELCBzaGlmdCArIFNISUZULCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcik7XG4gICAgICBpZiAobmV3Tm9kZSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0NvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBuZXdDb3VudCsrO1xuICAgICAgfSBlbHNlIGlmICghbmV3Tm9kZSkge1xuICAgICAgICBuZXdDb3VudC0tO1xuICAgICAgICBpZiAobmV3Q291bnQgPCBNSU5fSEFTSF9BUlJBWV9NQVBfU0laRSkge1xuICAgICAgICAgIHJldHVybiBwYWNrTm9kZXMob3duZXJJRCwgbm9kZXMsIG5ld0NvdW50LCBpZHgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gICAgICB2YXIgbmV3Tm9kZXMgPSBzZXRJbihub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKTtcblxuICAgICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IG5ld0NvdW50O1xuICAgICAgICB0aGlzLm5vZGVzID0gbmV3Tm9kZXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgbmV3Q291bnQsIG5ld05vZGVzKTtcbiAgICB9O1xuXG5cblxuXG4gICAgZnVuY3Rpb24gSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwga2V5SGFzaCwgZW50cmllcykge1xuICAgICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG4gICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgIH1cblxuICAgIEhhc2hDb2xsaXNpb25Ob2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgICBmb3IgKHZhciBpaSA9IDAsIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKykge1xuICAgICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcbiAgICAgICAgICByZXR1cm4gZW50cmllc1tpaV1bMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgICAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuXG4gICAgICBpZiAoa2V5SGFzaCAhPT0gdGhpcy5rZXlIYXNoKSB7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAgICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgICAgICByZXR1cm4gbWVyZ2VJbnRvTm9kZSh0aGlzLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgICB2YXIgaWR4ID0gMDtcbiAgICAgIGZvciAodmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWR4XVswXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGV4aXN0cyA9IGlkeCA8IGxlbjtcblxuICAgICAgaWYgKGV4aXN0cyA/IGVudHJpZXNbaWR4XVsxXSA9PT0gdmFsdWUgOiByZW1vdmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgICAgKHJlbW92ZWQgfHwgIWV4aXN0cykgJiYgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuXG4gICAgICBpZiAocmVtb3ZlZCAmJiBsZW4gPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwgdGhpcy5rZXlIYXNoLCBlbnRyaWVzW2lkeCBeIDFdKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICAgIHZhciBuZXdFbnRyaWVzID0gaXNFZGl0YWJsZSA/IGVudHJpZXMgOiBhcnJDb3B5KGVudHJpZXMpO1xuXG4gICAgICBpZiAoZXhpc3RzKSB7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgaWR4ID09PSBsZW4gLSAxID8gbmV3RW50cmllcy5wb3AoKSA6IChuZXdFbnRyaWVzW2lkeF0gPSBuZXdFbnRyaWVzLnBvcCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdFbnRyaWVzW2lkeF0gPSBba2V5LCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0VudHJpZXMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBuZXdFbnRyaWVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIG5ld0VudHJpZXMpO1xuICAgIH07XG5cblxuXG5cbiAgICBmdW5jdGlvbiBWYWx1ZU5vZGUob3duZXJJRCwga2V5SGFzaCwgZW50cnkpIHtcbiAgICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLmtleUhhc2ggPSBrZXlIYXNoO1xuICAgICAgdGhpcy5lbnRyeSA9IGVudHJ5O1xuICAgIH1cblxuICAgIFZhbHVlTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiBpcyhrZXksIHRoaXMuZW50cnlbMF0pID8gdGhpcy5lbnRyeVsxXSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBWYWx1ZU5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgICAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcbiAgICAgIHZhciBrZXlNYXRjaCA9IGlzKGtleSwgdGhpcy5lbnRyeVswXSk7XG4gICAgICBpZiAoa2V5TWF0Y2ggPyB2YWx1ZSA9PT0gdGhpcy5lbnRyeVsxXSA6IHJlbW92ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIFNldFJlZihkaWRBbHRlcik7XG5cbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICAgICAgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgaWYgKGtleU1hdGNoKSB7XG4gICAgICAgIGlmIChvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRCkge1xuICAgICAgICAgIHRoaXMuZW50cnlbMV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICAgIHJldHVybiBtZXJnZUludG9Ob2RlKHRoaXMsIG93bmVySUQsIHNoaWZ0LCBoYXNoKGtleSksIFtrZXksIHZhbHVlXSk7XG4gICAgfTtcblxuXG5cbiAgLy8gI3ByYWdtYSBJdGVyYXRvcnNcblxuICBBcnJheU1hcE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPVxuICBIYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgIGZvciAodmFyIGlpID0gMCwgbWF4SW5kZXggPSBlbnRyaWVzLmxlbmd0aCAtIDE7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICBpZiAoZm4oZW50cmllc1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBCaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9XG4gIEhhc2hBcnJheU1hcE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgIGZvciAodmFyIGlpID0gMCwgbWF4SW5kZXggPSBub2Rlcy5sZW5ndGggLSAxOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcbiAgICAgIGlmIChub2RlICYmIG5vZGUuaXRlcmF0ZShmbiwgcmV2ZXJzZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBWYWx1ZU5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICByZXR1cm4gZm4odGhpcy5lbnRyeSk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhNYXBJdGVyYXRvciwgSXRlcmF0b3IpO1xuXG4gICAgZnVuY3Rpb24gTWFwSXRlcmF0b3IobWFwLCB0eXBlLCByZXZlcnNlKSB7XG4gICAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuX3JldmVyc2UgPSByZXZlcnNlO1xuICAgICAgdGhpcy5fc3RhY2sgPSBtYXAuX3Jvb3QgJiYgbWFwSXRlcmF0b3JGcmFtZShtYXAuX3Jvb3QpO1xuICAgIH1cblxuICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG4gICAgICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFjaztcbiAgICAgIHdoaWxlIChzdGFjaykge1xuICAgICAgICB2YXIgbm9kZSA9IHN0YWNrLm5vZGU7XG4gICAgICAgIHZhciBpbmRleCA9IHN0YWNrLmluZGV4Kys7XG4gICAgICAgIHZhciBtYXhJbmRleDtcbiAgICAgICAgaWYgKG5vZGUuZW50cnkpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIG5vZGUuZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICBtYXhJbmRleCA9IG5vZGUuZW50cmllcy5sZW5ndGggLSAxO1xuICAgICAgICAgIGlmIChpbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgbm9kZS5lbnRyaWVzW3RoaXMuX3JldmVyc2UgPyBtYXhJbmRleCAtIGluZGV4IDogaW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4SW5kZXggPSBub2RlLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKGluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc3ViTm9kZSA9IG5vZGUubm9kZXNbdGhpcy5fcmV2ZXJzZSA/IG1heEluZGV4IC0gaW5kZXggOiBpbmRleF07XG4gICAgICAgICAgICBpZiAoc3ViTm9kZSkge1xuICAgICAgICAgICAgICBpZiAoc3ViTm9kZS5lbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIHN1Yk5vZGUuZW50cnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YWNrID0gdGhpcy5fc3RhY2sgPSBtYXBJdGVyYXRvckZyYW1lKHN1Yk5vZGUsIHN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gdGhpcy5fc3RhY2suX19wcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgIH07XG5cblxuICBmdW5jdGlvbiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5KSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcEl0ZXJhdG9yRnJhbWUobm9kZSwgcHJldikge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgaW5kZXg6IDAsXG4gICAgICBfX3ByZXY6IHByZXZcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZU1hcChzaXplLCByb290LCBvd25lcklELCBoYXNoKSB7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUoTWFwUHJvdG90eXBlKTtcbiAgICBtYXAuc2l6ZSA9IHNpemU7XG4gICAgbWFwLl9yb290ID0gcm9vdDtcbiAgICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgICBtYXAuX19oYXNoID0gaGFzaDtcbiAgICBtYXAuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIHZhciBFTVBUWV9NQVA7XG4gIGZ1bmN0aW9uIGVtcHR5TWFwKCkge1xuICAgIHJldHVybiBFTVBUWV9NQVAgfHwgKEVNUFRZX01BUCA9IG1ha2VNYXAoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTWFwKG1hcCwgaywgdikge1xuICAgIHZhciBuZXdSb290O1xuICAgIHZhciBuZXdTaXplO1xuICAgIGlmICghbWFwLl9yb290KSB7XG4gICAgICBpZiAodiA9PT0gTk9UX1NFVCkge1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfVxuICAgICAgbmV3U2l6ZSA9IDE7XG4gICAgICBuZXdSb290ID0gbmV3IEFycmF5TWFwTm9kZShtYXAuX19vd25lcklELCBbW2ssIHZdXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaWRDaGFuZ2VTaXplID0gTWFrZVJlZihDSEFOR0VfTEVOR1RIKTtcbiAgICAgIHZhciBkaWRBbHRlciA9IE1ha2VSZWYoRElEX0FMVEVSKTtcbiAgICAgIG5ld1Jvb3QgPSB1cGRhdGVOb2RlKG1hcC5fcm9vdCwgbWFwLl9fb3duZXJJRCwgMCwgdW5kZWZpbmVkLCBrLCB2LCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcik7XG4gICAgICBpZiAoIWRpZEFsdGVyLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9XG4gICAgICBuZXdTaXplID0gbWFwLnNpemUgKyAoZGlkQ2hhbmdlU2l6ZS52YWx1ZSA/IHYgPT09IE5PVF9TRVQgPyAtMSA6IDEgOiAwKTtcbiAgICB9XG4gICAgaWYgKG1hcC5fX293bmVySUQpIHtcbiAgICAgIG1hcC5zaXplID0gbmV3U2l6ZTtcbiAgICAgIG1hcC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgICBtYXAuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgbWFwLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Um9vdCA/IG1ha2VNYXAobmV3U2l6ZSwgbmV3Um9vdCkgOiBlbXB0eU1hcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTm9kZShub2RlLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gTk9UX1NFVCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBba2V5LCB2YWx1ZV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS51cGRhdGUob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGVhZk5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLmNvbnN0cnVjdG9yID09PSBWYWx1ZU5vZGUgfHwgbm9kZS5jb25zdHJ1Y3RvciA9PT0gSGFzaENvbGxpc2lvbk5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUludG9Ob2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBlbnRyeSkge1xuICAgIGlmIChub2RlLmtleUhhc2ggPT09IGtleUhhc2gpIHtcbiAgICAgIHJldHVybiBuZXcgSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwga2V5SGFzaCwgW25vZGUuZW50cnksIGVudHJ5XSk7XG4gICAgfVxuXG4gICAgdmFyIGlkeDEgPSAoc2hpZnQgPT09IDAgPyBub2RlLmtleUhhc2ggOiBub2RlLmtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgdmFyIGlkeDIgPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcblxuICAgIHZhciBuZXdOb2RlO1xuICAgIHZhciBub2RlcyA9IGlkeDEgPT09IGlkeDIgP1xuICAgICAgW21lcmdlSW50b05vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQgKyBTSElGVCwga2V5SGFzaCwgZW50cnkpXSA6XG4gICAgICAoKG5ld05vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJ5KSksIGlkeDEgPCBpZHgyID8gW25vZGUsIG5ld05vZGVdIDogW25ld05vZGUsIG5vZGVdKTtcblxuICAgIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgKDEgPDwgaWR4MSkgfCAoMSA8PCBpZHgyKSwgbm9kZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZXMob3duZXJJRCwgZW50cmllcywga2V5LCB2YWx1ZSkge1xuICAgIGlmICghb3duZXJJRCkge1xuICAgICAgb3duZXJJRCA9IG5ldyBPd25lcklEKCk7XG4gICAgfVxuICAgIHZhciBub2RlID0gbmV3IFZhbHVlTm9kZShvd25lcklELCBoYXNoKGtleSksIFtrZXksIHZhbHVlXSk7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGVudHJpZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2lpXTtcbiAgICAgIG5vZGUgPSBub2RlLnVwZGF0ZShvd25lcklELCAwLCB1bmRlZmluZWQsIGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFja05vZGVzKG93bmVySUQsIG5vZGVzLCBjb3VudCwgZXhjbHVkaW5nKSB7XG4gICAgdmFyIGJpdG1hcCA9IDA7XG4gICAgdmFyIHBhY2tlZElJID0gMDtcbiAgICB2YXIgcGFja2VkTm9kZXMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAodmFyIGlpID0gMCwgYml0ID0gMSwgbGVuID0gbm9kZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKywgYml0IDw8PSAxKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2lpXTtcbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgaWkgIT09IGV4Y2x1ZGluZykge1xuICAgICAgICBiaXRtYXAgfD0gYml0O1xuICAgICAgICBwYWNrZWROb2Rlc1twYWNrZWRJSSsrXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgYml0bWFwLCBwYWNrZWROb2Rlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBleHBhbmROb2Rlcyhvd25lcklELCBub2RlcywgYml0bWFwLCBpbmNsdWRpbmcsIG5vZGUpIHtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBleHBhbmRlZE5vZGVzID0gbmV3IEFycmF5KFNJWkUpO1xuICAgIGZvciAodmFyIGlpID0gMDsgYml0bWFwICE9PSAwOyBpaSsrLCBiaXRtYXAgPj4+PSAxKSB7XG4gICAgICBleHBhbmRlZE5vZGVzW2lpXSA9IGJpdG1hcCAmIDEgPyBub2Rlc1tjb3VudCsrXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZXhwYW5kZWROb2Rlc1tpbmNsdWRpbmddID0gbm9kZTtcbiAgICByZXR1cm4gbmV3IEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgY291bnQgKyAxLCBleHBhbmRlZE5vZGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSW50b01hcFdpdGgobWFwLCBtZXJnZXIsIGl0ZXJhYmxlcykge1xuICAgIHZhciBpdGVycyA9IFtdO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVyYWJsZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVyYWJsZXNbaWldO1xuICAgICAgdmFyIGl0ZXIgPSBLZXllZEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgIGlmICghaXNJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgaXRlciA9IGl0ZXIubWFwKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIGZyb21KUyh2KX0pO1xuICAgICAgfVxuICAgICAgaXRlcnMucHVzaChpdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlSW50b0NvbGxlY3Rpb25XaXRoKG1hcCwgbWVyZ2VyLCBpdGVycyk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWVwTWVyZ2VyKGV4aXN0aW5nLCB2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nICYmIGV4aXN0aW5nLm1lcmdlRGVlcCAmJiBpc0l0ZXJhYmxlKHZhbHVlKSA/XG4gICAgICBleGlzdGluZy5tZXJnZURlZXAodmFsdWUpIDpcbiAgICAgIGlzKGV4aXN0aW5nLCB2YWx1ZSkgPyBleGlzdGluZyA6IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVlcE1lcmdlcldpdGgobWVyZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV4aXN0aW5nLCB2YWx1ZSwga2V5KSAge1xuICAgICAgaWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nLm1lcmdlRGVlcFdpdGggJiYgaXNJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nLm1lcmdlRGVlcFdpdGgobWVyZ2VyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dFZhbHVlID0gbWVyZ2VyKGV4aXN0aW5nLCB2YWx1ZSwga2V5KTtcbiAgICAgIHJldHVybiBpcyhleGlzdGluZywgbmV4dFZhbHVlKSA/IGV4aXN0aW5nIDogbmV4dFZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUludG9Db2xsZWN0aW9uV2l0aChjb2xsZWN0aW9uLCBtZXJnZXIsIGl0ZXJzKSB7XG4gICAgaXRlcnMgPSBpdGVycy5maWx0ZXIoZnVuY3Rpb24oeCApIHtyZXR1cm4geC5zaXplICE9PSAwfSk7XG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uLnNpemUgPT09IDAgJiYgIWNvbGxlY3Rpb24uX19vd25lcklEICYmIGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uY29uc3RydWN0b3IoaXRlcnNbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbi53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKGNvbGxlY3Rpb24gKSB7XG4gICAgICB2YXIgbWVyZ2VJbnRvTWFwID0gbWVyZ2VyID9cbiAgICAgICAgZnVuY3Rpb24odmFsdWUsIGtleSkgIHtcbiAgICAgICAgICBjb2xsZWN0aW9uLnVwZGF0ZShrZXksIE5PVF9TRVQsIGZ1bmN0aW9uKGV4aXN0aW5nIClcbiAgICAgICAgICAgIHtyZXR1cm4gZXhpc3RpbmcgPT09IE5PVF9TRVQgPyB2YWx1ZSA6IG1lcmdlcihleGlzdGluZywgdmFsdWUsIGtleSl9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSA6XG4gICAgICAgIGZ1bmN0aW9uKHZhbHVlLCBrZXkpICB7XG4gICAgICAgICAgY29sbGVjdGlvbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgaXRlcnNbaWldLmZvckVhY2gobWVyZ2VJbnRvTWFwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUluRGVlcE1hcChleGlzdGluZywga2V5UGF0aEl0ZXIsIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gICAgdmFyIGlzTm90U2V0ID0gZXhpc3RpbmcgPT09IE5PVF9TRVQ7XG4gICAgdmFyIHN0ZXAgPSBrZXlQYXRoSXRlci5uZXh0KCk7XG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSBpc05vdFNldCA/IG5vdFNldFZhbHVlIDogZXhpc3Rpbmc7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB1cGRhdGVyKGV4aXN0aW5nVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ld1ZhbHVlID09PSBleGlzdGluZ1ZhbHVlID8gZXhpc3RpbmcgOiBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgaXNOb3RTZXQgfHwgKGV4aXN0aW5nICYmIGV4aXN0aW5nLnNldCksXG4gICAgICAnaW52YWxpZCBrZXlQYXRoJ1xuICAgICk7XG4gICAgdmFyIGtleSA9IHN0ZXAudmFsdWU7XG4gICAgdmFyIG5leHRFeGlzdGluZyA9IGlzTm90U2V0ID8gTk9UX1NFVCA6IGV4aXN0aW5nLmdldChrZXksIE5PVF9TRVQpO1xuICAgIHZhciBuZXh0VXBkYXRlZCA9IHVwZGF0ZUluRGVlcE1hcChcbiAgICAgIG5leHRFeGlzdGluZyxcbiAgICAgIGtleVBhdGhJdGVyLFxuICAgICAgbm90U2V0VmFsdWUsXG4gICAgICB1cGRhdGVyXG4gICAgKTtcbiAgICByZXR1cm4gbmV4dFVwZGF0ZWQgPT09IG5leHRFeGlzdGluZyA/IGV4aXN0aW5nIDpcbiAgICAgIG5leHRVcGRhdGVkID09PSBOT1RfU0VUID8gZXhpc3RpbmcucmVtb3ZlKGtleSkgOlxuICAgICAgKGlzTm90U2V0ID8gZW1wdHlNYXAoKSA6IGV4aXN0aW5nKS5zZXQoa2V5LCBuZXh0VXBkYXRlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BDb3VudCh4KSB7XG4gICAgeCA9IHggLSAoKHggPj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgICB4ID0gKHggJiAweDMzMzMzMzMzKSArICgoeCA+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICAgIHggPSAoeCArICh4ID4+IDQpKSAmIDB4MGYwZjBmMGY7XG4gICAgeCA9IHggKyAoeCA+PiA4KTtcbiAgICB4ID0geCArICh4ID4+IDE2KTtcbiAgICByZXR1cm4geCAmIDB4N2Y7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRJbihhcnJheSwgaWR4LCB2YWwsIGNhbkVkaXQpIHtcbiAgICB2YXIgbmV3QXJyYXkgPSBjYW5FZGl0ID8gYXJyYXkgOiBhcnJDb3B5KGFycmF5KTtcbiAgICBuZXdBcnJheVtpZHhdID0gdmFsO1xuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGljZUluKGFycmF5LCBpZHgsIHZhbCwgY2FuRWRpdCkge1xuICAgIHZhciBuZXdMZW4gPSBhcnJheS5sZW5ndGggKyAxO1xuICAgIGlmIChjYW5FZGl0ICYmIGlkeCArIDEgPT09IG5ld0xlbikge1xuICAgICAgYXJyYXlbaWR4XSA9IHZhbDtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgdmFyIG5ld0FycmF5ID0gbmV3IEFycmF5KG5ld0xlbik7XG4gICAgdmFyIGFmdGVyID0gMDtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmV3TGVuOyBpaSsrKSB7XG4gICAgICBpZiAoaWkgPT09IGlkeCkge1xuICAgICAgICBuZXdBcnJheVtpaV0gPSB2YWw7XG4gICAgICAgIGFmdGVyID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdBcnJheVtpaV0gPSBhcnJheVtpaSArIGFmdGVyXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaWNlT3V0KGFycmF5LCBpZHgsIGNhbkVkaXQpIHtcbiAgICB2YXIgbmV3TGVuID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICBpZiAoY2FuRWRpdCAmJiBpZHggPT09IG5ld0xlbikge1xuICAgICAgYXJyYXkucG9wKCk7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdMZW4pO1xuICAgIHZhciBhZnRlciA9IDA7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5ld0xlbjsgaWkrKykge1xuICAgICAgaWYgKGlpID09PSBpZHgpIHtcbiAgICAgICAgYWZ0ZXIgPSAxO1xuICAgICAgfVxuICAgICAgbmV3QXJyYXlbaWldID0gYXJyYXlbaWkgKyBhZnRlcl07XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfVxuXG4gIHZhciBNQVhfQVJSQVlfTUFQX1NJWkUgPSBTSVpFIC8gNDtcbiAgdmFyIE1BWF9CSVRNQVBfSU5ERVhFRF9TSVpFID0gU0laRSAvIDI7XG4gIHZhciBNSU5fSEFTSF9BUlJBWV9NQVBfU0laRSA9IFNJWkUgLyA0O1xuXG4gIGNyZWF0ZUNsYXNzKExpc3QsIEluZGV4ZWRDb2xsZWN0aW9uKTtcblxuICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cbiAgICBmdW5jdGlvbiBMaXN0KHZhbHVlKSB7XG4gICAgICB2YXIgZW1wdHkgPSBlbXB0eUxpc3QoKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xpc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyID0gSW5kZXhlZEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgIHZhciBzaXplID0gaXRlci5zaXplO1xuICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgfVxuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoc2l6ZSk7XG4gICAgICBpZiAoc2l6ZSA+IDAgJiYgc2l6ZSA8IFNJWkUpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VMaXN0KDAsIHNpemUsIFNISUZULCBudWxsLCBuZXcgVk5vZGUoaXRlci50b0FycmF5KCkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKGxpc3QgKSB7XG4gICAgICAgIGxpc3Quc2V0U2l6ZShzaXplKTtcbiAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uKHYsIGkpICB7cmV0dXJuIGxpc3Quc2V0KGksIHYpfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBMaXN0Lm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ0xpc3QgWycsICddJyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICAgIGluZGV4ICs9IHRoaXMuX29yaWdpbjtcbiAgICAgICAgdmFyIG5vZGUgPSBsaXN0Tm9kZUZvcih0aGlzLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBub2RlICYmIG5vZGUuYXJyYXlbaW5kZXggJiBNQVNLXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIExpc3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZUxpc3QodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5oYXMoaW5kZXgpID8gdGhpcyA6XG4gICAgICAgIGluZGV4ID09PSAwID8gdGhpcy5zaGlmdCgpIDpcbiAgICAgICAgaW5kZXggPT09IHRoaXMuc2l6ZSAtIDEgPyB0aGlzLnBvcCgpIDpcbiAgICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLl9vcmlnaW4gPSB0aGlzLl9jYXBhY2l0eSA9IDA7XG4gICAgICAgIHRoaXMuX2xldmVsID0gU0hJRlQ7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLl90YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlMaXN0KCk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIG9sZFNpemUgPSB0aGlzLnNpemU7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKGxpc3QgKSB7XG4gICAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgMCwgb2xkU2l6ZSArIHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmFsdWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgIGxpc3Quc2V0KG9sZFNpemUgKyBpaSwgdmFsdWVzW2lpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDAsIC0xKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKGxpc3QgKSB7XG4gICAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgLXZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmFsdWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgIGxpc3Quc2V0KGlpLCB2YWx1ZXNbaWldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAxKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gICAgTGlzdC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbigvKi4uLml0ZXJzKi8pIHtcbiAgICAgIHJldHVybiBtZXJnZUludG9MaXN0V2l0aCh0aGlzLCB1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLm1lcmdlV2l0aCA9IGZ1bmN0aW9uKG1lcmdlcikge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIG1lcmdlSW50b0xpc3RXaXRoKHRoaXMsIG1lcmdlciwgaXRlcnMpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5tZXJnZURlZXAgPSBmdW5jdGlvbigvKi4uLml0ZXJzKi8pIHtcbiAgICAgIHJldHVybiBtZXJnZUludG9MaXN0V2l0aCh0aGlzLCBkZWVwTWVyZ2VyLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gZnVuY3Rpb24obWVyZ2VyKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTGlzdFdpdGgodGhpcywgZGVlcE1lcmdlcldpdGgobWVyZ2VyKSwgaXRlcnMpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgcmV0dXJuIHNldExpc3RCb3VuZHModGhpcywgMCwgc2l6ZSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgSXRlcmF0aW9uXG5cbiAgICBMaXN0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKSxcbiAgICAgICAgcmVzb2x2ZUVuZChlbmQsIHNpemUpXG4gICAgICApO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciB2YWx1ZXMgPSBpdGVyYXRlTGlzdCh0aGlzLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBET05FID9cbiAgICAgICAgICBpdGVyYXRvckRvbmUoKSA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBpbmRleCsrLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgdmFsdWVzID0gaXRlcmF0ZUxpc3QodGhpcywgcmV2ZXJzZSk7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB3aGlsZSAoKHZhbHVlID0gdmFsdWVzKCkpICE9PSBET05FKSB7XG4gICAgICAgIGlmIChmbih2YWx1ZSwgaW5kZXgrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VMaXN0KHRoaXMuX29yaWdpbiwgdGhpcy5fY2FwYWNpdHksIHRoaXMuX2xldmVsLCB0aGlzLl9yb290LCB0aGlzLl90YWlsLCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gICAgfTtcblxuXG4gIGZ1bmN0aW9uIGlzTGlzdChtYXliZUxpc3QpIHtcbiAgICByZXR1cm4gISEobWF5YmVMaXN0ICYmIG1heWJlTGlzdFtJU19MSVNUX1NFTlRJTkVMXSk7XG4gIH1cblxuICBMaXN0LmlzTGlzdCA9IGlzTGlzdDtcblxuICB2YXIgSVNfTElTVF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0xJU1RfX0BAJztcblxuICB2YXIgTGlzdFByb3RvdHlwZSA9IExpc3QucHJvdG90eXBlO1xuICBMaXN0UHJvdG90eXBlW0lTX0xJU1RfU0VOVElORUxdID0gdHJ1ZTtcbiAgTGlzdFByb3RvdHlwZVtERUxFVEVdID0gTGlzdFByb3RvdHlwZS5yZW1vdmU7XG4gIExpc3RQcm90b3R5cGUuc2V0SW4gPSBNYXBQcm90b3R5cGUuc2V0SW47XG4gIExpc3RQcm90b3R5cGUuZGVsZXRlSW4gPVxuICBMaXN0UHJvdG90eXBlLnJlbW92ZUluID0gTWFwUHJvdG90eXBlLnJlbW92ZUluO1xuICBMaXN0UHJvdG90eXBlLnVwZGF0ZSA9IE1hcFByb3RvdHlwZS51cGRhdGU7XG4gIExpc3RQcm90b3R5cGUudXBkYXRlSW4gPSBNYXBQcm90b3R5cGUudXBkYXRlSW47XG4gIExpc3RQcm90b3R5cGUubWVyZ2VJbiA9IE1hcFByb3RvdHlwZS5tZXJnZUluO1xuICBMaXN0UHJvdG90eXBlLm1lcmdlRGVlcEluID0gTWFwUHJvdG90eXBlLm1lcmdlRGVlcEluO1xuICBMaXN0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSBNYXBQcm90b3R5cGUud2l0aE11dGF0aW9ucztcbiAgTGlzdFByb3RvdHlwZS5hc011dGFibGUgPSBNYXBQcm90b3R5cGUuYXNNdXRhYmxlO1xuICBMaXN0UHJvdG90eXBlLmFzSW1tdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzSW1tdXRhYmxlO1xuICBMaXN0UHJvdG90eXBlLndhc0FsdGVyZWQgPSBNYXBQcm90b3R5cGUud2FzQWx0ZXJlZDtcblxuXG5cbiAgICBmdW5jdGlvbiBWTm9kZShhcnJheSwgb3duZXJJRCkge1xuICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBzZWVtcyBsaWtlIHRoZXNlIG1ldGhvZHMgYXJlIHZlcnkgc2ltaWxhclxuXG4gICAgVk5vZGUucHJvdG90eXBlLnJlbW92ZUJlZm9yZSA9IGZ1bmN0aW9uKG93bmVySUQsIGxldmVsLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSBsZXZlbCA/IDEgPDwgbGV2ZWwgOiAwIHx8IHRoaXMuYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG9yaWdpbkluZGV4ID0gKGluZGV4ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgICAgaWYgKG9yaWdpbkluZGV4ID49IHRoaXMuYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVk5vZGUoW10sIG93bmVySUQpO1xuICAgICAgfVxuICAgICAgdmFyIHJlbW92aW5nRmlyc3QgPSBvcmlnaW5JbmRleCA9PT0gMDtcbiAgICAgIHZhciBuZXdDaGlsZDtcbiAgICAgIGlmIChsZXZlbCA+IDApIHtcbiAgICAgICAgdmFyIG9sZENoaWxkID0gdGhpcy5hcnJheVtvcmlnaW5JbmRleF07XG4gICAgICAgIG5ld0NoaWxkID0gb2xkQ2hpbGQgJiYgb2xkQ2hpbGQucmVtb3ZlQmVmb3JlKG93bmVySUQsIGxldmVsIC0gU0hJRlQsIGluZGV4KTtcbiAgICAgICAgaWYgKG5ld0NoaWxkID09PSBvbGRDaGlsZCAmJiByZW1vdmluZ0ZpcnN0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdmluZ0ZpcnN0ICYmICFuZXdDaGlsZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRhYmxlVk5vZGUodGhpcywgb3duZXJJRCk7XG4gICAgICBpZiAoIXJlbW92aW5nRmlyc3QpIHtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG9yaWdpbkluZGV4OyBpaSsrKSB7XG4gICAgICAgICAgZWRpdGFibGUuYXJyYXlbaWldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgICAgZWRpdGFibGUuYXJyYXlbb3JpZ2luSW5kZXhdID0gbmV3Q2hpbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRpdGFibGU7XG4gICAgfTtcblxuICAgIFZOb2RlLnByb3RvdHlwZS5yZW1vdmVBZnRlciA9IGZ1bmN0aW9uKG93bmVySUQsIGxldmVsLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSAobGV2ZWwgPyAxIDw8IGxldmVsIDogMCkgfHwgdGhpcy5hcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgc2l6ZUluZGV4ID0gKChpbmRleCAtIDEpID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgICAgaWYgKHNpemVJbmRleCA+PSB0aGlzLmFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0NoaWxkO1xuICAgICAgaWYgKGxldmVsID4gMCkge1xuICAgICAgICB2YXIgb2xkQ2hpbGQgPSB0aGlzLmFycmF5W3NpemVJbmRleF07XG4gICAgICAgIG5ld0NoaWxkID0gb2xkQ2hpbGQgJiYgb2xkQ2hpbGQucmVtb3ZlQWZ0ZXIob3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgpO1xuICAgICAgICBpZiAobmV3Q2hpbGQgPT09IG9sZENoaWxkICYmIHNpemVJbmRleCA9PT0gdGhpcy5hcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdGFibGVWTm9kZSh0aGlzLCBvd25lcklEKTtcbiAgICAgIGVkaXRhYmxlLmFycmF5LnNwbGljZShzaXplSW5kZXggKyAxKTtcbiAgICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgICBlZGl0YWJsZS5hcnJheVtzaXplSW5kZXhdID0gbmV3Q2hpbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRpdGFibGU7XG4gICAgfTtcblxuXG5cbiAgdmFyIERPTkUgPSB7fTtcblxuICBmdW5jdGlvbiBpdGVyYXRlTGlzdChsaXN0LCByZXZlcnNlKSB7XG4gICAgdmFyIGxlZnQgPSBsaXN0Ll9vcmlnaW47XG4gICAgdmFyIHJpZ2h0ID0gbGlzdC5fY2FwYWNpdHk7XG4gICAgdmFyIHRhaWxQb3MgPSBnZXRUYWlsT2Zmc2V0KHJpZ2h0KTtcbiAgICB2YXIgdGFpbCA9IGxpc3QuX3RhaWw7XG5cbiAgICByZXR1cm4gaXRlcmF0ZU5vZGVPckxlYWYobGlzdC5fcm9vdCwgbGlzdC5fbGV2ZWwsIDApO1xuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZU5vZGVPckxlYWYobm9kZSwgbGV2ZWwsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGxldmVsID09PSAwID9cbiAgICAgICAgaXRlcmF0ZUxlYWYobm9kZSwgb2Zmc2V0KSA6XG4gICAgICAgIGl0ZXJhdGVOb2RlKG5vZGUsIGxldmVsLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVMZWFmKG5vZGUsIG9mZnNldCkge1xuICAgICAgdmFyIGFycmF5ID0gb2Zmc2V0ID09PSB0YWlsUG9zID8gdGFpbCAmJiB0YWlsLmFycmF5IDogbm9kZSAmJiBub2RlLmFycmF5O1xuICAgICAgdmFyIGZyb20gPSBvZmZzZXQgPiBsZWZ0ID8gMCA6IGxlZnQgLSBvZmZzZXQ7XG4gICAgICB2YXIgdG8gPSByaWdodCAtIG9mZnNldDtcbiAgICAgIGlmICh0byA+IFNJWkUpIHtcbiAgICAgICAgdG8gPSBTSVpFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgcmV0dXJuIERPTkU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkeCA9IHJldmVyc2UgPyAtLXRvIDogZnJvbSsrO1xuICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXlbaWR4XTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZU5vZGUobm9kZSwgbGV2ZWwsIG9mZnNldCkge1xuICAgICAgdmFyIHZhbHVlcztcbiAgICAgIHZhciBhcnJheSA9IG5vZGUgJiYgbm9kZS5hcnJheTtcbiAgICAgIHZhciBmcm9tID0gb2Zmc2V0ID4gbGVmdCA/IDAgOiAobGVmdCAtIG9mZnNldCkgPj4gbGV2ZWw7XG4gICAgICB2YXIgdG8gPSAoKHJpZ2h0IC0gb2Zmc2V0KSA+PiBsZXZlbCkgKyAxO1xuICAgICAgaWYgKHRvID4gU0laRSkge1xuICAgICAgICB0byA9IFNJWkU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSAge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IERPTkUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gRE9ORTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlkeCA9IHJldmVyc2UgPyAtLXRvIDogZnJvbSsrO1xuICAgICAgICAgIHZhbHVlcyA9IGl0ZXJhdGVOb2RlT3JMZWFmKFxuICAgICAgICAgICAgYXJyYXkgJiYgYXJyYXlbaWR4XSwgbGV2ZWwgLSBTSElGVCwgb2Zmc2V0ICsgKGlkeCA8PCBsZXZlbClcbiAgICAgICAgICApO1xuICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZUxpc3Qob3JpZ2luLCBjYXBhY2l0eSwgbGV2ZWwsIHJvb3QsIHRhaWwsIG93bmVySUQsIGhhc2gpIHtcbiAgICB2YXIgbGlzdCA9IE9iamVjdC5jcmVhdGUoTGlzdFByb3RvdHlwZSk7XG4gICAgbGlzdC5zaXplID0gY2FwYWNpdHkgLSBvcmlnaW47XG4gICAgbGlzdC5fb3JpZ2luID0gb3JpZ2luO1xuICAgIGxpc3QuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgbGlzdC5fbGV2ZWwgPSBsZXZlbDtcbiAgICBsaXN0Ll9yb290ID0gcm9vdDtcbiAgICBsaXN0Ll90YWlsID0gdGFpbDtcbiAgICBsaXN0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgbGlzdC5fX2hhc2ggPSBoYXNoO1xuICAgIGxpc3QuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICB2YXIgRU1QVFlfTElTVDtcbiAgZnVuY3Rpb24gZW1wdHlMaXN0KCkge1xuICAgIHJldHVybiBFTVBUWV9MSVNUIHx8IChFTVBUWV9MSVNUID0gbWFrZUxpc3QoMCwgMCwgU0hJRlQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpc3QobGlzdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgaW5kZXggPSB3cmFwSW5kZXgobGlzdCwgaW5kZXgpO1xuXG4gICAgaWYgKGluZGV4ICE9PSBpbmRleCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID49IGxpc3Quc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBsaXN0LndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obGlzdCApIHtcbiAgICAgICAgaW5kZXggPCAwID9cbiAgICAgICAgICBzZXRMaXN0Qm91bmRzKGxpc3QsIGluZGV4KS5zZXQoMCwgdmFsdWUpIDpcbiAgICAgICAgICBzZXRMaXN0Qm91bmRzKGxpc3QsIDAsIGluZGV4ICsgMSkuc2V0KGluZGV4LCB2YWx1ZSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGluZGV4ICs9IGxpc3QuX29yaWdpbjtcblxuICAgIHZhciBuZXdUYWlsID0gbGlzdC5fdGFpbDtcbiAgICB2YXIgbmV3Um9vdCA9IGxpc3QuX3Jvb3Q7XG4gICAgdmFyIGRpZEFsdGVyID0gTWFrZVJlZihESURfQUxURVIpO1xuICAgIGlmIChpbmRleCA+PSBnZXRUYWlsT2Zmc2V0KGxpc3QuX2NhcGFjaXR5KSkge1xuICAgICAgbmV3VGFpbCA9IHVwZGF0ZVZOb2RlKG5ld1RhaWwsIGxpc3QuX19vd25lcklELCAwLCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Um9vdCA9IHVwZGF0ZVZOb2RlKG5ld1Jvb3QsIGxpc3QuX19vd25lcklELCBsaXN0Ll9sZXZlbCwgaW5kZXgsIHZhbHVlLCBkaWRBbHRlcik7XG4gICAgfVxuXG4gICAgaWYgKCFkaWRBbHRlci52YWx1ZSkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgaWYgKGxpc3QuX19vd25lcklEKSB7XG4gICAgICBsaXN0Ll9yb290ID0gbmV3Um9vdDtcbiAgICAgIGxpc3QuX3RhaWwgPSBuZXdUYWlsO1xuICAgICAgbGlzdC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICBsaXN0Ll9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VMaXN0KGxpc3QuX29yaWdpbiwgbGlzdC5fY2FwYWNpdHksIGxpc3QuX2xldmVsLCBuZXdSb290LCBuZXdUYWlsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVZOb2RlKG5vZGUsIG93bmVySUQsIGxldmVsLCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKSB7XG4gICAgdmFyIGlkeCA9IChpbmRleCA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgICB2YXIgbm9kZUhhcyA9IG5vZGUgJiYgaWR4IDwgbm9kZS5hcnJheS5sZW5ndGg7XG4gICAgaWYgKCFub2RlSGFzICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHZhciBuZXdOb2RlO1xuXG4gICAgaWYgKGxldmVsID4gMCkge1xuICAgICAgdmFyIGxvd2VyTm9kZSA9IG5vZGUgJiYgbm9kZS5hcnJheVtpZHhdO1xuICAgICAgdmFyIG5ld0xvd2VyTm9kZSA9IHVwZGF0ZVZOb2RlKGxvd2VyTm9kZSwgb3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgsIHZhbHVlLCBkaWRBbHRlcik7XG4gICAgICBpZiAobmV3TG93ZXJOb2RlID09PSBsb3dlck5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBuZXdOb2RlID0gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKTtcbiAgICAgIG5ld05vZGUuYXJyYXlbaWR4XSA9IG5ld0xvd2VyTm9kZTtcbiAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH1cblxuICAgIGlmIChub2RlSGFzICYmIG5vZGUuYXJyYXlbaWR4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIFNldFJlZihkaWRBbHRlcik7XG5cbiAgICBuZXdOb2RlID0gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBpZHggPT09IG5ld05vZGUuYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgICAgbmV3Tm9kZS5hcnJheS5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Tm9kZS5hcnJheVtpZHhdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgJiYgbm9kZSAmJiBvd25lcklEID09PSBub2RlLm93bmVySUQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGUgPyBub2RlLmFycmF5LnNsaWNlKCkgOiBbXSwgb3duZXJJRCk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0Tm9kZUZvcihsaXN0LCByYXdJbmRleCkge1xuICAgIGlmIChyYXdJbmRleCA+PSBnZXRUYWlsT2Zmc2V0KGxpc3QuX2NhcGFjaXR5KSkge1xuICAgICAgcmV0dXJuIGxpc3QuX3RhaWw7XG4gICAgfVxuICAgIGlmIChyYXdJbmRleCA8IDEgPDwgKGxpc3QuX2xldmVsICsgU0hJRlQpKSB7XG4gICAgICB2YXIgbm9kZSA9IGxpc3QuX3Jvb3Q7XG4gICAgICB2YXIgbGV2ZWwgPSBsaXN0Ll9sZXZlbDtcbiAgICAgIHdoaWxlIChub2RlICYmIGxldmVsID4gMCkge1xuICAgICAgICBub2RlID0gbm9kZS5hcnJheVsocmF3SW5kZXggPj4+IGxldmVsKSAmIE1BU0tdO1xuICAgICAgICBsZXZlbCAtPSBTSElGVDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExpc3RCb3VuZHMobGlzdCwgYmVnaW4sIGVuZCkge1xuICAgIC8vIFNhbml0aXplIGJlZ2luICYgZW5kIHVzaW5nIHRoaXMgc2hvcnRoYW5kIGZvciBUb0ludDMyKGFyZ3VtZW50KVxuICAgIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2ludDMyXG4gICAgaWYgKGJlZ2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJlZ2luID0gYmVnaW4gfCAwO1xuICAgIH1cbiAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IGVuZCB8IDA7XG4gICAgfVxuICAgIHZhciBvd25lciA9IGxpc3QuX19vd25lcklEIHx8IG5ldyBPd25lcklEKCk7XG4gICAgdmFyIG9sZE9yaWdpbiA9IGxpc3QuX29yaWdpbjtcbiAgICB2YXIgb2xkQ2FwYWNpdHkgPSBsaXN0Ll9jYXBhY2l0eTtcbiAgICB2YXIgbmV3T3JpZ2luID0gb2xkT3JpZ2luICsgYmVnaW47XG4gICAgdmFyIG5ld0NhcGFjaXR5ID0gZW5kID09PSB1bmRlZmluZWQgPyBvbGRDYXBhY2l0eSA6IGVuZCA8IDAgPyBvbGRDYXBhY2l0eSArIGVuZCA6IG9sZE9yaWdpbiArIGVuZDtcbiAgICBpZiAobmV3T3JpZ2luID09PSBvbGRPcmlnaW4gJiYgbmV3Q2FwYWNpdHkgPT09IG9sZENhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvLyBJZiBpdCdzIGdvaW5nIHRvIGVuZCBhZnRlciBpdCBzdGFydHMsIGl0J3MgZW1wdHkuXG4gICAgaWYgKG5ld09yaWdpbiA+PSBuZXdDYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIGxpc3QuY2xlYXIoKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGV2ZWwgPSBsaXN0Ll9sZXZlbDtcbiAgICB2YXIgbmV3Um9vdCA9IGxpc3QuX3Jvb3Q7XG5cbiAgICAvLyBOZXcgb3JpZ2luIG1pZ2h0IG5lZWQgY3JlYXRpbmcgYSBoaWdoZXIgcm9vdC5cbiAgICB2YXIgb2Zmc2V0U2hpZnQgPSAwO1xuICAgIHdoaWxlIChuZXdPcmlnaW4gKyBvZmZzZXRTaGlmdCA8IDApIHtcbiAgICAgIG5ld1Jvb3QgPSBuZXcgVk5vZGUobmV3Um9vdCAmJiBuZXdSb290LmFycmF5Lmxlbmd0aCA/IFt1bmRlZmluZWQsIG5ld1Jvb3RdIDogW10sIG93bmVyKTtcbiAgICAgIG5ld0xldmVsICs9IFNISUZUO1xuICAgICAgb2Zmc2V0U2hpZnQgKz0gMSA8PCBuZXdMZXZlbDtcbiAgICB9XG4gICAgaWYgKG9mZnNldFNoaWZ0KSB7XG4gICAgICBuZXdPcmlnaW4gKz0gb2Zmc2V0U2hpZnQ7XG4gICAgICBvbGRPcmlnaW4gKz0gb2Zmc2V0U2hpZnQ7XG4gICAgICBuZXdDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgICAgIG9sZENhcGFjaXR5ICs9IG9mZnNldFNoaWZ0O1xuICAgIH1cblxuICAgIHZhciBvbGRUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChvbGRDYXBhY2l0eSk7XG4gICAgdmFyIG5ld1RhaWxPZmZzZXQgPSBnZXRUYWlsT2Zmc2V0KG5ld0NhcGFjaXR5KTtcblxuICAgIC8vIE5ldyBzaXplIG1pZ2h0IG5lZWQgY3JlYXRpbmcgYSBoaWdoZXIgcm9vdC5cbiAgICB3aGlsZSAobmV3VGFpbE9mZnNldCA+PSAxIDw8IChuZXdMZXZlbCArIFNISUZUKSkge1xuICAgICAgbmV3Um9vdCA9IG5ldyBWTm9kZShuZXdSb290ICYmIG5ld1Jvb3QuYXJyYXkubGVuZ3RoID8gW25ld1Jvb3RdIDogW10sIG93bmVyKTtcbiAgICAgIG5ld0xldmVsICs9IFNISUZUO1xuICAgIH1cblxuICAgIC8vIExvY2F0ZSBvciBjcmVhdGUgdGhlIG5ldyB0YWlsLlxuICAgIHZhciBvbGRUYWlsID0gbGlzdC5fdGFpbDtcbiAgICB2YXIgbmV3VGFpbCA9IG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0ID9cbiAgICAgIGxpc3ROb2RlRm9yKGxpc3QsIG5ld0NhcGFjaXR5IC0gMSkgOlxuICAgICAgbmV3VGFpbE9mZnNldCA+IG9sZFRhaWxPZmZzZXQgPyBuZXcgVk5vZGUoW10sIG93bmVyKSA6IG9sZFRhaWw7XG5cbiAgICAvLyBNZXJnZSBUYWlsIGludG8gdHJlZS5cbiAgICBpZiAob2xkVGFpbCAmJiBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldCAmJiBuZXdPcmlnaW4gPCBvbGRDYXBhY2l0eSAmJiBvbGRUYWlsLmFycmF5Lmxlbmd0aCkge1xuICAgICAgbmV3Um9vdCA9IGVkaXRhYmxlVk5vZGUobmV3Um9vdCwgb3duZXIpO1xuICAgICAgdmFyIG5vZGUgPSBuZXdSb290O1xuICAgICAgZm9yICh2YXIgbGV2ZWwgPSBuZXdMZXZlbDsgbGV2ZWwgPiBTSElGVDsgbGV2ZWwgLT0gU0hJRlQpIHtcbiAgICAgICAgdmFyIGlkeCA9IChvbGRUYWlsT2Zmc2V0ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgICAgICBub2RlID0gbm9kZS5hcnJheVtpZHhdID0gZWRpdGFibGVWTm9kZShub2RlLmFycmF5W2lkeF0sIG93bmVyKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuYXJyYXlbKG9sZFRhaWxPZmZzZXQgPj4+IFNISUZUKSAmIE1BU0tdID0gb2xkVGFpbDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2l6ZSBoYXMgYmVlbiByZWR1Y2VkLCB0aGVyZSdzIGEgY2hhbmNlIHRoZSB0YWlsIG5lZWRzIHRvIGJlIHRyaW1tZWQuXG4gICAgaWYgKG5ld0NhcGFjaXR5IDwgb2xkQ2FwYWNpdHkpIHtcbiAgICAgIG5ld1RhaWwgPSBuZXdUYWlsICYmIG5ld1RhaWwucmVtb3ZlQWZ0ZXIob3duZXIsIDAsIG5ld0NhcGFjaXR5KTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbmV3IG9yaWdpbiBpcyB3aXRoaW4gdGhlIHRhaWwsIHRoZW4gd2UgZG8gbm90IG5lZWQgYSByb290LlxuICAgIGlmIChuZXdPcmlnaW4gPj0gbmV3VGFpbE9mZnNldCkge1xuICAgICAgbmV3T3JpZ2luIC09IG5ld1RhaWxPZmZzZXQ7XG4gICAgICBuZXdDYXBhY2l0eSAtPSBuZXdUYWlsT2Zmc2V0O1xuICAgICAgbmV3TGV2ZWwgPSBTSElGVDtcbiAgICAgIG5ld1Jvb3QgPSBudWxsO1xuICAgICAgbmV3VGFpbCA9IG5ld1RhaWwgJiYgbmV3VGFpbC5yZW1vdmVCZWZvcmUob3duZXIsIDAsIG5ld09yaWdpbik7XG5cbiAgICAvLyBPdGhlcndpc2UsIGlmIHRoZSByb290IGhhcyBiZWVuIHRyaW1tZWQsIGdhcmJhZ2UgY29sbGVjdC5cbiAgICB9IGVsc2UgaWYgKG5ld09yaWdpbiA+IG9sZE9yaWdpbiB8fCBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCkge1xuICAgICAgb2Zmc2V0U2hpZnQgPSAwO1xuXG4gICAgICAvLyBJZGVudGlmeSB0aGUgbmV3IHRvcCByb290IG5vZGUgb2YgdGhlIHN1YnRyZWUgb2YgdGhlIG9sZCByb290LlxuICAgICAgd2hpbGUgKG5ld1Jvb3QpIHtcbiAgICAgICAgdmFyIGJlZ2luSW5kZXggPSAobmV3T3JpZ2luID4+PiBuZXdMZXZlbCkgJiBNQVNLO1xuICAgICAgICBpZiAoYmVnaW5JbmRleCAhPT0gKG5ld1RhaWxPZmZzZXQgPj4+IG5ld0xldmVsKSAmIE1BU0spIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVnaW5JbmRleCkge1xuICAgICAgICAgIG9mZnNldFNoaWZ0ICs9ICgxIDw8IG5ld0xldmVsKSAqIGJlZ2luSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgbmV3TGV2ZWwgLT0gU0hJRlQ7XG4gICAgICAgIG5ld1Jvb3QgPSBuZXdSb290LmFycmF5W2JlZ2luSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICAvLyBUcmltIHRoZSBuZXcgc2lkZXMgb2YgdGhlIG5ldyByb290LlxuICAgICAgaWYgKG5ld1Jvb3QgJiYgbmV3T3JpZ2luID4gb2xkT3JpZ2luKSB7XG4gICAgICAgIG5ld1Jvb3QgPSBuZXdSb290LnJlbW92ZUJlZm9yZShvd25lciwgbmV3TGV2ZWwsIG5ld09yaWdpbiAtIG9mZnNldFNoaWZ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdSb290ICYmIG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0KSB7XG4gICAgICAgIG5ld1Jvb3QgPSBuZXdSb290LnJlbW92ZUFmdGVyKG93bmVyLCBuZXdMZXZlbCwgbmV3VGFpbE9mZnNldCAtIG9mZnNldFNoaWZ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRTaGlmdCkge1xuICAgICAgICBuZXdPcmlnaW4gLT0gb2Zmc2V0U2hpZnQ7XG4gICAgICAgIG5ld0NhcGFjaXR5IC09IG9mZnNldFNoaWZ0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsaXN0Ll9fb3duZXJJRCkge1xuICAgICAgbGlzdC5zaXplID0gbmV3Q2FwYWNpdHkgLSBuZXdPcmlnaW47XG4gICAgICBsaXN0Ll9vcmlnaW4gPSBuZXdPcmlnaW47XG4gICAgICBsaXN0Ll9jYXBhY2l0eSA9IG5ld0NhcGFjaXR5O1xuICAgICAgbGlzdC5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgIGxpc3QuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgbGlzdC5fdGFpbCA9IG5ld1RhaWw7XG4gICAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIGxpc3QuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICByZXR1cm4gbWFrZUxpc3QobmV3T3JpZ2luLCBuZXdDYXBhY2l0eSwgbmV3TGV2ZWwsIG5ld1Jvb3QsIG5ld1RhaWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VJbnRvTGlzdFdpdGgobGlzdCwgbWVyZ2VyLCBpdGVyYWJsZXMpIHtcbiAgICB2YXIgaXRlcnMgPSBbXTtcbiAgICB2YXIgbWF4U2l6ZSA9IDA7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGl0ZXJhYmxlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZXJhYmxlc1tpaV07XG4gICAgICB2YXIgaXRlciA9IEluZGV4ZWRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICBpZiAoaXRlci5zaXplID4gbWF4U2l6ZSkge1xuICAgICAgICBtYXhTaXplID0gaXRlci5zaXplO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0l0ZXJhYmxlKHZhbHVlKSkge1xuICAgICAgICBpdGVyID0gaXRlci5tYXAoZnVuY3Rpb24odiApIHtyZXR1cm4gZnJvbUpTKHYpfSk7XG4gICAgICB9XG4gICAgICBpdGVycy5wdXNoKGl0ZXIpO1xuICAgIH1cbiAgICBpZiAobWF4U2l6ZSA+IGxpc3Quc2l6ZSkge1xuICAgICAgbGlzdCA9IGxpc3Quc2V0U2l6ZShtYXhTaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlSW50b0NvbGxlY3Rpb25XaXRoKGxpc3QsIG1lcmdlciwgaXRlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGFpbE9mZnNldChzaXplKSB7XG4gICAgcmV0dXJuIHNpemUgPCBTSVpFID8gMCA6ICgoKHNpemUgLSAxKSA+Pj4gU0hJRlQpIDw8IFNISUZUKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE9yZGVyZWRNYXAsIE1hcCk7XG5cbiAgICAvLyBAcHJhZ21hIENvbnN0cnVjdGlvblxuXG4gICAgZnVuY3Rpb24gT3JkZXJlZE1hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eU9yZGVyZWRNYXAoKSA6XG4gICAgICAgIGlzT3JkZXJlZE1hcCh2YWx1ZSkgPyB2YWx1ZSA6XG4gICAgICAgIGVtcHR5T3JkZXJlZE1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obWFwICkge1xuICAgICAgICAgIHZhciBpdGVyID0gS2V5ZWRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gbWFwLnNldChrLCB2KX0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBPcmRlcmVkTWFwLm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ09yZGVyZWRNYXAgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrLCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fbWFwLmdldChrKTtcbiAgICAgIHJldHVybiBpbmRleCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fbGlzdC5nZXQoaW5kZXgpWzFdIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbGlzdC5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eU9yZGVyZWRNYXAoKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaywgdikge1xuICAgICAgcmV0dXJuIHVwZGF0ZU9yZGVyZWRNYXAodGhpcywgaywgdik7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIHJldHVybiB1cGRhdGVPcmRlcmVkTWFwKHRoaXMsIGssIE5PVF9TRVQpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLndhc0FsdGVyZWQoKSB8fCB0aGlzLl9saXN0Lndhc0FsdGVyZWQoKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9saXN0Ll9faXRlcmF0ZShcbiAgICAgICAgZnVuY3Rpb24oZW50cnkgKSB7cmV0dXJuIGVudHJ5ICYmIGZuKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyQwKX0sXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGlzdC5mcm9tRW50cnlTZXEoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24ob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcC5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICAgICAgdmFyIG5ld0xpc3QgPSB0aGlzLl9saXN0Ll9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXdNYXA7XG4gICAgICAgIHRoaXMuX2xpc3QgPSBuZXdMaXN0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld0xpc3QsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNPcmRlcmVkTWFwKG1heWJlT3JkZXJlZE1hcCkge1xuICAgIHJldHVybiBpc01hcChtYXliZU9yZGVyZWRNYXApICYmIGlzT3JkZXJlZChtYXliZU9yZGVyZWRNYXApO1xuICB9XG5cbiAgT3JkZXJlZE1hcC5pc09yZGVyZWRNYXAgPSBpc09yZGVyZWRNYXA7XG5cbiAgT3JkZXJlZE1hcC5wcm90b3R5cGVbSVNfT1JERVJFRF9TRU5USU5FTF0gPSB0cnVlO1xuICBPcmRlcmVkTWFwLnByb3RvdHlwZVtERUxFVEVdID0gT3JkZXJlZE1hcC5wcm90b3R5cGUucmVtb3ZlO1xuXG5cblxuICBmdW5jdGlvbiBtYWtlT3JkZXJlZE1hcChtYXAsIGxpc3QsIG93bmVySUQsIGhhc2gpIHtcbiAgICB2YXIgb21hcCA9IE9iamVjdC5jcmVhdGUoT3JkZXJlZE1hcC5wcm90b3R5cGUpO1xuICAgIG9tYXAuc2l6ZSA9IG1hcCA/IG1hcC5zaXplIDogMDtcbiAgICBvbWFwLl9tYXAgPSBtYXA7XG4gICAgb21hcC5fbGlzdCA9IGxpc3Q7XG4gICAgb21hcC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIG9tYXAuX19oYXNoID0gaGFzaDtcbiAgICByZXR1cm4gb21hcDtcbiAgfVxuXG4gIHZhciBFTVBUWV9PUkRFUkVEX01BUDtcbiAgZnVuY3Rpb24gZW1wdHlPcmRlcmVkTWFwKCkge1xuICAgIHJldHVybiBFTVBUWV9PUkRFUkVEX01BUCB8fCAoRU1QVFlfT1JERVJFRF9NQVAgPSBtYWtlT3JkZXJlZE1hcChlbXB0eU1hcCgpLCBlbXB0eUxpc3QoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlT3JkZXJlZE1hcChvbWFwLCBrLCB2KSB7XG4gICAgdmFyIG1hcCA9IG9tYXAuX21hcDtcbiAgICB2YXIgbGlzdCA9IG9tYXAuX2xpc3Q7XG4gICAgdmFyIGkgPSBtYXAuZ2V0KGspO1xuICAgIHZhciBoYXMgPSBpICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIG5ld01hcDtcbiAgICB2YXIgbmV3TGlzdDtcbiAgICBpZiAodiA9PT0gTk9UX1NFVCkgeyAvLyByZW1vdmVkXG4gICAgICBpZiAoIWhhcykge1xuICAgICAgICByZXR1cm4gb21hcDtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0LnNpemUgPj0gU0laRSAmJiBsaXN0LnNpemUgPj0gbWFwLnNpemUgKiAyKSB7XG4gICAgICAgIG5ld0xpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbihlbnRyeSwgaWR4KSAge3JldHVybiBlbnRyeSAhPT0gdW5kZWZpbmVkICYmIGkgIT09IGlkeH0pO1xuICAgICAgICBuZXdNYXAgPSBuZXdMaXN0LnRvS2V5ZWRTZXEoKS5tYXAoZnVuY3Rpb24oZW50cnkgKSB7cmV0dXJuIGVudHJ5WzBdfSkuZmxpcCgpLnRvTWFwKCk7XG4gICAgICAgIGlmIChvbWFwLl9fb3duZXJJRCkge1xuICAgICAgICAgIG5ld01hcC5fX293bmVySUQgPSBuZXdMaXN0Ll9fb3duZXJJRCA9IG9tYXAuX19vd25lcklEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdNYXAgPSBtYXAucmVtb3ZlKGspO1xuICAgICAgICBuZXdMaXN0ID0gaSA9PT0gbGlzdC5zaXplIC0gMSA/IGxpc3QucG9wKCkgOiBsaXN0LnNldChpLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKSB7XG4gICAgICAgIGlmICh2ID09PSBsaXN0LmdldChpKVsxXSkge1xuICAgICAgICAgIHJldHVybiBvbWFwO1xuICAgICAgICB9XG4gICAgICAgIG5ld01hcCA9IG1hcDtcbiAgICAgICAgbmV3TGlzdCA9IGxpc3Quc2V0KGksIFtrLCB2XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdNYXAgPSBtYXAuc2V0KGssIGxpc3Quc2l6ZSk7XG4gICAgICAgIG5ld0xpc3QgPSBsaXN0LnNldChsaXN0LnNpemUsIFtrLCB2XSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbWFwLl9fb3duZXJJRCkge1xuICAgICAgb21hcC5zaXplID0gbmV3TWFwLnNpemU7XG4gICAgICBvbWFwLl9tYXAgPSBuZXdNYXA7XG4gICAgICBvbWFwLl9saXN0ID0gbmV3TGlzdDtcbiAgICAgIG9tYXAuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9tYXA7XG4gICAgfVxuICAgIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld0xpc3QpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVG9LZXllZFNlcXVlbmNlLCBLZXllZFNlcSk7XG4gICAgZnVuY3Rpb24gVG9LZXllZFNlcXVlbmNlKGluZGV4ZWQsIHVzZUtleXMpIHtcbiAgICAgIHRoaXMuX2l0ZXIgPSBpbmRleGVkO1xuICAgICAgdGhpcy5fdXNlS2V5cyA9IHVzZUtleXM7XG4gICAgICB0aGlzLnNpemUgPSBpbmRleGVkLnNpemU7XG4gICAgfVxuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5nZXQoa2V5LCBub3RTZXRWYWx1ZSk7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5oYXMoa2V5KTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS52YWx1ZVNlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIudmFsdWVTZXEoKTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IHJldmVyc2VGYWN0b3J5KHRoaXMsIHRydWUpO1xuICAgICAgaWYgKCF0aGlzLl91c2VLZXlzKSB7XG4gICAgICAgIHJldmVyc2VkU2VxdWVuY2UudmFsdWVTZXEgPSBmdW5jdGlvbigpICB7cmV0dXJuIHRoaXMkMC5faXRlci50b1NlcSgpLnJldmVyc2UoKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV2ZXJzZWRTZXF1ZW5jZTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihtYXBwZXIsIGNvbnRleHQpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciBtYXBwZWRTZXF1ZW5jZSA9IG1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KTtcbiAgICAgIGlmICghdGhpcy5fdXNlS2V5cykge1xuICAgICAgICBtYXBwZWRTZXF1ZW5jZS52YWx1ZVNlcSA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gdGhpcyQwLl9pdGVyLnRvU2VxKCkubWFwKG1hcHBlciwgY29udGV4dCl9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlZFNlcXVlbmNlO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgaWk7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoXG4gICAgICAgIHRoaXMuX3VzZUtleXMgP1xuICAgICAgICAgIGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIGZuKHYsIGssIHRoaXMkMCl9IDpcbiAgICAgICAgICAoKGlpID0gcmV2ZXJzZSA/IHJlc29sdmVTaXplKHRoaXMpIDogMCksXG4gICAgICAgICAgICBmdW5jdGlvbih2ICkge3JldHVybiBmbih2LCByZXZlcnNlID8gLS1paSA6IGlpKyssIHRoaXMkMCl9KSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHRoaXMuX3VzZUtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaWkgPSByZXZlcnNlID8gcmVzb2x2ZVNpemUodGhpcykgOiAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gc3RlcC5kb25lID8gc3RlcCA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCByZXZlcnNlID8gLS1paSA6IGlpKyssIHN0ZXAudmFsdWUsIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlW0lTX09SREVSRURfU0VOVElORUxdID0gdHJ1ZTtcblxuXG4gIGNyZWF0ZUNsYXNzKFRvSW5kZXhlZFNlcXVlbmNlLCBJbmRleGVkU2VxKTtcbiAgICBmdW5jdGlvbiBUb0luZGV4ZWRTZXF1ZW5jZShpdGVyKSB7XG4gICAgICB0aGlzLl9pdGVyID0gaXRlcjtcbiAgICAgIHRoaXMuc2l6ZSA9IGl0ZXIuc2l6ZTtcbiAgICB9XG5cbiAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuaW5jbHVkZXModmFsdWUpO1xuICAgIH07XG5cbiAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbih2ICkge3JldHVybiBmbih2LCBpdGVyYXRpb25zKyssIHRoaXMkMCl9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gc3RlcC5kb25lID8gc3RlcCA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUsIHN0ZXApXG4gICAgICB9KTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhUb1NldFNlcXVlbmNlLCBTZXRTZXEpO1xuICAgIGZ1bmN0aW9uIFRvU2V0U2VxdWVuY2UoaXRlcikge1xuICAgICAgdGhpcy5faXRlciA9IGl0ZXI7XG4gICAgICB0aGlzLnNpemUgPSBpdGVyLnNpemU7XG4gICAgfVxuXG4gICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5pbmNsdWRlcyhrZXkpO1xuICAgIH07XG5cbiAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIGZuKHYsIHYsIHRoaXMkMCl9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmUgPyBzdGVwIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIHN0ZXAudmFsdWUsIHN0ZXAudmFsdWUsIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcblxuXG5cbiAgY3JlYXRlQ2xhc3MoRnJvbUVudHJpZXNTZXF1ZW5jZSwgS2V5ZWRTZXEpO1xuICAgIGZ1bmN0aW9uIEZyb21FbnRyaWVzU2VxdWVuY2UoZW50cmllcykge1xuICAgICAgdGhpcy5faXRlciA9IGVudHJpZXM7XG4gICAgICB0aGlzLnNpemUgPSBlbnRyaWVzLnNpemU7XG4gICAgfVxuXG4gICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuZW50cnlTZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLnRvU2VxKCk7XG4gICAgfTtcblxuICAgIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24oZW50cnkgKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGVudHJ5IGV4aXN0cyBmaXJzdCBzbyBhcnJheSBhY2Nlc3MgZG9lc24ndCB0aHJvdyBmb3IgaG9sZXNcbiAgICAgICAgLy8gaW4gdGhlIHBhcmVudCBpdGVyYXRpb24uXG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhbGlkYXRlRW50cnkoZW50cnkpO1xuICAgICAgICAgIHZhciBpbmRleGVkSXRlcmFibGUgPSBpc0l0ZXJhYmxlKGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gZm4oXG4gICAgICAgICAgICBpbmRleGVkSXRlcmFibGUgPyBlbnRyeS5nZXQoMSkgOiBlbnRyeVsxXSxcbiAgICAgICAgICAgIGluZGV4ZWRJdGVyYWJsZSA/IGVudHJ5LmdldCgwKSA6IGVudHJ5WzBdLFxuICAgICAgICAgICAgdGhpcyQwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgZXhpc3RzIGZpcnN0IHNvIGFycmF5IGFjY2VzcyBkb2Vzbid0IHRocm93IGZvciBob2xlc1xuICAgICAgICAgIC8vIGluIHRoZSBwYXJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICB2YXIgaW5kZXhlZEl0ZXJhYmxlID0gaXNJdGVyYWJsZShlbnRyeSk7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgaW5kZXhlZEl0ZXJhYmxlID8gZW50cnkuZ2V0KDApIDogZW50cnlbMF0sXG4gICAgICAgICAgICAgIGluZGV4ZWRJdGVyYWJsZSA/IGVudHJ5LmdldCgxKSA6IGVudHJ5WzFdLFxuICAgICAgICAgICAgICBzdGVwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuXG4gIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPVxuICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgICBjYWNoZVJlc3VsdFRocm91Z2g7XG5cblxuICBmdW5jdGlvbiBmbGlwRmFjdG9yeShpdGVyYWJsZSkge1xuICAgIHZhciBmbGlwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuICAgIGZsaXBTZXF1ZW5jZS5faXRlciA9IGl0ZXJhYmxlO1xuICAgIGZsaXBTZXF1ZW5jZS5zaXplID0gaXRlcmFibGUuc2l6ZTtcbiAgICBmbGlwU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gaXRlcmFibGV9O1xuICAgIGZsaXBTZXF1ZW5jZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBpdGVyYWJsZS5yZXZlcnNlLmFwcGx5KHRoaXMpOyAvLyBzdXBlci5yZXZlcnNlKClcbiAgICAgIHJldmVyc2VkU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gaXRlcmFibGUucmV2ZXJzZSgpfTtcbiAgICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICAgIH07XG4gICAgZmxpcFNlcXVlbmNlLmhhcyA9IGZ1bmN0aW9uKGtleSApIHtyZXR1cm4gaXRlcmFibGUuaW5jbHVkZXMoa2V5KX07XG4gICAgZmxpcFNlcXVlbmNlLmluY2x1ZGVzID0gZnVuY3Rpb24oa2V5ICkge3JldHVybiBpdGVyYWJsZS5oYXMoa2V5KX07XG4gICAgZmxpcFNlcXVlbmNlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuICAgIGZsaXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAge3JldHVybiBmbihrLCB2LCB0aGlzJDApICE9PSBmYWxzZX0sIHJldmVyc2UpO1xuICAgIH1cbiAgICBmbGlwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfRU5UUklFUykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoIXN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgdmFyIGsgPSBzdGVwLnZhbHVlWzBdO1xuICAgICAgICAgICAgc3RlcC52YWx1ZVswXSA9IHN0ZXAudmFsdWVbMV07XG4gICAgICAgICAgICBzdGVwLnZhbHVlWzFdID0gaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhYmxlLl9faXRlcmF0b3IoXG4gICAgICAgIHR5cGUgPT09IElURVJBVEVfVkFMVUVTID8gSVRFUkFURV9LRVlTIDogSVRFUkFURV9WQUxVRVMsXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBmbGlwU2VxdWVuY2U7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG1hcEZhY3RvcnkoaXRlcmFibGUsIG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciBtYXBwZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgbWFwcGVkU2VxdWVuY2Uuc2l6ZSA9IGl0ZXJhYmxlLnNpemU7XG4gICAgbWFwcGVkU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24oa2V5ICkge3JldHVybiBpdGVyYWJsZS5oYXMoa2V5KX07XG4gICAgbWFwcGVkU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24oa2V5LCBub3RTZXRWYWx1ZSkgIHtcbiAgICAgIHZhciB2ID0gaXRlcmFibGUuZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgICByZXR1cm4gdiA9PT0gTk9UX1NFVCA/XG4gICAgICAgIG5vdFNldFZhbHVlIDpcbiAgICAgICAgbWFwcGVyLmNhbGwoY29udGV4dCwgdiwga2V5LCBpdGVyYWJsZSk7XG4gICAgfTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIGl0ZXJhYmxlLl9faXRlcmF0ZShcbiAgICAgICAgZnVuY3Rpb24odiwgaywgYykgIHtyZXR1cm4gZm4obWFwcGVyLmNhbGwoY29udGV4dCwgdiwgaywgYyksIGssIHRoaXMkMCkgIT09IGZhbHNlfSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9XG4gICAgbWFwcGVkU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhYmxlLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIHZhciBrZXkgPSBlbnRyeVswXTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbWFwcGVyLmNhbGwoY29udGV4dCwgZW50cnlbMV0sIGtleSwgaXRlcmFibGUpLFxuICAgICAgICAgIHN0ZXBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwcGVkU2VxdWVuY2U7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHJldmVyc2VGYWN0b3J5KGl0ZXJhYmxlLCB1c2VLZXlzKSB7XG4gICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuICAgIHJldmVyc2VkU2VxdWVuY2UuX2l0ZXIgPSBpdGVyYWJsZTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLnNpemUgPSBpdGVyYWJsZS5zaXplO1xuICAgIHJldmVyc2VkU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gaXRlcmFibGV9O1xuICAgIGlmIChpdGVyYWJsZS5mbGlwKSB7XG4gICAgICByZXZlcnNlZFNlcXVlbmNlLmZsaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmbGlwU2VxdWVuY2UgPSBmbGlwRmFjdG9yeShpdGVyYWJsZSk7XG4gICAgICAgIGZsaXBTZXF1ZW5jZS5yZXZlcnNlID0gZnVuY3Rpb24oKSAge3JldHVybiBpdGVyYWJsZS5mbGlwKCl9O1xuICAgICAgICByZXR1cm4gZmxpcFNlcXVlbmNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbihrZXksIG5vdFNldFZhbHVlKSBcbiAgICAgIHtyZXR1cm4gaXRlcmFibGUuZ2V0KHVzZUtleXMgPyBrZXkgOiAtMSAtIGtleSwgbm90U2V0VmFsdWUpfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLmhhcyA9IGZ1bmN0aW9uKGtleSApXG4gICAgICB7cmV0dXJuIGl0ZXJhYmxlLmhhcyh1c2VLZXlzID8ga2V5IDogLTEgLSBrZXkpfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLmluY2x1ZGVzID0gZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIGl0ZXJhYmxlLmluY2x1ZGVzKHZhbHVlKX07XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5jYWNoZVJlc3VsdCA9IGNhY2hlUmVzdWx0VGhyb3VnaDtcbiAgICByZXZlcnNlZFNlcXVlbmNlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAge3JldHVybiBmbih2LCBrLCB0aGlzJDApfSwgIXJldmVyc2UpO1xuICAgIH07XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yID1cbiAgICAgIGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpICB7cmV0dXJuIGl0ZXJhYmxlLl9faXRlcmF0b3IodHlwZSwgIXJldmVyc2UpfTtcbiAgICByZXR1cm4gcmV2ZXJzZWRTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZmlsdGVyRmFjdG9yeShpdGVyYWJsZSwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG4gICAgdmFyIGZpbHRlclNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcbiAgICBpZiAodXNlS2V5cykge1xuICAgICAgZmlsdGVyU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24oa2V5ICkge1xuICAgICAgICB2YXIgdiA9IGl0ZXJhYmxlLmdldChrZXksIE5PVF9TRVQpO1xuICAgICAgICByZXR1cm4gdiAhPT0gTk9UX1NFVCAmJiAhIXByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGtleSwgaXRlcmFibGUpO1xuICAgICAgfTtcbiAgICAgIGZpbHRlclNlcXVlbmNlLmdldCA9IGZ1bmN0aW9uKGtleSwgbm90U2V0VmFsdWUpICB7XG4gICAgICAgIHZhciB2ID0gaXRlcmFibGUuZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgICAgIHJldHVybiB2ICE9PSBOT1RfU0VUICYmIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGtleSwgaXRlcmFibGUpID9cbiAgICAgICAgICB2IDogbm90U2V0VmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBmaWx0ZXJTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGssIGMpICB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgdGhpcyQwKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIGZpbHRlclNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIga2V5ID0gZW50cnlbMF07XG4gICAgICAgICAgdmFyIHZhbHVlID0gZW50cnlbMV07XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBrZXksIGl0ZXJhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgdXNlS2V5cyA/IGtleSA6IGl0ZXJhdGlvbnMrKywgdmFsdWUsIHN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gY291bnRCeUZhY3RvcnkoaXRlcmFibGUsIGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgZ3JvdXBzID0gTWFwKCkuYXNNdXRhYmxlKCk7XG4gICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7XG4gICAgICBncm91cHMudXBkYXRlKFxuICAgICAgICBncm91cGVyLmNhbGwoY29udGV4dCwgdiwgaywgaXRlcmFibGUpLFxuICAgICAgICAwLFxuICAgICAgICBmdW5jdGlvbihhICkge3JldHVybiBhICsgMX1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdyb3Vwcy5hc0ltbXV0YWJsZSgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBncm91cEJ5RmFjdG9yeShpdGVyYWJsZSwgZ3JvdXBlciwgY29udGV4dCkge1xuICAgIHZhciBpc0tleWVkSXRlciA9IGlzS2V5ZWQoaXRlcmFibGUpO1xuICAgIHZhciBncm91cHMgPSAoaXNPcmRlcmVkKGl0ZXJhYmxlKSA/IE9yZGVyZWRNYXAoKSA6IE1hcCgpKS5hc011dGFibGUoKTtcbiAgICBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHtcbiAgICAgIGdyb3Vwcy51cGRhdGUoXG4gICAgICAgIGdyb3VwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBpdGVyYWJsZSksXG4gICAgICAgIGZ1bmN0aW9uKGEgKSB7cmV0dXJuIChhID0gYSB8fCBbXSwgYS5wdXNoKGlzS2V5ZWRJdGVyID8gW2ssIHZdIDogdiksIGEpfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICB2YXIgY29lcmNlID0gaXRlcmFibGVDbGFzcyhpdGVyYWJsZSk7XG4gICAgcmV0dXJuIGdyb3Vwcy5tYXAoZnVuY3Rpb24oYXJyICkge3JldHVybiByZWlmeShpdGVyYWJsZSwgY29lcmNlKGFycikpfSk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNsaWNlRmFjdG9yeShpdGVyYWJsZSwgYmVnaW4sIGVuZCwgdXNlS2V5cykge1xuICAgIHZhciBvcmlnaW5hbFNpemUgPSBpdGVyYWJsZS5zaXplO1xuXG4gICAgLy8gU2FuaXRpemUgYmVnaW4gJiBlbmQgdXNpbmcgdGhpcyBzaG9ydGhhbmQgZm9yIFRvSW50MzIoYXJndW1lbnQpXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50MzJcbiAgICBpZiAoYmVnaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmVnaW4gPSBiZWdpbiB8IDA7XG4gICAgfVxuICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgZW5kID0gb3JpZ2luYWxTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gZW5kIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCBvcmlnaW5hbFNpemUpKSB7XG4gICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmVkQmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIG9yaWdpbmFsU2l6ZSk7XG4gICAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIG9yaWdpbmFsU2l6ZSk7XG5cbiAgICAvLyBiZWdpbiBvciBlbmQgd2lsbCBiZSBOYU4gaWYgdGhleSB3ZXJlIHByb3ZpZGVkIGFzIG5lZ2F0aXZlIG51bWJlcnMgYW5kXG4gICAgLy8gdGhpcyBpdGVyYWJsZSdzIHNpemUgaXMgdW5rbm93bi4gSW4gdGhhdCBjYXNlLCBjYWNoZSBmaXJzdCBzbyB0aGVyZSBpc1xuICAgIC8vIGEga25vd24gc2l6ZSBhbmQgdGhlc2UgZG8gbm90IHJlc29sdmUgdG8gTmFOLlxuICAgIGlmIChyZXNvbHZlZEJlZ2luICE9PSByZXNvbHZlZEJlZ2luIHx8IHJlc29sdmVkRW5kICE9PSByZXNvbHZlZEVuZCkge1xuICAgICAgcmV0dXJuIHNsaWNlRmFjdG9yeShpdGVyYWJsZS50b1NlcSgpLmNhY2hlUmVzdWx0KCksIGJlZ2luLCBlbmQsIHVzZUtleXMpO1xuICAgIH1cblxuICAgIC8vIE5vdGU6IHJlc29sdmVkRW5kIGlzIHVuZGVmaW5lZCB3aGVuIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSdzIGxlbmd0aCBpc1xuICAgIC8vIHVua25vd24gYW5kIHRoaXMgc2xpY2UgZGlkIG5vdCBzdXBwbHkgYW4gZW5kIGFuZCBzaG91bGQgY29udGFpbiBhbGxcbiAgICAvLyBlbGVtZW50cyBhZnRlciByZXNvbHZlZEJlZ2luLlxuICAgIC8vIEluIHRoYXQgY2FzZSwgcmVzb2x2ZWRTaXplIHdpbGwgYmUgTmFOIGFuZCBzbGljZVNpemUgd2lsbCByZW1haW4gdW5kZWZpbmVkLlxuICAgIHZhciByZXNvbHZlZFNpemUgPSByZXNvbHZlZEVuZCAtIHJlc29sdmVkQmVnaW47XG4gICAgdmFyIHNsaWNlU2l6ZTtcbiAgICBpZiAocmVzb2x2ZWRTaXplID09PSByZXNvbHZlZFNpemUpIHtcbiAgICAgIHNsaWNlU2l6ZSA9IHJlc29sdmVkU2l6ZSA8IDAgPyAwIDogcmVzb2x2ZWRTaXplO1xuICAgIH1cblxuICAgIHZhciBzbGljZVNlcSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG5cbiAgICAvLyBJZiBpdGVyYWJsZS5zaXplIGlzIHVuZGVmaW5lZCwgdGhlIHNpemUgb2YgdGhlIHJlYWxpemVkIHNsaWNlU2VxIGlzXG4gICAgLy8gdW5rbm93biBhdCB0aGlzIHBvaW50IHVubGVzcyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIHNsaWNlIGlzIDBcbiAgICBzbGljZVNlcS5zaXplID0gc2xpY2VTaXplID09PSAwID8gc2xpY2VTaXplIDogaXRlcmFibGUuc2l6ZSAmJiBzbGljZVNpemUgfHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCF1c2VLZXlzICYmIGlzU2VxKGl0ZXJhYmxlKSAmJiBzbGljZVNpemUgPj0gMCkge1xuICAgICAgc2xpY2VTZXEuZ2V0ID0gZnVuY3Rpb24gKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgc2xpY2VTaXplID9cbiAgICAgICAgICBpdGVyYWJsZS5nZXQoaW5kZXggKyByZXNvbHZlZEJlZ2luLCBub3RTZXRWYWx1ZSkgOlxuICAgICAgICAgIG5vdFNldFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNsaWNlU2VxLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIGlmIChzbGljZVNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHtcbiAgICAgICAgaWYgKCEoaXNTa2lwcGluZyAmJiAoaXNTa2lwcGluZyA9IHNraXBwZWQrKyA8IHJlc29sdmVkQmVnaW4pKSkge1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgdGhpcyQwKSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAgaXRlcmF0aW9ucyAhPT0gc2xpY2VTaXplO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG5cbiAgICBzbGljZVNlcS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAoc2xpY2VTaXplICE9PSAwICYmIHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgYm90aGVyIGluc3RhbnRpYXRpbmcgcGFyZW50IGl0ZXJhdG9yIGlmIHRha2luZyAwLlxuICAgICAgdmFyIGl0ZXJhdG9yID0gc2xpY2VTaXplICE9PSAwICYmIGl0ZXJhYmxlLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgd2hpbGUgKHNraXBwZWQrKyA8IHJlc29sdmVkQmVnaW4pIHtcbiAgICAgICAgICBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCsraXRlcmF0aW9ucyA+IHNsaWNlU2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHVzZUtleXMgfHwgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBJVEVSQVRFX0tFWVMpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zIC0gMSwgdW5kZWZpbmVkLCBzdGVwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zIC0gMSwgc3RlcC52YWx1ZVsxXSwgc3RlcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzbGljZVNlcTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdGFrZVdoaWxlRmFjdG9yeShpdGVyYWJsZSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHRha2VTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgdGFrZVNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrLCBjKSBcbiAgICAgICAge3JldHVybiBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSAmJiArK2l0ZXJhdGlvbnMgJiYgZm4odiwgaywgdGhpcyQwKX1cbiAgICAgICk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIHRha2VTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaXRlcmF0aW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICBpZiAoIWl0ZXJhdGluZykge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIHZhciBrID0gZW50cnlbMF07XG4gICAgICAgIHZhciB2ID0gZW50cnlbMV07XG4gICAgICAgIGlmICghcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgdGhpcyQwKSkge1xuICAgICAgICAgIGl0ZXJhdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHRha2VTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gc2tpcFdoaWxlRmFjdG9yeShpdGVyYWJsZSwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG4gICAgdmFyIHNraXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgc2tpcFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaywgYykgIHtcbiAgICAgICAgaWYgKCEoaXNTa2lwcGluZyAmJiAoaXNTa2lwcGluZyA9IHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSkpIHtcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgcmV0dXJuIGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIHRoaXMkMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICBza2lwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGUuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIHNraXBwaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgc3RlcCwgaywgdjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHVzZUtleXMgfHwgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IElURVJBVEVfS0VZUykge1xuICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHVuZGVmaW5lZCwgc3RlcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWVbMV0sIHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGsgPSBlbnRyeVswXTtcbiAgICAgICAgICB2ID0gZW50cnlbMV07XG4gICAgICAgICAgc2tpcHBpbmcgJiYgKHNraXBwaW5nID0gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgdGhpcyQwKSk7XG4gICAgICAgIH0gd2hpbGUgKHNraXBwaW5nKTtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IElURVJBVEVfRU5UUklFUyA/IHN0ZXAgOlxuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBza2lwU2VxdWVuY2U7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGNvbmNhdEZhY3RvcnkoaXRlcmFibGUsIHZhbHVlcykge1xuICAgIHZhciBpc0tleWVkSXRlcmFibGUgPSBpc0tleWVkKGl0ZXJhYmxlKTtcbiAgICB2YXIgaXRlcnMgPSBbaXRlcmFibGVdLmNvbmNhdCh2YWx1ZXMpLm1hcChmdW5jdGlvbih2ICkge1xuICAgICAgaWYgKCFpc0l0ZXJhYmxlKHYpKSB7XG4gICAgICAgIHYgPSBpc0tleWVkSXRlcmFibGUgP1xuICAgICAgICAgIGtleWVkU2VxRnJvbVZhbHVlKHYpIDpcbiAgICAgICAgICBpbmRleGVkU2VxRnJvbVZhbHVlKEFycmF5LmlzQXJyYXkodikgPyB2IDogW3ZdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNLZXllZEl0ZXJhYmxlKSB7XG4gICAgICAgIHYgPSBLZXllZEl0ZXJhYmxlKHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIHYuc2l6ZSAhPT0gMH0pO1xuXG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgIH1cblxuICAgIGlmIChpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBzaW5nbGV0b24gPSBpdGVyc1swXTtcbiAgICAgIGlmIChzaW5nbGV0b24gPT09IGl0ZXJhYmxlIHx8XG4gICAgICAgICAgaXNLZXllZEl0ZXJhYmxlICYmIGlzS2V5ZWQoc2luZ2xldG9uKSB8fFxuICAgICAgICAgIGlzSW5kZXhlZChpdGVyYWJsZSkgJiYgaXNJbmRleGVkKHNpbmdsZXRvbikpIHtcbiAgICAgICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29uY2F0U2VxID0gbmV3IEFycmF5U2VxKGl0ZXJzKTtcbiAgICBpZiAoaXNLZXllZEl0ZXJhYmxlKSB7XG4gICAgICBjb25jYXRTZXEgPSBjb25jYXRTZXEudG9LZXllZFNlcSgpO1xuICAgIH0gZWxzZSBpZiAoIWlzSW5kZXhlZChpdGVyYWJsZSkpIHtcbiAgICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS50b1NldFNlcSgpO1xuICAgIH1cbiAgICBjb25jYXRTZXEgPSBjb25jYXRTZXEuZmxhdHRlbih0cnVlKTtcbiAgICBjb25jYXRTZXEuc2l6ZSA9IGl0ZXJzLnJlZHVjZShcbiAgICAgIGZ1bmN0aW9uKHN1bSwgc2VxKSAge1xuICAgICAgICBpZiAoc3VtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IHNlcS5zaXplO1xuICAgICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdW0gKyBzaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiBjb25jYXRTZXE7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGZsYXR0ZW5GYWN0b3J5KGl0ZXJhYmxlLCBkZXB0aCwgdXNlS2V5cykge1xuICAgIHZhciBmbGF0U2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuICAgIGZsYXRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgZnVuY3Rpb24gZmxhdERlZXAoaXRlciwgY3VycmVudERlcHRoKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICAgIGl0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7XG4gICAgICAgICAgaWYgKCghZGVwdGggfHwgY3VycmVudERlcHRoIDwgZGVwdGgpICYmIGlzSXRlcmFibGUodikpIHtcbiAgICAgICAgICAgIGZsYXREZWVwKHYsIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zKyssIHRoaXMkMCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICFzdG9wcGVkO1xuICAgICAgICB9LCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIGZsYXREZWVwKGl0ZXJhYmxlLCAwKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH1cbiAgICBmbGF0U2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGUuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHdoaWxlIChpdGVyYXRvcikge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpdGVyYXRvciA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTKSB7XG4gICAgICAgICAgICB2ID0gdlsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCghZGVwdGggfHwgc3RhY2subGVuZ3RoIDwgZGVwdGgpICYmIGlzSXRlcmFibGUodikpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goaXRlcmF0b3IpO1xuICAgICAgICAgICAgaXRlcmF0b3IgPSB2Ll9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VLZXlzID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2LCBzdGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmbGF0U2VxdWVuY2U7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGZsYXRNYXBGYWN0b3J5KGl0ZXJhYmxlLCBtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgY29lcmNlID0gaXRlcmFibGVDbGFzcyhpdGVyYWJsZSk7XG4gICAgcmV0dXJuIGl0ZXJhYmxlLnRvU2VxKCkubWFwKFxuICAgICAgZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gY29lcmNlKG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGssIGl0ZXJhYmxlKSl9XG4gICAgKS5mbGF0dGVuKHRydWUpO1xuICB9XG5cblxuICBmdW5jdGlvbiBpbnRlcnBvc2VGYWN0b3J5KGl0ZXJhYmxlLCBzZXBhcmF0b3IpIHtcbiAgICB2YXIgaW50ZXJwb3NlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcbiAgICBpbnRlcnBvc2VkU2VxdWVuY2Uuc2l6ZSA9IGl0ZXJhYmxlLnNpemUgJiYgaXRlcmFibGUuc2l6ZSAqIDIgLTE7XG4gICAgaW50ZXJwb3NlZFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSBcbiAgICAgICAge3JldHVybiAoIWl0ZXJhdGlvbnMgfHwgZm4oc2VwYXJhdG9yLCBpdGVyYXRpb25zKyssIHRoaXMkMCkgIT09IGZhbHNlKSAmJlxuICAgICAgICBmbih2LCBpdGVyYXRpb25zKyssIHRoaXMkMCkgIT09IGZhbHNlfSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgaW50ZXJwb3NlZFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhYmxlLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgaWYgKCFzdGVwIHx8IGl0ZXJhdGlvbnMgJSAyKSB7XG4gICAgICAgICAgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdGlvbnMgJSAyID9cbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc2VwYXJhdG9yKSA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUsIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gaW50ZXJwb3NlZFNlcXVlbmNlO1xuICB9XG5cblxuICBmdW5jdGlvbiBzb3J0RmFjdG9yeShpdGVyYWJsZSwgY29tcGFyYXRvciwgbWFwcGVyKSB7XG4gICAgaWYgKCFjb21wYXJhdG9yKSB7XG4gICAgICBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3I7XG4gICAgfVxuICAgIHZhciBpc0tleWVkSXRlcmFibGUgPSBpc0tleWVkKGl0ZXJhYmxlKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBlbnRyaWVzID0gaXRlcmFibGUudG9TZXEoKS5tYXAoXG4gICAgICBmdW5jdGlvbih2LCBrKSAge3JldHVybiBbaywgdiwgaW5kZXgrKywgbWFwcGVyID8gbWFwcGVyKHYsIGssIGl0ZXJhYmxlKSA6IHZdfVxuICAgICkudG9BcnJheSgpO1xuICAgIGVudHJpZXMuc29ydChmdW5jdGlvbihhLCBiKSAge3JldHVybiBjb21wYXJhdG9yKGFbM10sIGJbM10pIHx8IGFbMl0gLSBiWzJdfSkuZm9yRWFjaChcbiAgICAgIGlzS2V5ZWRJdGVyYWJsZSA/XG4gICAgICBmdW5jdGlvbih2LCBpKSAgeyBlbnRyaWVzW2ldLmxlbmd0aCA9IDI7IH0gOlxuICAgICAgZnVuY3Rpb24odiwgaSkgIHsgZW50cmllc1tpXSA9IHZbMV07IH1cbiAgICApO1xuICAgIHJldHVybiBpc0tleWVkSXRlcmFibGUgPyBLZXllZFNlcShlbnRyaWVzKSA6XG4gICAgICBpc0luZGV4ZWQoaXRlcmFibGUpID8gSW5kZXhlZFNlcShlbnRyaWVzKSA6XG4gICAgICBTZXRTZXEoZW50cmllcyk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG1heEZhY3RvcnkoaXRlcmFibGUsIGNvbXBhcmF0b3IsIG1hcHBlcikge1xuICAgIGlmICghY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yO1xuICAgIH1cbiAgICBpZiAobWFwcGVyKSB7XG4gICAgICB2YXIgZW50cnkgPSBpdGVyYWJsZS50b1NlcSgpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gW3YsIG1hcHBlcih2LCBrLCBpdGVyYWJsZSldfSlcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbihhLCBiKSAge3JldHVybiBtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGFbMV0sIGJbMV0pID8gYiA6IGF9KTtcbiAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGl0ZXJhYmxlLnJlZHVjZShmdW5jdGlvbihhLCBiKSAge3JldHVybiBtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGEsIGIpID8gYiA6IGF9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGEsIGIpIHtcbiAgICB2YXIgY29tcCA9IGNvbXBhcmF0b3IoYiwgYSk7XG4gICAgLy8gYiBpcyBjb25zaWRlcmVkIHRoZSBuZXcgbWF4IGlmIHRoZSBjb21wYXJhdG9yIGRlY2xhcmVzIHRoZW0gZXF1YWwsIGJ1dFxuICAgIC8vIHRoZXkgYXJlIG5vdCBlcXVhbCBhbmQgYiBpcyBpbiBmYWN0IGEgbnVsbGlzaCB2YWx1ZS5cbiAgICByZXR1cm4gKGNvbXAgPT09IDAgJiYgYiAhPT0gYSAmJiAoYiA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiAhPT0gYikpIHx8IGNvbXAgPiAwO1xuICB9XG5cblxuICBmdW5jdGlvbiB6aXBXaXRoRmFjdG9yeShrZXlJdGVyLCB6aXBwZXIsIGl0ZXJzKSB7XG4gICAgdmFyIHppcFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGtleUl0ZXIpO1xuICAgIHppcFNlcXVlbmNlLnNpemUgPSBuZXcgQXJyYXlTZXEoaXRlcnMpLm1hcChmdW5jdGlvbihpICkge3JldHVybiBpLnNpemV9KS5taW4oKTtcbiAgICAvLyBOb3RlOiB0aGlzIGEgZ2VuZXJpYyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIF9faXRlcmF0ZSBpbiB0ZXJtcyBvZlxuICAgIC8vIF9faXRlcmF0b3Igd2hpY2ggbWF5IGJlIG1vcmUgZ2VuZXJpY2FsbHkgdXNlZnVsIGluIHRoZSBmdXR1cmUuXG4gICAgemlwU2VxdWVuY2UuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIC8qIGdlbmVyaWM6XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIGlmIChmbihzdGVwLnZhbHVlWzFdLCBzdGVwLnZhbHVlWzBdLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgICAqL1xuICAgICAgLy8gaW5kZXhlZDpcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgaWYgKGZuKHN0ZXAudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgemlwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9ycyA9IGl0ZXJzLm1hcChmdW5jdGlvbihpIClcbiAgICAgICAge3JldHVybiAoaSA9IEl0ZXJhYmxlKGkpLCBnZXRJdGVyYXRvcihyZXZlcnNlID8gaS5yZXZlcnNlKCkgOiBpKSl9XG4gICAgICApO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIGlzRG9uZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBzdGVwcztcbiAgICAgICAgaWYgKCFpc0RvbmUpIHtcbiAgICAgICAgICBzdGVwcyA9IGl0ZXJhdG9ycy5tYXAoZnVuY3Rpb24oaSApIHtyZXR1cm4gaS5uZXh0KCl9KTtcbiAgICAgICAgICBpc0RvbmUgPSBzdGVwcy5zb21lKGZ1bmN0aW9uKHMgKSB7cmV0dXJuIHMuZG9uZX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RvbmUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBpdGVyYXRpb25zKyssXG4gICAgICAgICAgemlwcGVyLmFwcGx5KG51bGwsIHN0ZXBzLm1hcChmdW5jdGlvbihzICkge3JldHVybiBzLnZhbHVlfSkpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB6aXBTZXF1ZW5jZVxuICB9XG5cblxuICAvLyAjcHJhZ21hIEhlbHBlciBGdW5jdGlvbnNcblxuICBmdW5jdGlvbiByZWlmeShpdGVyLCBzZXEpIHtcbiAgICByZXR1cm4gaXNTZXEoaXRlcikgPyBzZXEgOiBpdGVyLmNvbnN0cnVjdG9yKHNlcSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUVudHJ5KGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5ICE9PSBPYmplY3QoZW50cnkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBbSywgVl0gdHVwbGU6ICcgKyBlbnRyeSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNpemUoaXRlcikge1xuICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgcmV0dXJuIGVuc3VyZVNpemUoaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBpdGVyYWJsZUNsYXNzKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIGlzS2V5ZWQoaXRlcmFibGUpID8gS2V5ZWRJdGVyYWJsZSA6XG4gICAgICBpc0luZGV4ZWQoaXRlcmFibGUpID8gSW5kZXhlZEl0ZXJhYmxlIDpcbiAgICAgIFNldEl0ZXJhYmxlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoXG4gICAgICAoXG4gICAgICAgIGlzS2V5ZWQoaXRlcmFibGUpID8gS2V5ZWRTZXEgOlxuICAgICAgICBpc0luZGV4ZWQoaXRlcmFibGUpID8gSW5kZXhlZFNlcSA6XG4gICAgICAgIFNldFNlcVxuICAgICAgKS5wcm90b3R5cGVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FjaGVSZXN1bHRUaHJvdWdoKCkge1xuICAgIGlmICh0aGlzLl9pdGVyLmNhY2hlUmVzdWx0KSB7XG4gICAgICB0aGlzLl9pdGVyLmNhY2hlUmVzdWx0KCk7XG4gICAgICB0aGlzLnNpemUgPSB0aGlzLl9pdGVyLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFNlcS5wcm90b3R5cGUuY2FjaGVSZXN1bHQuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0Q29tcGFyYXRvcihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2VJdGVyYXRvcihrZXlQYXRoKSB7XG4gICAgdmFyIGl0ZXIgPSBnZXRJdGVyYXRvcihrZXlQYXRoKTtcbiAgICBpZiAoIWl0ZXIpIHtcbiAgICAgIC8vIEFycmF5IG1pZ2h0IG5vdCBiZSBpdGVyYWJsZSBpbiB0aGlzIGVudmlyb25tZW50LCBzbyB3ZSBuZWVkIGEgZmFsbGJhY2tcbiAgICAgIC8vIHRvIG91ciB3cmFwcGVkIHR5cGUuXG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKGtleVBhdGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGl0ZXJhYmxlIG9yIGFycmF5LWxpa2U6ICcgKyBrZXlQYXRoKTtcbiAgICAgIH1cbiAgICAgIGl0ZXIgPSBnZXRJdGVyYXRvcihJdGVyYWJsZShrZXlQYXRoKSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVyO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoUmVjb3JkLCBLZXllZENvbGxlY3Rpb24pO1xuXG4gICAgZnVuY3Rpb24gUmVjb3JkKGRlZmF1bHRWYWx1ZXMsIG5hbWUpIHtcbiAgICAgIHZhciBoYXNJbml0aWFsaXplZDtcblxuICAgICAgdmFyIFJlY29yZFR5cGUgPSBmdW5jdGlvbiBSZWNvcmQodmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBSZWNvcmRUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVjb3JkVHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlY29yZFR5cGUodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgaGFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdFZhbHVlcyk7XG4gICAgICAgICAgc2V0UHJvcHMoUmVjb3JkVHlwZVByb3RvdHlwZSwga2V5cyk7XG4gICAgICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5zaXplID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fbmFtZSA9IG5hbWU7XG4gICAgICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fa2V5cyA9IGtleXM7XG4gICAgICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRWYWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwID0gTWFwKHZhbHVlcyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgUmVjb3JkVHlwZVByb3RvdHlwZSA9IFJlY29yZFR5cGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWNvcmRQcm90b3R5cGUpO1xuICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlY29yZFR5cGU7XG5cbiAgICAgIHJldHVybiBSZWNvcmRUeXBlO1xuICAgIH1cblxuICAgIFJlY29yZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcocmVjb3JkTmFtZSh0aGlzKSArICcgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBSZWNvcmQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWVzLmhhc093blByb3BlcnR5KGspO1xuICAgIH07XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGssIG5vdFNldFZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKGspKSB7XG4gICAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkZWZhdWx0VmFsID0gdGhpcy5fZGVmYXVsdFZhbHVlc1trXTtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAgPyB0aGlzLl9tYXAuZ2V0KGssIGRlZmF1bHRWYWwpIDogZGVmYXVsdFZhbDtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIFJlY29yZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIFJlY29yZFR5cGUgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIFJlY29yZFR5cGUuX2VtcHR5IHx8IChSZWNvcmRUeXBlLl9lbXB0eSA9IG1ha2VSZWNvcmQodGhpcywgZW1wdHlNYXAoKSkpO1xuICAgIH07XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgIGlmICghdGhpcy5oYXMoaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IHVua25vd24ga2V5IFwiJyArIGsgKyAnXCIgb24gJyArIHJlY29yZE5hbWUodGhpcykpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLmhhcyhrKSkge1xuICAgICAgICB2YXIgZGVmYXVsdFZhbCA9IHRoaXMuX2RlZmF1bHRWYWx1ZXNba107XG4gICAgICAgIGlmICh2ID09PSBkZWZhdWx0VmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLnNldChrLCB2KTtcbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCB8fCBuZXdNYXAgPT09IHRoaXMuX21hcCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlUmVjb3JkKHRoaXMsIG5ld01hcCk7XG4gICAgfTtcblxuICAgIFJlY29yZC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaykge1xuICAgICAgaWYgKCF0aGlzLmhhcyhrKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLnJlbW92ZShrKTtcbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCB8fCBuZXdNYXAgPT09IHRoaXMuX21hcCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlUmVjb3JkKHRoaXMsIG5ld01hcCk7XG4gICAgfTtcblxuICAgIFJlY29yZC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC53YXNBbHRlcmVkKCk7XG4gICAgfTtcblxuICAgIFJlY29yZC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiBLZXllZEl0ZXJhYmxlKHRoaXMuX2RlZmF1bHRWYWx1ZXMpLm1hcChmdW5jdGlvbihfLCBrKSAge3JldHVybiB0aGlzJDAuZ2V0KGspfSkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgUmVjb3JkLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIEtleWVkSXRlcmFibGUodGhpcy5fZGVmYXVsdFZhbHVlcykubWFwKGZ1bmN0aW9uKF8sIGspICB7cmV0dXJuIHRoaXMkMC5nZXQoayl9KS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbihvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwICYmIHRoaXMuX21hcC5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3TWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlUmVjb3JkKHRoaXMsIG5ld01hcCwgb3duZXJJRCk7XG4gICAgfTtcblxuXG4gIHZhciBSZWNvcmRQcm90b3R5cGUgPSBSZWNvcmQucHJvdG90eXBlO1xuICBSZWNvcmRQcm90b3R5cGVbREVMRVRFXSA9IFJlY29yZFByb3RvdHlwZS5yZW1vdmU7XG4gIFJlY29yZFByb3RvdHlwZS5kZWxldGVJbiA9XG4gIFJlY29yZFByb3RvdHlwZS5yZW1vdmVJbiA9IE1hcFByb3RvdHlwZS5yZW1vdmVJbjtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlID0gTWFwUHJvdG90eXBlLm1lcmdlO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VXaXRoID0gTWFwUHJvdG90eXBlLm1lcmdlV2l0aDtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlSW4gPSBNYXBQcm90b3R5cGUubWVyZ2VJbjtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcCA9IE1hcFByb3RvdHlwZS5tZXJnZURlZXA7XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gTWFwUHJvdG90eXBlLm1lcmdlRGVlcFdpdGg7XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZURlZXBJbiA9IE1hcFByb3RvdHlwZS5tZXJnZURlZXBJbjtcbiAgUmVjb3JkUHJvdG90eXBlLnNldEluID0gTWFwUHJvdG90eXBlLnNldEluO1xuICBSZWNvcmRQcm90b3R5cGUudXBkYXRlID0gTWFwUHJvdG90eXBlLnVwZGF0ZTtcbiAgUmVjb3JkUHJvdG90eXBlLnVwZGF0ZUluID0gTWFwUHJvdG90eXBlLnVwZGF0ZUluO1xuICBSZWNvcmRQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IE1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zO1xuICBSZWNvcmRQcm90b3R5cGUuYXNNdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzTXV0YWJsZTtcbiAgUmVjb3JkUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzSW1tdXRhYmxlO1xuXG5cbiAgZnVuY3Rpb24gbWFrZVJlY29yZChsaWtlUmVjb3JkLCBtYXAsIG93bmVySUQpIHtcbiAgICB2YXIgcmVjb3JkID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YobGlrZVJlY29yZCkpO1xuICAgIHJlY29yZC5fbWFwID0gbWFwO1xuICAgIHJlY29yZC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIHJldHVybiByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmROYW1lKHJlY29yZCkge1xuICAgIHJldHVybiByZWNvcmQuX25hbWUgfHwgcmVjb3JkLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ1JlY29yZCc7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcm9wcyhwcm90b3R5cGUsIG5hbWVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5hbWVzLmZvckVhY2goc2V0UHJvcC5iaW5kKHVuZGVmaW5lZCwgcHJvdG90eXBlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBmYWlsZWQuIFByb2JhYmx5IElFOC5cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcm9wKHByb3RvdHlwZSwgbmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChuYW1lKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLl9fb3duZXJJRCwgJ0Nhbm5vdCBzZXQgb24gYW4gaW1tdXRhYmxlIHJlY29yZC4nKTtcbiAgICAgICAgdGhpcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoU2V0LCBTZXRDb2xsZWN0aW9uKTtcblxuICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cbiAgICBmdW5jdGlvbiBTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlTZXQoKSA6XG4gICAgICAgIGlzU2V0KHZhbHVlKSAmJiAhaXNPcmRlcmVkKHZhbHVlKSA/IHZhbHVlIDpcbiAgICAgICAgZW1wdHlTZXQoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKHNldCApIHtcbiAgICAgICAgICB2YXIgaXRlciA9IFNldEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbih2ICkge3JldHVybiBzZXQuYWRkKHYpfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIFNldC5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFNldC5mcm9tS2V5cyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcyhLZXllZEl0ZXJhYmxlKHZhbHVlKS5rZXlTZXEoKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NldCB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLnNldCh2YWx1ZSwgdHJ1ZSkpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdXBkYXRlU2V0KHRoaXMsIHRoaXMuX21hcC5yZW1vdmUodmFsdWUpKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuY2xlYXIoKSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQ29tcG9zaXRpb25cblxuICAgIFNldC5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbigpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIGl0ZXJzID0gaXRlcnMuZmlsdGVyKGZ1bmN0aW9uKHggKSB7cmV0dXJuIHguc2l6ZSAhPT0gMH0pO1xuICAgICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDAgJiYgIXRoaXMuX19vd25lcklEICYmIGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcihpdGVyc1swXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKHNldCApIHtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGl0ZXJzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgIFNldEl0ZXJhYmxlKGl0ZXJzW2lpXSkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSApIHtyZXR1cm4gc2V0LmFkZCh2YWx1ZSl9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24oKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaXRlcnMgPSBpdGVycy5tYXAoZnVuY3Rpb24oaXRlciApIHtyZXR1cm4gU2V0SXRlcmFibGUoaXRlcil9KTtcbiAgICAgIHZhciBvcmlnaW5hbFNldCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKHNldCApIHtcbiAgICAgICAgb3JpZ2luYWxTZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSApIHtcbiAgICAgICAgICBpZiAoIWl0ZXJzLmV2ZXJ5KGZ1bmN0aW9uKGl0ZXIgKSB7cmV0dXJuIGl0ZXIuaW5jbHVkZXModmFsdWUpfSkpIHtcbiAgICAgICAgICAgIHNldC5yZW1vdmUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uKCkge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGl0ZXJzID0gaXRlcnMubWFwKGZ1bmN0aW9uKGl0ZXIgKSB7cmV0dXJuIFNldEl0ZXJhYmxlKGl0ZXIpfSk7XG4gICAgICB2YXIgb3JpZ2luYWxTZXQgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbihzZXQgKSB7XG4gICAgICAgIG9yaWdpbmFsU2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUgKSB7XG4gICAgICAgICAgaWYgKGl0ZXJzLnNvbWUoZnVuY3Rpb24oaXRlciApIHtyZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSl9KSkge1xuICAgICAgICAgICAgc2V0LnJlbW92ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy51bmlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLm1lcmdlV2l0aCA9IGZ1bmN0aW9uKG1lcmdlcikge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIHRoaXMudW5pb24uYXBwbHkodGhpcywgaXRlcnMpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gICAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICAgIHJldHVybiBPcmRlcmVkU2V0KHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbihtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIExhdGUgYmluZGluZ1xuICAgICAgcmV0dXJuIE9yZGVyZWRTZXQoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC53YXNBbHRlcmVkKCk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9tYXAuX19pdGVyYXRlKGZ1bmN0aW9uKF8sIGspICB7cmV0dXJuIGZuKGssIGssIHRoaXMkMCl9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC5tYXAoZnVuY3Rpb24oXywgaykgIHtyZXR1cm4ga30pLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX21ha2UobmV3TWFwLCBvd25lcklEKTtcbiAgICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNTZXQobWF5YmVTZXQpIHtcbiAgICByZXR1cm4gISEobWF5YmVTZXQgJiYgbWF5YmVTZXRbSVNfU0VUX1NFTlRJTkVMXSk7XG4gIH1cblxuICBTZXQuaXNTZXQgPSBpc1NldDtcblxuICB2YXIgSVNfU0VUX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfU0VUX19AQCc7XG5cbiAgdmFyIFNldFByb3RvdHlwZSA9IFNldC5wcm90b3R5cGU7XG4gIFNldFByb3RvdHlwZVtJU19TRVRfU0VOVElORUxdID0gdHJ1ZTtcbiAgU2V0UHJvdG90eXBlW0RFTEVURV0gPSBTZXRQcm90b3R5cGUucmVtb3ZlO1xuICBTZXRQcm90b3R5cGUubWVyZ2VEZWVwID0gU2V0UHJvdG90eXBlLm1lcmdlO1xuICBTZXRQcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IFNldFByb3RvdHlwZS5tZXJnZVdpdGg7XG4gIFNldFByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gTWFwUHJvdG90eXBlLndpdGhNdXRhdGlvbnM7XG4gIFNldFByb3RvdHlwZS5hc011dGFibGUgPSBNYXBQcm90b3R5cGUuYXNNdXRhYmxlO1xuICBTZXRQcm90b3R5cGUuYXNJbW11dGFibGUgPSBNYXBQcm90b3R5cGUuYXNJbW11dGFibGU7XG5cbiAgU2V0UHJvdG90eXBlLl9fZW1wdHkgPSBlbXB0eVNldDtcbiAgU2V0UHJvdG90eXBlLl9fbWFrZSA9IG1ha2VTZXQ7XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2V0KHNldCwgbmV3TWFwKSB7XG4gICAgaWYgKHNldC5fX293bmVySUQpIHtcbiAgICAgIHNldC5zaXplID0gbmV3TWFwLnNpemU7XG4gICAgICBzZXQuX21hcCA9IG5ld01hcDtcbiAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdNYXAgPT09IHNldC5fbWFwID8gc2V0IDpcbiAgICAgIG5ld01hcC5zaXplID09PSAwID8gc2V0Ll9fZW1wdHkoKSA6XG4gICAgICBzZXQuX19tYWtlKG5ld01hcCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlU2V0KG1hcCwgb3duZXJJRCkge1xuICAgIHZhciBzZXQgPSBPYmplY3QuY3JlYXRlKFNldFByb3RvdHlwZSk7XG4gICAgc2V0LnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG4gICAgc2V0Ll9tYXAgPSBtYXA7XG4gICAgc2V0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgcmV0dXJuIHNldDtcbiAgfVxuXG4gIHZhciBFTVBUWV9TRVQ7XG4gIGZ1bmN0aW9uIGVtcHR5U2V0KCkge1xuICAgIHJldHVybiBFTVBUWV9TRVQgfHwgKEVNUFRZX1NFVCA9IG1ha2VTZXQoZW1wdHlNYXAoKSkpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoT3JkZXJlZFNldCwgU2V0KTtcblxuICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cbiAgICBmdW5jdGlvbiBPcmRlcmVkU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5T3JkZXJlZFNldCgpIDpcbiAgICAgICAgaXNPcmRlcmVkU2V0KHZhbHVlKSA/IHZhbHVlIDpcbiAgICAgICAgZW1wdHlPcmRlcmVkU2V0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbihzZXQgKSB7XG4gICAgICAgICAgdmFyIGl0ZXIgPSBTZXRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24odiApIHtyZXR1cm4gc2V0LmFkZCh2KX0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBPcmRlcmVkU2V0Lm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZFNldC5mcm9tS2V5cyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcyhLZXllZEl0ZXJhYmxlKHZhbHVlKS5rZXlTZXEoKSk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdPcmRlcmVkU2V0IHsnLCAnfScpO1xuICAgIH07XG5cblxuICBmdW5jdGlvbiBpc09yZGVyZWRTZXQobWF5YmVPcmRlcmVkU2V0KSB7XG4gICAgcmV0dXJuIGlzU2V0KG1heWJlT3JkZXJlZFNldCkgJiYgaXNPcmRlcmVkKG1heWJlT3JkZXJlZFNldCk7XG4gIH1cblxuICBPcmRlcmVkU2V0LmlzT3JkZXJlZFNldCA9IGlzT3JkZXJlZFNldDtcblxuICB2YXIgT3JkZXJlZFNldFByb3RvdHlwZSA9IE9yZGVyZWRTZXQucHJvdG90eXBlO1xuICBPcmRlcmVkU2V0UHJvdG90eXBlW0lTX09SREVSRURfU0VOVElORUxdID0gdHJ1ZTtcblxuICBPcmRlcmVkU2V0UHJvdG90eXBlLl9fZW1wdHkgPSBlbXB0eU9yZGVyZWRTZXQ7XG4gIE9yZGVyZWRTZXRQcm90b3R5cGUuX19tYWtlID0gbWFrZU9yZGVyZWRTZXQ7XG5cbiAgZnVuY3Rpb24gbWFrZU9yZGVyZWRTZXQobWFwLCBvd25lcklEKSB7XG4gICAgdmFyIHNldCA9IE9iamVjdC5jcmVhdGUoT3JkZXJlZFNldFByb3RvdHlwZSk7XG4gICAgc2V0LnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG4gICAgc2V0Ll9tYXAgPSBtYXA7XG4gICAgc2V0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgcmV0dXJuIHNldDtcbiAgfVxuXG4gIHZhciBFTVBUWV9PUkRFUkVEX1NFVDtcbiAgZnVuY3Rpb24gZW1wdHlPcmRlcmVkU2V0KCkge1xuICAgIHJldHVybiBFTVBUWV9PUkRFUkVEX1NFVCB8fCAoRU1QVFlfT1JERVJFRF9TRVQgPSBtYWtlT3JkZXJlZFNldChlbXB0eU9yZGVyZWRNYXAoKSkpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoU3RhY2ssIEluZGV4ZWRDb2xsZWN0aW9uKTtcblxuICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cbiAgICBmdW5jdGlvbiBTdGFjayh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eVN0YWNrKCkgOlxuICAgICAgICBpc1N0YWNrKHZhbHVlKSA/IHZhbHVlIDpcbiAgICAgICAgZW1wdHlTdGFjaygpLnVuc2hpZnRBbGwodmFsdWUpO1xuICAgIH1cblxuICAgIFN0YWNrLm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTdGFjayBbJywgJ10nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIHdoaWxlIChoZWFkICYmIGluZGV4LS0pIHtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZWFkID8gaGVhZC52YWx1ZSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hlYWQgJiYgdGhpcy5faGVhZC52YWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIFN0YWNrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZSArIGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBmb3IgKHZhciBpaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpaSA+PSAwOyBpaS0tKSB7XG4gICAgICAgIGhlYWQgPSB7XG4gICAgICAgICAgdmFsdWU6IGFyZ3VtZW50c1tpaV0sXG4gICAgICAgICAgbmV4dDogaGVhZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5wdXNoQWxsID0gZnVuY3Rpb24oaXRlcikge1xuICAgICAgaXRlciA9IEluZGV4ZWRJdGVyYWJsZShpdGVyKTtcbiAgICAgIGlmIChpdGVyLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemU7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBpdGVyLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlICkge1xuICAgICAgICBuZXdTaXplKys7XG4gICAgICAgIGhlYWQgPSB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIG5leHQ6IGhlYWRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKDEpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnVuc2hpZnRBbGwgPSBmdW5jdGlvbihpdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoQWxsKGl0ZXIpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlTdGFjaygpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCB0aGlzLnNpemUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIHJlc29sdmVkQmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgcmVzb2x2ZWRFbmQgPSByZXNvbHZlRW5kKGVuZCwgdGhpcy5zaXplKTtcbiAgICAgIGlmIChyZXNvbHZlZEVuZCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgIC8vIHN1cGVyLnNsaWNlKGJlZ2luLCBlbmQpO1xuICAgICAgICByZXR1cm4gSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZSAtIHJlc29sdmVkQmVnaW47XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICB3aGlsZSAocmVzb2x2ZWRCZWdpbi0tKSB7XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNdXRhYmlsaXR5XG5cbiAgICBTdGFjay5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VTdGFjayh0aGlzLnNpemUsIHRoaXMuX2hlYWQsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBJdGVyYXRpb25cblxuICAgIFN0YWNrLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLl9faXRlcmF0ZShmbik7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYWQ7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAoZm4obm9kZS52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLl9faXRlcmF0b3IodHlwZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYWQ7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuXG4gIGZ1bmN0aW9uIGlzU3RhY2sobWF5YmVTdGFjaykge1xuICAgIHJldHVybiAhIShtYXliZVN0YWNrICYmIG1heWJlU3RhY2tbSVNfU1RBQ0tfU0VOVElORUxdKTtcbiAgfVxuXG4gIFN0YWNrLmlzU3RhY2sgPSBpc1N0YWNrO1xuXG4gIHZhciBJU19TVEFDS19TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX1NUQUNLX19AQCc7XG5cbiAgdmFyIFN0YWNrUHJvdG90eXBlID0gU3RhY2sucHJvdG90eXBlO1xuICBTdGFja1Byb3RvdHlwZVtJU19TVEFDS19TRU5USU5FTF0gPSB0cnVlO1xuICBTdGFja1Byb3RvdHlwZS53aXRoTXV0YXRpb25zID0gTWFwUHJvdG90eXBlLndpdGhNdXRhdGlvbnM7XG4gIFN0YWNrUHJvdG90eXBlLmFzTXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc011dGFibGU7XG4gIFN0YWNrUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzSW1tdXRhYmxlO1xuICBTdGFja1Byb3RvdHlwZS53YXNBbHRlcmVkID0gTWFwUHJvdG90eXBlLndhc0FsdGVyZWQ7XG5cblxuICBmdW5jdGlvbiBtYWtlU3RhY2soc2l6ZSwgaGVhZCwgb3duZXJJRCwgaGFzaCkge1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKFN0YWNrUHJvdG90eXBlKTtcbiAgICBtYXAuc2l6ZSA9IHNpemU7XG4gICAgbWFwLl9oZWFkID0gaGVhZDtcbiAgICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgICBtYXAuX19oYXNoID0gaGFzaDtcbiAgICBtYXAuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIHZhciBFTVBUWV9TVEFDSztcbiAgZnVuY3Rpb24gZW1wdHlTdGFjaygpIHtcbiAgICByZXR1cm4gRU1QVFlfU1RBQ0sgfHwgKEVNUFRZX1NUQUNLID0gbWFrZVN0YWNrKDApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cmlidXRlcyBhZGRpdGlvbmFsIG1ldGhvZHMgdG8gYSBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gbWl4aW4oY3RvciwgbWV0aG9kcykge1xuICAgIHZhciBrZXlDb3BpZXIgPSBmdW5jdGlvbihrZXkgKSB7IGN0b3IucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07IH07XG4gICAgT2JqZWN0LmtleXMobWV0aG9kcykuZm9yRWFjaChrZXlDb3BpZXIpO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiZcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWV0aG9kcykuZm9yRWFjaChrZXlDb3BpZXIpO1xuICAgIHJldHVybiBjdG9yO1xuICB9XG5cbiAgSXRlcmFibGUuSXRlcmF0b3IgPSBJdGVyYXRvcjtcblxuICBtaXhpbihJdGVyYWJsZSwge1xuXG4gICAgLy8gIyMjIENvbnZlcnNpb24gdG8gb3RoZXIgdHlwZXNcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheSh0aGlzLnNpemUgfHwgMCk7XG4gICAgICB0aGlzLnZhbHVlU2VxKCkuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGkpICB7IGFycmF5W2ldID0gdjsgfSk7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcblxuICAgIHRvSW5kZXhlZFNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFRvSW5kZXhlZFNlcXVlbmNlKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b0pTOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU2VxKCkubWFwKFxuICAgICAgICBmdW5jdGlvbih2YWx1ZSApIHtyZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvSlMgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS50b0pTKCkgOiB2YWx1ZX1cbiAgICAgICkuX190b0pTKCk7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1NlcSgpLm1hcChcbiAgICAgICAgZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicgPyB2YWx1ZS50b0pTT04oKSA6IHZhbHVlfVxuICAgICAgKS5fX3RvSlMoKTtcbiAgICB9LFxuXG4gICAgdG9LZXllZFNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFRvS2V5ZWRTZXF1ZW5jZSh0aGlzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgdG9NYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIE1hcCh0aGlzLnRvS2V5ZWRTZXEoKSk7XG4gICAgfSxcblxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAgeyBvYmplY3Rba10gPSB2OyB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIHRvT3JkZXJlZE1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gT3JkZXJlZE1hcCh0aGlzLnRvS2V5ZWRTZXEoKSk7XG4gICAgfSxcblxuICAgIHRvT3JkZXJlZFNldDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gT3JkZXJlZFNldChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gICAgfSxcblxuICAgIHRvU2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBTZXQoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b1NldFNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFRvU2V0U2VxdWVuY2UodGhpcyk7XG4gICAgfSxcblxuICAgIHRvU2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpc0luZGV4ZWQodGhpcykgPyB0aGlzLnRvSW5kZXhlZFNlcSgpIDpcbiAgICAgICAgaXNLZXllZCh0aGlzKSA/IHRoaXMudG9LZXllZFNlcSgpIDpcbiAgICAgICAgdGhpcy50b1NldFNlcSgpO1xuICAgIH0sXG5cbiAgICB0b1N0YWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBTdGFjayhpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gICAgfSxcblxuICAgIHRvTGlzdDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gTGlzdChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gICAgfSxcblxuXG4gICAgLy8gIyMjIENvbW1vbiBKYXZhU2NyaXB0IG1ldGhvZHMgYW5kIHByb3BlcnRpZXNcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnW0l0ZXJhYmxlXSc7XG4gICAgfSxcblxuICAgIF9fdG9TdHJpbmc6IGZ1bmN0aW9uKGhlYWQsIHRhaWwpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlYWQgKyAnICcgKyB0aGlzLnRvU2VxKCkubWFwKHRoaXMuX190b1N0cmluZ01hcHBlcikuam9pbignLCAnKSArICcgJyArIHRhaWw7XG4gICAgfSxcblxuXG4gICAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG4gICAgY29uY2F0OiBmdW5jdGlvbigpIHt2YXIgdmFsdWVzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgY29uY2F0RmFjdG9yeSh0aGlzLCB2YWx1ZXMpKTtcbiAgICB9LFxuXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uKHZhbHVlICkge3JldHVybiBpcyh2YWx1ZSwgc2VhcmNoVmFsdWUpfSk7XG4gICAgfSxcblxuICAgIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMpO1xuICAgIH0sXG5cbiAgICBldmVyeTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGssIGMpICB7XG4gICAgICAgIGlmICghcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSxcblxuICAgIGZpbHRlcjogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmlsdGVyRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgZmluZDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzFdIDogbm90U2V0VmFsdWU7XG4gICAgfSxcblxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKHNpZGVFZmZlY3QsIGNvbnRleHQpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdGUoY29udGV4dCA/IHNpZGVFZmZlY3QuYmluZChjb250ZXh0KSA6IHNpZGVFZmZlY3QpO1xuICAgIH0sXG5cbiAgICBqb2luOiBmdW5jdGlvbihzZXBhcmF0b3IpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/ICcnICsgc2VwYXJhdG9yIDogJywnO1xuICAgICAgdmFyIGpvaW5lZCA9ICcnO1xuICAgICAgdmFyIGlzRmlyc3QgPSB0cnVlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24odiApIHtcbiAgICAgICAgaXNGaXJzdCA/IChpc0ZpcnN0ID0gZmFsc2UpIDogKGpvaW5lZCArPSBzZXBhcmF0b3IpO1xuICAgICAgICBqb2luZWQgKz0gdiAhPT0gbnVsbCAmJiB2ICE9PSB1bmRlZmluZWQgPyB2LnRvU3RyaW5nKCkgOiAnJztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGpvaW5lZDtcbiAgICB9LFxuXG4gICAga2V5czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfS0VZUyk7XG4gICAgfSxcblxuICAgIG1hcDogZnVuY3Rpb24obWFwcGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgbWFwRmFjdG9yeSh0aGlzLCBtYXBwZXIsIGNvbnRleHQpKTtcbiAgICB9LFxuXG4gICAgcmVkdWNlOiBmdW5jdGlvbihyZWR1Y2VyLCBpbml0aWFsUmVkdWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgdmFyIHJlZHVjdGlvbjtcbiAgICAgIHZhciB1c2VGaXJzdDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICB1c2VGaXJzdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWR1Y3Rpb24gPSBpbml0aWFsUmVkdWN0aW9uO1xuICAgICAgfVxuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaywgYykgIHtcbiAgICAgICAgaWYgKHVzZUZpcnN0KSB7XG4gICAgICAgICAgdXNlRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICByZWR1Y3Rpb24gPSB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZHVjdGlvbiA9IHJlZHVjZXIuY2FsbChjb250ZXh0LCByZWR1Y3Rpb24sIHYsIGssIGMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZWR1Y3Rpb247XG4gICAgfSxcblxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbihyZWR1Y2VyLCBpbml0aWFsUmVkdWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmV2ZXJzZWQgPSB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gcmV2ZXJzZWQucmVkdWNlLmFwcGx5KHJldmVyc2VkLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCByZXZlcnNlRmFjdG9yeSh0aGlzLCB0cnVlKSk7XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2xpY2VGYWN0b3J5KHRoaXMsIGJlZ2luLCBlbmQsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgc29tZTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gIXRoaXMuZXZlcnkobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBzb3J0OiBmdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvcikpO1xuICAgIH0sXG5cbiAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUyk7XG4gICAgfSxcblxuXG4gICAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cbiAgICBidXRMYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIC0xKTtcbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplICE9PSB1bmRlZmluZWQgPyB0aGlzLnNpemUgPT09IDAgOiAhdGhpcy5zb21lKGZ1bmN0aW9uKCkgIHtyZXR1cm4gdHJ1ZX0pO1xuICAgIH0sXG5cbiAgICBjb3VudDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gZW5zdXJlU2l6ZShcbiAgICAgICAgcHJlZGljYXRlID8gdGhpcy50b1NlcSgpLmZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpIDogdGhpc1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgY291bnRCeTogZnVuY3Rpb24oZ3JvdXBlciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGNvdW50QnlGYWN0b3J5KHRoaXMsIGdyb3VwZXIsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICByZXR1cm4gZGVlcEVxdWFsKHRoaXMsIG90aGVyKTtcbiAgICB9LFxuXG4gICAgZW50cnlTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcztcbiAgICAgIGlmIChpdGVyYWJsZS5fY2FjaGUpIHtcbiAgICAgICAgLy8gV2UgY2FjaGUgYXMgYW4gZW50cmllcyBhcnJheSwgc28gd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBjYWNoZSFcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVNlcShpdGVyYWJsZS5fY2FjaGUpO1xuICAgICAgfVxuICAgICAgdmFyIGVudHJpZXNTZXF1ZW5jZSA9IGl0ZXJhYmxlLnRvU2VxKCkubWFwKGVudHJ5TWFwcGVyKS50b0luZGV4ZWRTZXEoKTtcbiAgICAgIGVudHJpZXNTZXF1ZW5jZS5mcm9tRW50cnlTZXEgPSBmdW5jdGlvbigpICB7cmV0dXJuIGl0ZXJhYmxlLnRvU2VxKCl9O1xuICAgICAgcmV0dXJuIGVudHJpZXNTZXF1ZW5jZTtcbiAgICB9LFxuXG4gICAgZmlsdGVyTm90OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGZpbmRFbnRyeTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGZvdW5kID0gbm90U2V0VmFsdWU7XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrLCBjKSAge1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgICBmb3VuZCA9IFtrLCB2XTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH0sXG5cbiAgICBmaW5kS2V5OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF07XG4gICAgfSxcblxuICAgIGZpbmRMYXN0OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGZpbmRMYXN0RW50cnk6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBmaW5kTGFzdEtleTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpLmZpbmRLZXkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChyZXR1cm5UcnVlKTtcbiAgICB9LFxuXG4gICAgZmxhdE1hcDogZnVuY3Rpb24obWFwcGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdE1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KSk7XG4gICAgfSxcblxuICAgIGZsYXR0ZW46IGZ1bmN0aW9uKGRlcHRoKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdHRlbkZhY3RvcnkodGhpcywgZGVwdGgsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgZnJvbUVudHJ5U2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRnJvbUVudHJpZXNTZXF1ZW5jZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbihzZWFyY2hLZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uKF8sIGtleSkgIHtyZXR1cm4gaXMoa2V5LCBzZWFyY2hLZXkpfSwgdW5kZWZpbmVkLCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGdldEluOiBmdW5jdGlvbihzZWFyY2hLZXlQYXRoLCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIG5lc3RlZCA9IHRoaXM7XG4gICAgICAvLyBOb3RlOiBpbiBhbiBFUzYgZW52aXJvbm1lbnQsIHdlIHdvdWxkIHByZWZlcjpcbiAgICAgIC8vIGZvciAodmFyIGtleSBvZiBzZWFyY2hLZXlQYXRoKSB7XG4gICAgICB2YXIgaXRlciA9IGZvcmNlSXRlcmF0b3Ioc2VhcmNoS2V5UGF0aCk7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICB2YXIga2V5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkICYmIG5lc3RlZC5nZXQgPyBuZXN0ZWQuZ2V0KGtleSwgTk9UX1NFVCkgOiBOT1RfU0VUO1xuICAgICAgICBpZiAobmVzdGVkID09PSBOT1RfU0VUKSB7XG4gICAgICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmVzdGVkO1xuICAgIH0sXG5cbiAgICBncm91cEJ5OiBmdW5jdGlvbihncm91cGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gZ3JvdXBCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24oc2VhcmNoS2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoc2VhcmNoS2V5LCBOT1RfU0VUKSAhPT0gTk9UX1NFVDtcbiAgICB9LFxuXG4gICAgaGFzSW46IGZ1bmN0aW9uKHNlYXJjaEtleVBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEluKHNlYXJjaEtleVBhdGgsIE5PVF9TRVQpICE9PSBOT1RfU0VUO1xuICAgIH0sXG5cbiAgICBpc1N1YnNldDogZnVuY3Rpb24oaXRlcikge1xuICAgICAgaXRlciA9IHR5cGVvZiBpdGVyLmluY2x1ZGVzID09PSAnZnVuY3Rpb24nID8gaXRlciA6IEl0ZXJhYmxlKGl0ZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZXZlcnkoZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIGl0ZXIuaW5jbHVkZXModmFsdWUpfSk7XG4gICAgfSxcblxuICAgIGlzU3VwZXJzZXQ6IGZ1bmN0aW9uKGl0ZXIpIHtcbiAgICAgIGl0ZXIgPSB0eXBlb2YgaXRlci5pc1N1YnNldCA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZXIgOiBJdGVyYWJsZShpdGVyKTtcbiAgICAgIHJldHVybiBpdGVyLmlzU3Vic2V0KHRoaXMpO1xuICAgIH0sXG5cbiAgICBrZXlPZjogZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRLZXkoZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIGlzKHZhbHVlLCBzZWFyY2hWYWx1ZSl9KTtcbiAgICB9LFxuXG4gICAga2V5U2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU2VxKCkubWFwKGtleU1hcHBlcikudG9JbmRleGVkU2VxKCk7XG4gICAgfSxcblxuICAgIGxhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TZXEoKS5yZXZlcnNlKCkuZmlyc3QoKTtcbiAgICB9LFxuXG4gICAgbGFzdEtleU9mOiBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpLnJldmVyc2UoKS5rZXlPZihzZWFyY2hWYWx1ZSk7XG4gICAgfSxcblxuICAgIG1heDogZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIG1heEZhY3RvcnkodGhpcywgY29tcGFyYXRvcik7XG4gICAgfSxcblxuICAgIG1heEJ5OiBmdW5jdGlvbihtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcik7XG4gICAgfSxcblxuICAgIG1pbjogZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIG1heEZhY3RvcnkodGhpcywgY29tcGFyYXRvciA/IG5lZyhjb21wYXJhdG9yKSA6IGRlZmF1bHROZWdDb21wYXJhdG9yKTtcbiAgICB9LFxuXG4gICAgbWluQnk6IGZ1bmN0aW9uKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIG1heEZhY3RvcnkodGhpcywgY29tcGFyYXRvciA/IG5lZyhjb21wYXJhdG9yKSA6IGRlZmF1bHROZWdDb21wYXJhdG9yLCBtYXBwZXIpO1xuICAgIH0sXG5cbiAgICByZXN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKDEpO1xuICAgIH0sXG5cbiAgICBza2lwOiBmdW5jdGlvbihhbW91bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKE1hdGgubWF4KDAsIGFtb3VudCkpO1xuICAgIH0sXG5cbiAgICBza2lwTGFzdDogZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgdGhpcy50b1NlcSgpLnJldmVyc2UoKS5za2lwKGFtb3VudCkucmV2ZXJzZSgpKTtcbiAgICB9LFxuXG4gICAgc2tpcFdoaWxlOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBza2lwV2hpbGVGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICBza2lwVW50aWw6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2tpcFdoaWxlKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgc29ydEJ5OiBmdW5jdGlvbihtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcbiAgICB9LFxuXG4gICAgdGFrZTogZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgwLCBNYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgICB9LFxuXG4gICAgdGFrZUxhc3Q6IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHRoaXMudG9TZXEoKS5yZXZlcnNlKCkudGFrZShhbW91bnQpLnJldmVyc2UoKSk7XG4gICAgfSxcblxuICAgIHRha2VXaGlsZTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgdGFrZVdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQpKTtcbiAgICB9LFxuXG4gICAgdGFrZVVudGlsOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRha2VXaGlsZShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIHZhbHVlU2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvSW5kZXhlZFNlcSgpO1xuICAgIH0sXG5cblxuICAgIC8vICMjIyBIYXNoYWJsZSBPYmplY3RcblxuICAgIGhhc2hDb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9faGFzaCB8fCAodGhpcy5fX2hhc2ggPSBoYXNoSXRlcmFibGUodGhpcykpO1xuICAgIH1cblxuXG4gICAgLy8gIyMjIEludGVybmFsXG5cbiAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdGUoZm4sIHJldmVyc2UpXG5cbiAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpXG4gIH0pO1xuXG4gIC8vIHZhciBJU19JVEVSQUJMRV9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0lURVJBQkxFX19AQCc7XG4gIC8vIHZhciBJU19LRVlFRF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0tFWUVEX19AQCc7XG4gIC8vIHZhciBJU19JTkRFWEVEX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfSU5ERVhFRF9fQEAnO1xuICAvLyB2YXIgSVNfT1JERVJFRF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX09SREVSRURfX0BAJztcblxuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIEl0ZXJhYmxlUHJvdG90eXBlW0lTX0lURVJBQkxFX1NFTlRJTkVMXSA9IHRydWU7XG4gIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBJdGVyYWJsZVByb3RvdHlwZS52YWx1ZXM7XG4gIEl0ZXJhYmxlUHJvdG90eXBlLl9fdG9KUyA9IEl0ZXJhYmxlUHJvdG90eXBlLnRvQXJyYXk7XG4gIEl0ZXJhYmxlUHJvdG90eXBlLl9fdG9TdHJpbmdNYXBwZXIgPSBxdW90ZVN0cmluZztcbiAgSXRlcmFibGVQcm90b3R5cGUuaW5zcGVjdCA9XG4gIEl0ZXJhYmxlUHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRvU3RyaW5nKCk7IH07XG4gIEl0ZXJhYmxlUHJvdG90eXBlLmNoYWluID0gSXRlcmFibGVQcm90b3R5cGUuZmxhdE1hcDtcbiAgSXRlcmFibGVQcm90b3R5cGUuY29udGFpbnMgPSBJdGVyYWJsZVByb3RvdHlwZS5pbmNsdWRlcztcblxuICBtaXhpbihLZXllZEl0ZXJhYmxlLCB7XG5cbiAgICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICAgIGZsaXA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsaXBGYWN0b3J5KHRoaXMpKTtcbiAgICB9LFxuXG4gICAgbWFwRW50cmllczogZnVuY3Rpb24obWFwcGVyLCBjb250ZXh0KSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcyxcbiAgICAgICAgdGhpcy50b1NlcSgpLm1hcChcbiAgICAgICAgICBmdW5jdGlvbih2LCBrKSAge3JldHVybiBtYXBwZXIuY2FsbChjb250ZXh0LCBbaywgdl0sIGl0ZXJhdGlvbnMrKywgdGhpcyQwKX1cbiAgICAgICAgKS5mcm9tRW50cnlTZXEoKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgbWFwS2V5czogZnVuY3Rpb24obWFwcGVyLCBjb250ZXh0KSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcyxcbiAgICAgICAgdGhpcy50b1NlcSgpLmZsaXAoKS5tYXAoXG4gICAgICAgICAgZnVuY3Rpb24oaywgdikgIHtyZXR1cm4gbWFwcGVyLmNhbGwoY29udGV4dCwgaywgdiwgdGhpcyQwKX1cbiAgICAgICAgKS5mbGlwKClcbiAgICAgICk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIHZhciBLZXllZEl0ZXJhYmxlUHJvdG90eXBlID0gS2V5ZWRJdGVyYWJsZS5wcm90b3R5cGU7XG4gIEtleWVkSXRlcmFibGVQcm90b3R5cGVbSVNfS0VZRURfU0VOVElORUxdID0gdHJ1ZTtcbiAgS2V5ZWRJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcztcbiAgS2V5ZWRJdGVyYWJsZVByb3RvdHlwZS5fX3RvSlMgPSBJdGVyYWJsZVByb3RvdHlwZS50b09iamVjdDtcbiAgS2V5ZWRJdGVyYWJsZVByb3RvdHlwZS5fX3RvU3RyaW5nTWFwcGVyID0gZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoaykgKyAnOiAnICsgcXVvdGVTdHJpbmcodil9O1xuXG5cblxuICBtaXhpbihJbmRleGVkSXRlcmFibGUsIHtcblxuICAgIC8vICMjIyBDb252ZXJzaW9uIHRvIG90aGVyIHR5cGVzXG5cbiAgICB0b0tleWVkU2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgVG9LZXllZFNlcXVlbmNlKHRoaXMsIGZhbHNlKTtcbiAgICB9LFxuXG5cbiAgICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZpbHRlckZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCBmYWxzZSkpO1xuICAgIH0sXG5cbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzBdIDogLTE7XG4gICAgfSxcblxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5rZXlPZihzZWFyY2hWYWx1ZSk7XG4gICAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgPyAtMSA6IGtleTtcbiAgICB9LFxuXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5sYXN0S2V5T2Yoc2VhcmNoVmFsdWUpO1xuICAgICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID8gLTEgOiBrZXk7XG4gICAgfSxcblxuICAgIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHJldmVyc2VGYWN0b3J5KHRoaXMsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2xpY2VGYWN0b3J5KHRoaXMsIGJlZ2luLCBlbmQsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHNwbGljZTogZnVuY3Rpb24oaW5kZXgsIHJlbW92ZU51bSAvKiwgLi4udmFsdWVzKi8pIHtcbiAgICAgIHZhciBudW1BcmdzID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHJlbW92ZU51bSA9IE1hdGgubWF4KHJlbW92ZU51bSB8IDAsIDApO1xuICAgICAgaWYgKG51bUFyZ3MgPT09IDAgfHwgKG51bUFyZ3MgPT09IDIgJiYgIXJlbW92ZU51bSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICAvLyBJZiBpbmRleCBpcyBuZWdhdGl2ZSwgaXQgc2hvdWxkIHJlc29sdmUgcmVsYXRpdmUgdG8gdGhlIHNpemUgb2YgdGhlXG4gICAgICAvLyBjb2xsZWN0aW9uLiBIb3dldmVyIHNpemUgbWF5IGJlIGV4cGVuc2l2ZSB0byBjb21wdXRlIGlmIG5vdCBjYWNoZWQsIHNvXG4gICAgICAvLyBvbmx5IGNhbGwgY291bnQoKSBpZiB0aGUgbnVtYmVyIGlzIGluIGZhY3QgbmVnYXRpdmUuXG4gICAgICBpbmRleCA9IHJlc29sdmVCZWdpbihpbmRleCwgaW5kZXggPCAwID8gdGhpcy5jb3VudCgpIDogdGhpcy5zaXplKTtcbiAgICAgIHZhciBzcGxpY2VkID0gdGhpcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICByZXR1cm4gcmVpZnkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG51bUFyZ3MgPT09IDEgP1xuICAgICAgICAgIHNwbGljZWQgOlxuICAgICAgICAgIHNwbGljZWQuY29uY2F0KGFyckNvcHkoYXJndW1lbnRzLCAyKSwgdGhpcy5zbGljZShpbmRleCArIHJlbW92ZU51bSkpXG4gICAgICApO1xuICAgIH0sXG5cblxuICAgIC8vICMjIyBNb3JlIGNvbGxlY3Rpb24gbWV0aG9kc1xuXG4gICAgZmluZExhc3RJbmRleDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRMYXN0RW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzBdIDogLTE7XG4gICAgfSxcblxuICAgIGZpcnN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgwKTtcbiAgICB9LFxuXG4gICAgZmxhdHRlbjogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGF0dGVuRmFjdG9yeSh0aGlzLCBkZXB0aCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIHJldHVybiAoaW5kZXggPCAwIHx8ICh0aGlzLnNpemUgPT09IEluZmluaXR5IHx8XG4gICAgICAgICAgKHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGluZGV4ID4gdGhpcy5zaXplKSkpID9cbiAgICAgICAgbm90U2V0VmFsdWUgOlxuICAgICAgICB0aGlzLmZpbmQoZnVuY3Rpb24oXywga2V5KSAge3JldHVybiBrZXkgPT09IGluZGV4fSwgdW5kZWZpbmVkLCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIHJldHVybiBpbmRleCA+PSAwICYmICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHwgaW5kZXggPCB0aGlzLnNpemUgOlxuICAgICAgICB0aGlzLmluZGV4T2YoaW5kZXgpICE9PSAtMVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgaW50ZXJwb3NlOiBmdW5jdGlvbihzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBpbnRlcnBvc2VGYWN0b3J5KHRoaXMsIHNlcGFyYXRvcikpO1xuICAgIH0sXG5cbiAgICBpbnRlcmxlYXZlOiBmdW5jdGlvbigvKi4uLml0ZXJhYmxlcyovKSB7XG4gICAgICB2YXIgaXRlcmFibGVzID0gW3RoaXNdLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cykpO1xuICAgICAgdmFyIHppcHBlZCA9IHppcFdpdGhGYWN0b3J5KHRoaXMudG9TZXEoKSwgSW5kZXhlZFNlcS5vZiwgaXRlcmFibGVzKTtcbiAgICAgIHZhciBpbnRlcmxlYXZlZCA9IHppcHBlZC5mbGF0dGVuKHRydWUpO1xuICAgICAgaWYgKHppcHBlZC5zaXplKSB7XG4gICAgICAgIGludGVybGVhdmVkLnNpemUgPSB6aXBwZWQuc2l6ZSAqIGl0ZXJhYmxlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgaW50ZXJsZWF2ZWQpO1xuICAgIH0sXG5cbiAgICBrZXlTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFJhbmdlKDAsIHRoaXMuc2l6ZSk7XG4gICAgfSxcblxuICAgIGxhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KC0xKTtcbiAgICB9LFxuXG4gICAgc2tpcFdoaWxlOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBza2lwV2hpbGVGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgemlwOiBmdW5jdGlvbigvKiwgLi4uaXRlcmFibGVzICovKSB7XG4gICAgICB2YXIgaXRlcmFibGVzID0gW3RoaXNdLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cykpO1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHppcFdpdGhGYWN0b3J5KHRoaXMsIGRlZmF1bHRaaXBwZXIsIGl0ZXJhYmxlcykpO1xuICAgIH0sXG5cbiAgICB6aXBXaXRoOiBmdW5jdGlvbih6aXBwZXIvKiwgLi4uaXRlcmFibGVzICovKSB7XG4gICAgICB2YXIgaXRlcmFibGVzID0gYXJyQ29weShhcmd1bWVudHMpO1xuICAgICAgaXRlcmFibGVzWzBdID0gdGhpcztcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCB6aXBXaXRoRmFjdG9yeSh0aGlzLCB6aXBwZXIsIGl0ZXJhYmxlcykpO1xuICAgIH1cblxuICB9KTtcblxuICBJbmRleGVkSXRlcmFibGUucHJvdG90eXBlW0lTX0lOREVYRURfU0VOVElORUxdID0gdHJ1ZTtcbiAgSW5kZXhlZEl0ZXJhYmxlLnByb3RvdHlwZVtJU19PUkRFUkVEX1NFTlRJTkVMXSA9IHRydWU7XG5cblxuXG4gIG1peGluKFNldEl0ZXJhYmxlLCB7XG5cbiAgICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKHZhbHVlLCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKHZhbHVlKSA/IHZhbHVlIDogbm90U2V0VmFsdWU7XG4gICAgfSxcblxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKHZhbHVlKTtcbiAgICB9LFxuXG5cbiAgICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICAgIGtleVNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZVNlcSgpO1xuICAgIH1cblxuICB9KTtcblxuICBTZXRJdGVyYWJsZS5wcm90b3R5cGUuaGFzID0gSXRlcmFibGVQcm90b3R5cGUuaW5jbHVkZXM7XG4gIFNldEl0ZXJhYmxlLnByb3RvdHlwZS5jb250YWlucyA9IFNldEl0ZXJhYmxlLnByb3RvdHlwZS5pbmNsdWRlcztcblxuXG4gIC8vIE1peGluIHN1YmNsYXNzZXNcblxuICBtaXhpbihLZXllZFNlcSwgS2V5ZWRJdGVyYWJsZS5wcm90b3R5cGUpO1xuICBtaXhpbihJbmRleGVkU2VxLCBJbmRleGVkSXRlcmFibGUucHJvdG90eXBlKTtcbiAgbWl4aW4oU2V0U2VxLCBTZXRJdGVyYWJsZS5wcm90b3R5cGUpO1xuXG4gIG1peGluKEtleWVkQ29sbGVjdGlvbiwgS2V5ZWRJdGVyYWJsZS5wcm90b3R5cGUpO1xuICBtaXhpbihJbmRleGVkQ29sbGVjdGlvbiwgSW5kZXhlZEl0ZXJhYmxlLnByb3RvdHlwZSk7XG4gIG1peGluKFNldENvbGxlY3Rpb24sIFNldEl0ZXJhYmxlLnByb3RvdHlwZSk7XG5cblxuICAvLyAjcHJhZ21hIEhlbHBlciBmdW5jdGlvbnNcblxuICBmdW5jdGlvbiBrZXlNYXBwZXIodiwgaykge1xuICAgIHJldHVybiBrO1xuICB9XG5cbiAgZnVuY3Rpb24gZW50cnlNYXBwZXIodiwgaykge1xuICAgIHJldHVybiBbaywgdl07XG4gIH1cblxuICBmdW5jdGlvbiBub3QocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuZWcocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC1wcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBxdW90ZVN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRaaXBwZXIoKSB7XG4gICAgcmV0dXJuIGFyckNvcHkoYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHROZWdDb21wYXJhdG9yKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAxIDogYSA+IGIgPyAtMSA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNoSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUuc2l6ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgb3JkZXJlZCA9IGlzT3JkZXJlZChpdGVyYWJsZSk7XG4gICAgdmFyIGtleWVkID0gaXNLZXllZChpdGVyYWJsZSk7XG4gICAgdmFyIGggPSBvcmRlcmVkID8gMSA6IDA7XG4gICAgdmFyIHNpemUgPSBpdGVyYWJsZS5fX2l0ZXJhdGUoXG4gICAgICBrZXllZCA/XG4gICAgICAgIG9yZGVyZWQgP1xuICAgICAgICAgIGZ1bmN0aW9uKHYsIGspICB7IGggPSAzMSAqIGggKyBoYXNoTWVyZ2UoaGFzaCh2KSwgaGFzaChrKSkgfCAwOyB9IDpcbiAgICAgICAgICBmdW5jdGlvbih2LCBrKSAgeyBoID0gaCArIGhhc2hNZXJnZShoYXNoKHYpLCBoYXNoKGspKSB8IDA7IH0gOlxuICAgICAgICBvcmRlcmVkID9cbiAgICAgICAgICBmdW5jdGlvbih2ICkgeyBoID0gMzEgKiBoICsgaGFzaCh2KSB8IDA7IH0gOlxuICAgICAgICAgIGZ1bmN0aW9uKHYgKSB7IGggPSBoICsgaGFzaCh2KSB8IDA7IH1cbiAgICApO1xuICAgIHJldHVybiBtdXJtdXJIYXNoT2ZTaXplKHNpemUsIGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKSB7XG4gICAgaCA9IGltdWwoaCwgMHhDQzlFMkQ1MSk7XG4gICAgaCA9IGltdWwoaCA8PCAxNSB8IGggPj4+IC0xNSwgMHgxQjg3MzU5Myk7XG4gICAgaCA9IGltdWwoaCA8PCAxMyB8IGggPj4+IC0xMywgNSk7XG4gICAgaCA9IChoICsgMHhFNjU0NkI2NCB8IDApIF4gc2l6ZTtcbiAgICBoID0gaW11bChoIF4gaCA+Pj4gMTYsIDB4ODVFQkNBNkIpO1xuICAgIGggPSBpbXVsKGggXiBoID4+PiAxMywgMHhDMkIyQUUzNSk7XG4gICAgaCA9IHNtaShoIF4gaCA+Pj4gMTYpO1xuICAgIHJldHVybiBoO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzaE1lcmdlKGEsIGIpIHtcbiAgICByZXR1cm4gYSBeIGIgKyAweDlFMzc3OUI5ICsgKGEgPDwgNikgKyAoYSA+PiAyKSB8IDA7IC8vIGludFxuICB9XG5cbiAgdmFyIEltbXV0YWJsZSA9IHtcblxuICAgIEl0ZXJhYmxlOiBJdGVyYWJsZSxcblxuICAgIFNlcTogU2VxLFxuICAgIENvbGxlY3Rpb246IENvbGxlY3Rpb24sXG4gICAgTWFwOiBNYXAsXG4gICAgT3JkZXJlZE1hcDogT3JkZXJlZE1hcCxcbiAgICBMaXN0OiBMaXN0LFxuICAgIFN0YWNrOiBTdGFjayxcbiAgICBTZXQ6IFNldCxcbiAgICBPcmRlcmVkU2V0OiBPcmRlcmVkU2V0LFxuXG4gICAgUmVjb3JkOiBSZWNvcmQsXG4gICAgUmFuZ2U6IFJhbmdlLFxuICAgIFJlcGVhdDogUmVwZWF0LFxuXG4gICAgaXM6IGlzLFxuICAgIGZyb21KUzogZnJvbUpTXG5cbiAgfTtcblxuICByZXR1cm4gSW1tdXRhYmxlO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaW1tdXRhYmxlL2Rpc3QvaW1tdXRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLmRyYWZ0anNUb0h0bWw9ZSgpOnQuZHJhZnRqc1RvSHRtbD1lKCl9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHIpe2lmKG5bcl0pcmV0dXJuIG5bcl0uZXhwb3J0czt2YXIgdT1uW3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gdFtyXS5jYWxsKHUuZXhwb3J0cyx1LHUuZXhwb3J0cyxlKSx1Lmw9ITAsdS5leHBvcnRzfXZhciBuPXt9O3JldHVybiBlLm09dCxlLmM9bixlLmQ9ZnVuY3Rpb24odCxuLHIpe2Uubyh0LG4pfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6cn0pfSxlLm49ZnVuY3Rpb24odCl7dmFyIG49dCYmdC5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHQuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gdH07cmV0dXJuIGUuZChuLFwiYVwiLG4pLG59LGUubz1mdW5jdGlvbih0LGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX0sZS5wPVwiXCIsZShlLnM9MSl9KFtmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmU1t0XX1mdW5jdGlvbiB1KHQpe3ZhciBlPVwiXCI7cmV0dXJuKDAsTC5mb3JFYWNoKSh0LGZ1bmN0aW9uKHQsbil7biYmKGUrPXQrXCI6XCIrbitcIjtcIil9KSxlfWZ1bmN0aW9uIGEodCxlKXt2YXIgbj1bXTtpZihlKWZvcih2YXIgcj0wLHU9MCxhPXQsbz1lLnRyaWdnZXJ8fFwiI1wiLGk9ZS5zZXBhcmF0b3J8fFwiIFwiO2EubGVuZ3RoPjAmJnU+PTA7KWlmKGFbMF09PT1vPyh1PTAscj0wLGE9YS5zdWJzdHIoby5sZW5ndGgpKToodT1hLmluZGV4T2YoaStvKSk+PTAmJihhPWEuc3Vic3RyKHUrKGkrbykubGVuZ3RoKSxyKz11K2kubGVuZ3RoKSx1Pj0wKXt2YXIgcz1hLmluZGV4T2YoaSk+PTA/YS5pbmRleE9mKGkpOmEubGVuZ3RoLGY9YS5zdWJzdHIoMCxzKTtmJiZmLmxlbmd0aD4wJiZuLnB1c2goe29mZnNldDpyLGxlbmd0aDpmLmxlbmd0aCtvLmxlbmd0aCx0eXBlOlwiSEFTSFRBR1wifSkscis9by5sZW5ndGh9cmV0dXJuIG59ZnVuY3Rpb24gbyh0LGUpe3ZhciBuPVtdLHI9MCx1PXQuZW50aXR5UmFuZ2VzLm1hcChmdW5jdGlvbih0KXtyZXR1cm57b2Zmc2V0OnQub2Zmc2V0LGxlbmd0aDp0Lmxlbmd0aCxrZXk6dC5rZXksdHlwZTpcIkVOVElUWVwifX0pO3JldHVybiB1PXUuY29uY2F0KGEodC50ZXh0LGUpKSx1PXUuc29ydChmdW5jdGlvbih0LGUpe3JldHVybiB0Lm9mZnNldC1lLm9mZnNldH0pLHUuZm9yRWFjaChmdW5jdGlvbih0KXt0Lm9mZnNldD5yJiZuLnB1c2goe3N0YXJ0OnIsZW5kOnQub2Zmc2V0fSksbi5wdXNoKHtzdGFydDp0Lm9mZnNldCxlbmQ6dC5vZmZzZXQrdC5sZW5ndGgsZW50aXR5S2V5OnQua2V5LHR5cGU6dC50eXBlfSkscj10Lm9mZnNldCt0Lmxlbmd0aH0pLHI8dC50ZXh0Lmxlbmd0aCYmbi5wdXNoKHtzdGFydDpyLGVuZDp0LnRleHQubGVuZ3RofSksbn1mdW5jdGlvbiBpKHQpe3JldHVybiEhKHQuZW50aXR5UmFuZ2VzLmxlbmd0aD4wJiYoMCxMLmlzRW1wdHlTdHJpbmcpKHQudGV4dCl8fFwiYXRvbWljXCI9PT10LnR5cGUpfWZ1bmN0aW9uIHModCl7dmFyIGU9dC50ZXh0LG49dC5pbmxpbmVTdHlsZVJhbmdlcyxyPXtCT0xEOm5ldyBBcnJheShlLmxlbmd0aCksSVRBTElDOm5ldyBBcnJheShlLmxlbmd0aCksVU5ERVJMSU5FOm5ldyBBcnJheShlLmxlbmd0aCksU1RSSUtFVEhST1VHSDpuZXcgQXJyYXkoZS5sZW5ndGgpLENPREU6bmV3IEFycmF5KGUubGVuZ3RoKSxTVVBFUlNDUklQVDpuZXcgQXJyYXkoZS5sZW5ndGgpLFNVQlNDUklQVDpuZXcgQXJyYXkoZS5sZW5ndGgpLENPTE9SOm5ldyBBcnJheShlLmxlbmd0aCksQkdDT0xPUjpuZXcgQXJyYXkoZS5sZW5ndGgpLEZPTlRTSVpFOm5ldyBBcnJheShlLmxlbmd0aCksRk9OVEZBTUlMWTpuZXcgQXJyYXkoZS5sZW5ndGgpLGxlbmd0aDplLmxlbmd0aH07cmV0dXJuIG4mJm4ubGVuZ3RoPjAmJm4uZm9yRWFjaChmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5vZmZzZXQsbj1lK3QubGVuZ3RoLHU9ZTt1PG47dSs9MSkwPT09dC5zdHlsZS5pbmRleE9mKFwiY29sb3ItXCIpP3IuQ09MT1JbdV09dC5zdHlsZS5zdWJzdHJpbmcoNik6MD09PXQuc3R5bGUuaW5kZXhPZihcImJnY29sb3ItXCIpP3IuQkdDT0xPUlt1XT10LnN0eWxlLnN1YnN0cmluZyg4KTowPT09dC5zdHlsZS5pbmRleE9mKFwiZm9udHNpemUtXCIpP3IuRk9OVFNJWkVbdV09dC5zdHlsZS5zdWJzdHJpbmcoOSk6MD09PXQuc3R5bGUuaW5kZXhPZihcImZvbnRmYW1pbHktXCIpP3IuRk9OVEZBTUlMWVt1XT10LnN0eWxlLnN1YnN0cmluZygxMSk6clt0LnN0eWxlXSYmKHJbdC5zdHlsZV1bdV09ITApfSkscn1mdW5jdGlvbiBmKHQsZSl7dmFyIG49e307cmV0dXJuIHQuQ09MT1JbZV0mJihuLkNPTE9SPXQuQ09MT1JbZV0pLHQuQkdDT0xPUltlXSYmKG4uQkdDT0xPUj10LkJHQ09MT1JbZV0pLHQuRk9OVFNJWkVbZV0mJihuLkZPTlRTSVpFPXQuRk9OVFNJWkVbZV0pLHQuRk9OVEZBTUlMWVtlXSYmKG4uRk9OVEZBTUlMWT10LkZPTlRGQU1JTFlbZV0pLHQuVU5ERVJMSU5FW2VdJiYobi5VTkRFUkxJTkU9ITApLHQuSVRBTElDW2VdJiYobi5JVEFMSUM9ITApLHQuQk9MRFtlXSYmKG4uQk9MRD0hMCksdC5TVFJJS0VUSFJPVUdIW2VdJiYobi5TVFJJS0VUSFJPVUdIPSEwKSx0LkNPREVbZV0mJihuLkNPREU9ITApLHQuU1VCU0NSSVBUW2VdJiYobi5TVUJTQ1JJUFQ9ITApLHQuU1VQRVJTQ1JJUFRbZV0mJihuLlNVUEVSU0NSSVBUPSEwKSxufWZ1bmN0aW9uIGwodCxlLG4pe3ZhciByPSEwO3JldHVybiBuPjAmJm48dC5sZW5ndGg/ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3I9ciYmdFtlXVtuXT09PXRbZV1bbi0xXX0pOnI9ITEscn1mdW5jdGlvbiBoKHQsZSl7cmV0dXJuXCJCT0xEXCI9PT10P1wiPHN0cm9uZz5cIitlK1wiPC9zdHJvbmc+XCI6XCJJVEFMSUNcIj09PXQ/XCI8ZW0+XCIrZStcIjwvZW0+XCI6XCJVTkRFUkxJTkVcIj09PXQ/XCI8aW5zPlwiK2UrXCI8L2lucz5cIjpcIlNUUklLRVRIUk9VR0hcIj09PXQ/XCI8ZGVsPlwiK2UrXCI8L2RlbD5cIjpcIkNPREVcIj09PXQ/XCI8Y29kZT5cIitlK1wiPC9jb2RlPlwiOlwiU1VQRVJTQ1JJUFRcIj09PXQ/XCI8c3VwPlwiK2UrXCI8L3N1cD5cIjpcIlNVQlNDUklQVFwiPT09dD9cIjxzdWI+XCIrZStcIjwvc3ViPlwiOmV9ZnVuY3Rpb24gYyh0KXtpZih0JiZ0Lmxlbmd0aD4wKXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7c3dpdGNoKHQpe2Nhc2VcIlxcblwiOnJldHVyblwiPGJyPlwiO2Nhc2VcIiZcIjpyZXR1cm5cIiZhbXA7XCI7Y2FzZVwiPFwiOnJldHVyblwiJmx0O1wiO2Nhc2VcIj5cIjpyZXR1cm5cIiZndDtcIjtkZWZhdWx0OnJldHVybiB0fX0pLmpvaW4oXCJcIil9cmV0dXJuXCJcIn1mdW5jdGlvbiBwKHQsZSl7aWYodCYmKHQuQ09MT1J8fHQuQkdDT0xPUnx8dC5GT05UU0laRXx8dC5GT05URkFNSUxZKSl7dmFyIG49J3N0eWxlPVwiJztyZXR1cm4gdC5DT0xPUiYmKG4rPVwiY29sb3I6IFwiK3QuQ09MT1IrXCI7XCIpLHQuQkdDT0xPUiYmKG4rPVwiYmFja2dyb3VuZC1jb2xvcjogXCIrdC5CR0NPTE9SK1wiO1wiKSx0LkZPTlRTSVpFJiYobis9XCJmb250LXNpemU6IFwiK3QuRk9OVFNJWkUrKC9eXFxkKyQvLnRlc3QodC5GT05UU0laRSk/XCJweFwiOlwiXCIpK1wiO1wiKSx0LkZPTlRGQU1JTFkmJihuKz1cImZvbnQtZmFtaWx5OiBcIit0LkZPTlRGQU1JTFkrXCI7XCIpLFwiPHNwYW4gXCIrKG4rPSdcIicpK1wiPlwiK2UrXCI8L3NwYW4+XCJ9cmV0dXJuIGV9ZnVuY3Rpb24gZyh0LGUsbixyKXt2YXIgdT10W2VdO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHIpe3ZhciBhPXIodSxuKTtpZihhKXJldHVybiBhfWlmKFwiTUVOVElPTlwiPT09dS50eXBlKXJldHVybic8YSBocmVmPVwiJyt1LmRhdGEudXJsKydcIiBjbGFzcz1cInd5c2l3eWctbWVudGlvblwiIGRhdGEtbWVudGlvbiBkYXRhLXZhbHVlPVwiJyt1LmRhdGEudmFsdWUrJ1wiPicrbitcIjwvYT5cIjtpZihcIkxJTktcIj09PXUudHlwZSl7dmFyIG89dS5kYXRhLnRhcmdldE9wdGlvbnx8XCJfc2VsZlwiO3JldHVybic8YSBocmVmPVwiJyt1LmRhdGEudXJsKydcIiB0YXJnZXQ9XCInK28rJ1wiPicrbitcIjwvYT5cIn1yZXR1cm5cIklNQUdFXCI9PT11LnR5cGU/JzxpbWcgc3JjPVwiJyt1LmRhdGEuc3JjKydcIiBhbHQ9XCInK3UuZGF0YS5hbHQrJ1wiIHN0eWxlPVwiZmxvYXQ6JysodS5kYXRhLmFsaWdubWVudHx8XCJub25lXCIpK1wiO2hlaWdodDogXCIrdS5kYXRhLmhlaWdodCtcIjt3aWR0aDogXCIrdS5kYXRhLndpZHRoKydcIi8+JzpcIkVNQkVEREVEX0xJTktcIj09PXUudHlwZT8nPGlmcmFtZSB3aWR0aD1cIicrdS5kYXRhLndpZHRoKydcIiBoZWlnaHQ9XCInK3UuZGF0YS5oZWlnaHQrJ1wiIHNyYz1cIicrdS5kYXRhLnNyYysnXCIgZnJhbWVCb3JkZXI9XCIwXCI+PC9pZnJhbWU+JzpufWZ1bmN0aW9uIGQodCxlLG4scil7dmFyIHU9W10sYT10LnRleHQ7aWYoYS5sZW5ndGg+MClmb3IodmFyIG89cyh0KSxpPXZvaWQgMCxoPW47aDxyO2grPTEpaCE9PW4mJmwobyxlLGgpPyhpLnRleHQucHVzaChhW2hdKSxpLmVuZD1oKzEpOihpPXtzdHlsZXM6ZihvLGgpLHRleHQ6W2FbaF1dLHN0YXJ0OmgsZW5kOmgrMX0sdS5wdXNoKGkpKTtyZXR1cm4gdX1mdW5jdGlvbiB5KHQpe2lmKHQpe2Zvcih2YXIgZT10LG49MDtuPGUubGVuZ3RoJiZcIiBcIj09PXRbbl07bis9MSllPWUucmVwbGFjZShcIiBcIixcIiZuYnNwO1wiKTtyZXR1cm4gZX1yZXR1cm4gdH1mdW5jdGlvbiBPKHQpe2lmKHQpe2Zvcih2YXIgZT10LG49ZS5sZW5ndGgtMTtuPj0wJiZcIiBcIj09PWVbbl07bi09MSllPWUuc3Vic3RyaW5nKDAsbikrXCImbmJzcDtcIitlLnN1YnN0cmluZyhuKzEpO3JldHVybiBlfXJldHVybiB0fWZ1bmN0aW9uIFQodCl7dmFyIGU9dC5zdHlsZXMsbj10LnRleHQscj1jKG4pO3JldHVybigwLEwuZm9yRWFjaCkoZSxmdW5jdGlvbih0LGUpe3I9aCh0LHIsZSl9KSxyfWZ1bmN0aW9uIEkodCxlKXt2YXIgbj1kKHQsW1wiQk9MRFwiLFwiSVRBTElDXCIsXCJVTkRFUkxJTkVcIixcIlNUUklLRVRIUk9VR0hcIixcIkNPREVcIixcIlNVUEVSU0NSSVBUXCIsXCJTVUJTQ1JJUFRcIl0sZS5zdGFydCxlLmVuZCkscj1cIlwiO3JldHVybiBuLmZvckVhY2goZnVuY3Rpb24odCl7cis9VCh0KX0pLHI9cChlLnN0eWxlcyxyKX1mdW5jdGlvbiB2KHQsZSxuLHIpe3ZhciB1PVtdO2QodCxbXCJDT0xPUlwiLFwiQkdDT0xPUlwiLFwiRk9OVFNJWkVcIixcIkZPTlRGQU1JTFlcIl0sbi5zdGFydCxuLmVuZCkuZm9yRWFjaChmdW5jdGlvbihlKXt1LnB1c2goSSh0LGUpKX0pO3ZhciBhPXUuam9pbihcIlwiKTtyZXR1cm5cIkVOVElUWVwiPT09bi50eXBlP3ZvaWQgMCE9PW4uZW50aXR5S2V5JiZudWxsIT09bi5lbnRpdHlLZXkmJihhPWcoZSxuLmVudGl0eUtleSxhLHIpKTpcIkhBU0hUQUdcIj09PW4udHlwZSYmKGE9JzxhIGhyZWY9XCInK2ErJ1wiIGNsYXNzPVwid3lzaXd5Zy1oYXNodGFnXCI+JythK1wiPC9hPlwiKSxhfWZ1bmN0aW9uIEUodCxlLG4scil7dmFyIHU9W10sYT1vKHQsbik7cmV0dXJuIGEuZm9yRWFjaChmdW5jdGlvbihuLG8pe3ZhciBpPXYodCxlLG4scik7MD09PW8mJihpPXkoaSkpLG89PT1hLmxlbmd0aC0xJiYoaT1PKGkpKSx1LnB1c2goaSl9KSx1LmpvaW4oXCJcIil9ZnVuY3Rpb24gUih0LGUsbixhLG8pe3ZhciBzPVtdO2lmKGkodCkpcy5wdXNoKGcoZSx0LmVudGl0eVJhbmdlc1swXS5rZXksdm9pZCAwLG8pKTtlbHNle3ZhciBmPXIodC50eXBlKTtpZihmKXtzLnB1c2goXCI8XCIrZik7dmFyIGw9dSh0LmRhdGEpO2wmJnMucHVzaCgnIHN0eWxlPVwiJytsKydcIicpLGEmJnMucHVzaCgnIGRpciA9IFwiYXV0b1wiJykscy5wdXNoKFwiPlwiKSxzLnB1c2goRSh0LGUsbixvKSkscy5wdXNoKFwiPC9cIitmK1wiPlwiKX19cmV0dXJuIHMucHVzaChcIlxcblwiKSxzLmpvaW4oXCJcIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5nZXRCbG9ja1RhZz1yLGUuZ2V0QmxvY2tTdHlsZT11LGUuZ2V0U3R5bGVzQXRPZmZzZXQ9ZixlLnNhbWVTdHlsZUFzUHJldmlvdXM9bCxlLmFkZElubGluZVN0eWxlTWFya3VwPWgsZS5hZGRTdHlsZVByb3BlcnR5TWFya3VwPXAsZS50cmltTGVhZGluZ1plcm9zPXksZS50cmltVHJhaWxpbmdaZXJvcz1PLGUuZ2V0QmxvY2tJbm5lck1hcmt1cD1FLGUuZ2V0QmxvY2tNYXJrdXA9Ujt2YXIgTD1uKDIpLFM9e3Vuc3R5bGVkOlwicFwiLFwiaGVhZGVyLW9uZVwiOlwiaDFcIixcImhlYWRlci10d29cIjpcImgyXCIsXCJoZWFkZXItdGhyZWVcIjpcImgzXCIsXCJoZWFkZXItZm91clwiOlwiaDRcIixcImhlYWRlci1maXZlXCI6XCJoNVwiLFwiaGVhZGVyLXNpeFwiOlwiaDZcIixcInVub3JkZXJlZC1saXN0LWl0ZW1cIjpcInVsXCIsXCJvcmRlcmVkLWxpc3QtaXRlbVwiOlwib2xcIixibG9ja3F1b3RlOlwiYmxvY2txdW90ZVwiLGNvZGU6XCJwcmVcIn19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQsZSxuLHIpe3ZhciBvPVtdO2lmKHQpe3ZhciBpPXQuYmxvY2tzLHM9dC5lbnRpdHlNYXA7aWYoaSYmaS5sZW5ndGg+MCl7dmFyIGY9W107aWYoaS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKCgwLGEuaXNMaXN0KSh0LnR5cGUpKWYucHVzaCh0KTtlbHNle2lmKGYubGVuZ3RoPjApe3ZhciBpPSgwLGEuZ2V0TGlzdE1hcmt1cCkoZixzLGUscik7by5wdXNoKGkpLGY9W119dmFyIGw9KDAsdS5nZXRCbG9ja01hcmt1cCkodCxzLGUsbixyKTtvLnB1c2gobCl9fSksZi5sZW5ndGg+MCl7dmFyIGw9KDAsYS5nZXRMaXN0TWFya3VwKShmLHMsZSxuLHIpO28ucHVzaChsKSxmPVtdfX19cmV0dXJuIG8uam9pbihcIlwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9cjt2YXIgdT1uKDApLGE9bigzKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCxlKXtpZih0KWZvcih2YXIgbiBpbiB0KSh7fSkuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiZlKG4sdFtuXSl9ZnVuY3Rpb24gdSh0KXtyZXR1cm4gdm9pZCAwPT09dHx8bnVsbD09PXR8fDA9PT10Lmxlbmd0aHx8MD09PXQudHJpbSgpLmxlbmd0aH1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmZvckVhY2g9cixlLmlzRW1wdHlTdHJpbmc9dX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuXCJ1bm9yZGVyZWQtbGlzdC1pdGVtXCI9PT10fHxcIm9yZGVyZWQtbGlzdC1pdGVtXCI9PT10fWZ1bmN0aW9uIHUodCxlLG4scixvKXt2YXIgaT1bXSxzPVtdLGY9dm9pZCAwO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGw9ITE7aWYoZj9mLnR5cGUhPT10LnR5cGU/KGkucHVzaChcIjwvXCIrKDAsYS5nZXRCbG9ja1RhZykoZi50eXBlKStcIj5cXG5cIiksaS5wdXNoKFwiPFwiKygwLGEuZ2V0QmxvY2tUYWcpKHQudHlwZSkrXCI+XFxuXCIpKTpmLmRlcHRoPT09dC5kZXB0aD9zJiZzLmxlbmd0aD4wJiYoaS5wdXNoKHUocyxlLG4scixvKSkscz1bXSk6KGw9ITAscy5wdXNoKHQpKTppLnB1c2goXCI8XCIrKDAsYS5nZXRCbG9ja1RhZykodC50eXBlKStcIj5cXG5cIiksIWwpe2kucHVzaChcIjxsaVwiKTt2YXIgaD0oMCxhLmdldEJsb2NrU3R5bGUpKHQuZGF0YSk7aCYmaS5wdXNoKCcgc3R5bGU9XCInK2grJ1wiJyksciYmaS5wdXNoKCcgZGlyID0gXCJhdXRvXCInKSxpLnB1c2goXCI+XCIpLGkucHVzaCgoMCxhLmdldEJsb2NrSW5uZXJNYXJrdXApKHQsZSxuLG8pKSxpLnB1c2goXCI8L2xpPlxcblwiKSxmPXR9fSkscyYmcy5sZW5ndGg+MCYmaS5wdXNoKHUocyxlLG4scixvKSksaS5wdXNoKFwiPC9cIisoMCxhLmdldEJsb2NrVGFnKShmLnR5cGUpK1wiPlxcblwiKSxpLmpvaW4oXCJcIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5pc0xpc3Q9cixlLmdldExpc3RNYXJrdXA9dTt2YXIgYT1uKDApfV0pfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZHJhZnRqcy10by1odG1sL2xpYi9kcmFmdGpzLXRvLWh0bWwuanNcbi8vIG1vZHVsZSBpZCA9IDQ3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcmVhY3QtZHJhZnQtd3lzaXd5Zy5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3JlYWN0LWRyYWZ0LXd5c2l3eWcuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcmVhY3QtZHJhZnQtd3lzaXd5Zy5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWZ0LXd5c2l3eWcvZGlzdC9yZWFjdC1kcmFmdC13eXNpd3lnLmNzc1xuLy8gbW9kdWxlIGlkID0gNDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5yZHctb3B0aW9uLXdyYXBwZXIge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI0YxRjFGMTtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIG1pbi13aWR0aDogMjVweDtcXG4gIGhlaWdodDogMjBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIG1hcmdpbjogMCA0cHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxuICB0ZXh0LXRyYW5zZm9ybTogY2FwaXRhbGl6ZTtcXG59XFxuLnJkdy1vcHRpb24td3JhcHBlcjpob3ZlciB7XFxuICBib3gtc2hhZG93OiAxcHggMXB4IDBweCAjQkZCREJEO1xcbn1cXG4ucmR3LW9wdGlvbi13cmFwcGVyOmFjdGl2ZSB7XFxuICBib3gtc2hhZG93OiAxcHggMXB4IDBweCAjQkZCREJEIGluc2V0O1xcbn1cXG4ucmR3LW9wdGlvbi1hY3RpdmUge1xcbiAgYm94LXNoYWRvdzogMXB4IDFweCAwcHggI0JGQkRCRCBpbnNldDtcXG59XFxuLnJkdy1vcHRpb24tZGlzYWJsZWQge1xcbiAgb3BhY2l0eTogMC4zO1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG4ucmR3LWRyb3Bkb3duLXdyYXBwZXIge1xcbiAgaGVpZ2h0OiAzMHB4O1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjRjFGMUYxO1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgbWFyZ2luOiAwIDNweDtcXG4gIHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplO1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxufVxcbi5yZHctZHJvcGRvd24td3JhcHBlcjpmb2N1cyB7XFxuICBvdXRsaW5lOiBub25lO1xcbn1cXG4ucmR3LWRyb3Bkb3duLXdyYXBwZXI6aG92ZXIge1xcbiAgYm94LXNoYWRvdzogMXB4IDFweCAwcHggI0JGQkRCRDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7XFxufVxcbi5yZHctZHJvcGRvd24td3JhcHBlcjphY3RpdmUge1xcbiAgYm94LXNoYWRvdzogMXB4IDFweCAwcHggI0JGQkRCRCBpbnNldDtcXG59XFxuLnJkdy1kcm9wZG93bi1jYXJldHRvb3BlbiB7XFxuICBoZWlnaHQ6IDBweDtcXG4gIHdpZHRoOiAwcHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDM1JTtcXG4gIHJpZ2h0OiAxMCU7XFxuICBib3JkZXItdG9wOiA2cHggc29saWQgYmxhY2s7XFxuICBib3JkZXItbGVmdDogNXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXJpZ2h0OiA1cHggc29saWQgdHJhbnNwYXJlbnQ7XFxufVxcbi5yZHctZHJvcGRvd24tY2FyZXR0b2Nsb3NlIHtcXG4gIGhlaWdodDogMHB4O1xcbiAgd2lkdGg6IDBweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMzUlO1xcbiAgcmlnaHQ6IDEwJTtcXG4gIGJvcmRlci1ib3R0b206IDZweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1sZWZ0OiA1cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItcmlnaHQ6IDVweCBzb2xpZCB0cmFuc3BhcmVudDtcXG59XFxuLnJkdy1kcm9wZG93bi1zZWxlY3RlZHRleHQge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBwYWRkaW5nOiAwIDVweDtcXG59XFxuLnJkdy1kcm9wZG93bi1vcHRpb253cmFwcGVyIHtcXG4gIHotaW5kZXg6IDEwMDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNGMUYxRjE7XFxuICB3aWR0aDogOTglO1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWF4LWhlaWdodDogMjUwcHg7XFxuICBvdmVyZmxvdy15OiBzY3JvbGw7XFxufVxcbi5yZHctZHJvcGRvd24tb3B0aW9ud3JhcHBlcjpob3ZlciB7XFxuICBib3gtc2hhZG93OiAxcHggMXB4IDBweCAjQkZCREJEO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRjtcXG59XFxuLnJkdy1kcm9wZG93bm9wdGlvbi1kZWZhdWx0IHtcXG4gIG1pbi1oZWlnaHQ6IDI1cHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHBhZGRpbmc6IDAgNXB4O1xcbn1cXG4ucmR3LWRyb3Bkb3dub3B0aW9uLWhpZ2hsaWdodGVkIHtcXG4gIGJhY2tncm91bmQ6ICNGMUYxRjE7XFxufVxcbi5yZHctZHJvcGRvd25vcHRpb24tYWN0aXZlIHtcXG4gIGJhY2tncm91bmQ6ICNmNWY1ZjU7XFxufVxcbi5yZHctZHJvcGRvd25vcHRpb24tZGlzYWJsZWQge1xcbiAgb3BhY2l0eTogMC4zO1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG4ucmR3LWlubGluZS13cmFwcGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWFyZ2luLWJvdHRvbTogNnB4O1xcbn1cXG4ucmR3LWlubGluZS1kcm9wZG93biB7XFxuICB3aWR0aDogNTBweDtcXG59XFxuLnJkdy1pbmxpbmUtZHJvcGRvd25vcHRpb24ge1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG4ucmR3LWJsb2NrLXdyYXBwZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBtYXJnaW4tYm90dG9tOiA2cHg7XFxufVxcbi5yZHctYmxvY2stZHJvcGRvd24ge1xcbiAgd2lkdGg6IDExMHB4O1xcbn1cXG4ucmR3LWZvbnRzaXplLXdyYXBwZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBtYXJnaW4tYm90dG9tOiA2cHg7XFxufVxcbi5yZHctZm9udHNpemUtZHJvcGRvd24ge1xcbiAgbWluLXdpZHRoOiA0MHB4O1xcbn1cXG4ucmR3LWZvbnRzaXplLW9wdGlvbiB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcbi5yZHctZm9udGZhbWlseS13cmFwcGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWFyZ2luLWJvdHRvbTogNnB4O1xcbn1cXG4ucmR3LWZvbnRmYW1pbHktZHJvcGRvd24ge1xcbiAgd2lkdGg6IDExNXB4O1xcbn1cXG4ucmR3LWZvbnRmYW1pbHktcGxhY2Vob2xkZXIge1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIG1heC13aWR0aDogOTBweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG59XFxuLnJkdy1mb250ZmFtaWx5LW9wdGlvbndyYXBwZXIge1xcbiAgd2lkdGg6IDE0MHB4O1xcbn1cXG4ucmR3LWxpc3Qtd3JhcHBlciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIG1hcmdpbi1ib3R0b206IDZweDtcXG59XFxuLnJkdy1saXN0LWRyb3Bkb3duIHtcXG4gIHdpZHRoOiA1MHB4O1xcbiAgei1pbmRleDogOTA7XFxufVxcbi5yZHctbGlzdC1kcm9wZG93bk9wdGlvbiB7XFxuICBoZWlnaHQ6IDQwcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcbi5yZHctdGV4dC1hbGlnbi13cmFwcGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWFyZ2luLWJvdHRvbTogNnB4O1xcbn1cXG4ucmR3LXRleHQtYWxpZ24tZHJvcGRvd24ge1xcbiAgd2lkdGg6IDUwcHg7XFxuICB6LWluZGV4OiA5MDtcXG59XFxuLnJkdy10ZXh0LWFsaWduLWRyb3Bkb3duT3B0aW9uIHtcXG4gIGhlaWdodDogNDBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuLnJkdy1yaWdodC1hbGlnbmVkLWJsb2NrIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG4ucmR3LWxlZnQtYWxpZ25lZC1ibG9jayB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0ICFpbXBvcnRhbnQ7XFxufVxcbi5yZHctY2VudGVyLWFsaWduZWQtYmxvY2sge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyICFpbXBvcnRhbnQ7XFxufVxcbi5yZHctanVzdGlmeS1hbGlnbmVkLWJsb2NrIHtcXG4gIHRleHQtYWxpZ246IGp1c3RpZnkgIWltcG9ydGFudDtcXG59XFxuLnJkdy1yaWdodC1hbGlnbmVkLWJsb2NrID4gZGl2IHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuLnJkdy1sZWZ0LWFsaWduZWQtYmxvY2sgPiBkaXYge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG4ucmR3LWNlbnRlci1hbGlnbmVkLWJsb2NrID4gZGl2IHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuLnJkdy1qdXN0aWZ5LWFsaWduZWQtYmxvY2sgPiBkaXYge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG4ucmR3LWNvbG9ycGlja2VyLXdyYXBwZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBtYXJnaW4tYm90dG9tOiA2cHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5yZHctY29sb3JwaWNrZXItbW9kYWwge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAzNXB4O1xcbiAgbGVmdDogNXB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB3aWR0aDogMTc1cHg7XFxuICBoZWlnaHQ6IDE3NXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI0YxRjFGMTtcXG4gIHBhZGRpbmc6IDE1cHg7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICB6LWluZGV4OiAxMDA7XFxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gIGJveC1zaGFkb3c6IDNweCAzcHggNXB4ICNCRkJEQkQ7XFxufVxcbi5yZHctY29sb3JwaWNrZXItbW9kYWwtaGVhZGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBwYWRkaW5nLWJvdHRvbTogNXB4O1xcbn1cXG4ucmR3LWNvbG9ycGlja2VyLW1vZGFsLXN0eWxlLWxhYmVsIHtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG4gIHdpZHRoOiA1MCU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBwYWRkaW5nOiAwIDEwcHggNXB4O1xcbn1cXG4ucmR3LWNvbG9ycGlja2VyLW1vZGFsLXN0eWxlLWxhYmVsLWFjdGl2ZSB7XFxuICBib3JkZXItYm90dG9tOiAycHggc29saWQgIzBhNjZiNztcXG59XFxuLnJkdy1jb2xvcnBpY2tlci1tb2RhbC1vcHRpb25zIHtcXG4gIG1hcmdpbjogNXB4IGF1dG87XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBmbGV4LXdyYXA6IHdyYXA7XFxuICBvdmVyZmxvdzogc2Nyb2xsO1xcbn1cXG4ucmR3LWNvbG9ycGlja2VyLWN1YmUge1xcbiAgd2lkdGg6IDIycHg7XFxuICBoZWlnaHQ6IDIycHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjRjFGMUYxO1xcbn1cXG4ucmR3LWNvbG9ycGlja2VyLW9wdGlvbiB7XFxuICBtYXJnaW46IDNweDtcXG4gIHBhZGRpbmc6IDA7XFxuICBtaW4taGVpZ2h0OiAyMHB4O1xcbiAgYm9yZGVyOiBub25lO1xcbiAgd2lkdGg6IDIycHg7XFxuICBoZWlnaHQ6IDIycHg7XFxuICBtaW4td2lkdGg6IDIycHg7XFxuICBib3gtc2hhZG93OiAxcHggMnB4IDFweCAjQkZCREJEIGluc2V0O1xcbn1cXG4ucmR3LWNvbG9ycGlja2VyLW9wdGlvbjpob3ZlciB7XFxuICBib3gtc2hhZG93OiAxcHggMnB4IDFweCAjQkZCREJEO1xcbn1cXG4ucmR3LWNvbG9ycGlja2VyLW9wdGlvbjphY3RpdmUge1xcbiAgYm94LXNoYWRvdzogLTFweCAtMnB4IDFweCAjQkZCREJEO1xcbn1cXG4ucmR3LWNvbG9ycGlja2VyLW9wdGlvbi1hY3RpdmUge1xcbiAgYm94LXNoYWRvdzogMHB4IDBweCAycHggMnB4ICNCRkJEQkQ7XFxufVxcbi5yZHctbGluay13cmFwcGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWFyZ2luLWJvdHRvbTogNnB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4ucmR3LWxpbmstZHJvcGRvd24ge1xcbiAgd2lkdGg6IDUwcHg7XFxufVxcbi5yZHctbGluay1kcm9wZG93bk9wdGlvbiB7XFxuICBoZWlnaHQ6IDQwcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcbi5yZHctbGluay1kcm9wZG93blBsYWNlaG9sZGVyIHtcXG4gIG1hcmdpbi1sZWZ0OiA4cHg7XFxufVxcbi5yZHctbGluay1tb2RhbCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDM1cHg7XFxuICBsZWZ0OiA1cHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIHdpZHRoOiAyMzVweDtcXG4gIGhlaWdodDogMjA1cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjRjFGMUYxO1xcbiAgcGFkZGluZzogMTVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIHotaW5kZXg6IDEwMDtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgYm94LXNoYWRvdzogM3B4IDNweCA1cHggI0JGQkRCRDtcXG59XFxuLnJkdy1saW5rLW1vZGFsLWxhYmVsIHtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG59XFxuLnJkdy1saW5rLW1vZGFsLWlucHV0IHtcXG4gIG1hcmdpbi10b3A6IDVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNGMUYxRjE7XFxuICBoZWlnaHQ6IDI1cHg7XFxuICBtYXJnaW4tYm90dG9tOiAxNXB4O1xcbiAgcGFkZGluZzogMCA1cHg7XFxufVxcbi5yZHctbGluay1tb2RhbC1pbnB1dDpmb2N1cyB7XFxuICBvdXRsaW5lOiBub25lO1xcbn1cXG4ucmR3LWxpbmstbW9kYWwtYnV0dG9uc2VjdGlvbiB7XFxuICBtYXJnaW46IDAgYXV0bztcXG59XFxuLnJkdy1saW5rLW1vZGFsLXRhcmdldC1vcHRpb24ge1xcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG59XFxuLnJkdy1saW5rLW1vZGFsLXRhcmdldC1vcHRpb24gPiBzcGFuIHtcXG4gIG1hcmdpbi1sZWZ0OiA1cHg7XFxufVxcbi5yZHctbGluay1tb2RhbC1idG4ge1xcbiAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxuICB3aWR0aDogNzVweDtcXG4gIGhlaWdodDogMzBweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNGMUYxRjE7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gIHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplO1xcbn1cXG4ucmR3LWxpbmstbW9kYWwtYnRuOmhvdmVyIHtcXG4gIGJveC1zaGFkb3c6IDFweCAxcHggMHB4ICNCRkJEQkQ7XFxufVxcbi5yZHctbGluay1tb2RhbC1idG46YWN0aXZlIHtcXG4gIGJveC1zaGFkb3c6IDFweCAxcHggMHB4ICNCRkJEQkQgaW5zZXQ7XFxufVxcbi5yZHctbGluay1tb2RhbC1idG46Zm9jdXMge1xcbiAgb3V0bGluZTogbm9uZSAhaW1wb3J0YW50O1xcbn1cXG4ucmR3LWxpbmstbW9kYWwtYnRuOmRpc2FibGVkIHtcXG4gIGJhY2tncm91bmQ6ICNlY2U5ZTk7XFxufVxcbi5yZHctbGluay1kcm9wZG93bm9wdGlvbiB7XFxuICBoZWlnaHQ6IDQwcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcbi5yZHctaGlzdG9yeS1kcm9wZG93biB7XFxuICB3aWR0aDogNTBweDtcXG59XFxuLnJkdy1lbWJlZGRlZC13cmFwcGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWFyZ2luLWJvdHRvbTogNnB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4ucmR3LWVtYmVkZGVkLW1vZGFsIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMzVweDtcXG4gIGxlZnQ6IDVweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgd2lkdGg6IDIzNXB4O1xcbiAgaGVpZ2h0OiAxODBweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNGMUYxRjE7XFxuICBwYWRkaW5nOiAxNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgei1pbmRleDogMTAwO1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICBib3gtc2hhZG93OiAzcHggM3B4IDVweCAjQkZCREJEO1xcbn1cXG4ucmR3LWVtYmVkZGVkLW1vZGFsLWhlYWRlciB7XFxuICBmb250LXNpemU6IDE1cHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbn1cXG4ucmR3LWVtYmVkZGVkLW1vZGFsLWhlYWRlci1vcHRpb24ge1xcbiAgd2lkdGg6IDUwJTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG4ucmR3LWVtYmVkZGVkLW1vZGFsLWhlYWRlci1sYWJlbCB7XFxuICB3aWR0aDogOTVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNmMWYxZjE7XFxuICBtYXJnaW4tdG9wOiA1cHg7XFxuICBiYWNrZ3JvdW5kOiAjNkVCOEQ0O1xcbiAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICMwYTY2Yjc7XFxufVxcbi5yZHctZW1iZWRkZWQtbW9kYWwtbGluay1zZWN0aW9uIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG4ucmR3LWVtYmVkZGVkLW1vZGFsLWxpbmstaW5wdXQge1xcbiAgd2lkdGg6IDg4JTtcXG4gIGhlaWdodDogMzVweDtcXG4gIG1hcmdpbjogMTBweCAwO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI0YxRjFGMTtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG4gIHBhZGRpbmc6IDAgNXB4O1xcbn1cXG4ucmR3LWVtYmVkZGVkLW1vZGFsLWxpbmstaW5wdXQtd3JhcHBlciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuLnJkdy1lbWJlZGRlZC1tb2RhbC1saW5rLWlucHV0OmZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcbi5yZHctZW1iZWRkZWQtbW9kYWwtYnRuLXNlY3Rpb24ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG4ucmR3LWVtYmVkZGVkLW1vZGFsLWJ0biB7XFxuICBtYXJnaW46IDAgM3B4O1xcbiAgd2lkdGg6IDc1cHg7XFxuICBoZWlnaHQ6IDMwcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjRjFGMUYxO1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxuICB0ZXh0LXRyYW5zZm9ybTogY2FwaXRhbGl6ZTtcXG59XFxuLnJkdy1lbWJlZGRlZC1tb2RhbC1idG46aG92ZXIge1xcbiAgYm94LXNoYWRvdzogMXB4IDFweCAwcHggI0JGQkRCRDtcXG59XFxuLnJkdy1lbWJlZGRlZC1tb2RhbC1idG46YWN0aXZlIHtcXG4gIGJveC1zaGFkb3c6IDFweCAxcHggMHB4ICNCRkJEQkQgaW5zZXQ7XFxufVxcbi5yZHctZW1iZWRkZWQtbW9kYWwtYnRuOmZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuLnJkdy1lbWJlZGRlZC1tb2RhbC1idG46ZGlzYWJsZWQge1xcbiAgYmFja2dyb3VuZDogI2VjZTllOTtcXG59XFxuLnJkdy1lbWJlZGRlZC1tb2RhbC1zaXplIHtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgbWFyZ2luOiA4cHggMDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG59XFxuLnJkdy1lbWJlZGRlZC1tb2RhbC1zaXplLWlucHV0IHtcXG4gIHdpZHRoOiA4MCU7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjRjFGMUYxO1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbn1cXG4ucmR3LWVtYmVkZGVkLW1vZGFsLXNpemUtaW5wdXQ6Zm9jdXMge1xcbiAgb3V0bGluZTogbm9uZTtcXG59XFxuLnJkdy1lbW9qaS13cmFwcGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWFyZ2luLWJvdHRvbTogNnB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4ucmR3LWVtb2ppLW1vZGFsIHtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAzNXB4O1xcbiAgbGVmdDogNXB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtd3JhcDogd3JhcDtcXG4gIHdpZHRoOiAyMzVweDtcXG4gIGhlaWdodDogMTgwcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjRjFGMUYxO1xcbiAgcGFkZGluZzogMTVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIHotaW5kZXg6IDEwMDtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgYm94LXNoYWRvdzogM3B4IDNweCA1cHggI0JGQkRCRDtcXG59XFxuLnJkdy1lbW9qaS1pY29uIHtcXG4gIG1hcmdpbjogMi41cHg7XFxuICBoZWlnaHQ6IDI0cHg7XFxuICB3aWR0aDogMjRweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGZvbnQtc2l6ZTogMjJweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5yZHctc3Bpbm5lciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbi5yZHctc3Bpbm5lciA+IGRpdiB7XFxuICB3aWR0aDogMTJweDtcXG4gIGhlaWdodDogMTJweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMzMzM7XFxuXFxuICBib3JkZXItcmFkaXVzOiAxMDAlO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgLXdlYmtpdC1hbmltYXRpb246IHNrLWJvdW5jZWRlbGF5IDEuNHMgaW5maW5pdGUgZWFzZS1pbi1vdXQgYm90aDtcXG4gIGFuaW1hdGlvbjogc2stYm91bmNlZGVsYXkgMS40cyBpbmZpbml0ZSBlYXNlLWluLW91dCBib3RoO1xcbn1cXG4ucmR3LXNwaW5uZXIgLnJkdy1ib3VuY2UxIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAtMC4zMnM7XFxuICBhbmltYXRpb24tZGVsYXk6IC0wLjMycztcXG59XFxuLnJkdy1zcGlubmVyIC5yZHctYm91bmNlMiB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogLTAuMTZzO1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAtMC4xNnM7XFxufVxcbkAtd2Via2l0LWtleWZyYW1lcyBzay1ib3VuY2VkZWxheSB7XFxuICAwJSwgODAlLCAxMDAlIHsgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApIH1cXG4gIDQwJSB7IC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLjApIH1cXG59XFxuQGtleWZyYW1lcyBzay1ib3VuY2VkZWxheSB7XFxuICAwJSwgODAlLCAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgfSA0MCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMS4wKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjApO1xcbiAgfVxcbn1cXG4ucmR3LWltYWdlLXdyYXBwZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBtYXJnaW4tYm90dG9tOiA2cHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5yZHctaW1hZ2UtbW9kYWwge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAzNXB4O1xcbiAgbGVmdDogNXB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB3aWR0aDogMjM1cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjRjFGMUYxO1xcbiAgcGFkZGluZzogMTVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIHotaW5kZXg6IDEwMDtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgYm94LXNoYWRvdzogM3B4IDNweCA1cHggI0JGQkRCRDtcXG59XFxuLnJkdy1pbWFnZS1tb2RhbC1oZWFkZXIge1xcbiAgZm9udC1zaXplOiAxNXB4O1xcbiAgbWFyZ2luOiAxMHB4IDA7XFxuICBkaXNwbGF5OiBmbGV4O1xcbn1cXG4ucmR3LWltYWdlLW1vZGFsLWhlYWRlci1vcHRpb24ge1xcbiAgd2lkdGg6IDUwJTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG4ucmR3LWltYWdlLW1vZGFsLWhlYWRlci1sYWJlbCB7XFxuICB3aWR0aDogODBweDtcXG4gIGJhY2tncm91bmQ6ICNmMWYxZjE7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZjFmMWYxO1xcbiAgbWFyZ2luLXRvcDogNXB4O1xcbn1cXG4ucmR3LWltYWdlLW1vZGFsLWhlYWRlci1sYWJlbC1oaWdobGlnaHRlZCB7XFxuICBiYWNrZ3JvdW5kOiAjNkVCOEQ0O1xcbiAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICMwYTY2Yjc7XFxufVxcbi5yZHctaW1hZ2UtbW9kYWwtdXBsb2FkLW9wdGlvbiB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGNvbG9yOiBncmF5O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmMWYxZjE7XFxuICBvdXRsaW5lOiAycHggZGFzaGVkIGdyYXk7XFxuICBvdXRsaW5lLW9mZnNldDogLTEwcHg7XFxuICBtYXJnaW46IDEwcHggMDtcXG4gIHBhZGRpbmc6IDlweCAwO1xcbn1cXG4ucmR3LWltYWdlLW1vZGFsLXVwbG9hZC1vcHRpb24taGlnaGxpZ2h0ZWQge1xcbiAgb3V0bGluZTogMnB4IGRhc2hlZCAjMGE2NmI3O1xcbn1cXG4ucmR3LWltYWdlLW1vZGFsLXVwbG9hZC1vcHRpb24tbGFiZWwge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgcGFkZGluZzogMTVweDtcXG59XFxuLnJkdy1pbWFnZS1tb2RhbC11cGxvYWQtb3B0aW9uLWxhYmVsIHNwYW57XFxuICBwYWRkaW5nOiAwIDIwcHg7XFxufVxcbi5yZHctaW1hZ2UtbW9kYWwtdXBsb2FkLW9wdGlvbi1pbWFnZS1wcmV2aWV3IHtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIG1heC1oZWlnaHQ6IDIwMHB4O1xcbn1cXG4ucmR3LWltYWdlLW1vZGFsLXVwbG9hZC1vcHRpb24taW5wdXQge1xcblxcdHdpZHRoOiAwLjFweDtcXG5cXHRoZWlnaHQ6IDAuMXB4O1xcblxcdG9wYWNpdHk6IDA7XFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0ei1pbmRleDogLTE7XFxufVxcbi5yZHctaW1hZ2UtbW9kYWwtdXJsLXNlY3Rpb24ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5yZHctaW1hZ2UtbW9kYWwtdXJsLWlucHV0IHtcXG4gIHdpZHRoOiA5MCU7XFxuICBoZWlnaHQ6IDM1cHg7XFxuICBtYXJnaW46IDE1cHggMCAxMnB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI0YxRjFGMTtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG4gIHBhZGRpbmc6IDAgNXB4O1xcbn1cXG4ucmR3LWltYWdlLW1vZGFsLWJ0bi1zZWN0aW9uIHtcXG4gIG1hcmdpbjogMTBweCBhdXRvIDA7XFxufVxcbi5yZHctaW1hZ2UtbW9kYWwtdXJsLWlucHV0OmZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcbi5yZHctaW1hZ2UtbW9kYWwtYnRuIHtcXG4gIG1hcmdpbjogMCA1cHg7XFxuICB3aWR0aDogNzVweDtcXG4gIGhlaWdodDogMzBweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNGMUYxRjE7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gIHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplO1xcbn1cXG4ucmR3LWltYWdlLW1vZGFsLWJ0bjpob3ZlciB7XFxuICBib3gtc2hhZG93OiAxcHggMXB4IDBweCAjQkZCREJEO1xcbn1cXG4ucmR3LWltYWdlLW1vZGFsLWJ0bjphY3RpdmUge1xcbiAgYm94LXNoYWRvdzogMXB4IDFweCAwcHggI0JGQkRCRCBpbnNldDtcXG59XFxuLnJkdy1pbWFnZS1tb2RhbC1idG46Zm9jdXMge1xcbiAgb3V0bGluZTogbm9uZSAhaW1wb3J0YW50O1xcbn1cXG4ucmR3LWltYWdlLW1vZGFsLWJ0bjpkaXNhYmxlZCB7XFxuICBiYWNrZ3JvdW5kOiAjZWNlOWU5O1xcbn1cXG4ucmR3LWltYWdlLW1vZGFsLXNwaW5uZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAtM3B4O1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgb3BhY2l0eTogMC41O1xcbn1cXG4ucmR3LWltYWdlLW1vZGFsLWFsdC1pbnB1dCB7XFxuICB3aWR0aDogNzAlO1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI0YxRjFGMTtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIG1hcmdpbi1sZWZ0OiA1cHg7XFxufVxcbi5yZHctaW1hZ2UtbW9kYWwtYWx0LWlucHV0OmZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcbi5yZHctaW1hZ2UtbW9kYWwtYWx0LWxibCB7XFxuICBmb250LXNpemU6IDEycHg7XFxufVxcbi5yZHctaW1hZ2UtbW9kYWwtc2l6ZSB7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIG1hcmdpbjogOHB4IDA7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcbi5yZHctaW1hZ2UtbW9kYWwtc2l6ZS1pbnB1dCB7XFxuICB3aWR0aDogNDAlO1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI0YxRjFGMTtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG59XFxuLnJkdy1pbWFnZS1tb2RhbC1zaXplLWlucHV0OmZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcbi5yZHctaW1hZ2UtbWFuZGF0b3J5LXNpZ24ge1xcbiAgY29sb3I6IHJlZDtcXG4gIG1hcmdpbi1sZWZ0OiAzcHg7XFxuICBtYXJnaW4tcmlnaHQ6IDNweDtcXG59XFxuLnJkdy1yZW1vdmUtd3JhcHBlciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIG1hcmdpbi1ib3R0b206IDZweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLnJkdy1oaXN0b3J5LXdyYXBwZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBtYXJnaW4tYm90dG9tOiA2cHg7XFxufVxcbi5yZHctaGlzdG9yeS1kcm9wZG93bm9wdGlvbiB7XFxuICBoZWlnaHQ6IDQwcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcbi5yZHctaGlzdG9yeS1kcm9wZG93biB7XFxuICB3aWR0aDogNTBweDtcXG59XFxuLnJkdy1saW5rLWRlY29yYXRvci13cmFwcGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLnJkdy1saW5rLWRlY29yYXRvci1pY29uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDQwJTtcXG4gIHRvcDogMDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbn1cXG4ucmR3LW1lbnRpb24tbGluayB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICBjb2xvcjogIzEyMzZmZjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmMGZiZmY7XFxuICBwYWRkaW5nOiAxcHggMnB4O1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbn1cXG4ucmR3LXN1Z2dlc3Rpb24td3JhcHBlciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5yZHctc3VnZ2VzdGlvbi1kcm9wZG93biB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNGMUYxRjE7XFxuICBtaW4td2lkdGg6IDEwMHB4O1xcbiAgbWF4LWhlaWdodDogMTUwcHg7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgei1pbmRleDogMTAwO1xcbn1cXG4ucmR3LXN1Z2dlc3Rpb24tb3B0aW9uIHtcXG4gIHBhZGRpbmc6IDdweCA1cHg7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2YxZjFmMTtcXG59XFxuLnJkdy1zdWdnZXN0aW9uLW9wdGlvbi1hY3RpdmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI0YxRjFGMTtcXG59XFxuLnJkdy1oYXNodGFnLWxpbmsge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgY29sb3I6ICMxMjM2ZmY7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjBmYmZmO1xcbiAgcGFkZGluZzogMXB4IDJweDtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG59XFxuLnJkdy1pbWFnZS1hbGlnbm1lbnQtb3B0aW9ucy1wb3B1cCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7O1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgcGFkZGluZzogNXB4IDJweDtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNGMUYxRjE7XFxuICB3aWR0aDogMTA1cHg7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB6LWluZGV4OiAxMDA7XFxufVxcbi5yZHctYWxpZ25tZW50LW9wdGlvbi1sZWZ0IHtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG59XFxuLnJkdy1pbWFnZS1hbGlnbm1lbnQtb3B0aW9uIHtcXG4gIGhlaWdodDogMTVweDtcXG4gIHdpZHRoOiAxNXB4O1xcbiAgbWluLXdpZHRoOiAxNXB4O1xcbn1cXG4ucmR3LWltYWdlLWFsaWdubWVudCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5yZHctaW1hZ2UtaW1hZ2V3cmFwcGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLnJkdy1pbWFnZS1jZW50ZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG4ucmR3LWltYWdlLWxlZnQge1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuLnJkdy1pbWFnZS1yaWdodCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG59XFxuLnJkdy1pbWFnZS1hbGlnbm1lbnQtb3B0aW9ucy1wb3B1cC1yaWdodCB7XFxuICByaWdodDogMDtcXG59XFxuLnJkdy1lZGl0b3ItbWFpbiB7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcbi5yZHctZWRpdG9yLXRvb2xiYXIge1xcbiAgcGFkZGluZzogNnB4IDVweCAwO1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI0YxRjFGMTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gIGZsZXgtd3JhcDogd3JhcDtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG4gIG1hcmdpbi1ib3R0b206IDVweDtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG4ucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWJsb2NrIHtcXG4gIG1hcmdpbjogMWVtIDA7XFxufVxcbi5yZHctZWRpdG9yLXdyYXBwZXI6Zm9jdXMge1xcbiAgb3V0bGluZTogbm9uZTtcXG59XFxuLnJkdy1lZGl0b3Itd3JhcHBlciB7XFxuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG59XFxuLnJkdy1lZGl0b3ItbWFpbiBibG9ja3F1b3RlIHtcXG4gIGJvcmRlci1sZWZ0OiA1cHggc29saWQgI2YxZjFmMTtcXG4gIHBhZGRpbmctbGVmdDogNXB4O1xcbn1cXG4ucmR3LWVkaXRvci1tYWluIHByZSB7XFxuICBiYWNrZ3JvdW5kOiAjZjFmMWYxO1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgcGFkZGluZzogMXB4IDEwcHg7XFxufS8qKlxcbiAqIERyYWZ0IHYwLjkuMVxcbiAqXFxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxcbiAqL1xcbi5EcmFmdEVkaXRvci1lZGl0b3JDb250YWluZXIsLkRyYWZ0RWRpdG9yLXJvb3QsLnB1YmxpYy1EcmFmdEVkaXRvci1jb250ZW50e2hlaWdodDppbmhlcml0O3RleHQtYWxpZ246aW5pdGlhbH0ucHVibGljLURyYWZ0RWRpdG9yLWNvbnRlbnRbY29udGVudGVkaXRhYmxlPXRydWVdey13ZWJraXQtdXNlci1tb2RpZnk6cmVhZC13cml0ZS1wbGFpbnRleHQtb25seX0uRHJhZnRFZGl0b3Itcm9vdHtwb3NpdGlvbjpyZWxhdGl2ZX0uRHJhZnRFZGl0b3ItZWRpdG9yQ29udGFpbmVye2JhY2tncm91bmQtY29sb3I6cmdiYSgyNTUsMjU1LDI1NSwwKTtib3JkZXItbGVmdDouMXB4IHNvbGlkIHRyYW5zcGFyZW50O3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MX0ucHVibGljLURyYWZ0RWRpdG9yLWJsb2Nre3Bvc2l0aW9uOnJlbGF0aXZlfS5EcmFmdEVkaXRvci1hbGlnbkxlZnQgLnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1ibG9ja3t0ZXh0LWFsaWduOmxlZnR9LkRyYWZ0RWRpdG9yLWFsaWduTGVmdCAucHVibGljLURyYWZ0RWRpdG9yUGxhY2Vob2xkZXItcm9vdHtsZWZ0OjA7dGV4dC1hbGlnbjpsZWZ0fS5EcmFmdEVkaXRvci1hbGlnbkNlbnRlciAucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWJsb2Nre3RleHQtYWxpZ246Y2VudGVyfS5EcmFmdEVkaXRvci1hbGlnbkNlbnRlciAucHVibGljLURyYWZ0RWRpdG9yUGxhY2Vob2xkZXItcm9vdHttYXJnaW46MCBhdXRvO3RleHQtYWxpZ246Y2VudGVyO3dpZHRoOjEwMCV9LkRyYWZ0RWRpdG9yLWFsaWduUmlnaHQgLnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1ibG9ja3t0ZXh0LWFsaWduOnJpZ2h0fS5EcmFmdEVkaXRvci1hbGlnblJpZ2h0IC5wdWJsaWMtRHJhZnRFZGl0b3JQbGFjZWhvbGRlci1yb290e3JpZ2h0OjA7dGV4dC1hbGlnbjpyaWdodH0ucHVibGljLURyYWZ0RWRpdG9yUGxhY2Vob2xkZXItcm9vdHtjb2xvcjojOTE5N2EzO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MH0ucHVibGljLURyYWZ0RWRpdG9yUGxhY2Vob2xkZXItaGFzRm9jdXN7Y29sb3I6I2JkYzFjOX0uRHJhZnRFZGl0b3JQbGFjZWhvbGRlci1oaWRkZW57ZGlzcGxheTpub25lfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtYmxvY2t7cG9zaXRpb246cmVsYXRpdmU7d2hpdGUtc3BhY2U6cHJlLXdyYXB9LnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1sdHJ7ZGlyZWN0aW9uOmx0cjt0ZXh0LWFsaWduOmxlZnR9LnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1ydGx7ZGlyZWN0aW9uOnJ0bDt0ZXh0LWFsaWduOnJpZ2h0fS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtbGlzdExUUntkaXJlY3Rpb246bHRyfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtbGlzdFJUTHtkaXJlY3Rpb246cnRsfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtb2wsLnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC11bHttYXJnaW46MTZweCAwO3BhZGRpbmc6MH0ucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWRlcHRoMC5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtbGlzdExUUnttYXJnaW4tbGVmdDoxLjVlbX0ucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWRlcHRoMC5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtbGlzdFJUTHttYXJnaW4tcmlnaHQ6MS41ZW19LnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1kZXB0aDEucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWxpc3RMVFJ7bWFyZ2luLWxlZnQ6M2VtfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGgxLnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1saXN0UlRMe21hcmdpbi1yaWdodDozZW19LnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1kZXB0aDIucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWxpc3RMVFJ7bWFyZ2luLWxlZnQ6NC41ZW19LnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1kZXB0aDIucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWxpc3RSVEx7bWFyZ2luLXJpZ2h0OjQuNWVtfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGgzLnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1saXN0TFRSe21hcmdpbi1sZWZ0OjZlbX0ucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWRlcHRoMy5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtbGlzdFJUTHttYXJnaW4tcmlnaHQ6NmVtfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGg0LnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1saXN0TFRSe21hcmdpbi1sZWZ0OjcuNWVtfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGg0LnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1saXN0UlRMe21hcmdpbi1yaWdodDo3LjVlbX0ucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LXVub3JkZXJlZExpc3RJdGVte2xpc3Qtc3R5bGUtdHlwZTpzcXVhcmU7cG9zaXRpb246cmVsYXRpdmV9LnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC11bm9yZGVyZWRMaXN0SXRlbS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGgwe2xpc3Qtc3R5bGUtdHlwZTpkaXNjfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtdW5vcmRlcmVkTGlzdEl0ZW0ucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWRlcHRoMXtsaXN0LXN0eWxlLXR5cGU6Y2lyY2xlfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtb3JkZXJlZExpc3RJdGVte2xpc3Qtc3R5bGUtdHlwZTpub25lO3Bvc2l0aW9uOnJlbGF0aXZlfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtb3JkZXJlZExpc3RJdGVtLnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1saXN0TFRSOmJlZm9yZXtsZWZ0Oi0zNnB4O3Bvc2l0aW9uOmFic29sdXRlO3RleHQtYWxpZ246cmlnaHQ7d2lkdGg6MzBweH0ucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LW9yZGVyZWRMaXN0SXRlbS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtbGlzdFJUTDpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTM2cHg7dGV4dC1hbGlnbjpsZWZ0O3dpZHRoOjMwcHh9LnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1vcmRlcmVkTGlzdEl0ZW06YmVmb3Jle2NvbnRlbnQ6Y291bnRlcihvbDApIFxcXCIuIFxcXCI7Y291bnRlci1pbmNyZW1lbnQ6b2wwfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtb3JkZXJlZExpc3RJdGVtLnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1kZXB0aDE6YmVmb3Jle2NvbnRlbnQ6Y291bnRlcihvbDEpIFxcXCIuIFxcXCI7Y291bnRlci1pbmNyZW1lbnQ6b2wxfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtb3JkZXJlZExpc3RJdGVtLnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1kZXB0aDI6YmVmb3Jle2NvbnRlbnQ6Y291bnRlcihvbDIpIFxcXCIuIFxcXCI7Y291bnRlci1pbmNyZW1lbnQ6b2wyfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtb3JkZXJlZExpc3RJdGVtLnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1kZXB0aDM6YmVmb3Jle2NvbnRlbnQ6Y291bnRlcihvbDMpIFxcXCIuIFxcXCI7Y291bnRlci1pbmNyZW1lbnQ6b2wzfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtb3JkZXJlZExpc3RJdGVtLnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1kZXB0aDQ6YmVmb3Jle2NvbnRlbnQ6Y291bnRlcihvbDQpIFxcXCIuIFxcXCI7Y291bnRlci1pbmNyZW1lbnQ6b2w0fS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGgwLnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1yZXNldHtjb3VudGVyLXJlc2V0Om9sMH0ucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWRlcHRoMS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtcmVzZXR7Y291bnRlci1yZXNldDpvbDF9LnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1kZXB0aDIucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LXJlc2V0e2NvdW50ZXItcmVzZXQ6b2wyfS5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtZGVwdGgzLnB1YmxpYy1EcmFmdFN0eWxlRGVmYXVsdC1yZXNldHtjb3VudGVyLXJlc2V0Om9sM30ucHVibGljLURyYWZ0U3R5bGVEZWZhdWx0LWRlcHRoNC5wdWJsaWMtRHJhZnRTdHlsZURlZmF1bHQtcmVzZXR7Y291bnRlci1yZXNldDpvbDR9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFmdC13eXNpd3lnL2Rpc3QvcmVhY3QtZHJhZnQtd3lzaXd5Zy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDQ3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIGltcG9ydCBsaWJzXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnXG5pbXBvcnQgeyBhcnRpY2xlRWRpdFJlcXVlc3QsIGFydGljbGVVcGRhdGVSZXF1ZXN0IH0gZnJvbSAnLi4vLi4vc2VydmljZSdcbmltcG9ydCBSZWVWYWxpZGF0ZSBmcm9tICdyZWUtdmFsaWRhdGUnXG5cbi8vIGltcG9ydCBjb21wb25lbnRzXG5pbXBvcnQgRm9ybSBmcm9tICcuL2NvbXBvbmVudHMvRm9ybSdcblxuY2xhc3MgUGFnZSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBkaXNwbGF5TmFtZSA9ICdFZGl0QXJ0aWNsZSdcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBtYXRjaDogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGFydGljbGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgZGlzcGF0Y2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIH1cbiAgXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgXG4gICAgdGhpcy52YWxpZGF0b3IgPSBuZXcgUmVlVmFsaWRhdGUoe1xuICAgICAgdGl0bGU6ICdyZXF1aXJlZHxtaW46MycsXG4gICAgICBjb250ZW50OiAncmVxdWlyZWR8bWluOjEwJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAncmVxdWlyZWR8bWluOjEwJyxcbiAgICB9KVxuICAgIFxuICAgIGNvbnN0IGFydGljbGUgPSB0aGlzLnByb3BzLmFydGljbGUudG9Kc29uKClcbiAgICBcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgYXJ0aWNsZSxcbiAgICAgIGVycm9yczogdGhpcy52YWxpZGF0b3IuZXJyb3JzXG4gICAgfVxuICAgIFxuICAgIHRoaXMuaGFuZGxlU3VibWl0ID0gdGhpcy5oYW5kbGVTdWJtaXQuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlQ2hhbmdlID0gdGhpcy5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzKVxuICB9XG4gIFxuICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdGhpcy5sb2FkQXJ0aWNsZSgpXG4gIH1cbiAgXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgY29uc3QgYXJ0aWNsZSA9IG5leHRQcm9wcy5hcnRpY2xlLnRvSnNvbigpXG4gICAgXG4gICAgaWYgKCFfLmlzRXF1YWwodGhpcy5zdGF0ZS5hcnRpY2xlLCBhcnRpY2xlKSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGFydGljbGUgfSlcbiAgICB9XG4gICAgXG4gIH1cbiAgXG4gIGxvYWRBcnRpY2xlKCkge1xuICAgIGNvbnN0IHsgbWF0Y2gsIGFydGljbGUsIGRpc3BhdGNoIH0gPSB0aGlzLnByb3BzXG4gICAgXG4gICAgaWYgKCFhcnRpY2xlLmlkKSB7XG4gICAgICBkaXNwYXRjaChhcnRpY2xlRWRpdFJlcXVlc3QobWF0Y2gucGFyYW1zLmlkKSlcbiAgICB9XG4gIH1cbiAgXG4gIGhhbmRsZUNoYW5nZShuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgZXJyb3JzIH0gPSB0aGlzLnZhbGlkYXRvclxuICAgIFxuICAgIHRoaXMuc2V0U3RhdGUoeyBhcnRpY2xlOiB7IC4uLnRoaXMuc3RhdGUuYXJ0aWNsZSwgW25hbWVdOiB2YWx1ZX0gfSlcbiAgICBcbiAgICBlcnJvcnMucmVtb3ZlKG5hbWUpXG4gICAgXG4gICAgdGhpcy52YWxpZGF0b3IudmFsaWRhdGUobmFtZSwgdmFsdWUpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcnMgfSlcbiAgICAgIH0pXG4gIH1cbiAgXG4gIGhhbmRsZVN1Ym1pdChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgY29uc3QgYXJ0aWNsZSA9IHRoaXMuc3RhdGUuYXJ0aWNsZVxuICAgIGNvbnN0IHsgZXJyb3JzIH0gPSB0aGlzLnZhbGlkYXRvclxuICAgIFxuICAgIHRoaXMudmFsaWRhdG9yLnZhbGlkYXRlQWxsKGFydGljbGUpXG4gICAgICAudGhlbigoc3VjY2VzcykgPT4ge1xuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIHRoaXMuc3VibWl0KGFydGljbGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9ycyB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG4gIFxuICBzdWJtaXQoYXJ0aWNsZSkge1xuICAgIHRoaXMucHJvcHMuZGlzcGF0Y2goYXJ0aWNsZVVwZGF0ZVJlcXVlc3QoYXJ0aWNsZSkpXG4gICAgICAuY2F0Y2goKHsgZXJyb3IsIHN0YXR1c0NvZGUgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IGVycm9ycyB9ID0gdGhpcy52YWxpZGF0b3JcbiAgICAgICAgXG4gICAgICAgIGlmIChzdGF0dXNDb2RlID09PSA0MjIpIHtcbiAgICAgICAgICBfLmZvck93bihlcnJvciwgKG1lc3NhZ2UsIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBlcnJvcnMuYWRkKGZpZWxkLCBtZXNzYWdlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9ycyB9KVxuICAgICAgfSlcbiAgfVxuICBcbiAgcmVuZGVyRm9ybSgpIHtcbiAgICBjb25zdCB7IGFydGljbGUgfSA9IHRoaXMucHJvcHNcbiAgICBcbiAgICBpZiAoYXJ0aWNsZS5pZCkge1xuICAgICAgcmV0dXJuIDxGb3JtIHsuLi50aGlzLnN0YXRlfVxuICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICBvblN1Ym1pdD17dGhpcy5oYW5kbGVTdWJtaXR9IC8+XG4gICAgfVxuICB9XG4gIFxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIDxtYWluIGNsYXNzTmFtZT1cImNvbC1zbS05IG1sLXNtLWF1dG8gY29sLW1kLTEwIHB0LTNcIiByb2xlPVwibWFpblwiPlxuICAgICAgPGgxPkVkaXQ8L2gxPlxuICAgICAgeyB0aGlzLnJlbmRlckZvcm0oKSB9XG4gICAgPC9tYWluPlxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhZ2VcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvbW9kdWxlcy9hcnRpY2xlL3BhZ2VzL2VkaXQvUGFnZS5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBNeUVkaXRvciBmcm9tICcuLi8uLi8uLi8uLi8uLi9jb21tb24vd3lzaXd5Zy1lZGl0b3InXG5cbmNvbnN0IGRpc3BsYXlOYW1lID0gJ0FydGljbGVGcm9tJ1xuY29uc3QgcHJvcFR5cGVzID0ge1xuICBhcnRpY2xlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGVycm9yczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25TdWJtaXQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG59XG5cbmNvbnN0IEZvcm0gPSAoeyBhcnRpY2xlLCBlcnJvcnMsIG9uQ2hhbmdlLCBvblN1Ym1pdCB9KSA9PiB7XG4gIFxuICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IGFydGljbGVbbmFtZV0pIHtcbiAgICAgIG9uQ2hhbmdlKG5hbWUsIHZhbHVlKVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIDxmb3JtIG9uU3VibWl0PXtlID0+IG9uU3VibWl0KGUpfT5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICA8bGFiZWwgaHRtbEZvcj1cInRpdGxlXCIgY2xhc3NOYW1lPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWxcIj5UaXRsZTwvbGFiZWw+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS0xMFwiPlxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgaWQ9XCJ0aXRsZVwiXG4gICAgICAgICAgICAgICBuYW1lPVwidGl0bGVcIlxuICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgZm9ybS1jb250cm9sICR7ZXJyb3JzLmhhcygndGl0bGUnKSAmJiAnaXMtaW52YWxpZCd9YH1cbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVGl0bGVcIlxuICAgICAgICAgICAgICAgdmFsdWU9e2FydGljbGUudGl0bGUgfHwgJyd9XG4gICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiBoYW5kbGVDaGFuZ2UoZS50YXJnZXQubmFtZSwgZS50YXJnZXQudmFsdWUpfSAvPlxuICAgICAgICB7ZXJyb3JzLmhhcygndGl0bGUnKSAmJiA8ZGl2IGNsYXNzTmFtZT1cImludmFsaWQtZmVlZGJhY2tcIj57ZXJyb3JzLmZpcnN0KCd0aXRsZScpfTwvZGl2Pn1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgIDxsYWJlbCBodG1sRm9yPVwiZGVzY3JpcHRpb25cIiBjbGFzc05hbWU9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbFwiPkRlc2NyaXB0aW9uPC9sYWJlbD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtLTEwXCI+XG4gICAgICAgIDx0ZXh0YXJlYSBpZD1cImRlc2NyaXB0aW9uXCJcbiAgICAgICAgICAgICAgICAgIG5hbWU9XCJkZXNjcmlwdGlvblwiXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Bmb3JtLWNvbnRyb2wgJHtlcnJvcnMuaGFzKCdkZXNjcmlwdGlvbicpICYmICdpcy1pbnZhbGlkJ31gfVxuICAgICAgICAgICAgICAgICAgcm93cz1cIjNcIlxuICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJEZXNjcmlwdGlvblwiXG4gICAgICAgICAgICAgICAgICB2YWx1ZT17YXJ0aWNsZS5kZXNjcmlwdGlvbn1cbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IGhhbmRsZUNoYW5nZShlLnRhcmdldC5uYW1lLCBlLnRhcmdldC52YWx1ZSl9IC8+XG4gICAgICAgIHtlcnJvcnMuaGFzKCdkZXNjcmlwdGlvbicpICYmIDxkaXYgY2xhc3NOYW1lPVwiaW52YWxpZC1mZWVkYmFja1wiPntlcnJvcnMuZmlyc3QoJ2Rlc2NyaXB0aW9uJyl9PC9kaXY+fVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgPGxhYmVsIGh0bWxGb3I9XCJjb250ZW50XCIgY2xhc3NOYW1lPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWxcIj5Db250ZW50PC9sYWJlbD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtLTEwXCI+XG4gICAgICAgIDxNeUVkaXRvciBpZD1cImNvbnRlbnRcIiB2YWx1ZT17YXJ0aWNsZS5jb250ZW50fSBvbkNoYW5nZT17ZSA9PiBoYW5kbGVDaGFuZ2UoJ2NvbnRlbnQnLCBlKX0gLz5cbiAgICAgICAge2Vycm9ycy5oYXMoJ2NvbnRlbnQnKSAmJiA8ZGl2IGNsYXNzTmFtZT1cImludmFsaWQtZmVlZGJhY2tcIj57ZXJyb3JzLmZpcnN0KCdjb250ZW50Jyl9PC9kaXY+fVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tMTAgbWwtYXV0b1wiPlxuICAgICAgICA8YnV0dG9uIGRpc2FibGVkPXtlcnJvcnMuYW55KCl9IHR5cGU9XCJzdWJtaXRcIiBjbGFzc05hbWU9XCJidG4gYnRuLXByaW1hcnlcIj5VcGRhdGU8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Zvcm0+XG59XG5cbkZvcm0uZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZVxuRm9ybS5wcm9wVHlwZXMgPSBwcm9wVHlwZXNcblxuZXhwb3J0IGRlZmF1bHQgRm9ybVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9tb2R1bGVzL2FydGljbGUvcGFnZXMvZWRpdC9jb21wb25lbnRzL0Zvcm0uanMiXSwic291cmNlUm9vdCI6IiJ9